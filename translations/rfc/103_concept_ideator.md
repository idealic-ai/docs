# 103: Скрытое/Идеатор

> **Идеатор:** `Idea`, которая принимает входные данные, что обозначается сообщением в контексте с `type: "input"`. Она действует как функция, преобразующая входные данные в выходные.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
>   - [Протокол Idea](./101_concept_idea.md)
>   - [Протокол Input](./005_agent_input.md)
> - Позволяет:
>   - [Протокол Call](./003_agent_call.md)
>   - [Протокол: Суверенитет](./102_concept_sovereignty.md)

## 1. Введение

Этот документ описывает протокол для **Идеаторов** и **Трансформаторов Idea** как исполняемых компонентов на основе сервисов. Он основан на базовом [Протоколе Idea](./101_concept_idea.md), который определяет основную структуру данных, и описывает, как `Idea` преобразуется в функциональную, вызываемую сущность.

Подробнее о различных моделях хостинга и развертывания см. в [RFC 11: Протокол: Суверенитет](./102_concept_sovereignty.md).

## 2. От Idea к Идеатору

**Идеатор** — это не отдельная сущность, а функциональная роль, которую может выполнять любая `Idea`. Его можно рассматривать как функцию, которая выполняет работу, преобразуя входные данные в выходные в **скрытом пространстве**. Это означает, что его логика не обязательно определяется явным кодом, а направляется богатым `context`'ом `Idea` — его схемами, примерами и инструкциями на естественном языке, которые интерпретируются LLM.

Определяющим признаком того, что `Idea` является Идеатором, является наличие сообщения в `context` с `type: "input"`. Это сообщение определяет схему данных, которые ожидает Идеатор. _Исполняемый_ Идеатор также может включать сообщение в `context` с `type: "code"`, указывающее на явную реализацию.

### 2.1. Трансформатор Idea: Частный случай

Распространенный и мощный паттерн — это Идеатор, входными данными для которого является другая `Idea`. Мы называем этот специфический тип Идеатора **Трансформатором Idea**. Именно это позволяет создавать композиционные конвейеры, в которых `Idea` соединяются в цепочки и развиваются.

## 3. Реализации и композиция

Архитектурные принципы, изложенные в этом документе, определяют **поведенческий контракт** для любого сервиса Идеатора. Этот контракт предназначен не для одной программы, а является стандартом для взаимодействия, что позволяет создавать множество реализаций и богатую композиционную экосистему.

### 3.1. Множество реализаций

Контракт сервиса Идеатора выполняется путем соблюдения его публичного API (принятие одной `Idea` и возврат другой). Это позволяет создавать множество конкретных реализаций, каждая из которых подходит для разных случаев использования:

- **Управляемые сервисы**: Провайдер может предложить хостинг в виде управляемого облачного сервиса, абстрагируя инфраструктуру, как описано в [Протоколе Суверенитета](./102_concept_sovereignty.md).
- **Собственные экземпляры**: Разработчик может запустить собственную реализацию сервиса на своей инфраструктуре, получая полный контроль.
- **Реализации в памяти**: Для локальной разработки и тестирования логика выполнения Идеатора может быть запущена как простая функция в памяти, минуя сеть, но при этом соблюдая основной контракт.

### 3.2. Композиция и системы высшего порядка

В этой экосистеме нет понятия «приватного API». Все сервисы созданы для взаимодействия через свои публичные интерфейсы, основанные на контрактах.

Более сложные сервисы, которые можно рассматривать как **Системы Высшего Порядка**, создаются путем композиции других, более примитивных `Идеаторов`. Внутренняя логика сервиса высшего порядка включает вызовы публичных API других `Идеаторов`.

Например, система **Реактор** — это `Идеатор` высшего порядка. Для управления игрой он может:

1.  Принимать `Idea` состояния игры через свой публичный API.
2.  Внутренне вызывать публичный сервис `Player` для создания и управления идентификаторами игроков.
3.  Вызывать публичный сервис `Storage` для записи истории игры.
4.  Возвращать новую `Idea` состояния игры через свой публичный API.

Снаружи Реактор — это просто еще один `Идеатор`. Его сложность управляется внутри за счет композиции других независимых публичных сервисов. Это гарантирует, что вся система остается модульной, прозрачной и масштабируемой.