# 003: Агент/Вызов

> **Вызов:** Конкретный, исполняемый экземпляр `Инструмента` с заданными значениями для его `params`. Это сфокусированный на исполнении запрос о том, *что должно быть сделано*.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует: [Протокол: Ideators](./103_concept_ideator.md)
> - Позволяет: [Протокол Imports](./006_agent_imports.md), [Протокол Instancing](./008_agent_instancing.md)

[Протокол Idea](./101_concept_idea.md) определяет мощную, самодостаточную структуру данных для представления знаний и скрытой логики. [Система Инструментов](./002_agent_tool.md) создает базовый, управляемый схемами интерфейс, который позволяет агентам понимать структурированные возможности. Этот документ описывает **Протокол Call**, который основывается на Инструментах для определения того, как происходит выполнение через элементы управления Областью (Scope) и Методом (Method).

> Sidenote:
>
> - Требует
>   - [RFC 1: Tool](/)
> - Позволяет
>   - [RFC 9: Plan](/)

**Вызов** — это конкретный экземпляр Инструмента с заданными значениями параметров, готовый к исполнению. Если Инструменты определяют, *что можно сделать*, то Вызовы определяют, *как это будет выполнено*.

## Конвейер от Idea к Вызову

1.  **Idea**: Самодостаточный, ориентированный на результат документ, представляющий знание или процесс.
2.  **Инструмент**: `Idea`, преобразованная в схему, ориентированную на интерфейс, и зарегистрированная в системе инструментов агента (подробности о схемах Инструментов, регистрации и архитектуре двойного реестра см. в [Системе Инструментов](./002_agent_tool.md)).
3.  **Вызов**: Когда LLM решает использовать `Инструмент`, она заполняет конкретные параметры, создавая **Вызов**. `Вызов` — это единичный, конкретный экземпляр вызова `Инструмента`.

Основной принцип: **любую Idea можно превратить в Инструмент, который затем может быть вызван как Call.**

Для подробного объяснения того, как входная схема `Idea` преобразуется в схему параметров `Инструмента`, см. **[Протокол Input](./005_agent_input.md)**.

## Элементы управления выполнением: Область и Метод

Выполнение `Вызова` определяется двумя независимыми свойствами: **Областью** (где он выполняется) и **Методом** (как он выполняется). Эти элементы управления обозначаются специальными свойствами (`_module`, `_activity`, `_output`) в схеме инструмента.

### Две Оси Выполнения

1.  **Область (Встроенная vs. Модульная)**
    Область определяет, происходит ли выполнение в текущем контексте агента или делегируется внешнему, изолированному модулю.
    - **Встроенная Область**: Режим по умолчанию, при котором `Вызов` обрабатывается напрямую.
    - **Модульная Область**: Обозначается свойством `_module` и делегирует `Вызов` внешнему `Activity` или `Idea`.

2.  **Метод (Явный vs. Скрытый)**
    Метод определяет, генерируется ли результат детерминированным кодом или с помощью LLM.
    - **Явный Метод**: Обозначается наличием свойства `_activity`, результат `Вызова` генерируется детерминированным кодом.
    - **Скрытый Метод**: Поведение по умолчанию при отсутствии `_activity`. Результат `Вызова` генерируется LLM. Требует наличия необязательного свойства `_output`.

Эти элементы управления можно комбинировать в различные паттерны выполнения, а их контекстом можно управлять с помощью импортов. Для подробного объяснения того, как эти элементы управления комбинируются и как управляется контекст, см. **[Протокол Imports](./008_agent_imports.md)**.

## Idea, Инструмент и Вызов: Спектр фокуса

Чтобы понять эту связь, мы должны уяснить фундаментальную разницу в направленности этих трех понятий.

- **Idea** **ориентирована на результат**. Её основная цель — представить завершенную мысль или результат. `schema` определяет форму `solution` (результата), который был сгенерирован из `context`. Это запись того, *что было* или *могло бы быть*.

- **Инструмент** **ориентирован на интерфейс**. Его схема определяет параметры (входные данные) и структуру `_output`. Это абстрактный шаблон для действия — сигнатура функции, ожидающая вызова.

- **Вызов** **ориентирован на исполнение**. Это конкретный, исполняемый экземпляр `Инструмента`. Он берет интерфейс `Инструмента`, ориентированный на параметры, и заполняет его конкретными значениями, превращая в готовый к выполнению запрос о том, *что должно быть сделано*.

## Vessel Idea: Единый момент принятия решения

Когда агенту необходимо принять решение, полный запрос, отправляемый в LLM, структурируется как особый тип `Idea`, который мы называем **Vessel Idea**. Он представляет собой единый, самодостаточный момент принятия решения.

Vessel Idea объединяет два ключевых компонента, необходимых LLM для принятия решения:

1.  **Контекст**: Включает в себя всю релевантную информацию, которая нужна агенту, например, запрос пользователя, память и другие данные из окружения.
2.  **Схема**: Для Vessel Idea основная роль схемы — определить «Контейнер» (Vessel) — набор возможных `Инструментов`, которые агенту разрешено использовать в данной конкретной ситуации.

LLM обрабатывает всю эту `Idea` — контекст и схему доступных инструментов — и её `solution` является результатом этого решения: массив из нуля или более `Вызовов` для исполнения.

Эта структура позволяет одной целостной `Idea` представлять сложное, многошаговое действие.

## Паттерны выполнения Вызовов

Когда Vessel Idea создает несколько Вызовов, можно применять различные стратегии их выполнения в зависимости от потребностей приложения:

```typescript
// Выполнение одного Вызова
const result = await Tool(call);

// Выполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Вызовы, вернуть первый завершившийся (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны обеспечивают:

- **Детальный контроль**: Обрабатывайте Вызовы по отдельности с пользовательской логикой между выполнениями.
- **Пакетная обработка**: Выполняйте независимые Вызовы параллельно для максимальной производительности.
- **Стратегии быстрого отказа**: Останавливайтесь при первом успехе (`.any()`) или первом завершении (`.race()`).
- **Операции «всё или ничего»**: Гарантируйте, что все Вызовы успешно завершатся вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы.