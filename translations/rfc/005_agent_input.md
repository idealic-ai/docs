# 005: Агент/Ввод

> **Сообщение Input:** Контекстное сообщение, содержащее `schema` и данные `input`. Его наличие превращает `Idea` в `Ideator`, определяя ожидаемые входные данные.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует: [Протокол Idea](./101_concept_idea.md)
> - Включает: [Протокол: Ideators](./103_concept_ideator.md)

Этот документ описывает **Протокол Ввода (Input Protocol)** — систему для определения структурированных входных данных для `Ideas`. Этот протокол вводит особый тип сообщения, который при включении в контекст `Idea` превращает ее из статической единицы знания в исполняемую, подобную функции сущность, известную как **Ideator**.

## Тип сообщения `Input`

Сообщение `Input` — это особый тип контекстного сообщения, предназначенный для формального объявления данных, которые принимает `Idea`. Это механизм, который фиксирует структурированные входные данные, использованные для получения конкретного `solution`, завершая "Триаду Idea" и обеспечивая полную, воспроизводимую запись творческого или вычислительного процесса.

Сообщение `Input` содержит два ключевых свойства:

1.  **`schema`**: Объект JSON Schema, который определяет структуру, типы и ограничения данных, ожидаемых `Idea`.
2.  **`input`**: Конкретный объект данных, который соответствует `schema` и представляет фактические значения, использованные для конкретного выполнения.

Определяя свои входные данные таким структурированным образом, любая `Idea` может стать самоописываемой не только в части своего вывода (`solution` и `schema`), но и в том, что ей требуется для генерации.

### Путь к простоте использования

Значительным преимуществом этого протокола является его способность обеспечивать автоматическую генерацию пользовательского интерфейса. Поскольку `schema` для `input` явно определяет требуемые данные, система может динамически отображать форму с правильными полями, метками и проверкой. Это позволяет мгновенно предоставить любую `Idea` человеку через функциональный интерфейс, значительно снижая барьер для взаимодействия.

## От Idea к Ideator

Как описано в [Протоколе Idea](./101_concept_idea.md), наличие сообщения `Input` в контексте `Idea` является окончательным сигналом того, что это **Ideator** — `Idea`, которая выполняет работу. Она становится воспроизводимой функцией.

## Взаимодействие с Протоколом Инстансинга

Сообщение `Input` полностью совместимо с [Протоколом Инстансинга](./008_agent_instancing.md), что позволяет использовать сложные стратегии получения данных при одновременной обработке нескольких инстансов. Оно может работать в двух различных режимах:

1.  **Глобальный Ввод (Global Input)**: Если сообщение `Input` предоставлено в контексте агента без свойства `_instance`, его данные `input` рассматриваются как глобальное значение. Оно неявно доступно каждому инстансу, обрабатываемому в запросе. Это полезно для предоставления общей конфигурации, подсказок или параметров, которые применяются ко всем инстансам одинаково.

2.  **Ввод для конкретного инстанса (Instance-Specific Input)**: Если сообщение `Input` включает идентификатор `_instance`, его данные `input` берутся непосредственно из состояния этого конкретного инстанса. Это предоставляет мощный механизм для переопределения параметров для каждого инстанса или для передачи уникальных данных каждого инстанса в общий `Ideator`.

Эта возможность работы в двух режимах позволяет создавать гибкие и эффективные рабочие процессы с несколькими инстансами, где один `Ideator` может быть настроен с базовым набором глобальных входных данных, а затем кастомизирован с помощью конкретных данных из каждого обрабатываемого им инстанса.

## Инверсия: от Ideator к Tool

Хотя `Ideator` является самодостаточной, исполняемой концепцией, для его интеграции в императивный рабочий процесс агента мы должны преобразовать его в **Tool**. Механический процесс превращения `Ideator`, ориентированного на вывод, в `Tool`, ориентированный на интерфейс, называется **инверсией**. Мы реструктурируем его компоненты, чтобы приоритет отдавался его входным данным.

`Idea` — это триада, определяемая ее выводом `schema` и `solution`:
`{ context, schema, solution }`

Чтобы преобразовать ее в `Tool`, мы ищем в ее `context` сообщение `Input`. Основной шаг инверсии — **продвинуть** свойства схемы `input` до уровня свойств параметров верхнего уровня для `Tool` (подробнее о структуре схемы `Tool` см. в [Системе Инструментов](./002_agent_tool.md)).

Это создает определение `Tool`, которое, по сути, является сигнатурой функции, готовой к регистрации в системе агента и использованию в `Call`.