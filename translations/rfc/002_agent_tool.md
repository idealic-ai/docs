# 002: Агент: Инструмент

> **Инструмент**: Схема, которая определяет возможность, доступную агенту. Она предоставляется LLM как часть запроса и служит структурированным интерфейсом для потенциального действия. LLM активирует инструмент, создавая `Call` с определёнными параметрами. Этот `Call` затем исполняется либо скрыто самой LLM, либо явно через зарегистрированную кодовую функцию (`Activity`).
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется: [Агент: Запрос](./001_agent_request.md)

Этот документ описывает Инструмент — фундаментальный интерфейс на основе схемы, который позволяет агентам понимать и использовать структурированные возможности.

## Что такое Инструменты?

**Инструменты — это основа** систем действий агента. Они открывают новый тип возможностей: **выбор действия в определённом контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от ситуации.

Инструменты обеспечивают:

- **Структурированные интерфейсы**: Возможности, определённые схемой, которые агенты могут обнаруживать и понимать.
- **Типобезопасность**: Чёткие правила для входных и выходных данных.
- **Компонуемость**: Строительные блоки, которые объединяются в сложное поведение агента.
- **Интеграция с LLM**: Схемы, которые языковые модели могут анализировать и выбирать.

Когда агент заполняет параметры для Инструмента, он создаёт **Вызов** (`Call`) — экземпляр Инструмента со всеми заполненными обязательными параметрами, представляющий конкретный запрос на исполнение (подробнее об исполнении Вызовов, Области видимости и методах управления см. в [Протоколе Вызовов](./002_agent_calls.md)).

> **Примечание**: Хотя любой запрос к LLM можно представить в виде Идеи (что хорошо подходит для простого создания структурированного контента), Инструменты предоставляют механизм для более сложных сценариев, требующих динамического выбора действий. Подробнее о том, как Идеи можно преобразовать в Инструменты с помощью входных схем, см. в [RFC по Вводу Агента](./003_agent_input.md).

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации.
- **Выбирали между несколькими возможностями** для достижения цели.
- **Исполняли разные реализации** одной и той же возможности (например, разные поисковые системы).
- **Сочетали рассуждения LLM с явной логикой** в процессе принятия решений.

## Архитектура системы Инструментов

### Основной принцип: Схема как интерфейс

Система Инструментов построена на фундаментальном принципе: **Инструменты — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Схема Инструмента указывает:

- **Что делает инструмент** (описание)
- **Что ему нужно** (входные параметры)
- **Что он производит** (структура `_output`)
- **Как он идентифицируется** (имя `_tool`)
- **Как он вызывается** (поле `_activity` — определяет режим исполнения, см. ниже Стратегию определения Деятельности)

### Архитектура двойного реестра

Система Инструментов использует два взаимодополняющих реестра:

**Реестр Инструментов**: Хранит определения схем (интерфейс).
**Реестр Деятельностей**: Хранит функции реализации (исполнение).

Такое разделение позволяет инструментам существовать без реализаций (для рассуждений LLM) и менять реализации во время выполнения (например, для сред разработки и продакшена).

### Мета-поля схемы Инструмента

Схемы Инструментов используют мета-поля (с префиксом в виде подчёркивания) для определения системных свойств:

- **_tool**: Уникальный идентификатор инструмента (обязательно).
- **_activity**: Указание режима исполнения (определяется автоматически, если не задано).
- **_output**: Ожидаемая структура вывода (система делает её необязательной).
- **_reasoningForCall**: Объяснение агента, почему был создан этот Вызов (добавляется системой).

Пользователи определяют эти мета-поля в своих определениях инструментов, а система Инструментов дополняет их во время композиции схемы: определяет `_activity`, если не указано, делает `_output` необязательным и добавляет `_reasoningForCall`. Любое поле без префикса-подчёркивания считается параметром инструмента. Мета-поля всегда идут первыми при композиции схемы, обеспечивая единообразную структуру для понимания LLM.

### Границы системы

Система Инструментов отвечает за:

- Регистрацию Инструментов (определение и хранение схем).
- Заполнение параметров (извлечение из контекста с помощью LLM).
- Маршрутизацию исполнения (определение, будет ли оно скрытым или явным).
- Управление Деятельностями (регистрация и вызов реализаций).

Более высокоуровневые протоколы (например, [Протокол Вызовов](./002_agent_calls.md)) строят на основе этих примитивов оркестровку рабочих процессов, управление состоянием и политики исполнения.

## Определение и регистрация Инструмента

Инструменты определяются с помощью JSON-схем, которые полностью описывают их интерфейс:

### Базовая схема Инструмента

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

### Инструмент с регистрацией Деятельности

```typescript
// Определяем схему инструмента (как в базовом примере)
Tool.register('weatherCheck', {
  /* ... */
});

// Регистрируем реализацию - имя совпадает с инструментом для авто-конфигурации
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

## Стратегия определения Деятельности

Система Инструментов поддерживает два принципиально разных режима исполнения:

- **Скрытое исполнение** использует способности LLM к рассуждению: агент «продумывает» задачу и выдаёт результат напрямую в том же вызове. Это исполнение на основе знаний, идеально подходящее для анализа, планирования или творческих задач, где достаточно знаний, полученных LLM при обучении.
  > Sidenote:
  >
  > - [RFC 104: Скрытое исполнение](../rfc/104_concept_latent.md)
- **Явное исполнение** передаёт задачу детерминированному коду: для вычисления результата вызывается функция Деятельности. Это исполнение на основе кода, необходимое для вызовов внешних API, операций с базами данных или любых задач, требующих точного и повторяемого поведения.

### Сопоставление Деятельности без конфигурации

Система автоматически определяет режим исполнения во время композиции схемы:

1.  **Явное поле `_activity`**: Если в определении инструмента есть поле `_activity`, используется его значение.
2.  **Соглашение об одинаковых именах** (рекомендуется): Если `Activity.Names` содержит имя инструмента, `_activity` устанавливается в это же имя (явное исполнение).
3.  **Возврат к Скрытому исполнению**: В противном случае `_activity` устанавливается в пустую строку (скрытое исполнение).

Такой подход на основе соглашений означает:

- **Регистрируйте вашу Деятельность под тем же именем, что и ваш Инструмент**, для автоматической настройки.
- Отсутствующие Деятельности по умолчанию переключаются на скрытое исполнение.
- Явно указанные поля `_activity` всегда имеют приоритет.

### Композиция схемы

Схемы Инструментов объединяются в массив `calls` для LLM. Каждая схема дополняется мета-полями и информацией о режиме исполнения (определённом по правилам выше), а затем добавляется с использованием шаблона `anyOf` из JSON Schema:

```typescript
{
  calls: {
    type: 'array',
    items: {
      anyOf: [
        { /* схема инструмента sentimentAnalysis с _activity: '' */ },
        { /* схема инструмента weatherCheck с _activity: 'weatherCheck' */ },
        // ... другие зарегистрированные инструменты
      ]
    }
  }
}
```

Это позволяет LLM выбирать из доступных инструментов и создавать несколько Вызовов (`Calls`) в одном запросе.

## Почему важны двойные реестры

Без разделения схем Инструментов и реализаций Деятельностей, смена режима исполнения потребовала бы переписывания кода агента. Если вы захотите переключиться с рассуждений LLM на внешний API, вам придётся изменить каждого агента, использующего эту возможность.

Архитектура с двойным реестром решает эту проблему, сохраняя интерфейсы инструментов стабильными, в то время как реализации могут меняться. Агенты всегда взаимодействуют с одной и той же схемой Инструмента, независимо от того, исполняется ли она с помощью рассуждений LLM или внешнего кода. Это означает:

- **Изменения в реализации не ломают агентов** — переключайтесь со скрытого на явное исполнение, не трогая код агента.
- **A/B-тестирование стратегий исполнения** — сравнивайте рассуждения LLM и внешние API для одной и той же возможности.
- **Постепенное внедрение** — развёртывайте новые реализации для части агентов, в то время как остальные используют старые.

## Инструменты как основа

Инструменты представляют собой **первый строительный блок** системы действий агента — они определяют, *что можно сделать* с помощью чистых интерфейсов-схем. Следующий уровень, [Протокол Вызовов](./002_agent_calls.md), строится на этой основе, чтобы определить, *как всё исполняется* с помощью управления Областью видимости и Методами, обеспечивая сложные рабочие процессы с несколькими инструментами и стратегии исполнения.