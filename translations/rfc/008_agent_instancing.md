# 008: Агент/Инстансинг

> **Инстансинг:** Процесс обработки нескольких независимых `Instances` (каждый со своим `State Object` и уникальным идентификатором) в рамках одного запроса к агенту.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется: [Агент: Состояние](./007_agent_state.md)
> - Совместимо:
>   - [Агент: Ввод](./005_agent_input.md)
>   - [Агент: Импорты](./006_agent_imports.md)
>   - [Агент: План](./009_agent_plan.md)

Этот документ описывает протокол для обработки нескольких независимых экземпляров в рамках одного запроса к агенту, используя архитектуру, управляемую состоянием.

## 1. Фундаментальное требование: Система состояний

Основным предварительным условием для этого протокола инстансинга является **Система Состояний**, которая явно разделяет планирование действий от их выполнения.

**State Object** — это мост между этими фазами. Это изменяемый, JSON-подобный объект, который выполняет две критически важные функции:

1.  **Цель для выполнения**: Это холст, на котором работают инструменты. Каждый `Tool Call` включает свойство `_outputPath`, которое указывает путь в объекте `State`, куда должен быть записан результат работы инструмента во время выполнения.
2.  **Источник для зависимостей**: `Tool Call` может ссылаться на значение из `State` в качестве одного из своих входных данных. Это позволяет создавать графы зависимостей.

## 2. Механизм инстансинга

Истинная мощь этой архитектуры раскрывается в ее нативной поддержке операций с несколькими экземплярами, что становится возможным благодаря Системе Состояний.

### 2.1. Идентификаторы состояний

Для обработки нескольких экземпляров в одном запросе система принимает массив контекстных сообщений. Каждому сообщению, представляющему отдельный экземпляр, присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы — короткие, уникальные токены (например, числа в кружочках, такие как `①`, `②`), которые хорошо видны LLM, но не несут семантического значения, кроме как служить ссылкой.

### 2.2. Целевые операции

Затем `_instance` используется для направления всех операций в контекст конкретного экземпляра. Кроме того, все мета-параметры для `Tool Call` имеют префикс в виде подчеркивания (`_`), а его `params` встраиваются непосредственно в объект вызова.

- **Связь с `Tool Call`**: Каждый `Tool Call` в сгенерированном плане содержит `_instance` контекста, в котором он должен работать.
- **Неявное ограничение области**: `_instance` в `Tool Call` неявно ограничивает область всех операций, основанных на путях (`_outputPath` и ссылки на входные данные), в пределах этого вызова. Это означает, что когда инструмент читает из объекта состояния или записывает в него, путь является относительным к `_instance` контекста, к которому он принадлежит.

Этот механизм позволяет определениям самих инструментов оставаться простыми и не зависеть от контекста инстансинга. `_outputPath` и ссылки на входные данные в схеме инструмента не требуют обновления; идентификатор четко разделяет операционные контексты.

### 2.3. Пример

Один запрос может содержать два объекта состояния для анализа тональности. Схема состояния может быть предоставлена для ограничения доступных свойств и направления работы LLM.

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "This is wonderful!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "This is terrible." } }
  ]
}
```

LLM обрабатывает оба в едином контексте и генерирует объединенный план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      "text": "†state.text",
      "_outputPath": "sentiment"
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

Затем хост-окружение выполняет этот план, записывая результаты в соответствующие объекты состояний.

## 3. Дополнительная система: Граф планирования

Хотя это и не является строгим требованием для инстансинга, **Система Планирования** работает в симбиозе с этой архитектурой, чтобы обеспечить высоко предсказуемые и переиспользуемые рабочие процессы.

**План** — это шаблон для процесса, определенный как направленный ациклический граф (DAG) из `Tool Calls`. Этот граф генерируется путем анализа зависимостей между инструментами, которые читают из `State Object` и пишут в него.

Важно отметить, что этот план можно сгенерировать и усовершенствовать _до_ выполнения. После завершения план можно передать агенту как `Context Message`. При обработке нескольких экземпляров агент может следовать этому заранее определенному плану для каждого `State Object`, достигая высокой согласованности и предсказуемости результатов при многократных вызовах. `State Object` для каждого экземпляра служит снимком его текущего положения в этом графе выполнения.

## 4. Преимущества этого подхода

Эта модель инстансинга, управляемая состоянием, предоставляет значительные преимущества:

- **Эффективность**: Увеличивает пропускную способность системы за счет обработки множества экземпляров в одном запросе к LLM, что значительно повышает скорость и снижает затраты.
- **Согласованность и качество**: Позволяя LLM видеть несколько связанных экземпляров в одном контексте, модель может генерировать более согласованные и качественные планы, используя общие закономерности для всех экземпляров.
- **Предсказуемость**: В сочетании с заранее определенным **Планом** система может достигать детерминированных результатов. Детерминированный цикл выполнения гарантирует, что после следования плану его результат будет надежным и повторяемым для каждого экземпляра.