# 008: Агент/Импорты

> **Импорты:** Это способ дать программе, которая что-то выполняет, доступ к определённой информации из её «родительской» среды. Свойство `_imports` работает как список разрешённого, создавая ограниченный и безопасный набор данных, который может видеть команда `Call`. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
>   - [004: Агент/Вызов](./004_agent_call.md)

**Протокол импортов** — это главный способ управлять информацией, доступной для команды `Call`. Представь себе умного робота (агента), который выполняет сложные задачи. Его команды редко работают в пустоте. Им часто нужна информация извне: что сказал пользователь, что происходило до этого или каковы результаты предыдущих шагов. Протокол импортов — это безопасный и понятный способ контролировать, какую именно информацию получает команда.

Ограничивая доступ к данным, импорты делают систему безопаснее, не дают случайно «проболтаться» лишней информации и помогают искусственному интеллекту (ИИ) сосредоточиться. Это делает его работу более предсказуемой и дешёвой. Такой контроль также позволяет создавать независимые и многоразовые детали, как кубики LEGO (`Идеи` и `Действия`). В этом документе мы разберём, как это работает.

## Предоставление и Запрос Информации

То, как мы описываем свойство `_imports`, определяет, будет ли информация **предоставлена** сразу или **запрошена** в процессе работы.

> Sidenote:
> ```mermaid
> graph TD
>     subgraph Родительская Среда
>         direction LR
>         input("ввод")
>         state("состояние")
>     end
>
>     subgraph Вызов Инструмента
>         direction LR
>         filter{{"_imports: ['ввод']"}}
>     end
>
>     input --> filter
>     state -.-> filter
>
>     subgraph Предоставленная Информация
>         Execute(Выполнить Инструмент)
>     end
>
>     filter --> HITL{{Одобрение человеком}}
>     HITL --> Execute
>
>     classDef unused stroke-dasharray: 5, 5, stroke:#aaa, color:#aaa
>     class state unused
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

- **Статические импорты (Предоставление информации)**: Если для `_imports` указано постоянное значение (`const`), это означает, что информация **предоставляется** жёстко. Создатель программы заранее прописал, какие именно данные может видеть инструмент.

  ```json
  {
    "_imports": {
      "const": ["input"]
    }
  }
  ```
  Представь, что ты даёшь роботу-повару рецепт и говоришь: «Ты можешь использовать *только* муку и яйца». Он не может взять ничего другого.

- **Динамические импорты (Запрос информации)**: Схема `_imports` может быть более гибкой, позволяя **запрашивать** информацию. В этом случае ИИ сам решает, какие из доступных данных ему нужны для выполнения команды.

  ```json
  {
    "_imports": {
      "type": "array",
      "items": {
        "enum": ["state", "input"]
      }
    }
  }
  ```
  Это как сказать повару: «На полке лежат мука, яйца и сахар. Посмотри на задачу и скажи, что тебе нужно». Это особенно круто, когда человек может проверить и одобрить запрос, добавляя дополнительный слой контроля.

## Роль импортов в работе команд

Свойство `_imports` — это главный фильтр, который контролирует, какую информацию видит команда `Call`. Оно создаёт для неё ограниченное «поле зрения». Это основа того, как обрабатываются команды и как разные возможности — такие как чёткая логика, работа с несколькими объектами и независимые модули — могут работать вместе.

- **Скрытое исполнение**: В обычном режиме, когда ИИ «думает» сам, `_imports` работает как подсказка, чтобы сфокусировать его внимание на нужных частях родительской информации. Это не строгий запрет, а скорее дружеский совет, который помогает отсеять шум и сделать работу ИИ более надёжной и дешёвой.

  > Sidenote:
  > - [002: Агент/Инструмент](./002_agent_tool.md).

- **Явное исполнение (`_activity`)**: Когда команда `Call` запускает конкретный, заранее написанный код (`Activity`), роль импортов становится более прямой. Вся разрешённая информация передаётся в этот код как дополнительный параметр. Это даёт коду всё необходимое, даже если ИИ использовал лишь малую часть этих данных, чтобы решить, какой код запустить.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Инстансинг (`_instance`)**: Представь, что агенту нужно обработать сразу целую пачку одинаковых объектов, например, сто писем. Импорты следят, чтобы при работе над одним письмом команда видела информацию, относящуюся *только к этому письму*. Это очень важно, чтобы данные не перемешались и не произошла путаница между параллельно выполняемыми задачами.

  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

- **Модульная изоляция (`_module`)**: Когда команда передаётся внешнему помощнику (`Модулю`), импорты становятся строгими охранниками на входе. Они определяют *всю* информацию, которую увидит этот модуль в своей «чистой комнате». Ничто из родительской среды не попадёт внутрь, если это не было явно разрешено. Это гарантирует, что модуль будет полностью независимым и его можно будет использовать где угодно.

  > Sidenote:
  > - [009: Агент/Модуль](./009_agent_module.md)

Свойство `_imports` — это мост, по которому команда `Call` получает нужную информацию. И как показывает последний пример, когда этот мост становится *единственным* входом в изолированную среду, он создаёт мощный **Протокол Модулей**. Следующий документ, [009: Агент/Модуль](./009_agent_module.md), подробно описывает этот протокол.
