# 008: Агент/Импорты

> **Импорт:** Это как записка, которая говорит, какую часть информации из главной «комнаты» нужно взять и передать для выполнения задачи. Это помогает направить внимание ИИ (искусственного интеллекта) во время **скрытого исполнения** или создать целое новое рабочее место для **модульного исполнения**. Управляется с помощью специального свойства `_imports`. — [Словарь](./000_glossary.md)

В документе [004: Агент/Вызов](./004_agent_call.md) мы говорили о главных способах запускать задачи: **Область** (встроенная или модульная) и **Метод** (явный или скрытый). Протокол импортов объясняет, как совмещать эти способы и управлять информацией для каждого из них.

## Сочетание Области и Метода

Представь, что ИИ — это твой помощник. Вот четыре разных способа, как он может выполнять твои поручения:

1.  **Встроенный Явный (`_activity`)**. Это самый обычный способ использования инструмента. ИИ видит, что нужно сделать, придумывает данные для инструмента (`params`) и тут же его использует. Например, ты просишь его посчитать «2+2», он берёт калькулятор (`_activity`) и вводит «2+2» (`params`). `_imports` здесь не нужны, потому что всё происходит прямо на месте и сразу.

2.  **Встроенный Скрытый (без `_activity`)**. Здесь ИИ как будто сам всё придумывает в уме: и что делать (`params`), и какой будет результат (`_output`), всё за один шаг. `_imports` здесь очень полезны. Они помогают ИИ сосредоточиться только на нужной информации. Например, если ты просишь его написать о кошках, `_imports` скажут ему: «Смотри только на файлы о кошках, а папки с собаками не трогай».

3.  **Модульный Явный (`_module` + `_activity`)**. ИИ решает, какой инструмент (`_activity`) из какого набора инструментов (`_module`) использовать. Это как если бы твой помощник решил, что задачу по рисованию лучше отдать художнику (`_module`) и попросить его нарисовать дом (`_activity`). Если указаны `_imports`, то это те самые материалы (фотографии, карандаши), которые помощник передаст художнику. Художник будет работать в своей отдельной мастерской (в изолированном контексте).

4.  **Модульный Скрытый (`_module`, без `_activity`)**. ИИ решает, какому специалисту (`_module`) отдать задачу, но не говорит, как именно её делать. Например, «Эй, отдел маркетинга, придумайте нам слоган». Система создаёт для этого отдела новое, чистое рабочее пространство. А информация для работы (`_imports`) берётся из твоего запроса и смешивается с собственными знаниями отдела маркетинга.

## Направляем «поле зрения»

Свойство `_imports` — это главный механизм, который решает, какую информацию увидит ИИ для выполнения задачи. Он работает как фейс-контроль в клубе: пропускает только тех, кто есть в списке, и отсеивает всё лишнее. Это создаёт ограниченное «поле зрения».

-   **Во встроенной области**: `_imports` помогают ИИ сконцентрироваться.
-   **В модульной области**: `_imports` определяют *всю* информацию, которая будет доступна в отдельном рабочем пространстве.

## Предоставление и Запрос информации: Статические и Динамические импорты

В правилах для каждого инструмента (в его схеме `Tool`) свойство `_imports` определяет, как инструмент получает информацию: заранее (ему её **предоставляют**) или он сам её **запрашивает** в нужный момент.

-   **Статические импорты (Предоставление информации)**: Если в правилах инструмента `_imports` прописано как постоянное значение (например, `_imports: { "const": ["input"] }`), это значит, что создатель инструмента заранее решил, какую именно информацию тот может видеть. Например, калькулятор может видеть только введённые числа (`input`) и ничего больше. Это жёстко запрограммировано.

> Sidenote:
> 
> ```mermaid
> graph TD
>     subgraph Родительский контекст
>         direction LR
>         input("входные данные")
>         state("состояние")
>     end
> 
>     subgraph Вызов инструмента
>         direction LR
>         filter{{"_imports: ['input']"}}
>     end
> 
>     input --> filter
>     state -.-> filter
> 
>     subgraph Предоставленный контекст
>         direction LR
>         input_prov("входные данные")
>     end
> 
>     filter --> HITL{{Одобрение человеком}}
>     HITL --> input_prov
>     input_prov --> Execute(Выполнить)
> 
>     classDef unused stroke-dasharray: 5, 5, stroke:#aaa, color:#aaa
>     class state unused
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

-   **Динамические импорты (Запрос информации)**: Если `_imports` описано более гибко (например, как список возможных вариантов: `_imports: { "type": "array", "items": { "enum": ["state"] } }`), то информацию инструмент **запрашивает**. В этом случае ИИ сам решает, какие данные из разрешённого списка ему нужны прямо сейчас для работы.

Этот способ особенно крут, когда есть человек, который всё проверяет. ИИ может сказать: «Чтобы ответить, мне нужно посмотреть твою историю сообщений. Разрешаешь?» А ты можешь согласиться или отказать. Это даёт прозрачность и контроль.

## Сила ограниченной информации

-   **Безопасность и концентрация**: Ограничивая «поле зрения», импорты не дают ИИ случайно увидеть и разболтать секреты. А ещё это помогает ему сосредоточиться, что делает его работу точнее, предсказуемее и дешевле (ведь он не тратит время на размышления о лишнем).
-   **Улучшенная модульность**: Импорты позволяют делать инструменты (`Ideas` и `Activities`) похожими на кубики LEGO. Каждый кубик самодостаточен. Ему не нужно знать обо всей постройке, чтобы быть полезным. Его можно использовать в любом месте, просто передав ему нужные детали через `_imports`.