# 001: Агент/Запрос

> **Запрос:** Одно отдельное обращение к умному помощнику (LLM), которое берёт «контекст» и «схему» и создаёт «решение». — [Глоссарий](./000_glossary.md)

> Sidenote: NPM: [https://www.npmjs.com/package/@augceo/agent](@idealic-ai/agent)

Этот документ описывает **Протокол Запроса** — правила, по которым мы общаемся с искусственным интеллектом (ИИ). `Запрос` — это как моторчик, который заставляет абстрактную **[Концепцию/Идею](./101_concept_idea.md)** работать. Он берёт её `контекст` (всю предысторию) и `схему` (шаблон ответа), чтобы получить готовое `решение`.

## Конвейер Запросов

`Запрос` — это не просто одна команда для ИИ. Это целый пошаговый процесс, похожий на сборочный конвейер, который превращает сложный, многосоставной контекст в один чёткий ответ от ИИ, соответствующий заданному шаблону.

### 1. Контекст: Список Сообщений

Основа любого `Запроса` — это его `контекст`. Представь его как историю переписки в чате, где каждое сообщение — это отдельный объект `Message`. Такой список позволяет передать ИИ сложный разговор с разными участниками или множеством поворотов.

Простой контекст может выглядеть так:

```json
[
  { "role": "system", "content": "Ты — полезный ассистент." },
  { "role": "user", "content": "Какая столица у Франции?" }
]
```

### 2. Особые Типы Содержимого

Система делает этот чат ещё умнее, позволяя использовать **особые типы содержимого** в сообщениях. Вместо обычного текста в `content` может быть специальный объект, например: `{ "type": "state", "state": { ... } }`.

Думай об этом как о секретных командах или волшебных ингредиентах, которые ты добавляешь в разговор. Для каждого такого «ингредиента» есть свой обработчик — маленький робот-помощник на нашем конвейере. Когда он видит своё сообщение, он может изменить три важные вещи в `Запросе`:

- **Настройки ИИ**: Поменять модель, креативность («температуру») или другие параметры.
- **Схему**: Изменить шаблон, по которому ИИ должен дать ответ.
- **Контекст**: Подправить саму историю переписки. Например, превратить «секретную команду» в понятный для ИИ текст или добавить новые сообщения.

Этот мощный конвейер позволяет системе работать со сложными идеями, каждый раз создавая идеальный, точно настроенный запрос для ИИ.

### 3. Схема: Шаблон для Решения

`Схема` — это как форма для заполнения, которая говорит ИИ, в каком виде мы ждём от него ответ (`решение`). Система сама выясняет, как лучше всего заставить ИИ следовать этому шаблону:

1.  **Родной режим JSON-схемы**: Если ИИ это умеет (как новые модели OpenAI), ему просто передают эту «форму» напрямую. Это самый надёжный способ.
2.  **Запасной план с «инструментом»**: Если ИИ не понимает схемы, но умеет пользоваться «инструментами», система хитро заворачивает схему в инструмент под названием `generate_response` и просит ИИ его использовать.
3.  **Режим JSON с подсказкой**: В крайнем случае, если ИИ умеет только выдавать текст в формате JSON, система просто пишет в своей инструкции: «Сгенерируй JSON-объект, который выглядит вот так...» и показывает схему в виде текста.

### 4. Выполнение и Решение

После всей этой подготовки готовая история переписки и правила для ответа упаковываются в один запрос и отправляются к ИИ. ИИ генерирует ответ, который точно соответствует нашему шаблону.

Система получает этот ответ и превращает его в удобный для работы объект. Этот объект и есть `решение`.

Весь этот процесс — от обработки сложного контекста до получения проверенного по схеме решения — и позволяет абстрактной **Идее** стать чем-то реальным и работающим внутри системы.