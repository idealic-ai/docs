# 001: Агент/Запрос

> **Запрос:** Это как одноразовое задание для искусственного интеллекта (ИИ). Ты даёшь ему «контекст» (что происходит) и «схему» (как должен выглядеть ответ), а он выдаёт тебе «решение». — [Глоссарий](./000_glossary.md)

> Sidenote: NPM: [https://www.npmjs.com/package/@augceo/agent](@idealic-ai/agent)

В этом документе мы разберём «Протокол Запроса». Протокол — это просто набор правил. А Запрос — это основная команда, которую мы даём искусственному интеллекту (ИИ). «Запрос» — это как моторчик, который заставляет абстрактную **[101: Концепция/Идея](./101_concept_idea.md)** работать. Он берёт её «контекст» и «схему», чтобы создать «решение».

## Конвейер Запроса

> Sidenote:
>
> ИИ обработает «контекст», чтобы создать «решение», которое соответствует «схеме».
>
> ```mermaid
> graph TD
>     subgraph Что даёт пользователь
>         direction LR
>         Context[\Контекст\]
>         Schema[\Схема\]
>     end
> 
>     Process{{"Запрос"}}
> 
>     subgraph Что выдаёт ИИ
>         direction LR
>         Solution[/Решение/]
>     end
> 
>     Context --> Process
>     Schema --> Process
>     Process --> Solution
>     Schema -.-> Solution
> 
>     linkStyle 2 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
>     linkStyle 3 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
> ```

`Запрос` — это не просто вопрос, который ты задаёшь чат-боту. Это целый конвейер, который превращает сложную информацию из разных частей («контекст») в один чёткий ответ от ИИ, построенный по строгим правилам («схеме»).

### 1. Контекст: Вся переписка по порядку

Основа любого `Запроса` — это `контекст`. Представь его как историю вашей переписки с ИИ. Технически это список (`массив`) сообщений. Благодаря этому ИИ видит весь разговор: кто что сказал и в каком порядке. Это помогает ему понять, что происходит, даже если беседа длинная и запутанная.

Простой пример контекста:

```json
[
  { "role": "system", "content": "Ты — полезный ассистент." },
  { "role": "user", "content": "Какая столица Франции?" }
]
```

### 2. Особые типы сообщений

Наша система умеет больше, чем просто обмениваться текстом. Сообщение может содержать не просто слова, а особые структурированные данные, например: `{ "type": "state", "state": { ... } }`. Это как отправить не записку, а целую анкету с данными.

Для каждого такого особого типа есть свой «обработчик» — специальная программка. Когда система видит такое сообщение, обработчик может на лету изменить три главных элемента Запроса:

- **Настройки ИИ (`LLM Config`)**: Изменить параметры ИИ, например, сделать его более креативным или, наоборот, более строгим.
- **Схема (`Schema`)**: Поменять правила, по которым ИИ должен построить свой финальный ответ.
- **Контекст (`Context`)**: Изменить список сообщений, которые увидит ИИ. Например, превратить сложный код в простое текстовое описание или добавить уточняющие сообщения.

Этот мощный «конвейер» позволяет агенту работать со сложными идеями, каждый раз автоматически создавая идеальную команду для ИИ, чтобы тот выполнил задачу.

### 3. Схема: Правила для Решения

`Схема` — это как чертёж или анкета, которая объясняет ИИ, как именно должен выглядеть его ответ (`решение`). Функция `Запроса` проверяет, что умеет конкретный ИИ, и выбирает лучший способ заставить его следовать правилам:

1.  **Родной режим JSON-схемы**: Если ИИ это умеет (как новые модели OpenAI), мы просто передаём ему схему напрямую. Это самый надёжный способ. Это как дать человеку анкету, которую он был создан заполнять.
2.  **Через вызов инструмента**: Если ИИ не понимает схемы напрямую, но умеет пользоваться «инструментами», мы хитрим. Мы «заворачиваем» нашу схему в инструмент под названием `generate_response` и просим ИИ «использовать» его.
3.  **Через подсказку в задании**: Это крайний случай. Мы просто пишем ИИ в задании: «твой ответ должен быть в формате JSON», и вставляем текст схемы прямо в инструкцию.

### 4. Выполнение и получение Решения

После всей подготовки финальный список сообщений и правила для ответа упаковываются в одну команду и отправляются ИИ. Искусственный интеллект генерирует ответ, который точно соответствует схеме.

Затем система берёт этот ответ — неважно, пришёл он как обычное сообщение или через «инструмент» — и превращает его в аккуратный, структурированный объект данных. Этот объект и есть наше `решение`.

Весь этот конвейер — от обработки сложного разговора до получения чёткого, проверенного по схеме решения — и позволяет «Идее» стать основной «деталькой», из которой строятся вычисления в нашей системе.

`Схема` определяет, как будет выглядеть `решение`.