# 011: Агент/Инстансинг

> **Инстансинг:** Это как если бы повар на кухне готовил сразу несколько разных заказов. Каждый заказ — это отдельный «экземпляр» (`Instance`), у которого есть свой собственный чек (`State Object`) и уникальный номер. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется: [010: Агент/Состояние](./010_agent_state.md)
> - Совместимо с:
>   - [007: Агент/Ввод](./007_agent_input.md)
>   - [008: Агент/Импорты](./008_agent_imports.md)
>   - [012: Агент/План](./012_agent_plan.md)

Этот документ объясняет, как обрабатывать много независимых задач (экземпляров) за один раз, используя систему, основанную на «состояниях».

## 1. Главное требование: Система Состояний

Чтобы всё работало, нам нужна **Система Состояний**. Представь её как кухню, где планирование (что приготовить) и исполнение (сама готовка) — это два разных шага.

Мостиком между этими шагами служит **Объект Состояния** (`State Object`). Это как чек заказа на кухне, который можно менять. У него две важные роли:

1.  **Место для результата**: Это холст, на котором работают инструменты. Когда повар что-то делает (например, жарит котлету), он отмечает результат на чеке. Каждое действие (`Tool Call`) содержит специальную пометку `_outputPath`, которая указывает, в какую строчку на чеке записать результат.
2.  **Источник для следующих шагов**: Инструмент может посмотреть на чек, чтобы понять, что ему нужно для работы. Например, чтобы «пожарить котлету», нужно сначала «взять котлету из холодильника». Так шаги связываются друг с другом.

## 2. Механизм Инстансинга

Настоящая магия этой системы в том, что она с самого начала умеет работать с кучей задач одновременно. И всё благодаря Системе Состояний.

### 2.1. Номера-идентификаторы

Чтобы обработать много заказов за раз, система получает их списком. Каждому заказу (экземпляру) присваивается **уникальный номер** с помощью специального свойства `_instance`. Эти номера — короткие и простые значки (например, цифры в кружочках: `①`, `②`). Они нужны только для того, чтобы нейросеть-повар не перепутала заказы.

### 2.2. Адресные операции

Этот номер `_instance` используется, чтобы все действия применялись только к нужному заказу. Все служебные команды для инструмента начинаются с подчёркивания (`_`), а его обычные параметры находятся прямо внутри.

- **Связь с инструментом**: В плане у каждого шага (`Tool Call`) есть пометка `_instance`, чтобы было понятно, к какому заказу он относится.
- **Автоматическая привязка**: Когда у действия есть номер `_instance`, все пути (вроде `_outputPath` или ссылки на другие данные) автоматически относятся только к этому заказу. Это значит, что когда инструмент читает что-то с чека или записывает на него, он работает только с данными заказа `①` или заказа `②`, не путая их.

Благодаря этому сами инструменты остаются очень простыми. Им не нужно знать, что они работают с одним из многих заказов. Номер-идентификатор сам всё организует.

### 2.3. Пример

Представь, что нам пришёл один запрос с двумя задачами: проанализировать настроение двух фраз. Мы можем также дать нейросети подсказку, как должен выглядеть чек заказа (это называется «схема»).

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "Это прекрасно!" },
      // Это схема - подсказка, как должен выглядеть чек
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "Это ужасно." } }
  ]
}
```

Нейросеть видит обе задачи сразу и составляет единый план для них:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      // Взять текст с чека
      "text": "†state.text", 
      // Записать результат в поле 'sentiment'
      "_outputPath": "sentiment" 
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

После этого система выполняет этот план и записывает результаты в чеки соответствующих заказов.

## 3. Дополнительная система: Граф Планирования

Хотя для инстансинга это не обязательно, **Система Планирования** идеально с ним сочетается. Она позволяет создавать очень надёжные и повторяемые процессы.

**План** — это как идеальный рецепт для сложного блюда. Он состоит из шагов-инструментов (`Tool Calls`), связанных между собой. Этот рецепт можно составить и отточить *до* начала готовки.

Когда рецепт готов, его можно передать повару (агенту) вместе с заказами. И тогда агент будет просто следовать этому идеальному рецепту для каждого из заказов. Результат получится одинаково хорошим для всех. А чек заказа (`State Object`) для каждого экземпляра будет показывать, на каком этапе «рецепта» он сейчас находится.

## 4. Плюсы такого подхода

Эта модель инстансинга даёт нам большие преимущества:

- **Эффективность**: Она позволяет обрабатывать много задач за один запрос к нейросети. Это как если бы официант принёс повару сразу 10 заказов вместо того, чтобы бегать по одному. Всё делается быстрее и дешевле.
- **Постоянство и Качество**: Когда нейросеть видит несколько похожих задач одновременно, она может составить для них более качественный и одинаковый план, находя общие закономерности.
- **Предсказуемость**: Если использовать готовый **План** (рецепт), то результат будет гарантированно одинаковым. Процесс становится очень надёжным, и мы точно знаем, что получим в итоге для каждого заказа.