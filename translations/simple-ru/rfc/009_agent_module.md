# 009: Агент/Модуль

> **Модуль**: Это правило, которое позволяет изолировать выполнение задачи. Представь себе «чистую комнату», где специалист работает над чем-то, не отвлекаясь на беспорядок снаружи. Модуль вызывается с помощью специального свойства `_module` в `Вызове` и выполняет задачу в этой «чистой комнате». А свойство `_imports` — это как окошко, через которое можно передать специалисту только те инструменты, которые ему нужны.

> — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Мы уже знаем, как работают отдельные «инструменты» агента. Теперь **Протокол Модулей** объясняет, как объединять эти инструменты в большие и сложные системы. Он позволяет запускать инструменты в изолированных «чистых комнатах». Это не даёт разным задачам мешать друг другу и позволяет использовать одни и те же инструменты в разных местах.

Представь, что агент может передать сложную задачу другому агенту-специалисту. Так система может строить очень сложное поведение, собирая его из маленьких, независимых и самодостаточных блоков.

## Проблема: Гигантские инструменты и «перекрёстное загрязнение»

Когда у агента появляется всё больше способностей, хранить все его «инструменты» в одной большой коробке становится неудобно.

1.  **Слишком большие инструкции**: У «мозга» системы (ИИ) есть предел того, сколько информации он может обработать за раз. Если дать ему гигантский список сложных инструментов, он может запутаться и не сможет правильно выбрать нужный.
2.  **«Перекрёстное загрязнение» контекста**: Когда все инструменты лежат в одной куче, ИИ может случайно использовать информацию от одного инструмента при работе с другим. Это как если бы ты пытался рисовать, а на кисточку попала глина из набора для лепки — результат будет не тот, что ты ожидал.
3.  **Невозможность повторного использования**: Инструмент, созданный для одного агента, трудно использовать в другом, не перетаскивая с собой всю «коробку», в которой он лежал.

Протокол Модулей решает эти проблемы, создавая **Область Видимости Модуля** — способ передать задачу во внешнюю, изолированную среду выполнения.

## Свойство `_module`

Чтобы указать, что задача должна выполняться в такой «чистой комнате», используется специальное свойство `_module` в схеме Инструмента. Это свойство говорит системе: «Не делай это здесь. Отправь эту работу внешнему специалисту (модулю)».

Свойство `_module` — это просто текст (`string`), и его можно использовать двумя способами:

- **Ссылка на «Идею»**: Текст может быть ссылкой на другую «Идею» — это как чертёж, в котором описаны все нужные инструкции. Это позволяет одному инструменту передать свою работу совершенно другому набору инструкций. Ссылка может выглядеть как:
  - Путь к файлу на компьютере (например, `../ideas/my-idea.json`).
  - Специальная интернет-ссылка `idea://`.

  > Sidenote:
  > Сохранённый, многоразовый **[001: Агент/Запрос](./001_agent_request.md)** — это самая распространённая форма «Идеи». Протокол Модулей — основной способ объединения этих «Идей» в более сложные системы. Подробнее см. в **[101: Концепция/Идея](./101_concept_idea.md)**.

- **Создание анонимного модуля**: Если написать слово `'anonymous'`, система создаст временную «чистую комнату» для одной конкретной задачи, без необходимости создавать и сохранять отдельный чертёж «Идеи».

## Работа в «чистой комнате»

Модуль предоставляет «чистую комнату» для работы. Вместо того чтобы выполняться в шумной мастерской главного агента, задача обрабатывается в новом, изолированном пространстве. Все инструменты и материалы для этой новой задачи подбираются с нуля, а не берутся из общей кучи.

И здесь становится очень важен **[Протокол Импортов](./008_agent_imports.md)**. Свойство `_imports` в схеме Инструмента работает как пропускной пункт. Оно чётко указывает, какие именно «инструменты» и «материалы» из главной мастерской нужно передать в «чистую комнату» модуля. Это позволяет главному агенту точно контролировать, что видит модуль, и предотвращает «перекрёстное загрязнение».

> Sidenote:
> - [008: Агент/Импорты](./008_agent_imports.md)

## Работа с очень большими инструкциями

Протокол Модулей также помогает, когда у инструмента очень сложный результат работы. Представь, что инструмент должен создать огромный и детальный чертёж. Вместо того чтобы вставлять этот гигантский чертёж в общий план работы (занимая место и путая ИИ), можно создать инструмент, который описывает только то, *что нужно для начала работы*.

ИИ видит только простые входные данные и решает использовать этот инструмент. А вся сложная работа по созданию гигантского чертежа происходит внутри изолированной «чистой комнаты» модуля. Это позволяет агенту планировать последовательность сложных действий, не видя всех мельчайших деталей каждого шага одновременно. ИИ как бы доверяет модулю, что тот сделает свою работу правильно и вернёт нужный результат.

## Когда модуль вступает в игру?

Инструмент становится Модулем, как только в его описании появляется свойство `_module`. Это сигнал, что работу нужно передать кому-то ещё. Главный вопрос — *в какой момент* система решает, кому именно передать задачу? Есть два подхода.

### 1. Решение в момент выполнения (по умолчанию)

Самый гибкий подход — решать, как будет работать модуль, уже **во время выполнения**, после того как агент решил его использовать.

Этот метод позволяет ИИ работать как умный «переводчик» или «посредник». Агент может дать модулю задание, которое не совсем точно совпадает с инструкцией модуля. Во время выполнения система собирает вместе инструкцию модуля и задание от агента, и уже другой, вспомогательный ИИ внутри «чистой комнаты» пытается понять, как выполнить это задание наилучшим образом.

Это огромное преимущество. Модули-специалисты могут обновлять свои инструменты и методы работы, а агенты, которые их вызывают, не сломаются. ИИ-посредник постарается адаптировать старый запрос под новые правила. Это делает систему очень гибкой и устойчивой.

Вот как это происходит:

> Sidenote:
> ```mermaid
> graph TD
>     A[Агент создаёт Вызов] --> B{Исполнитель};
>     B --> C["1. Сборка Контекста<br/>(Модуль + Импорты)"];
>     C --> D["2. Сопоставление Входных Данных<br/>(Параметры Вызова)"];
>     D --> E["3. Исполнение<br/>(Новый Запрос)"];
>     E --> F["ИИ-помощник устраняет<br/>несоответствия"];
>     F --> G[Результат возвращается Агенту];
> ```

1.  Агент решает использовать инструмент-модуль.
2.  Система-исполнитель видит свойство `_module` и запускает процесс.
3.  **Сборка контекста**: Исполнитель находит «Идею» модуля (его инструкцию) и готовит «чистую комнату». Затем он использует `_imports` (пропускной пункт), чтобы передать нужные данные из мира агента.
4.  **Передача задания**: Параметры из `Вызова` агента упаковываются в «Задание» и отправляются в «чистую комнату». Здесь ИИ-посредник может проявить свою смекалку, чтобы выполнить задание, даже если оно описано не идеально.
5.  **Выполнение**: Запускается новая, изолированная задача. Её результат возвращается как ответ на первоначальный `Вызов` агента.

### 2. Решение заранее (опционально)

В ситуациях, где нужна стопроцентная надёжность, модуль можно подготовить **заранее**, ещё до того, как агент получит свою главную задачу.

В этом режиме система заранее загружает инструкцию модуля и как бы «склеивает» её с описанием инструмента. Благодаря этому главный ИИ агента с самого начала видит точные требования модуля. Это гарантирует, что созданный `Вызов` будет идеально правильным и безопасным. При таком подходе можно даже заранее знать, какой именно результат вернёт модуль.

Этот подход похож на работу со строгим контрактом, где всё прописано заранее. Он менее гибкий, но более безопасный. Его лучше использовать для критически важных задач, где сюрпризы не нужны.

## Собираем конструктор: Композитор и Звукорежиссёр

Модули позволяют создавать сложные системы, где одни «Идеи» (агенты-специалисты) выполняют задачи для других. Это создаёт понятную иерархию: агенты-руководители могут заниматься общей стратегией, передавая конкретные задачи узким специалистам.

Представим себе двух специалистов: **`Композитора`** и **`Звукорежиссёра`**.

- **`Звукорежиссёр`** — это эксперт низкого уровня. Это отдельная «Идея» (`idea://sound-designer`), которая всё знает о физике звука и умеет работать с синтезаторами, чтобы создавать конкретные звуковые файлы.

- **`Композитор`** — специалист среднего уровня. Его работа — сочинять музыку. Он использует свои собственные инструменты, чтобы придумать мелодию и структуру песни. А чтобы эта музыка зазвучала, он делает `Вызовы` к модулю `Звукорежиссёра`, который и создаёт нужные звуки.

Это простая двухуровневая система. Но настоящая сила модулей — в их гибкости.

Теперь давайте добавим **`Продюсера`** — агента высокого уровня. Его цель — выпустить готовую пластинку. В зависимости от задачи, `Продюсер` может использовать своих специалистов по-разному:

- **Иерархическая работа**: Чтобы просто создать песню, `Продюсер` может сделать один `Вызов` модулю `Композитора`. `Продюсер` даёт общее указание («Мне нужна грустная баллада»), а `Композитор` выполняет всю свою внутреннюю работу, включая вызовы `Звукорежиссёру`. В этом случае `Продюсеру` даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельная работа**: Если `Продюсеру` для пластинки нужны ещё и звуковые эффекты (например, шум дождя или гул города), он может напрямую обратиться к модулю `Звукорежиссёра` за этими звуками. И это будет происходить одновременно с тем, как `Композитор` пишет музыку.

Это показывает главный принцип: схема работы не зашита в инструментах намертво. `Продюсер` может либо обращаться к `Композитору` как к «чёрному ящику», либо напрямую работать с его помощником (`Звукорежиссёром`) — всё зависит от текущей задачи. Эта гибкость позволяет собирать из одних и тех же экспертов-модулей самые разные команды, создавая невероятно мощные и адаптируемые системы.
