# 009: Агент/Модуль

> **Модуль**: Это как отдельная деталька LEGO. Готовый кусочек программы (называемый `Действием` или `Идеей`), который можно использовать много раз. Чтобы его вызвать, мы используем команду `Вызов` в специальном «режиме модуля». Сигналом для этого режима служит свойство `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует наличия:
> - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
> - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ рассказывает о «Протоколе Модулей». Подумай о нём как о правилах, которые позволяют инструментам (`Tools`) работать в своей собственной, изолированной «комнате». Это главный способ собирать сложные программы-агенты из маленьких, самостоятельных и многоразовых «кубиков».

## Проблема: Громоздкие Инструменты и «Утечка Контекста»

Когда агенты становятся умнее и сложнее, хранить все их `Инструменты` в одном большом ящике становится неудобно.

1.  **Слишком большие инструкции**: У искусственного интеллекта (ИИ) есть предел тому, сколько информации он может держать в голове за раз. Если смешать кучу сложных `Инструментов`, он может запутаться и не понять, что ему делать.
2.  **«Утечка контекста»**: Когда все `Инструменты` лежат в одной коробке, ИИ может отвлечься на что-то ненужное. Это как если бы ты пытался собрать модель самолёта, а рядом лежали детали от машины — можно случайно взять не ту деталь.
3.  **Трудно использовать повторно**: `Инструмент`, созданный для одного агента, нельзя просто так взять и использовать в другом. Придётся тащить с собой всю его «коробку» с инструкциями.

Протокол Модулей решает эти проблемы, вводя «Область Видимости Модуля». Это способ передать задачу (`Вызов`) кому-то другому, кто выполнит её в своей отдельной, чистой «комнате».

## Свойство `_module`

Область видимости модуля обозначается свойством `_module` в инструкции (схеме) `Инструмента`. Это свойство — как специальная записка для системы. Она говорит: «Не делай это здесь. Отправь эту задачу как запрос внешнему модулю».

Свойство `_module` — это текстовая строка.

- **`_module: 'idea://<idea-name>'`**: Эта строчка — как адрес, который ведёт к определённой `Идее`. Она говорит исполнителю запустить `Вызов` в окружении этой конкретной `Идеи`.
- **`_module: 'anonymous'`**: Это слово говорит, что нужен анонимный модуль. Он используется, когда тебе нужна чистая «комната» для выполнения `Действия`, но без создания целой `Идеи`.

## Исполнение в «Чистой Комнате»

Модуль предоставляет «чистую комнату» для работы. Вместо того чтобы выполнять задачу в шумном и загруженном окружении родительского агента, `Вызов` обрабатывается в новом, изолированном месте. Окружение для этой работы создаётся с нуля, а не наследуется.

И тут на сцену выходит **[Протокол Импортов](./008_agent_imports.md)**. Свойство `_imports` в схеме инструмента работает как мостик. Оно точно указывает, какие кусочки информации из родительского окружения нужно «перенести» в эту чистую комнату. Так родительский агент контролирует, что видит модуль, и предотвращает путаницу.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Композиция и Повторное Использование: Композитор и Звукорежиссёр

Модули позволяют собирать что-то мощное из простых частей, как из LEGO. `Идеи` могут работать как отдельные сервисы, которыми управляют другие агенты. Получается чёткая иерархия: главные агенты занимаются организацией процесса, а специализированные задачи поручают маленьким, многоразовым модулям.

Представь себе рабочий процесс с двумя модулями-специалистами: **`Композитором`** и **`Звукорежиссёром`**.

- **`Звукорежиссёр`** — это низкоуровневый эксперт. Это самостоятельная `Идея` (`idea://sound-designer`), которая знает всё о физике звука и умеет управлять синтезаторами, чтобы создавать конкретные звуки.

- **`Композитор`** — специалист среднего уровня. Его работа — создать песню. Он использует свои собственные инструменты, чтобы придумать мелодию и структуру. А чтобы воплотить свою задумку, он делает `Вызовы` к модулю `Звукорежиссёра` для синтеза самих звуков.

Такая двухэтажная система — обычное дело. Но настоящая сила модулей в том, как гибко они могут работать вместе в зависимости от задачи.

Теперь представим высокоуровневого агента-**`Продюсера`**. Его цель — выпустить готовую пластинку. В зависимости от задачи, `Продюсер` может по-разному организовывать работу своих модулей:

- **Иерархическая организация**: Для создания песни `Продюсер` может сделать один `Вызов` к модулю `Композитора`. `Продюсер` даёт общее указание («Мне нужна грустная баллада»), а `Композитор` выполняет всю свою внутреннюю работу, включая свои собственные `Вызовы` к `Звукорежиссёру`. `Продюсеру` в этом случае даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельная организация**: Если `Продюсеру` также нужны особые звуковые эффекты для пластинки (например, шаги или шум фона), он может делать `Вызовы` напрямую к `Звукорежиссёру` для этих задач, параллельно с `Вызовом` к `Композитору`.

Главный принцип здесь такой: структура работы не зашита в самих инструментах. `Продюсер` может обращаться к `Композитору` как к «чёрному ящику» или напрямую взаимодействовать с его отдельными частями (`Звукорежиссёром`), в зависимости от того, что нужно в данный момент. Это позволяет комбинировать одни и те же модули-эксперты по-разному, создавая очень гибкую и мощную систему.

## Работа с Большими Схемами

Модули также помогают, когда у инструмента очень сложный или большой результат работы. Вместо того чтобы описывать этот гигантский результат (`_output`) в главном запросе (что может занять всё внимание ИИ), инструмент можно определить только с параметрами `ввода` и ссылкой-указателем `_module`.

ИИ может спланировать `Вызов`, зная только, что нужно подать на вход. А сложный результат будет создан внутри отдельной «комнаты» модуля. Это позволяет агенту планировать последовательность сложных действий, не видя перед собой подробные инструкции для каждого шага одновременно. ИИ просто доверяет, что модуль сделает свою работу правильно и вернёт нужный результат, который можно будет использовать дальше.

## Стратегии Разрешения Модулей

Инструмент становится `Модулем`, как только у него появляется свойство `_module`. Это сигнал, что задачу нужно передать дальше. Главный вопрос — *когда* система находит этот модуль, которому нужно передать задачу. Есть два способа, которые позволяют выбирать между строгой безопасностью и гибкостью.

### 1. Разрешение во время выполнения (По умолчанию)

Самый гибкий и стандартный подход — это находить модуль прямо **во время выполнения**, уже после того, как агент создал `Вызов`.

Этот метод позволяет делать то, что невозможно в обычном программировании: **ИИ работает как умный клей или переводчик.** Агент может отправить `Вызов` с параметрами, которые не совсем точно совпадают с тем, что ожидает модуль. Во время выполнения система собирает всё вместе, и уже ИИ внутри модуля пытается «склеить» одно с другим.

Это огромное преимущество, потому что модули можно обновлять и менять независимо друг от друга. Даже если модуль изменится, агенты, которые его вызывают, не сломаются сразу. ИИ попытается приспособить старый `Вызов` к новым правилам, делая систему очень живучей и гибкой.

Процесс выглядит так:

1.  Агент создаёт `Вызов` к модульному инструменту.
2.  Исполнитель видит свойство `_module` и запускает протокол.
3.  **Сборка Контекста**: Исполнитель находит нужную `Идею` модуля (если он не анонимный) и собирает его базовое окружение. Затем с помощью `_imports` он добавляет туда нужную информацию от родителя.
4.  **Передача Входных Данных**: Параметры из `Вызова` упаковываются во `Входное Сообщение` и добавляются в окружение. Здесь и проявляется «клейкая» способность ИИ: он будет использовать эти данные, чтобы выполнить логику модуля, даже если схемы не совпадают идеально.
5.  **Исполнение**: Создаётся новый, изолированный `Запрос` с собранным окружением. Результат этой работы возвращается как ответ на первоначальный `Вызов`.

### 2. Предварительное Разрешение (Опционально)

Для случаев, когда нужны более строгие гарантии, модуль можно «проверить» **заранее**, ещё до того, как агент отправит первый `Запрос`.

В этом режиме система заранее загружает `Идею` модуля и объединяет его требования к `вводу` с параметрами инструмента. Это позволяет ИИ агента с самого начала видеть точные требования модуля и быть уверенным, что он создаст идеально правильный и безопасный `Вызов`.

Этот подход даёт безопасность, как при работе со строгими инструкциями, но жертвует гибкостью. Он лучше всего подходит для очень важных и чётко определённых задач, где сюрпризы нежелательны.