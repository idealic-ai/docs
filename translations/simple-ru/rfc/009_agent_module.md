# 009: Агент/Модуль

> **Модуль**: Это как отдельное приложение или инструмент, который можно использовать много раз. Это может быть какая-то программа (`Действие`) или даже другая «умная» система (`Идея`). Ты можешь «вызвать» его, чтобы он поработал в своём собственном, отдельном пространстве. Это как запустить программу в новом окне, чтобы она не мешала остальным. О том, что это модуль, нам говорит свойство `_module`.
>
> — [Словарь](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ расскажет тебе о **Протоколе Модулей**. Это набор правил, который позволяет «инструментам» (`Tools`) работать в отдельном, изолированном пространстве. Думай об этом как о возможности собирать большие и сложные программы из маленьких, независимых и многоразовых «кубиков».

## Проблема: Гигантские Инструменты и Информационная «Каша»

Когда «агент» (умная программа) становится очень сложным, хранить все его инструменты в одном месте — плохая идея. И вот почему:

1.  **Слишком много правил**: У больших языковых моделей, которые являются «мозгом» нашего агента, есть предел. Они не могут удержать в голове сразу тысячу сложных инструкций. Если у агента будет слишком много инструментов, он запутается и не сможет правильно выбрать нужный.
2.  **Информационная каша**: Когда все инструменты лежат в одной коробке, информация от одного может случайно «перетечь» к другому. Это как если бы ты пытался решить задачу по математике, а тебе в ухо кто-то бубнил рецепт пирога. Агент может запутаться и использовать не тот инструмент или дать ему неверные данные.
3.  **Одноразовые инструменты**: Инструмент, созданный для одного агента, очень сложно забрать и отдать другому. Придётся тащить с собой всю «коробку», в которой он лежал.

Протокол Модулей решает эти проблемы, создавая для `Вызова` отдельное, чистое рабочее пространство — **Пространство Модуля**.

## Свойство `_module`

Чтобы сказать системе, что нужно использовать такое отдельное пространство, мы добавляем к инструменту специальную метку — свойство `_module`. Это свойство — как записка, которая говорит: «Эту задачу нужно выполнять не здесь, а поручить внешнему специалисту».

Свойство `_module` — это текстовая строка (`string`).

- **`_module: 'idea://<idea-name>'`**: Эта запись, похожая на веб-адрес, указывает на конкретную `Идею`. Она говорит системе: «Выполни этот `Вызов` в пространстве той `Идеи`, на которую я ссылаюсь».
- **`_module: 'anonymous'`**: Эта запись означает «без имени». Она используется, когда нужно просто создать временное, изолированное место для выполнения какого-то `Действия`, не подключая целую `Идею`.

## Работа в «Чистой Комнате»

Модуль предоставляет «чистую комнату» для работы. Вместо того чтобы толкаться в шумном офисе главного агента, `Вызов` обрабатывается в новом, изолированном кабинете. Вся информация для работы в этом кабинете не берётся случайно, а тщательно подбирается.

Именно здесь в игру вступает **[Протокол Импорта](./008_agent_imports.md)**. Свойство `_imports` в инструменте — это как пропуск на входе в «чистую комнату». Оно точно определяет, какие данные из главного офиса можно пронести внутрь. Так главный агент полностью контролирует, что видит модуль, и никакой информационной каши не возникает.

## Сборка и Повторное Использование: Композитор и Звукорежиссёр

Модули позволяют собирать сложные системы, как из конструктора, где одна `Идея` может выступать в роли сервиса для другой.

Представь, что у нас есть два агента: `Композитор` и `Звукорежиссёр`.

- **`Звукорежиссёр`** — это самостоятельная `Идея` (допустим, по адресу `idea://sound-designer`). Он — эксперт по синтезаторам и знает всё о создании звуков. У него есть свои правила и инструкции. Он — независимый специалист, которого можно нанять.
- **`Композитор`** — его задача написать песню. У него есть инструмент `createMelody` (создать мелодию). Но фишка в том, что этот инструмент сам не умеет создавать звуки. Вместо этого он просто вызывает на помощь эксперта, указывая `_module: 'idea://sound-designer'`.

Когда `Композитор` решает использовать инструмент `createMelody`, он создаёт `Вызов`. И вот что происходит дальше:

1.  Система создаёт новую, изолированную «чистую комнату» (под-запрос).
2.  В эту комнату приглашается `Звукорежиссёр` со всеми его знаниями о синтезаторах.
3.  С помощью `_imports` в комнату передаётся «рассказ о песне» от `Композитора`.
4.  Теперь `Звукорежиссёр` видит и свои экспертные знания, и конкретную творческую задачу от `Композитора`.
5.  Он создаёт мелодию и отправляет её обратно как результат работы инструмента `createMelody`.

`Композитору` не нужно знать, как работает синтезатор, а `Звукорежиссёру` не обязательно знать о существовании `Композитора`. Они — независимые модули, которые объединяются для решения сложной задачи.

## Как Справиться с Огромными Инструкциями

Протокол Модулей также помогает, когда у инструмента очень сложный или большой результат работы. Вместо того чтобы описывать этот гигантский результат (`_output`) в общем списке инструментов (и пугать этим языковую модель), можно просто создать инструмент, у которого есть только параметры для `ввода` (`input`) и указатель `_module`.

Языковая модель может спланировать `Вызов`, видя только входные данные, а сложный результат будет создан внутри изолированной «комнаты» модуля. Это позволяет агенту обдумывать последовательность сложных действий, не нуждаясь в том, чтобы «видеть» всю подробную схему для каждого шага в одном окне. Модель просто доверяет, что модуль сделает свою работу, а она получит результат и будет использовать его на следующих шагах.