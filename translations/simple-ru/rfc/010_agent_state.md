# 010: Агент/Состояние

> **Сообщение о состоянии (State):** Это как записная книжка для процесса, которая не стирается. В ней хранятся «переменные» или заметки, которые нужны для выполнения шагов, зависящих друг от друга. По сути, это память для одного конкретного задания. — [Словарь](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [006: Агент/Данные](./006_agent_data.md)
> - Открывает возможности для:
>   - [012: Агент/План](./012_agent_plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ объясняет, что такое **сообщение о состоянии** (или просто `State`). Это способ управлять памятью, пока агент выполняет свою работу. `State` — это специальная разновидность системы **Данных**, созданная для того, чтобы можно было выполнять сложные, многошаговые задачи. Оно работает как общая папка с файлами или «рабочая тетрадь» для одного процесса, позволяя сохранять важную информацию между вызовами разных `Инструментов`.

Объект `State` — это главный источник правды о том, на каком этапе находится выполнение задачи. Глядя на него, система понимает, что уже сделано, и может продолжать работу с того места, где она остановилась.

## Многошаговые Инструменты

Главная задача `State` — позволить разным `Инструментам` обмениваться информацией в рамках одного непрерывного процесса. Это похоже на общую доску, на которой `Инструменты` могут записывать свои результаты.

Работает это просто: один `Инструмент` записывает свой результат в `State`, а другой `Инструмент` на следующем шаге может прочитать эти данные и использовать их в своей работе. Это позволяет создавать целые «цепочки» инструментов, где результат работы одного становится заданием для другого, и всё это происходит без потери контекста.

## Схемы и пути для вывода

`State` добавляет очень полезный способ направлять работу ИИ. В «схеме» `State` можно заранее определить, какие данные должны появиться в итоге. Это как дать ИИ шаблон или список того, что нужно заполнить.

Это работает в паре с новым свойством в объекте `Вызова` (Call): `_outputPath`.

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

`Инструмент` может заявить о своём намерении записать что-то в `State`, указав `_outputPath` в своём `Вызове`. Этот «путь» говорит системе, куда именно в `State` нужно положить результат работы `Инструмента`. `_outputPath` — это строка, которая может использовать специальный синтаксис для описания сложных потоков данных.

### Синтаксис пути

Строка `_outputPath` может выглядеть по-разному:

- **Обычный путь:** Простая строка, указывающая на одно место. Префикс `†state.` — это как ярлык, который говорит: «это относится к нашей общей доске».
  ```json
  "†state.user.summary"
  ```
- **Альтернативные пути (Ветвление):** Символ `||` (означает «ИЛИ») используется для разделения путей, когда есть несколько возможных вариантов. Результат будет записан в одно из этих мест. Например, если операция удалась, результат пишется в одно место, а если нет — в другое.
  ```json
  "†state.summary.text || †state.summary.json"
  ```
- **Одновременные пути (Разветвление):** Символ `&&` (означает «И») указывает системе записать один и тот же результат сразу в несколько мест. Это как сделать копии отчёта и положить их в разные папки.
  ```json
  "†state.user.profile.summary && †state.audit.log.summary"
  ```

### Способы указания пути

Как именно определяется значение `_outputPath`, зависит от его схемы. Это похоже на то, как работает система **Импортов**:

- **Динамический (решает ИИ):** Схема `Инструмента` для `_outputPath` может быть гибкой (например, `{ "type": "string" }`). Это даёт ИИ свободу самому решать, куда сохранять результат, используя любой из перечисленных выше синтаксисов. Так агент может на лету соединять инструменты и создавать новые способы обработки данных.

  _Схема Инструмента:_

  ```json
  {
    "_outputPath": {
      "type": "string"
    }
  }
  ```

- **Предписанный (жёстко заданный):** С другой стороны, схема может использовать `const`, чтобы закрепить поведение инструмента. Это заставляет `Инструмент` всегда использовать один и тот же, заранее определённый путь. Это очень важно для создания стабильных и предсказуемых процессов. Например, так можно создать надёжную обработку ошибок, указав разные пути для успешного и провального исхода.

  _Схема Инструмента (с путями для успеха и ошибки):_

  ```json
  {
    "_outputPath": {
      "const": "†state.operation.result || †state.operation.error"
    }
  }
  ```
Эта гибкость — ключевая часть системы **Планов**, которая позволяет разработчику выбирать: дать агенту простор для творчества или заставить его следовать строгому и надёжному сценарию.

Когда в схеме `State` указано, что нужно заполнить определённые поля, ИИ будет стараться вызывать те `Инструменты`, у которых `_outputPath` совпадает с этими полями. Это гарантирует, что последовательность `Инструментов` будет не только логичной, но и правильной по структуре.

## Ссылки на переменные

Чтобы получился настоящий рабочий процесс, инструменты должны не только записывать данные в `State`, но и читать их оттуда. Система позволяет это делать: любой параметр в `Вызове` инструмента может быть специальной строкой, которая ссылается на переменную из «рабочей тетради».

Для этого используется простой синтаксис со знаком кинжала (`†`). Формат такой: `†<тип>.<путь>`, где `<тип>` — это вид данных (например, `state` для состояния или `input` для входных данных), а `<путь>` — это путь к нужному значению.

Например, `Вызов` инструмента для получения профиля пользователя может выглядеть так:

```json
{
  "_tool": "fetchUserProfile",
  "userId": "†state.currentUser.id"
}
```

Во время выполнения система найдёт эту ссылку, возьмёт значение из `state.currentUser.id` и подставит его в качестве параметра `userId` перед тем, как запустить инструмент.

Именно этот механизм позволяет ИИ «соединять проводами» разные инструменты, используя результат работы одного (сохранённый в `State` через `_outputPath`) как входные данные для другого. Это замыкает полный цикл: прочитать данные, обработать их и записать результат. Так инструменты могут взаимодействовать друг с другом через общую доску `State`.

## Возобновление работы

Объект `State` — это ключ к надёжности. Поскольку он хранит полную картину рабочего процесса в определённый момент времени, он позволяет приостановить процесс, а затем возобновить его. Когда начинается новый шаг, `State` с предыдущего шага даёт ИИ чёткое понимание, на чём остановилась работа, что уже сделано и что ещё предстоит сделать.

## Как это связано с другими частями

- **Вызов (Call):** Система `Вызовов` тесно связана с `State` через свойство `_outputPath`. Это свойство превращает обычный вызов инструмента, который сам по себе мог бы ничего не помнить, в операцию, которая изменяет состояние. Указывая `_outputPath`, `Вызов` даёт команду записать свой результат в `State`, и так агент шаг за шагом фиксирует результаты своих действий.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Данные (Data):** По своей сути, `State` — это просто специальное применение системы `Данных` (сообщение `Data` с `kind: "state"`). Оно использует все основные возможности `Данных` для создания постоянной памяти для агента. Свойство `schema` используется для описания структуры этой памяти, как чертёж, по которому ИИ строит свою работу. А возможность объединять данные позволяет обновлять `State` по частям, а система сама собирает всё в единое целое.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **Импорты (Imports):** Хотя прямой зависимости нет, механизм `_outputPath` в `State` идейно похож на систему `Импортов`. И там, и там используется схема, чтобы определить, будет ли значение решаться ИИ на лету или будет жёстко задано с помощью `const`. Это создаёт единый подход к управлению потоками данных.

  > Sidenote:
  > - [008: Агент/Импорты](./008_agent_imports.md)

- **План (Plan):** `State` позволяет создавать простые цепочки инструментов, но вся его мощь раскрывается, когда он используется как основа для системы `Планов`. В `Плане` рабочий процесс — это как схема, где узлы — это `Вызовы` инструментов. `State` в этой схеме играет роль соединительных линий между узлами. Он позволяет одному узлу записать что-то в переменную, а другим — прочитать её, что даёт возможность создавать сложные сценарии, например, с условиями (если-то) или параллельным выполнением задач.

  > Sidenote:
  > - [012: Агент/План](./012_agent_plan.md)

## Параллельные Состояния

Сообщение `State` — это способ управлять памятью одного процесса. Но чтобы строить по-настоящему большие системы, агенты должны уметь применять один и тот же процесс ко множеству разных данных одновременно. Для этого нужен способ управлять множеством независимых «рабочих тетрадей» параллельно в рамках одного запроса.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает, как достичь такого параллельного выполнения.
