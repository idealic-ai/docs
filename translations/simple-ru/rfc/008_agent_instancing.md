# 008: Агент/Инстансинг

> **Инстансинг:** Представь, что ты играешь в несколько игр одновременно на одном компьютере. Инстансинг — это процесс, который позволяет компьютеру управлять каждой игрой отдельно, чтобы они не мешали друг другу. У каждой игры есть своё сохранение (`State Object`) и своя уникальная метка.
> 
> — [Глоссарий](./000_glossary.md)

> Sidenote:
> 
> - Требуется: [Агент: Состояние](./007_agent_state.md)
> - Совместимо:
>   - [Агент: Ввод](./005_agent_input.md)
>   - [Агент: Импорт](./006_agent_imports.md)
>   - [Агент: План](./009_agent_plan.md)

Этот документ объясняет, как наша система-агент может выполнять много независимых задач за один раз, как будто у неё много рук. Для этого мы используем умную систему, основанную на «состояниях».

## 1. Основа основ: Система состояний

Чтобы вся эта магия работала, нам нужна одна очень важная вещь — **Система Состояний**. Её главная идея — разделить «придумывание плана» и «выполнение плана» на два разных шага.

Между этими шагами есть мостик, который называется **Объект Состояния**. Это как цифровой блокнот или файл сохранения в игре. У него две важные задачи:

1.  **Холст для работы**: Инструменты, которые использует наш агент, работают с этим блокнотом. Когда инструмент что-то делает, он записывает результат в определённое место в блокноте. У каждой команды для инструмента есть специальный адрес (`_outputPath`), куда нужно записать результат.
2.  **Источник информации**: Инструмент может взять нужную ему информацию прямо из этого блокнота. Это позволяет создавать цепочки действий, где следующий шаг зависит от предыдущего. Например, чтобы приготовить лимонад, сначала нужно выжать лимоны, а уже потом добавлять сахар.

## 2. Как работает Инстансинг

Настоящая суперсила этой системы в том, что она с самого начала умеет работать с множеством задач одновременно. И всё благодаря Системе Состояний.

### 2.1. Уникальные метки

Чтобы обработать сразу несколько задач, система получает список этих задач. Каждой задаче мы даём уникальную метку — мы называем её `_instance`. Эти метки похожи на стикеры с номерами (например, `①`, `②`). Они нужны только для того, чтобы наш умный компьютер (LLM) не перепутал задачи между собой.

### 2.2. Прицельные действия

Этот стикер `_instance` используется, чтобы каждая команда точно знала, с какой задачей ей работать. Все специальные инструкции для инструментов начинаются с нижнего подчёркивания (`_`), чтобы система понимала, что это служебная информация.

- **Связь с командой**: У каждой команды в плане есть стикер `_instance`, который говорит, к какой задаче она относится.
- **Работа в своём «мире»**: Этот стикер как бы создаёт для каждой задачи свой отдельный мирок. Когда инструмент читает или записывает что-то в блокнот состояния, он делает это только в пределах мира своей задачи. Ему не нужно знать, что происходит в других.

Благодаря этому сами инструменты остаются очень простыми. Им не нужно усложняться, чтобы работать с кучей задач. Они просто получают команду и стикер, который говорит, где её выполнить. Это как если бы у тебя был один и тот же молоток, которым ты можешь строить и скворечник, и домик для собаки, просто переключаясь между ними.

### 2.3. Пример

Представь, что нам нужно проанализировать настроение двух предложений. Мы можем отправить их в одном запросе, дав каждому свой блокнот состояния и свой стикер.

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "Это прекрасно!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "Это ужасно." } }
  ]
}
```

Компьютер видит обе задачи сразу и составляет один общий план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      "text": "†state.text",
      "_outputPath": "sentiment"
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

Затем система-исполнитель выполняет этот план, и результат для каждой задачи записывается в её собственный блокнот.

## 3. Полезное дополнение: Граф планирования

Это не обязательная часть, но она отлично работает вместе с нашей системой. Это **Система Планирования**.

**План** — это как идеальный рецепт или чертёж для какого-то процесса. Он выглядит как пошаговая схема действий, где нельзя вернуться назад (как в рецепте: нельзя «раз-испечь» пирог).

Самое классное, что этот план можно создать и проверить *до* того, как мы начнём что-то делать. А когда он готов, мы можем дать его агенту. Если у агента много одинаковых задач, он просто будет следовать этому идеальному плану для каждой из них. Это гарантирует, что результат для всех задач будет одинаково хорошим. А блокнот состояния для каждой задачи будет показывать, на каком шаге рецепта она сейчас находится.

## 4. Плюсы этого подхода

Такой способ организации работы даёт нам много преимуществ:

- **Эффективность**: Это как делать домашку по нескольким предметам сразу. Система обрабатывает много задач за один запрос к умному компьютеру, что экономит время и деньги.
- **Постоянство и Качество**: Когда компьютер видит все похожие задачи вместе, он может заметить общие закономерности и составить более качественный и одинаковый план для всех. Как повар, который готовит 10 одинаковых тортов за раз — они получатся более похожими, чем если бы он готовил их в разные дни.
- **Предсказуемость**: Если мы используем заранее подготовленный **План** (наш идеальный рецепт), то точно знаем, каким будет результат. Никаких сюрпризов! Это делает работу системы очень надёжной.