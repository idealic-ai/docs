# 304: Идеатор/Наблюдатель

> **Наблюдатель (Watcher):** Это как сторож, который постоянно следит за каким-то хранилищем. Когда в хранилище что-то меняется (например, кто-то сохраняет новую версию `Идеи`), он немедленно запускает новый процесс — обычно он вызывает `План`, чтобы тот обработал новые данные.
> 
> — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [301: Идеатор/Хранилище](./301_ideator_storage.md)
>   - [012: Агент/План](./012_agent_plan.md)

## 1. Введение

Этот документ описывает **Протокол Наблюдателя**. Это очень важная часть системы, которая позволяет создавать процессы, работающие не по порядку, а в ответ на какие-то события. `Наблюдатель` — это постоянно работающая служба, которая следит за `Хранилищем` и, если там что-то поменялось, запускает новые задачи.

Представь себе датчик движения. Он не работает постоянно, а включается только тогда, когда кто-то проходит мимо. `Наблюдатель` работает похожим образом — он «просыпается» и начинает действовать, когда в данных происходит изменение.

Это главный способ соединить части системы, которые помнят своё состояние, и те, которые не помнят. А ещё он помогает справляться с очень долгими задачами, которые нельзя выполнить за один раз.

## 2. Наблюдатель как «источник» Идеатора

Если `Хранилище` — это «приёмник», куда в итоге попадают данные (как финишная черта для задачи), то `Наблюдатель` — это «источник». Его роль не заканчивать работу, а **начинать новую**.

Обычно всё происходит так:

1.  Какая-то `Идея` сохраняется в `Хранилище`. Первая задача выполнена.
2.  `Хранилище` тут же посылает всем сигнал: «Эй, у меня обновление!»
3.  `Наблюдатель`, который подписан на эти сигналы, видит это уведомление.
4.  `Наблюдатель` запускает совершенно новую, независимую задачу. Чаще всего он вызывает какой-нибудь `План` ([012: Agent/Plan](./012_agent_plan.md)) и передаёт ему новую `Идею`, чтобы тот начал с ней работать.

## 3. Работа с долгими и асинхронными процессами

`Наблюдатель` — это ключ к решению проблемы очень долгих задач, которые выполняются в фоновом режиме.

Представь, что у тебя есть `План`, в котором один из шагов занимает несколько часов или даже дней (например, нужно дождаться ответа от человека или обработать огромный файл). Обычная программа не может просто «зависнуть» и ждать так долго.

Вместо этого `План` может поступить умнее:

1. Он поручает долгую задачу какому-то внешнему сервису.
2. Сразу после этого `План` завершает свою работу, освобождая ресурсы.
3. Когда внешний сервис закончит (спустя часы или дни), он сохранит результат своей работы обратно в `Хранилище`.
4. А там уже ждёт другой `Наблюдатель`, настроенный именно на этот результат. Как только он увидит, что нужные данные появились, он запустит *новый* `План`, который продолжит работу с того места, где остановился первый.

Такой подход позволяет создавать очень надёжные и мощные системы. Они не ограничены памятью или временем работы одного компьютера. Это и есть настоящая «асинхронность»: мы разбиваем один гигантский процесс на серию маленьких задач, которые запускаются по цепочке в ответ на события.
