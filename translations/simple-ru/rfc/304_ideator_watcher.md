# 304: Идеатор/Наблюдатель

> **Наблюдатель:** Это как умный охранник (`Идеатор`), который постоянно следит за складом (`Хранилище`). Как только на склад поступает новая коробка с данными (`Идея`), он замечает это и запускает новый процесс, обычно вызывая специальный `План` для работы с этими данными.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
> Представьте Наблюдателя как охранника у склада. Его работа — не принимать товары, а замечать, когда прибывает что-то новое, и вызывать команду для его обработки. Он — инициатор, который запускает действия в ответ на события.
>
> - Требуется:
>   - [301: Идеатор/Хранилище](./301_ideator_storage.md)
>   - [012: Агент/План](./012_agent_plan.md)

## 1. Введение

Этот документ описывает **Протокол Наблюдателя**. Это очень важная часть системы, которая позволяет создавать задачи, запускающиеся автоматически в ответ на какие-то события. `Наблюдатель` — это постоянно работающий сервис, который смотрит за изменениями в `Хранилище` и запускает новые процессы, когда что-то меняется.

Это главный способ соединить сервисы, которые «помнят» своё состояние, с теми, которые «не помнят». А ещё он помогает справляться с очень долгими задачами, которые нельзя выполнить за один раз.

## 2. Наблюдатель как «источник»

Если `Хранилище` — это как финишная черта, куда приходят данные в конце операции, то `Наблюдатель` — это стартовый пистолет. Его работа — не закончить операцию, а **начать новую**.

Обычно всё происходит так:

1.  Новая `Идея` (данные) сохраняется в `Хранилище`. Первая операция завершена.
2.  `Хранилище` посылает сигнал всем, кто на него «подписан», сообщая об изменении.
3.  `Наблюдатель`, который подписан на эти сигналы, получает уведомление.
4.  `Наблюдатель` запускает совершенно новую, независимую операцию. Обычно он вызывает [012: Агент/План](./012_agent_plan.md) и передаёт ему новую `Идею`, чтобы тот начал с ней работать.

## 3. Работа с долгими процессами

`Наблюдатель` — это ключ к управлению задачами, которые могут длиться очень долго, например, часы или даже дни.

Представь, что у `Плана` есть шаг, который требует много времени (например, нужно дождаться ответа от человека или обработать огромный файл). Программа не может просто остановиться и ждать так долго.

Вместо этого `План` делает так:
1.  Он поручает долгую задачу какому-то внешнему сервису.
2.  Сам `План` на этом завершает свою работу.
3.  Когда внешний сервис наконец заканчивает свою долгую работу, он сохраняет результат обратно в `Хранилище`.
4.  И вот тут в дело вступает другой `Наблюдатель`! Он был настроен ждать именно этот результат. Увидев его, он запускает _новый_ `План`, чтобы продолжить общую задачу со следующего шага.

Это похоже на эстафету. Один бегун пробегает свой этап, передаёт эстафетную палочку и уходит отдыхать. Следующий бегун ждал именно эту палочку, и как только он её получает, он начинает свой этап. Такой подход позволяет создавать очень надёжные и мощные системы, которые не боятся долгих пауз и могут выполнять задачи любой сложности по частям.

