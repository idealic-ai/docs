# 009: Агент/Модуль

> **Модуль**: Представь себе отдельный, многоразовый «кубик Лего». Внутри него есть какая-то логика (программа или идея), и его можно вызвать специальной командой `Call`. Для этого используется свойство `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Чтобы понять это, сначала прочитай:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Этот документ дополняет:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ объясняет **Правила для Модулей**. Они позволяют запускать разные «инструменты» в своей собственной, отдельной «комнате». Представь, что у каждого инструмента есть чистое рабочее место, где он никому не мешает. Это как бы ссылка на другую `Идею` или запуск `Действия` в совершенно новом, свежем задании. Это главный способ собирать сложное поведение из маленьких, самостоятельных и многоразовых кусочков.

## Проблема: Огромные инструкции и каша в «голове»

Когда у нашего умного помощника (агента) появляется много разных способностей, хранить описание всех его `инструментов` в одном большом файле становится очень неудобно. Почему?

1.  **Слишком длинный список дел**: У искусственного интеллекта (ИИ) есть предел, сколько информации он может держать в голове одновременно. Если дать ему гигантский список сложных `инструментов`, он может запутаться и не сможет выбрать тот, который нужен.
2.  **Всё смешивается**: Представь, что ты одновременно готовишь и торт, и суп на одном столе. Ты можешь случайно насыпать сахар в суп. То же самое и с ИИ: когда все `инструменты` лежат на одном «рабочем столе», он может запутаться в ненужных деталях и выбрать не тот инструмент или использовать его неправильно.
3.  **Трудно использовать снова**: Если ты сделал крутой `инструмент` для одного помощника, его нельзя просто так взять и отдать другому. Придётся тащить с собой весь «рабочий стол» со всеми остальными инструментами.

Правила Модулей решают эти проблемы, создавая для каждого модуля свою «чистую комнату». Это способ передать команду (`Call`) кому-то другому, кто выполнит её в своей собственной, изолированной среде.

## Свойство `_module`

Чтобы включить режим «чистой комнаты», мы используем специальное свойство `_module` в описании `инструмента`. Это свойство — как записка для системы: «Эту команду выполняй не здесь, а передай вот этому специалисту».

Свойство `_module` — это просто строчка текста.

- **`_module: 'idea://<idea-name>'`**: Это как почтовый адрес, который указывает на конкретную `Идею`. Система понимает, что нужно отправить задание по этому адресу.
- **`_module: 'anonymous'`**: Эта особая команда означает «безымянный модуль». Она нужна, когда тебе нужна чистая комната для выполнения какого-то `Действия`, но ты не хочешь создавать для этого целую отдельную `Идею`.

## Работа в «чистой комнате»

Модуль предоставляет идеальное рабочее место. Вместо того чтобы работать в шумном и забитом делами пространстве главного помощника, команда (`Call`) выполняется в новом, отдельном задании. Всё начинается с чистого листа.

И тут на сцену выходит **[Правило Импортов](./008_agent_imports.md)**. Свойство `_imports` — это как мостик между главным помощником и модулем. Оно точно указывает, какие именно кусочки информации нужно принести в «чистую комнату» модуля. Это позволяет главному помощнику контролировать, что именно увидит модуль, и помогает создавать по-настоящему независимые и многоразовые «кубики Лего».

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Собираем из кубиков: Композитор и Звукорежиссёр

Модули позволяют создавать крутые комбинации, где одни `Идеи` работают как отдельные сервисы, которыми управляют другие. Получается понятная система: главные помощники думают о большой задаче (как дирижёр в оркестре), а узкие, сложные задачи передают модулям-специалистам.

Представь себе агента-**`Композитора`** и модуль-**`Звукорежиссёра`**.

- **`Звукорежиссёр`** — это отдельная `Идея` (`idea://sound-designer`). В ней хранятся все его знания о том, как создавать крутые звуки на синтезаторе. Это многоразовый специалист, который получает музыкальную идею, а возвращает готовый аудиофайл.

- Задача **`Композитора`** — написать целую песню. Сначала он придумывает мелодию, а потом создаёт для неё звуки. Для первой части у `Композитора` есть свой инструмент, `createMelody`. А для второй он вызывает инструмент `synthesizeSound`, который передаёт работу `Звукорежиссёру`, используя `_module: 'idea://sound-designer'`.

Вот как `Композитор` работает:

1.  **Придумывает сам**: Сначала `Композитор` использует свой собственный инструмент `createMelody`. Он делает это у себя на «рабочем столе». В результате появляются ноты и идея для песни.

2.  **Вызывает специалиста**: Теперь, когда есть мелодия, `Композитор` несколько раз вызывает `synthesizeSound` — для основной мелодии, для баса и так далее. Каждый раз, когда он это делает, происходит следующее:
    1.  Запускается новое, отдельное задание (как будто открывается новая звукозаписывающая студия).
    2.  В эту студию «приходит» `Звукорежиссёр`. Его собственные знания и инструкции («Ты — лучший в мире эксперт по синтезаторам...») становятся основой.
    3.  `Композитор` через `_imports` передаёт ему записку с задачей: «Вот мелодия и история песни, сделай для них крутой звук».
    4.  В итоге `Звукорежиссёр` в своей студии видит две вещи: свои постоянные знания и конкретное задание от `Композитора`.
    5.  Он выполняет свою работу и создаёт нужный звук, который отправляет обратно `Композитору` как результат вызова `synthesizeSound`.

3.  **Собирает всё вместе**: `Композитор` получает все готовые звуки от `Звукорежиссёра` и собирает из них готовую песню. Так он выполняет главную творческую работу, а для технических деталей нанимает модули-специалистов.

## Работа с гигантскими инструкциями

Модули также помогают, когда у `инструмента` очень сложный результат. Например, инструмент, который создаёт детальную 3D-модель. Описание этой модели (`_output`) может быть огромным. Вместо того чтобы показывать ИИ эту гигантскую инструкцию сразу (что может его запутать), мы показываем ему только то, что нужно для начала работы (`input`).

ИИ видит, что нужно вызвать `инструмент` для создания 3D-модели, и делает это. Ему не нужно знать все детали конечного результата, чтобы принять это решение. Он просто доверяет модулю, что тот сделает свою работу правильно. А сложный результат будет создан уже внутри «чистой комнаты» модуля.

## Как система находит нужный модуль

`Инструмент` становится `Модулем`, как только у него появляется свойство `_module`. Это сигнал системе, что задание нужно передать кому-то другому. Но когда именно система должна понять, что это за модуль? Есть два способа.

### 1. Определять на лету (по умолчанию)

Это самый гибкий способ. Система разбирается, что за модуль, уже **после того**, как помощник решил его вызвать.

Этот метод позволяет делать то, что в обычном программировании невозможно: **ИИ работает как умный «клей»**. Помощник может попросить модуль что-то сделать, даже если его просьба не совсем точно совпадает с инструкцией модуля. Когда система запускает модуль, ИИ внутри него смотрит на просьбу и на свои инструкции и пытается понять, что от него хотят. Он как бы «склеивает» одно с другим.

Это очень круто, потому что модули могут меняться и улучшаться независимо друг от друга. Даже если модуль-специалист немного изменит свои правила, помощники, которые к нему обращаются, не сломаются. ИИ постарается адаптироваться.

Как это работает:

1.  Помощник решает вызвать `инструмент`-модуль.
2.  Система видит свойство `_module` и запускает особый процесс.
3.  **Сборка информации**: Система находит нужную `Идею` модуля и загружает его «знания». Затем с помощью `_imports` добавляет задание от помощника.
4.  **Передача задания**: Параметры из команды `Call` упаковываются в сообщение и передаются модулю. Здесь ИИ и выступает в роли «клея», пытаясь выполнить задание, даже если оно описано не идеально точно.
5.  **Выполнение**: Запускается новое задание в «чистой комнате» модуля. Результат этой работы возвращается как ответ на первоначальный вызов.

### 2. Договориться заранее (дополнительная возможность)

Иногда нужна стопроцентная надёжность. В таких случаях можно определить модуль **заранее**, ещё до того, как главный помощник начнёт свою работу.

В этом режиме система заранее находит `Идею` модуля и объединяет его требования с описанием `инструмента`. Таким образом, главный помощник с самого начала видит абсолютно точную инструкцию и знает, как правильно попросить модуль о помощи. Это гарантирует, что не будет никаких недопониманий.

Это похоже на строгий контракт в реальном мире. Надёжно, но не так гибко. Этот способ хорош для очень важных задач, где ошибки недопустимы.