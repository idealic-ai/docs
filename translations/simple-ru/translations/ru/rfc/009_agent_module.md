# 009: Агент/Модуль

> **Модуль**: Это как отдельный «эксперт» (`Действие` или `Идея`), которого можно позвать на помощь. Он работает сам по себе и используется с помощью специальной команды `_module`.
>
> — [Словарь](./000_glossary.md)

> Sidenote:
>
> - Что нужно знать сначала:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Что дополняет эту тему:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ объясняет **Правила Модулей**. Эти правила позволяют нашему умному помощнику (агенту) использовать `Инструменты` в отдельном, «чистом» пространстве. Представь, что агент может либо заглянуть в другую «книгу с идеями», либо попросить другого помощника выполнить задание в совершенно новой, изолированной комнате. Это главный способ научить агента делать сложные вещи, собирая их из маленьких, готовых кубиков.

## Проблема: Гигантские инструменты и путаница в мыслях

Когда агент становится всё умнее и у него появляется много `Инструментов`, хранить их все в одной большой коробке — плохая идея.

1.  **Слишком много правил**: У компьютера, который думает (LLM), есть предел тому, сколько инструкций он может держать в голове одновременно. Если свалить на него кучу сложных `Инструментов`, он может запутаться и не понять, что ему делать.
2.  **Путаница в мыслях**: Когда все `Инструменты` лежат на одном «рабочем столе», агент может отвлечься на ненужную информацию. Это как если бы ты пытался собрать модель самолёта, а на столе лежат ещё и детали от машины — можно случайно взять не ту деталь.
3.  **Нельзя поделиться**: `Инструмент`, сделанный для одного агента, сложно просто так взять и отдать другому, потому что он слишком сильно связан со своим первым «хозяином».

Правила Модулей решают эти проблемы, создавая **пространство Модуля** — способ передать задание внешнему, отдельному помощнику.

## Свойство `_module`

Чтобы сказать системе: «Эй, это задание для отдельного помощника!», мы используем специальную метку `_module` в описании `Инструмента`. Эта метка говорит, что команду нужно не выполнять здесь и сейчас, а отправить внешнему модулю.

Эта метка — просто текст (`string`).

- **`_module: 'idea://<имя-идеи>'`**: Адрес, похожий на ссылку в интернете, который указывает на конкретную `Идею`. Это приказ запустить команду в «мире» другой `Идеи`.
- **`_module: 'anonymous'`**: Специальное слово, которое означает «безымянный модуль». Это используется, когда тебе нужна просто чистая комната для выполнения одного действия, без загрузки целой новой `Идеи`.

## Работа в «чистой комнате»

Модуль — это как «чистая комната» для работы. Вместо того чтобы выполнять команду на заваленном рабочем столе главного агента, она выполняется в новом, абсолютно пустом пространстве. Всё, что нужно для работы, приносится туда специально, а не берётся из того, что уже было.

И вот тут-то нам на помощь приходят **[Правила Импортов](./008_agent_imports.md)**. Свойство `_imports` в описании `Инструмента` — это как список вещей, которые нужно принести в эту чистую комнату с рабочего стола главного агента. Это позволяет главному агенту точно контролировать, что увидит его помощник-модуль, и избежать путаницы.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Собираем сложное из простого: Композитор и Звукорежиссёр

Модули — это как кубики LEGO. Они позволяют строить большие и сложные вещи, давая одним агентам возможность управлять другими. Получается такая команда: есть главный агент-дирижёр, который раздаёт указания, и есть агенты-специалисты, которые выполняют конкретные задачи.

Представь себе агента-**`Композитора`** и модуль-**`Звукорежиссёра`**.

- **`Звукорежиссёр`** — это отдельная `Идея` (`idea://sound-designer`). В его «голове» есть все знания о том, как создавать крутые звуки на синтезаторе. Это готовый специалист, которому можно дать музыкальную задумку, а он вернёт готовый звук.

- Задача **`Композитора`** — написать целую песню. Сначала он придумывает мелодию, а потом создаёт для неё звуки. Чтобы придумать мелодию, у него есть свой собственный инструмент, `createMelody`. А чтобы создать звук, он использует другой инструмент, `synthesizeSound`, который на самом деле просто зовёт на помощь `Звукорежиссёра` (с помощью метки `_module: 'idea://sound-designer'`).

Вот как работает `Композитор`:

1.  **Творчество**: Сначала `Композитор` использует свой внутренний инструмент `createMelody`. Он работает в своём собственном пространстве, придумывая мелодию и историю для песни.

2.  **Передача задания**: Теперь, когда мелодия готова, `Композитор` несколько раз вызывает `synthesizeSound` — для основной партии, для баса и так далее. Каждый раз происходит следующее:
    1.  Создаётся новая, «чистая комната» для работы.
    2.  В эту комнату приглашается `Звукорежиссёр`. Его собственные знания (вроде «Ты — лучший в мире эксперт по синтезаторам...») становятся основой.
    3.  `Композитор` с помощью `_imports` отправляет в комнату нужные детали: саму мелодию, настроение песни и т.д. Эти детали **добавляются** к знаниям `Звукорежиссёра`.
    4.  Компьютерный мозг (LLM) для этой задачи видит **объединённую инструкцию**: постоянные знания эксперта-звукорежиссёра и временное творческое задание от композитора.
    5.  `Звукорежиссёр` применяет свои знания к заданию и создаёт нужный звук, который отправляется обратно `Композитору` как результат работы.

3.  **Сборка**: `Композитор` получает все готовые звуки от `Звукорежиссёра` и соединяет их со своей мелодией, чтобы получилась песня. Так `Композитор` занимается главным — творчеством, а рутинную работу поручает специалистам.

## Работа с огромными инструкциями

Модули также помогают, когда у `Инструмента` очень сложный результат. Вместо того чтобы пытаться запихнуть огромную инструкцию по результату (`_output`) в один запрос (что может помешать другим инструментам), можно создать `Инструмент` только с описанием того, что ему нужно на вход (`input`), и меткой `_module`.

Агент может спланировать свою работу, зная только, что нужно подать на вход, а сложный результат будет создан в отдельной «чистой комнате» модуля. Это позволяет агенту планировать шаги, не видя всех мельчайших деталей каждого шага одновременно. Он просто доверяет, что модуль сделает свою работу правильно и вернёт нужный результат.

## Как агент находит нужный модуль

`Инструмент` становится `Модулем`, как только у него появляется метка `_module`. Она — сигнал, что работу нужно передать кому-то другому. Но главный вопрос: _когда_ система ищет этого «кого-то другого»? Есть два способа.

### 1. Поиск во время работы (по умолчанию)

Самый обычный и гибкий способ — это искать модуль **прямо во время выполнения**, уже после того, как агент решил его использовать.

Этот метод позволяет делать то, что невозможно в обычном программировании: **агент (LLM) выступает в роли умного переводчика.** Агент может дать команду с параметрами, которые не совсем точно совпадают с тем, что ожидает модуль. Во время выполнения система смотрит на то, что ожидает модуль, и на то, что прислал агент, и просит «думающий» компьютер (LLM) найти компромисс и всё-таки выполнить задачу.

Это очень круто, потому что модули-специалисты могут меняться и улучшаться. Даже если модуль начнёт требовать информацию в новом формате, агенты, которые его вызывают, не сломаются. LLM попытается «перевести» старый запрос на новый язык, делая систему очень гибкой.

Как это происходит:

1.  Агент решает использовать модульный `Инструмент`.
2.  Система видит метку `_module` и запускает процесс.
3.  **Подготовка**: Система находит `Идею` модуля, загружает его знания. Затем с помощью `_imports` добавляет информацию от агента.
4.  **Сопоставление данных**: Параметры из команды агента упаковываются в «сообщение с заданием». Здесь-то и включается «магия перевода» LLM, который поймёт, как использовать эти данные для выполнения задачи, даже если они не идеальны.
5.  **Выполнение**: Создаётся новый, отдельный `Запрос` со всеми собранными инструкциями. Результат возвращается главному агенту.

### 2. Поиск заранее (по желанию)

Для случаев, когда нужна стопроцентная надёжность, модуль можно найти **заранее**, ещё до того, как агент получит своё основное задание.

В этом режиме система заранее загружает `Идею` модуля и объединяет его требования с описанием `Инструмента`. Это позволяет агенту с самого начала видеть точные «чертежи» модуля и гарантирует, что его команда будет идеально правильной и понятной.

Этот способ надёжен, как договор на бумаге, но он менее гибкий. Он хорош для очень важных задач, где нельзя ошибаться и где творческая гибкость не нужна.