# 009: Агент/Модуль

> **Модуль**: Представь, что Модуль — это специалист, которого можно позвать на помощь. Это самостоятельный эксперт в одной теме (`Действие` или `Идея`), которого ты можешь «нанять» для выполнения конкретной задачи с помощью `Вызова`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ объясняет, как заставить разные «Инструменты» искусственного интеллекта (ИИ) работать вместе чисто и организованно. Это как строить из LEGO — ты можешь использовать отдельные, многоразовые кубики, чтобы построить что-то большое и сложное.

## Проблема: Грязные ящики с инструментами и путаница в разговорах

Когда ИИ становится мощнее, просто сваливать все его «Инструменты» в одну большую кучу создаёт проблемы.

1.  **Слишком много инструментов**: Представь, что пытаешься найти нужную отвёртку в ящике с миллионом разных инструментов. У ИИ есть предел того, сколько инструментов он может понять за раз. Если дать ему слишком много, он перегрузится и не сможет выбрать правильный.
2.  **Перепутанные разговоры**: Когда все инструменты находятся в одном рабочем пространстве, возникает путаница. Это как пытаться испечь торт, пока кто-то другой в той же комнате говорит о ремонте машины. ИИ может запутаться в информации, которая не относится к его текущей задаче.
3.  **Трудно использовать инструменты повторно**: Если ты создал отличный инструмент для одного ИИ, его сложно использовать с другим. Придётся тащить с собой всю грязную мастерскую.

Эта система решает эти проблемы, создавая **Область видимости Модуля**. Представь, что ты отправляешь конкретное задание специалисту в другую комнату, чтобы он мог сосредоточиться без всяких отвлекающих факторов.

## Тег `_module`

Чтобы сказать системе отправить задачу специалисту, мы используем специальную метку под названием `_module` внутри инструкций Инструмента.

Метка `_module` — это простая текстовая строка:

- **`_module: 'idea://<idea-name>'`**: Это как конкретный адрес. Он говорит системе отправить задание известному эксперту, `Идее`, у которого есть своя мастерская и знания.
- **`_module: 'anonymous'`**: Это как сказать: «Мне нужна чистая, пустая мастерская только для этой одной задачи». Это создаёт временное, изолированное пространство для выполнения работы, не требуя постоянного эксперта.

## Работа в чистой комнате

Модуль — это как «чистая комната», идеально чистое, изолированное пространство для работы. Вместо того чтобы выполнять задачу посреди шумной, хаотичной мастерской, задача отправляется в эту новую, пустую комнату. Ничто извне не попадает внутрь, если его специально не пригласили.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** супер-важен. Тег `_imports` в Инструменте работает как специальный пропуск. Он перечисляет конкретные части информации из основной мастерской, которым разрешено войти в чистую комнату. Это даёт главному ИИ полный контроль над тем, что может видеть модуль-специалист, предотвращая любую путаницу.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Строим большое из малого: Композитор и Звукорежиссёр

Модули позволяют создавать удивительные вещи. У тебя могут быть ИИ, которые видят общую картину и действуют как менеджеры, а затем поручают более мелкие, конкретные задачи ИИ-специалистам.

Представь себе ИИ, отвечающий за написание песни, назовём его **`Композитор`**. И другого ИИ-специалиста, **`Звукорежиссёра`**, который является экспертом в создании крутых звуков на синтезаторах.

- **`Звукорежиссёр`** — это самостоятельный эксперт (`idea://sound-designer`). Он знает всё о синтезаторах. Это многоразовый специалист, которому ты можешь дать музыкальную идею, и он вернёт тебе настоящий аудиофайл.

- Задача **`Композитора`** — создать целую песню. Для этого он сначала придумывает мелодию. Затем ему нужно превратить эту мелодию в настоящий звук. `Композитор` может создать мелодию сам, но для создания звуков он использует Инструмент под названием `synthesizeSound`. У этого инструмента есть тег: `_module: 'idea://sound-designer'`, который говорит ему передать работу эксперту.

Вот как `Композитор` создаёт песню:

1.  **Придумывание идеи**: Сначала `Композитор` работает самостоятельно, чтобы создать мелодию и историю для песни.

2.  **Наём эксперта**: Когда мелодия готова, `Композитор` вызывает Инструмент `synthesizeSound`, возможно, один раз для основной мелодии, один раз для баса и так далее. Каждый раз, когда он вызывает эксперта, происходит следующее:
    1.  Для задачи создаётся совершенно новая, пустая «чистая комната».
    2.  В комнату приглашается эксперт `Звукорежиссёр`. Его собственные знания (например, «Я эксперт по аналоговым синтезаторам») — это первое, что появляется в комнате.
    3.  `Композитор` использует `_imports`, чтобы передать конкретные инструкции для этой работы, например, мелодию и историю.
    4.  ИИ в чистой комнате получает оба набора инструкций: постоянные знания `Звукорежиссёра` и конкретные творческие идеи `Композитора` для этой задачи.
    5.  `Звукорежиссёр` использует свои знания для обработки творческих инструкций, создаёт звук и отправляет аудиофайл обратно.

3.  **Сборка воедино**: `Композитор` собирает все аудиофайлы от `Звукорежиссёра` и объединяет их со своей оригинальной мелодией, чтобы создать финальную песню. `Композитор` сосредотачивается на общей картине, в то время как специалист занимается техническими деталями.

## Обработка огромных инструкций

Модули также помогают, когда инструменту нужно создать что-то действительно большое и сложное. Вместо того чтобы загромождать рабочее пространство главного ИИ гигантской инструкцией о том, как должен выглядеть результат, можно просто указать на модуль.

ИИ может планировать свои шаги, зная только то, что ему нужно *передать* модулю. Он доверяет, что модуль выполнит свою работу и правильно создаст сложный результат. Это позволяет ИИ планировать сложные проекты, не увязая в каждой мелочи на начальном этапе.

## Когда вызывать специалиста

Когда у Инструмента есть тег `_module`, это сигнал о том, что работу следует отправить специалисту. Но когда система на самом деле делает вызов? Есть два способа.

### 1. Разбираться на лету (способ по умолчанию)

Самый распространённый и гибкий способ — это разбираться в деталях, когда работа уже выполняется.

Это позволяет ИИ действовать как умный соединитель. Главный ИИ может сделать запрос, который не идеально соответствует тому, что ожидает модуль-специалист. Когда работа передаётся, ИИ внутри «чистой комнаты» модуля достаточно умён, чтобы посмотреть на запрос и понять, как с ним работать. Он действует как умный клей.

Это огромное преимущество, потому что это означает, что ты можешь обновлять своих специалистов, не ломая всё остальное. Даже если специалист изменит способ своей работы, другие ИИ всё равно смогут с ним общаться, и «клей»-ИИ попытается устранить разрыв. Это делает всю систему более устойчивой и гибкой.

Вот как это работает:

1.  Главный ИИ решает вызвать Инструмент-специалист.
2.  Система видит тег `_module` и запускает процесс.
3.  **Подготовка комнаты**: Система готовит «чистую комнату» специалиста и использует `_imports`, чтобы перенести необходимую информацию от главного ИИ.
4.  **Передача записки**: Инструкции от главного ИИ передаются специалисту. Здесь и происходит волшебство — ИИ-специалист разбирается, как использовать эти инструкции, даже если они не в идеальном формате.
5.  **Выполнение работы**: В чистой комнате делается новый, отдельный запрос, и результат отправляется обратно главному ИИ.

### 2. Проверять всё заранее (более безопасный способ)

Для задач, где не должно быть никаких ошибок, можно проверить всё заранее, ещё до того, как главный ИИ начнёт свою работу.

В этом режиме система заранее ищет модуль-специалист и добавляет его требования прямо в список инструментов главного ИИ. Это означает, что главный ИИ с самого начала знает *точные* инструкции, которые нужны специалисту. Это как заполнять очень строгий бланк, где каждое поле должно быть заполнено идеально.

Это гораздо безопаснее и гарантирует, что запрос будет идеально понят, но вы теряете гибкость другого метода. Этот способ лучше всего подходит для очень важных связей, где нужно, чтобы всё работало как традиционная, предсказуемая компьютерная программа.