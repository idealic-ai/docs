# Обновления системы Агентов (встреча от 30 октября 2025 года)

В этом документе мы расскажем о нескольких важных обновлениях в главных правилах работы наших агентов. Мы улучшили то, как они выполняют :term[Действия]{canonical="Activity"}, создали официальную систему Планов и уточнили, как именно всё происходит.

## 1. Улучшенное :term[Действие]{canonical="Activity"} и понимание того, что происходит вокруг (`003_agent_activity.md`)

Мы дополнили правила для обработчиков :term[Действий]{canonical="Activity"}, чтобы они получали больше информации о происходящем и лучше всё контролировали. Это позволит создавать более сложную и предсказуемую логику.

### Изменение:

- Теперь обработчик :term[Действия]{canonical="Activity"} получает три аргумента: `(call, tool, context)`.
  - **`call`**: Объект вызова целиком, включая все параметры и специальные мета-свойства (вроде `_outputPath`, `_instance` и т.д.).
  - **`tool`**: Схема инструмента, который сейчас работает. Это позволяет действию посмотреть на свою собственную инструкцию, например, чтобы узнать, в каком формате должен быть результат.
  - **`context`**: Набор сообщений, которые были специально переданы из родительской среды с помощью протокола :term[Областей]{canonical="Scope"}.

### Зачем это нужно:

Это изменение очень важно для работы сложных, управляемых кодом процессов. Раньше действие было как бы «слепым» и не знало, что происходит вокруг. Теперь у него есть всё необходимое, чтобы:

- **Решать, куда идти дальше**: :term[Действие]{canonical="Activity"} может посмотреть на выражение, предлагающее несколько путей для записи результата (например, `'†state.sunny || †state.rainy'`), и, используя свою логику, решить, по какому пути сохранить ответ.
- **Получать доступ к нужным данным**: Оно может безопасно получить нужную информацию из родительского состояния, не видя при этом вообще всё подряд.

## 2. Официальная система Планов и режимы выполнения (`012_agent_plan.md`)

Понятие «планирования» стало более чётким и официальным. Теперь это основной способ работы агента.

### Изменения:

- **Сохранение по желанию**: Если в запросе есть сообщение `Plan`, это теперь явно говорит о том, что мы начинаем долгий процесс, где нужно запоминать шаги. Это команда для системы сохранять план и состояние между ходами. Если такого сообщения нет, то запрос считается одноразовым и ничего не сохраняется.
- **Режимы выполнения (`eager` и `lazy`)**: В сообщении `Plan` появилось свойство `mode`, которое управляет тем, как агент будет действовать.
  - **`eager` (энергичный, по умолчанию)**: В этом режиме **планировать — значит делать**. ИИ создаёт план и одновременно выполняет все скрытые шаги, которые может, в одном непрерывном потоке рассуждений. Нет никакого промежуточного шага для «проверки».
  - **`lazy` (неторопливый)**: Этот режим вводит строгое разделение. ИИ работает как архитектор: он просто создаёт полный чертёж (план) того, что нужно сделать, не выполняя никаких скрытых действий. Это создаёт «точку контроля», где можно проверить план или получить одобрение от человека, прежде чем начнётся выполнение.
- **Уточнение про ветвление на лету**: Мы уточнили, что на **самом первом шаге** «энергичного» плана скрытый вызов не может разделиться на несколько путей в зависимости от своего же результата. Поскольку планирование и выполнение происходят одновременно, ИИ в процессе размышления сводит все возможные пути (`_outputPath`) к одному конкретному для текущего шага.

### Зачем это нужно:

Эти изменения делают работу агента более строгой и гибкой. Теперь легко отличить простые задачи от сложных. А режимы `eager` и `lazy` дают разработчикам точный контроль над самостоятельностью агента, позволяя использовать как очень быстрые реакции, так и обдуманные процессы под присмотром человека, не меняя при этом основную архитектуру.

## 3. Временные и фоновые команды (`008_agent_output.md`)

Мы чётко определили, что происходит, когда в команде не указан путь для сохранения результата (`_outputPath`). Это открывает новые и полезные возможности.

### Изменение:

- Мы добавили новый раздел «Вызовы без пути для вывода», который объясняет два разных случая:
  - **Скрытые вызовы (Мысли в уме)**: Скрытый вызов без `_outputPath` работает как промежуточная мысль. Он помогает ИИ лучше сориентироваться для следующих шагов в рамках одного ответа, но сам результат никуда не записывается, чтобы не засорять память. Это позволяет строить более сложные цепочки рассуждений за один ход.
  - **Явные вызовы («Отправил и забыл»)**: Вызов :term[Действия]{canonical="Activity"} без `_outputPath` — это операция в режиме «отправил и забыл». Система запускает действие, но не ждёт и не сохраняет его результат.

### Зачем это нужно:

Это уточнение показывает, что отсутствие `_outputPath` — это осознанное решение, а не ошибка. Оно позволяет ИИ выполнять более сложные рассуждения, не создавая слишком подробную историю состояний. Также это даёт простой способ запускать побочные эффекты (например, запись в журнал или отправку уведомлений), которые не должны тормозить основной поток работы.