# 304: Идеатор/Наблюдатель

> **Наблюдатель (Watcher):** Это особый вид «Идеатора», который работает как «источник». Он постоянно следит за хранилищем (`Storage`) и ждёт изменений. Когда что-то меняется (например, кто-то сохранил новую версию `Идеи`), он запускает новый процесс — обычно вызывая `План` для обработки этих новых данных.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [301: Идеатор/Хранилище](./301_ideator_storage.md)
>   - [013: Agent/План](./013_agent_plan.md)

## 1. Введение

Этот документ объясняет, как работает **Протокол Наблюдателя**. Это очень важная часть системы, которая позволяет создавать процессы, работающие в фоновом режиме и реагирующие на события. `Наблюдатель` — это постоянно запущенная программа, которая следит за `Хранилищем` и запускает новые задачи, когда там что-то меняется.

Представь себе датчик движения в умном доме. Он ничего не делает, пока в комнате пусто. Но как только кто-то входит, датчик это замечает и даёт команду включить свет. `Наблюдатель` — это такой же датчик для данных.

Это главный способ соединить сервисы, которые «помнят» состояние, с теми, которые «не помнят», и выполнять очень долгие задачи, которые нельзя сделать за один раз.

## 2. Наблюдатель как «источник»

Если `Хранилище` — это конечная точка, куда всё приходит (как почтовый ящик, куда опускают письмо), то `Наблюдатель` — это отправная точка. Его работа не закончить процесс, а **начать новый**.

Обычно всё происходит так:

1.  Кто-то сохраняет `Идею` в `Хранилище`. Первый процесс на этом завершён.
2.  `Хранилище` сообщает всем, кто подписан: «Эй, у меня появились новые данные!».
3.  `Наблюдатель`, который подписан на эти уведомления, получает сигнал.
4.  `Наблюдатель` запускает совершенно новый, независимый процесс. Чаще всего он вызывает [План (012: Агент/План)](./013_agent_plan.md) и передаёт ему новую `Идею`, чтобы тот начал с ней работать.

## 3. Работа с долгими процессами

`Наблюдатель` — это ключ к управлению задачами, которые могут длиться очень долго, например, часы или даже дни.

Представь, что у `Плана` есть шаг, который требует участия человека или обработки огромного файла. Программа не может просто остановиться и ждать часами — это неэффективно и рискованно.

Вместо этого `План` делает вот что:

1.  Он отдаёт долгую задачу другому, специальному сервису, а сам завершает свою работу.
2.  Когда тот внешний сервис наконец закончит (через час или день), он сохраняет свой результат обратно в `Хранилище`.
3.  Другой `Наблюдатель`, который настроен ждать именно этот результат, видит его и запускает _новый_ `План`, чтобы продолжить работу с того места, где остановился первый.

Этот подход позволяет создавать очень надёжные и мощные системы. Процесс разбивается на серию коротких шагов, запускаемых по событиям, и ему не страшны перезагрузки или сбои.
