# 008: Агент/Вывод

> [!DEFINITION] [Путь вывода](./000_glossary.md)
> `_outputPath` — это специальная инструкция (мета-свойство) в :term[Вызове]{canonical="Call"}, которая указывает, куда сохранить результат работы инструмента. Это как адрес на посылке, который говорит системе, куда доставить результат, чтобы его можно было использовать на следующих шагах.


> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

У системы агентов есть два вида вывода: промежуточные результаты :term[Вызовов инструментов]{canonical="Tool Call"}, которые записываются в общий контекст (как в черновик), и :term[Финальный вывод]{canonical="Final Output"}, то есть окончательный результат всей работы.

## Запись в контекст с помощью :term[Пути вывода]{canonical="Output Path"}

Хотя любое :term[Сообщение с данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком для рабочего процесса, :term[Путь вывода]{canonical="Output Path"} в :term[Вызове]{canonical="Call"} — это основной способ делать на нём записи. Когда выполняется :term[Вызов инструмента]{canonical="Tool Call"} с этим свойством, система добавляет его результат в контекст как новое сообщение.


> Sidenote:
> Хотя целью может быть любое :term[Сообщение с данными]{canonical="Data Message"}, чаще всего запись происходит в :term[Сообщение о состоянии]{canonical="State Message" href="./009_agent_state.md"} для сохранения информации между несколькими шагами процесса.

Это новое сообщение является стандартным :term[Сообщением с данными]{canonical="Data Message"}, но оно содержит два дополнительных элемента, которые скрыты от языковой модели:

- **`_call`**: Оригинальный :term[Вызов инструмента]{canonical="Tool Call"}, который сгенерировал этот результат.
- **`_date`**: Точное время, когда результат был записан.
- **`_outputMethod`**: Способ, указанный в первоначальном вызове, который определяет, как эти данные должны быть объединены с другими.

Это оставляет полный, проверяемый след того, как менялся контекст, что очень ценно для отладки и отслеживания логики агента.

### Определение Пути вывода

:term[Путь вывода]{canonical="Output Path"} можно определить двумя способами, что позволяет гибко управлять поведением инструмента.

::::columns{.examples}
:::column{title="Динамический путь (решает ИИ)"}

В этом режиме ИИ сам решает, куда сохранить результат во время работы, что делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный путь (задан заранее)"}

Этот подход обеспечивает строгое, предсказуемое поведение, гарантируя, что инструмент всегда будет записывать свой вывод в одно и то же, заранее определённое место.

```json
// Схема инструмента закрепляет _outputPath за конкретным значением
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Динамическое определение переменных

Ключевой момент в том, что эти сообщения с результатами **добавляются в конец**, а не перезаписывают старые. Это позволяет собирать финальное состояние любой переменной «на лету» во время чтения, основываясь на инструкции `_outputMethod`, хранящейся в каждом сообщении.

Когда нужно найти значение :term[ссылки на переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, движок ищет по сообщениям в **обратном хронологическом порядке** (от новых к старым).

- Если движок находит сообщение для нужного пути с методом **`set`** (установить) или без метода (так как `set` — это стандартное поведение), он немедленно останавливается. Значение из этого сообщения и есть финальный результат, а все более старые записи для этого пути игнорируются. Это правило «кто последний, тот и прав».
- Если движок находит сообщения с методами **`merge`** (объединить), **`push`** (добавить в конец списка) или **`concat`** (соединить), он продолжает поиск вглубь, собирая все такие сообщения, пока не дойдёт до сообщения с `set` или до самого начала истории. Затем он воссоздаёт финальное значение, применяя все собранные операции в хронологическом порядке (от старых к новым).

Такой динамический подход гарантирует, что состояние всегда будет правильным и точно отражающим историю операций, что позволяет надёжно управлять сложными данными.

:::::details{title="Пример: Добавление и поиск значения"}

**1. Начальное состояние**

Вначале в контексте есть одно сообщение с данными.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "inactive",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Движок добавляет новое сообщение с результатом, которое также содержит информацию о вызове, создавшем его.


```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  },
  // Добавленное сообщение с результатом вызова
  {
    "type": "data",
    "data": { "user": { "status": "inactive" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "inactive",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Поиск значения переменной**

- Чтобы найти `†data.user.status`, движок сначала проверяет последнее сообщение. Он находит `user.status` и возвращает `"inactive"`.
- Чтобы найти `†data.user.name`, движок проверяет последнее сообщение, не находит `user.name`, а затем проверяет предыдущее. Он находит его там и возвращает `"Alex"`.

:::::

Сила комбинации :term[Ссылок на переменные]{canonical="Variable Reference"} и :term[Путей вывода]{canonical="Output Path"} в том, что они позволяют описывать операции над данными, которых ещё нет. Например, :term[Вызов инструмента]{canonical="Call"} может быть настроен на работу со значением из :term[Входного]{canonical="Input"} сообщения, даже если это конкретное сообщение ещё не было предоставлено. Это позволяет создавать универсальные, параметризуемые рабочие процессы.

Эта концепция позволяет выстраивать :term[Вызовы инструментов]{canonical="Call"} в цепочки. Можно создать :term[Вызов инструмента]{canonical="Call"} со :term[Ссылкой на переменную]{canonical="Variable Reference"}, которая указывает на :term[Путь вывода]{canonical="Output Path"} *предыдущего* вызова в той же последовательности. Это создаёт многошаговый поток данных, где вывод одного инструмента становится вводом для следующего.

## Вызовы без Пути вывода

Не каждому :term[Вызову инструмента]{canonical="Call"} нужно сохранять свой результат. Отсутствие свойства `_outputPath` — это осознанный выбор, который указывает на различное поведение для скрытых и явных вызовов.

### Временные размышления для скрытых вызовов

Для скрытого вызова отсутствие `_outputPath` позволяет ему работать как временный шаг рассуждения — «мысль», которая влияет на последующие действия в том же ходу, но не сохраняется в постоянное :term[Состояние]{canonical="State"}. Это мощный способ структурировать процесс мышления ИИ.

Например, агент может сначала использовать скрытый инструмент `think` для анализа проблемы и наброска стратегии. Эта «мысль» не сохраняется, но её генерация немедленно обогащает внутренний контекст самого ИИ. На следующем шаге того же `solution` ИИ может сгенерировать уже конкретные, явные :term[Вызовы инструментов]{canonical="Call"}, которые будут более эффективными и точными благодаря предыдущему, несохранённому шагу размышления.

### «Сделать и забыть» для явных вызовов

Для явного вызова :term[Действия]{canonical="Activity"} отсутствие `_outputPath` означает операцию «сделать и забыть». :term[Цикл выполнения]{canonical="Execution Loop"} вызовет :term[Действие]{canonical="Activity"}, но не будет ждать результата и не будет сохранять его в контекст.

Это полезно для побочных эффектов, где возвращаемое значение не требуется для продолжения текущего рабочего процесса. Типичные примеры:

- Запись события во внешний сервис аналитики.
- Отправка уведомления пользователю или другой системе.
- Запуск длительного фонового процесса без необходимости блокировать текущий план.

## Взаимодействие с другими системами

- **:term[Сообщение с данными]{canonical="Data Message"}:** `_outputPath` — это основной механизм для создания и обновления :term[Сообщений с данными]{canonical="Data Message"} в рамках рабочего процесса. Он превращает одноразовый :term[Вызов инструмента]{canonical="Tool Call"} в операцию с состоянием, сохраняя его результат в контекст и делая его доступным для последующих шагов.

  

> Sidenote:
> \- :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщение о состоянии]{canonical="State Message"}:** Хотя целью может быть любое :term[Сообщение с данными]{canonical="Data Message"}, чаще всего запись происходит в :term[Сообщение о состоянии]{canonical="State Message"}. Это превращает объект :term[Состояния]{canonical="State"} в «черновик» рабочего процесса, позволяя разным инструментам обмениваться информацией и опираться на результаты друг друга на протяжении нескольких тактов :term[Цикла выполнения]{canonical="Execution Loop"}.

  

> Sidenote:
> \- :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылка на переменную]{canonical="Variable Reference"}:** :term[Путь вывода]{canonical="Output Path"} — это прямой аналог :term[Ссылки на переменную]{canonical="Variable Reference"}. :term[Путь вывода]{canonical="Output Path"} записывает данные в контекст, а :term[Ссылка на переменную]{canonical="Variable Reference"} их читает. Вместе они образуют полную, декларативную схему потока данных, соединяя вывод одного инструмента со входом другого.

  

> Sidenote:
> \- :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** Выражения вводят логику прямо в поток данных. Используя `||` и `&&` в :term[Пути вывода]{canonical="Output Path"}, :term[Вызов инструмента]{canonical="Tool Call"} может объявлять условные результаты или направлять свой результат в несколько мест одновременно. Это уводит систему от жёстких, заранее прописанных конвейеров данных к гибкой структуре, которая адаптируется к условиям во время выполнения.

  

> Sidenote:
> \- :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[Плана]{canonical="Plan"} :term[Пути вывода]{canonical="Output Path"} действуют как «провода», которые соединяют различные :term[Вызовы инструментов]{canonical="Tool Call"} («узлы») в единый граф потока данных. Это позволяет агенту определять и выполнять целую многошаговую стратегию как единый, декларативный объект.

  

> Sidenote:
> \- :term[012: Агент/План]{href="./012_agent_plan.md"}

- **:term[Экземплирование]{canonical="Instancing"}:** Когда :term[Вызов инструмента]{canonical="Tool Call"} включает свойство `_instance`, любой указанный в нём `_outputPath` автоматически привязывается к контексту данных именно этого экземпляра. Это обеспечивает изоляцию данных при параллельной обработке, гарантируя, что вывод инструмента, работающего над одним экземпляром, не будет мешать состоянию другого.

  

> Sidenote:
> \- :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

## От временных выводов к постоянному состоянию

Механизм :term[Пути вывода]{canonical="Output Path"} предоставляет надёжный способ управления потоком данных между отдельными :term[Вызовами инструментов]{canonical="Tool Call"} и может работать с любым :term[Сообщением с данными]{canonical="Data Message"}. Однако для создания сложных, многошаговых агентов, способных рассуждать и адаптироваться со временем, требуется особая форма памяти — тип сообщения, специально разработанный для сохранения информации между несколькими независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает протокол для этой постоянной памяти.
