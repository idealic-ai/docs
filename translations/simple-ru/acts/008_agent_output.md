# 008: Агент/Вывод

> [!DEFINITION] [Путь Вывода](./000_glossary.md)
> Мета-свойство `_outputPath` в :term[вызове]{canonical="Call"} указывает, куда сохранить результат работы инструмента. Это просто строка, которая говорит системе, куда положить результат, чтобы его можно было использовать на следующих шагах.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает путь к:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

У системы агентов есть два вида вывода: промежуточные результаты :term[вызовов инструментов]{canonical="Tool Call"}, которые записываются в контекст (его «блокнот»), и :term[окончательный вывод]{canonical="Final Output"}, который получается в конце всей работы.

## Запись в контекст с помощью :term[пути вывода]{canonical="Output Path"}

Хотя любое :term[сообщение с данными]{canonical="Data Message" href="./005_agent_data.md"} может служить «черновиком» для работы, :term[путь вывода]{canonical="Output Path"} в :term[вызове]{canonical="Call"} — это главный способ что-то туда записать. Когда выполняется :term[вызов инструмента]{canonical="Tool Call"} с этим свойством, система добавляет его результат в контекст как новое сообщение.

> Sidenote:
> Хотя записывать можно в любое :term[сообщение с данными]{canonical="Data Message"}, чаще всего результат сохраняют в :term[сообщение о состоянии]{canonical="State Message" href="./009_agent_state.md"}, чтобы информация не потерялась между шагами процесса.

Это новое сообщение — обычное :term[сообщение с данными]{canonical="Data Message"}, но в нём есть две дополнительные мета-записи, которые скрыты от ИИ:

- **`_call`**: Изначальный :term[вызов инструмента]{canonical="Tool Call"}, который создал этот вывод.
- **`_date`**: Отметка времени в формате ISO, когда был записан вывод.

Это создаёт полный и проверяемый след того, как менялся контекст. Это очень ценно для отладки и отслеживания «мыслей» агента.

### Как определить путь вывода

:term[Путь вывода]{canonical="Output Path"} можно задать двумя способами, что даёт разный уровень контроля над поведением инструмента.

::::columns{.examples}
:::column{title="Динамический путь (решает ИИ)"}

В этом режиме ИИ сам решает, куда сохранить результат прямо во время работы. Это делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Заданный путь (прописан жёстко)"}

Этот подход обеспечивает строгое, предсказуемое поведение. Инструмент всегда будет записывать свой вывод в одно и то же, жёстко заданное место.

```json
// Схема инструмента закрепляет _outputPath за конкретным значением
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Принцип «кто последний, тот и прав»

Важно: эти сообщения с выводом **добавляются в конец**, а не смешиваются со старыми. Такое решение упрощает систему и соответствует естественному ходу процесса, где новая информация важнее старой.

Когда нужно найти значение по :term[ссылке на переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, система начинает искать по сообщениям в контексте **в обратном порядке** — от нового к старому. Она проверяет каждое сообщение, и первое, где найдётся нужный путь (`user.name`), отдаёт своё значение. Эта стратегия «кто последний, тот и прав» гарантирует, что всегда используется самое свежее значение, без сложной логики слияния.

:::::details{title="Пример: добавление и поиск значения"}

**1. Исходное состояние**

В начале в контексте есть исходное сообщение `data`.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "inactive",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Система добавляет новое сообщение с результатом, которое содержит метаданные о породившем его вызове.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  },
  // Добавленное сообщение с результатом вызова
  {
    "type": "data",
    "data": { "user": { "status": "inactive" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "inactive",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Поиск значения переменной**

- Чтобы найти `†data.user.status`, система сначала проверяет последнее сообщение. Находит `user.status` и возвращает `"inactive"`.
- Чтобы найти `†data.user.name`, система проверяет последнее сообщение, не находит `user.name`, затем проверяет предыдущее. Находит его там и возвращает `"Alex"`

:::::

Сила совместного использования :term[ссылок на переменные]{canonical="Variable Reference"} и :term[путей вывода]{canonical="Output Path"} в том, что они позволяют описывать операции с данными, которых ещё нет. Например, можно задать :term[вызов инструмента]{canonical="Call"} для работы со значением из :term[входного сообщения]{canonical="Input"}, даже если это сообщение ещё не пришло. Это позволяет создавать гибкие рабочие процессы, которые можно использовать много раз.

Этот же принцип позволяет выстраивать :term[вызовы инструментов]{canonical="Call"} в цепочку. Можно создать :term[вызов]{canonical="Call"} со :term[ссылкой на переменную]{canonical="Variable Reference"}, которая указывает на :term[путь вывода]{canonical="Output Path"} _предыдущего_ вызова в той же последовательности. Так создаётся многошаговый поток данных, где вывод одного инструмента становится входом для следующего.

## Вызовы без пути вывода

Не каждому :term[вызову инструмента]{canonical="Call"} нужно сохранять свой результат. Отсутствие свойства `_outputPath` — это осознанное решение, которое означает разное поведение для скрытых и явных вызовов.

### Мимолётные размышления для скрытых вызовов

Для скрытого вызова отсутствие `_outputPath` позволяет ему работать как мимолётный шаг рассуждения — «мысль», которая влияет на следующие действия в том же шаге, но не сохраняется в постоянное :term[состояние]{canonical="State"}. Это мощный способ структурировать процесс «мышления» ИИ.

Например, агент может сначала использовать скрытый инструмент `think`, чтобы проанализировать проблему и набросать план. Эта «мысль» не сохраняется, но её появление сразу обогащает внутренний контекст ИИ. На следующем же шаге того же `solution` ИИ сможет сгенерировать конкретные, явные :term[вызовы инструментов]{canonical="Call"}, которые будут более точными и эффективными благодаря этому предварительному, несохранённому размышлению.

### «Сделал и забыл» для явных вызовов

Для явного вызова :term[действия]{canonical="Activity"} отсутствие `_outputPath` — это сигнал операции «сделал и забыл». :term[Цикл выполнения]{canonical="Execution Loop"} запустит :term[действие]{canonical="Activity"}, но не будет ждать результата и не будет сохранять его в контекст.

Это полезно для побочных эффектов, когда возвращаемое значение не нужно для продолжения текущей работы. Частые примеры:

- Запись события во внешний сервис аналитики.
- Отправка уведомления пользователю или другой системе.
- Запуск долгого фонового процесса, который не должен блокировать текущий план.

## Взаимодействия с другими системами

- **:term[Сообщение с данными]{canonical="Data Message"}:** :term[Путь вывода]{canonical="Output Path"} — это главный способ создавать и обновлять :term[сообщения с данными]{canonical="Data Message"} в процессе работы. Он превращает :term[вызов инструмента]{canonical="Tool Call"}, который сам по себе не хранит состояния, в операцию с состоянием, сохраняя её результат в контекст и делая его доступным для следующих шагов.

  > Sidenote:
  > - :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщение о состоянии]{canonical="State Message"}:** Хотя записывать можно в любое :term[сообщение с данными]{canonical="Data Message"}, чаще всего результат сохраняют в :term[сообщение о состоянии]{canonical="State Message"}. Это делает объект :term[состояния]{canonical="State"} «черновиком» для всего процесса, позволяя разным инструментам обмениваться информацией и опираться на результаты друг друга на разных тактах :term[цикла выполнения]{canonical="Execution Loop"}.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылка на переменную]{canonical="Variable Reference"}:** :term[Путь вывода]{canonical="Output Path"} — это прямая пара для :term[ссылки на переменную]{canonical="Variable Reference"}. :term[Путь вывода]{canonical="Output Path"} записывает данные в контекст, а :term[ссылка на переменную]{canonical="Variable Reference"} их читает. Вместе они образуют полную, понятную схему потока данных, соединяя выход одного инструмента со входом другого.

  > Sidenote:
  > - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** :term[Выражения]{canonical="Expression"} добавляют логику прямо в «проводку» потока данных. Используя `||` и `&&` в :term[пути вывода]{canonical="Output Path"}, :term[вызов инструмента]{canonical="Tool Call"} может объявлять условные результаты или разветвлять свой вывод в несколько мест. Это уводит систему от жёстких, заранее прописанных конвейеров данных к гибкой структуре, которая адаптируется к условиям во время работы.

  > Sidenote:
  > - :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[плана]{canonical="Plan"} :term[пути вывода]{canonical="Output Path"} действуют как «провода», которые соединяют разные :term[вызовы инструментов]{canonical="Tool Call"} («узлы») в единую схему потока данных. Это позволяет агенту определять и выполнять целую многошаговую стратегию как единый, понятный объект.

  > Sidenote:
  > - :term[012: Агент/План]{href="./012_agent_plan.md"}

- **:term[Экземплирование]{canonical="Instancing"}:** Когда :term[вызов инструмента]{canonical="Tool Call"} включает свойство `_instance`, любой указанный в нём `_outputPath` автоматически привязывается к контексту данных именно этого экземпляра. Это обеспечивает изоляцию данных при параллельной обработке, гарантируя, что вывод инструмента, работающего над одним экземпляром, не помешает состоянию другого.

  > Sidenote:
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

## От мимолётных выводов к постоянному состоянию

Механизм :term[пути вывода]{canonical="Output Path"} предоставляет надёжный способ управлять потоком данных между отдельными :term[вызовами инструментов]{canonical="Tool Call"}, и он может указывать на любое :term[сообщение с данными]{canonical="Data Message"}. Однако, чтобы строить сложных, многошаговых агентов, которые могут рассуждать и адаптироваться со временем, нужна особая форма памяти — тип сообщения, специально разработанный для сохранения информации между несколькими независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает протокол для этой постоянной памяти.
