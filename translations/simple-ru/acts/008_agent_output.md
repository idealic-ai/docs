# 008: Агент/Вывод

> [!DEFINITION] [Путь Вывода](./000_glossary.md)
> `_outputPath` — это особое свойство в :term[Вызове]{canonical="Call"}, которое указывает, куда нужно сохранить результат работы инструмента. Представь, что это адрес на посылке. Он говорит системе, куда доставить результат, чтобы его можно было использовать на следующих шага.




Система агентов использует два вида вывода: промежуточные результаты от :term[вызовов инструментов]{canonical="Tool Call"}, которые записываются в «контекст» (что-то вроде рабочей тетради), и :term[итоговый результат]{canonical="Final Output"} всего процесса.

## Запись в контекст с помощью :term[Пути Вывода]{canonical="Output Path"}

Хотя любое :term[Сообщение с данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком, :term[Путь Вывода]{canonical="Output Path"} в :term[Вызове]{canonical="Call"} — это основной способ делать в нём записи. Когда выполняется :term[Вызов Инструмента]{canonical="Tool Call"} с этим свойством, система добавляет его результат в виде нового сообщения в конец контекста.



Это новое сообщение — обычное :term[сообщение с данными]{canonical="Data Message"}, но оно содержит два дополнительных элемента, которые скрыты от нейросети:

- **`_call`**: Оригинальный :term[Вызов Инструмента]{canonical="Tool Call"}, который создал этот результат.
- **`_date`**: Точное время и дата, когда был записан результат.

Это позволяет отследить всю цепочку действий и понять, как менялись данные, что очень полезно для поиска ошибок и понимания «мыслей» агента.

### Как определить Путь Вывода

:term[Путь Вывода]{canonical="Output Path"} можно задать двумя способами, что даёт разный уровень контроля над поведением инструмента.

::::columns{.examples}
:::column{title="Гибкий путь (решает нейросеть)"}

В этом режиме нейросеть сама решает, куда сохранить результат во время работы. Это делает инструмент очень гибким.

```json
// Схема инструмента, которая позволяет указать любой путь
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Заданный путь (жёстко прописан)"}

Этот подход заставляет инструмент всегда записывать результат в одно и то же, строго определённое место. Это делает его поведение предсказуемым.

```json
// Схема, где путь зафиксирован
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Правило «последняя запись главнее»

Важно, что новые сообщения с результатами **добавляются в конец**, а не смешиваются со старыми. Это упрощает систему. Представь стопку записок: каждая новая кладётся поверх старой.

Когда нужно найти значение по :term[ссылке на переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, система начинает искать с самой верхней записки (самого нового сообщения) и движется вниз. Как только она находит нужную информацию (`user.name`), она берёт её и прекращает поиск. Так всегда используется самая свежая информация без сложных правил смешивания.

:::::details{title="Пример: добавление и поиск данных"}

**1. Исходное состояние**

Вначале в контексте есть одно сообщение с данными.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "неактивен",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Система добавляет новое сообщение с результатом, включая информацию о том, какой вызов его создал.

```json
[
  // Исходное сообщение
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  },
  // Добавленное сообщение с результатом вызова
  {
    "type": "data",
    "data": { "user": { "status": "неактивен" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "неактивен",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Поиск значения переменной**

- Чтобы найти `†data.user.status`, система сначала смотрит в последнее сообщение. Она находит `user.status` и возвращает `"неактивен"`.
- Чтобы найти `†data.user.name`, система сначала смотрит в последнее сообщение, не находит `user.name`, а затем проверяет предыдущее. Там она находит его и возвращает `"Алекс"`.

:::::

### Построение потоков данных

Сила сочетания :term[ссылок на переменные]{canonical="Variable Reference"} и :term[путей вывода]{canonical="Output Path"} в том, что они позволяют описывать операции с данными, которых ещё нет. Например, можно сказать инструменту обработать данные из :term[входящего сообщения]{canonical="Input"}, даже если это сообщение ещё не пришло. Это позволяет создавать гибкие и многоразовые сценарии.

Точно так же можно связывать :term[вызовы инструментов]{canonical="Call"} в цепочку. Один :term[вызов]{canonical="Call"} может использовать в качестве входных данных результат работы *предыдущего* вызова. Так создаётся поток, где вывод одного инструмента становится вводом для следующего.

Эта система становится ещё мощнее, когда :term[пути вывода]{canonical="Output Path"} используются для описания возможных исходов работы.

::::columns
:::column{title="Альтернативные пути (ветвление)"}
Использование `||` (или) в :term[пути вывода]{canonical="Output Path"} позволяет инструменту объявить, что у него может быть несколько исходов. В зависимости от своей внутренней логики, он запишет результат в один из путей.

```json
// Если `verifyUser` сработает успешно, результат
// запишется в `data.user.verified`;
// иначе — в `data.user.failed`.
{
  "_tool": "verifyUser",
  "userId": "perfect-stranger",
  "_outputPath": "†data.user.verified || †data.user.failed"
}
```

:::
:::column{title="Параллельные пути (копирование)"}
Использование `&&` (и) в :term[пути вывода]{canonical="Output Path"} указывает системе скопировать один и тот же результат в несколько мест одновременно.

```json
// Запись одновременно в объекты `user` и `audit`.
{
  "_tool": "generateSummary",
  "text": "Длинный текст здесь...",
  "_outputPath": "†data.user.summary && †data.audit.summary"
}
```

:::
::::

## От временных результатов к постоянной памяти

Механизм :term[Пути Вывода]{canonical="Output Path"} отлично справляется с передачей данных между отдельными :term[вызовами инструментов]{canonical="Tool Call"} и может записывать их в любое :term[Сообщение с данными]{canonical="Data Message"}. Но чтобы строить сложных агентов, которые могут рассуждать и учиться со временем, нужна особая память — специальный тип сообщений, созданный для хранения информации между разными, независимыми запросами.

В следующем документе, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывается, как работает эта постоянная память.