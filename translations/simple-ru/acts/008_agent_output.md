# 008: Агент/Вывод

> [!DEFINITION] [Путь вывода](./000_glossary.md)
> `_outputPath` — это как адрес на посылке, который ты пишешь для инструмента. Это специальное мета-свойство в :term[Вызове]{canonical="Call"}, которое говорит системе, куда положить результат работы инструмента. Этот результат потом могут использовать другие инструменты на следующих шагах.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

В системе агентов есть два вида «ответов» (вывода). Первый — это промежуточные результаты :term[вызовов инструментов]{canonical="Tool Call"}, которые записываются в общую «память» (контекст) во время работы. Второй — это :term[итоговый ответ]{canonical="Final Output"}, который получается в самом конце всего процесса.

## Запись в контекст с помощью :term[Пути вывода]{canonical="Output Path"}

Любое :term[сообщение с данными]{canonical="Data Message" href="./005_agent_data.md"} можно использовать как черновик, куда агент записывает свои мысли. Но главный способ что-то записать — это использовать мета-свойство :term[Путь вывода]{canonical="Output Path"} в :term[Вызове]{canonical="Call"}. Когда инструмент с таким свойством заканчивает работу, система берёт его результат и добавляет в общую «память» как новое сообщение.

> Sidenote:
> Хотя записывать можно в любое :term[сообщение с данными]{canonical="Data Message"}, чаще всего результат сохраняют в :term[сообщение о состоянии]{canonical="State Message" href="./009_agent_state.md"}, чтобы информация сохранялась между разными шагами процесса.

Это новое сообщение — обычное :term[сообщение с данными]{canonical="Data Message"}, но с двумя секретными «записками» (метаданными), которые большая языковая модель (ИИ) не видит:

- **`_call`**: Оригинальный :term[Вызов инструмента]{canonical="Tool Call"}, который создал этот результат.
- **`_date`**: Точное время и дата, когда результат был записан.

Благодаря этому у нас остаётся полный след всех изменений. Это очень помогает, если нужно найти ошибку или понять, как именно «думал» агент.

### Как определить Путь вывода

:term[Путь вывода]{canonical="Output Path"} можно задать двумя способами. Это позволяет нам решать, насколько свободным в своих действиях будет инструмент.

::::columns{.examples}
:::column{title="Динамический путь (решает ИИ)"}

В этом режиме ИИ сам решает, куда сохранить результат прямо во время работы. Это делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения информации о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Заданный путь (жёстко прописан)"}

Такой подход заставляет инструмент вести себя строго и предсказуемо. Он всегда будет записывать свой результат в одно и то же, заранее определённое место.

```json
// Схема инструмента закрепляет _outputPath за конкретным значением
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Решение по принципу «кто последний, тот и прав»

Крайне важно, что новые сообщения с результатами **добавляются в конец**, а не смешиваются со старыми. Представьте, что это не один большой документ, который все правят, а стопка листов, где каждый новый лист кладётся поверх старого. Это делает систему проще и понятнее, ведь в жизни новая информация тоже обычно важнее старой.

Когда системе нужно найти значение :term[переменной]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, она начинает просматривать эту стопку листов **с самого верхнего**. Она смотрит на самый свежий лист, потом на предыдущий, и так далее, пока не найдёт то, что ищет (`user.name`). Как только находит — останавливается и берёт это значение. Такая стратегия «кто последний, тот и прав» гарантирует, что мы всегда используем самую свежую информацию, без сложного смешивания данных.

:::::details{title="Пример: добавление и поиск значения"}

**1. Начальное состояние**

Вначале в контексте есть одно сообщение с данными.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  }
]
```

**2. Запуск инструмента**

Вызывается инструмент, чтобы обновить статус пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "неактивен",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Система добавляет новое сообщение с результатом, которое также содержит информацию о том, какой вызов его создал.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  },
  // Добавленное сообщение с результатом вызова
  {
    "type": "data",
    "data": { "user": { "status": "неактивен" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "неактивен",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Поиск значения переменной**

- Чтобы найти `†data.user.status`, система сначала проверяет последнее сообщение. Она находит `user.status` и возвращает `"неактивен"`.
- Чтобы найти `†data.user.name`, система проверяет последнее сообщение, не находит там `user.name`, и тогда проверяет предыдущее. Там она его находит и возвращает `"Алекс"`.

:::::

Сила совмещения :term[ссылок на переменные]{canonical="Variable Reference"} и :term[путей вывода]{canonical="Output Path"} в том, что они позволяют описывать, что делать с данными, которых ещё нет. Например, можно сказать, что один инструмент должен будет обработать :term[Входящие данные]{canonical="Input"}, хотя эти данные ещё не пришли. Это позволяет создавать универсальные и многоразовые цепочки действий.

Эта идея позволяет выстраивать целые цепочки :term[вызовов инструментов]{canonical="Call"}. Один :term[Вызов]{canonical="Call"} может использовать :term[ссылку на переменную]{canonical="Variable Reference"}, которая указывает на :term[Путь вывода]{canonical="Output Path"} *предыдущего* вызова в этой же цепочке. Так создаётся поток данных из нескольких шагов, где результат работы одного инструмента становится входными данными для следующего.

## Взаимодействие с другими системами

- **:term[Сообщения с данными]{canonical="Data Message"}:** `_outputPath` — это основной способ создавать и обновлять :term[сообщения с данными]{canonical="Data Message"} в процессе работы. Он превращает одноразовый :term[вызов инструмента]{canonical="Tool Call"} в действие, которое оставляет след, сохраняя свой результат в общей «памяти» (контексте) для следующих шагов.

  > Sidenote:
  > - :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщение о состоянии]{canonical="State Message"}:** Хотя записывать можно в любое :term[сообщение с данными]{canonical="Data Message"}, чаще всего результат сохраняют в :term[сообщение о состоянии]{canonical="State Message"}. Это превращает объект :term[Состояния]{canonical="State"} в «черновик» для всего процесса, позволяя разным инструментам обмениваться информацией и опираться на результаты друг друга на протяжении всего :term[цикла выполнения]{canonical="Execution Loop"}.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылки на переменные]{canonical="Variable Reference"}:** :term[Путь вывода]{canonical="Output Path"} и :term[ссылка на переменную]{canonical="Variable Reference"} — это две половинки одного целого. :term[Путь вывода]{canonical="Output Path"} записывает данные в контекст, а :term[ссылка на переменную]{canonical="Variable Reference"} их оттуда читает. Вместе они создают простую и понятную схему передачи данных, соединяя выход одного инструмента со входом другого.

  > Sidenote:
  > - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** Выражения добавляют логику прямо в «провода», по которым текут данные. Используя `||` (ИЛИ) и `&&` (И) в :term[Пути вывода]{canonical="Output Path"}, :term[вызов инструмента]{canonical="Tool Call"} может выбирать, куда записать результат в зависимости от условия, или отправлять его сразу в несколько мест. Это делает систему гибкой, как конструктор, а не жёсткой, как рельсы.

  > Sidenote:
  > - :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[Плана]{canonical="Plan"} :term[пути вывода]{canonical="Output Path"} работают как «провода», которые соединяют разные :term[вызовы инструментов]{canonical="Tool Call"} (узлы) в единую схему потока данных. Это позволяет агенту описать и выполнить сложную стратегию из нескольких шагов как один целый объект.

  > Sidenote:
  > - :term[012: Агент/План]{href="./012_agent_plan.md"}

- **:term[Экземплирование]{canonical="Instancing"}:** Когда в :term[вызове инструмента]{canonical="Tool Call"} есть свойство `_instance`, любой указанный в нём `_outputPath` автоматически относится только к «памяти» этого конкретного экземпляра. Это как если бы у каждого параллельного процесса был свой собственный блокнот: результат работы одного не будет мешать другому.

  > Sidenote:
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

## От временных результатов к постоянной памяти

Механизм :term[Пути вывода]{canonical="Output Path"} — это надёжный способ управлять потоком данных между отдельными :term[вызовами инструментов]{canonical="Tool Call"}, и он может указывать на любое :term[сообщение с данными]{canonical="Data Message"}. Однако, чтобы создавать сложных, многошаговых агентов, которые могут рассуждать и адаптироваться со временем, нужна особая память — тип сообщения, специально разработанный для сохранения информации между множеством независимых запросов.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает правила работы этой постоянной памяти.
