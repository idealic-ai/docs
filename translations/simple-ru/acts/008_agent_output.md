# 008: Агент/Вывод

> [!DEFINITION] [Путь вывода](./000_glossary.md)
> Мета-свойство `_outputPath` у :term[Вызова]{canonical="Call"}, которое указывает, куда сохранить результат работы инструмента. Представьте, что это адресная этикетка на посылке: она говорит системе, куда положить результат, чтобы другие инструменты могли найти и использовать его позже.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

У агента есть два вида «ответов» или выводов. Во-первых, это промежуточные результаты от :term[Вызовов Инструментов]{canonical="Tool Call"}, которые записываются в общий «блокнот» (контекст). Во-вторых, это :term[Финальный Вывод]{canonical="Final Output"} — окончательный ответ, когда вся работа завершена.

## Запись в контекст с помощью :term[Пути Вывода]{canonical="Output Path"}

Хотя любое :term[Сообщение с данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком, :term[Путь вывода]{canonical="Output Path"} — это основной способ делать в нём записи. Когда инструмент с таким свойством заканчивает работу, система добавляет его результат в общий «блокнот» как новое сообщение.

> Sidenote:
> Хотя целью может быть любое :term[Сообщение с данными]{canonical="Data Message"}, чаще всего запись происходит в :term[Сообщение о состоянии]{canonical="State Message" href="./009_agent_state.md"}, чтобы сохранить информацию между несколькими шагами процесса.

Это новое сообщение — обычное :term[Сообщение с данными]{canonical="Data Message"}, но с двумя дополнительными пометками, которые скрыты от искусственного интеллекта (LLM):

- **`_call`**: Какой именно :term[Вызов Инструмента]{canonical="Tool Call"} создал этот результат.
- **`_date`**: Точное время, когда результат был записан.

Благодаря этому у нас есть полный журнал всех изменений. Это очень помогает, если нужно разобраться, как агент принимал решения, или найти ошибку.

### Определение Пути Вывода

:term[Путь вывода]{canonical="Output Path"} можно задать двумя способами, что даёт разный уровень контроля над поведением инструмента.

::::columns{.examples}
:::column{title="Динамический путь (решает LLM)"}

В этом режиме ИИ сам решает, куда сохранить результат во время работы. Это делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный путь (жёстко заданный)"}

Этот подход обеспечивает строгое, предсказуемое поведение. Инструмент всегда будет записывать свой результат в одно и то же, заранее определённое место.

```json
// Схема инструмента закрепляет _outputPath за конкретным значением
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Разрешение по принципу «последняя запись побеждает»

Важный момент: новые сообщения **добавляются в конец**, а не смешиваются со старыми. Это упрощает систему и похоже на то, как мы работаем в реальной жизни — новая информация обычно важнее старой.

Когда системе нужно найти значение по :term[Ссылке на переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, она просматривает все сообщения в «блокноте» **в обратном порядке, с конца**. Как только она находит нужную информацию (в данном случае `user.name`), она берёт это значение и прекращает поиск. Такое правило «последняя запись побеждает» гарантирует, что всегда используется самая свежая информация без всякой путаницы.

:::::details{title="Пример: Добавление и разрешение"}

**1. Начальное состояние**

Вначале в «блокноте» есть одно сообщение с данными.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент, чтобы обновить статус пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "неактивен",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Система добавляет в конец новое сообщение с результатом, включая информацию о том, какой вызов его создал.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Алекс", "status": "активен" } }
  },
  // Добавленное сообщение с выводом от вызова
  {
    "type": "data",
    "data": { "user": { "status": "неактивен" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "неактивен",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Разрешение переменной**

- Чтобы найти `†data.user.status`, система сначала смотрит в последнее сообщение. Находит `user.status` и получает значение `"неактивен"`.
- Чтобы найти `†data.user.name`, система тоже смотрит в последнее сообщение, но не находит там `user.name`. Тогда она смотрит в предыдущее, находит его и получает значение `"Алекс"`.

:::::

Сила комбинации :term[Ссылок на переменные]{canonical="Variable Reference"} и :term[Путей вывода]{canonical="Output Path"} в том, что они позволяют описывать действия с данными, которых ещё нет. Например, можно настроить :term[Вызов Инструмента]{canonical="Call"} так, чтобы он работал со значением из :term[Входного]{canonical="Input"} сообщения, даже если само это сообщение ещё не пришло. Это позволяет создавать гибкие и многоразовые рабочие процессы.

Этот же принцип позволяет выстраивать :term[Вызовы Инструментов]{canonical="Call"} в цепочки. Один :term[Вызов]{canonical="Call"} может использовать :term[Ссылку на переменную]{canonical="Variable Reference"}, которая указывает на :term[Путь вывода]{canonical="Output Path"} *предыдущего* вызова в той же последовательности. Так создаётся многоступенчатый поток данных, где результат работы одного инструмента становится входными данными для следующего.

## Взаимодействие с другими системами

- **:term[Сообщения с данными]{canonical="Data Message"}:** `_outputPath` — это главный способ создавать и обновлять :term[Сообщения с данными]{canonical="Data Message"} в процессе работы. Он превращает одноразовый :term[Вызов Инструмента]{canonical="Tool Call"} в операцию, которая сохраняет свой результат, делая его доступным для следующих шагов.

  > Sidenote:
  > - :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщения о состоянии]{canonical="State Message"}:** Чаще всего результаты записывают в :term[Сообщение о состоянии]{canonical="State Message"}. Это превращает объект :term[Состояния]{canonical="State"} в тот самый «блокнот», где инструменты могут обмениваться информацией и опираться на результаты друг друга на протяжении всего :term[Цикла выполнения]{canonical="Execution Loop"}.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылки на переменные]{canonical="Variable Reference"}:** :term[Путь вывода]{canonical="Output Path"} — это «запись», а :term[Ссылка на переменную]{canonical="Variable Reference"} — «чтение». Вместе они создают замкнутую цепь для потока данных, соединяя выход одного инструмента со входом другого.

  > Sidenote:
  > - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** Выражения добавляют логику прямо в эту «проводку» данных. Используя `||` (или) и `&&` (и) в :term[Пути вывода]{canonical="Output Path"}, :term[Вызов Инструмента]{canonical="Tool Call"} может выбирать, куда отправить результат в зависимости от условий, или отправлять его сразу в несколько мест. Это делает систему более гибкой, чем жёстко запрограммированные конвейеры данных.

  > Sidenote:
  > - :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[Плана]{canonical="Plan"} :term[Пути вывода]{canonical="Output Path"} действуют как «провода», которые соединяют разные :term[Вызовы Инструментов]{canonical="Tool Call"} («узлы») в единую схему потока данных. Это позволяет агенту определить и выполнить целую многошаговую стратегию как единый объект.

  > Sidenote:
  > - :term[012: Агент/План]{href="./012_agent_plan.md"}

## От временных результатов к постоянному состоянию

Механизм :term[Пути вывода]{canonical="Output Path"} отлично справляется с потоком данных между отдельными :term[Вызовами Инструментов]{canonical="Tool Call"}. Но чтобы создавать сложных агентов, которые могут рассуждать и учиться со временем, им нужна особая память — тип сообщений, специально разработанный для сохранения информации между разными, независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает протокол для такой постоянной памяти.
