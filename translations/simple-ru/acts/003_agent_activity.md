# 003: Агент/Действие

> [!DEFINITION] [Действие](./000_glossary.md)
> Это конкретная команда, которая выполняется отдельно и «оживляет» :term[Инструмент]{canonical="Tool"}, заставляя его работать. :term[Действие]{canonical="Activity"} нужно тогда, когда агенту требуется что-то сделать во внешнем мире — например, запросить данные из интернета, обратиться к базе данных или выполнить любую задачу, с которой нейросеть не может справиться просто «в уме» (в своём скрытом пространстве).

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

**Протокол Действий** определяет, как :term[Инструменты]{canonical="Tool"} подкрепляются настоящим, исполняемым кодом. Если :term[Инструмент]{canonical="Tool"} — это описание того, *что* можно сделать, то :term[Действие]{canonical="Activity"} — это инструкция, *как* это сделать.

## Архитектура с двумя реестрами

Система агентов использует два дополняющих друг друга реестра, чтобы отделить описание способности от её реализации:

- **Реестр :term[Инструментов]{canonical="Tool"}**: Хранит схемы, описывающие :term[Инструменты]{canonical="Tool"}.
- **Реестр :term[Действий]{canonical="Activity"}**: Хранит сам исполняемый код (`async` функции, то есть :term[Действия]{canonical="Activity"}), которые реализуют :term[Инструменты]{canonical="Tool"}.

Такое разделение — ключ к гибкости системы. Оно позволяет определять и использовать :term[Инструменты]{canonical="Tool"} в «скрытом» режиме (когда ИИ сам генерирует результат), а также легко заменять одну реализацию :term[Действия]{canonical="Activity"} на другую, не меняя описание самого :term[Инструмента]{canonical="Tool"} (например, для разных окружений, таких как разработка и рабочая версия).

## Регистрация Действия

:term[Действие]{canonical="Activity"} регистрируется под уникальным именем, которое используется для его связи с :term[Инструментом]{canonical="Tool"}. Обработчик — это `async` функция, которая получает три аргумента:

- **`call`**: Конкретный объект :term[Вызова]{canonical="Call"}. Он содержит все параметры для инструмента, включая любые мета-свойства (начинаются с `_`), которые управляют выполнением.
- **`tool`**: Схема-описание :term[Инструмента]{canonical="Tool"}, который выполняется. Это позволяет действию заглянуть в свою «инструкцию» и понять, например, какой результат `_output` от него ожидается.
- **`context`**: Набор сообщений, выборочно полученных из родительского окружения. Это не полный контекст родителя, а ограниченный набор данных, контролируемый протоколом :term[Областей]{canonical="Scope"}, что делает использование контекстной информации осознанным выбором.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрируем реализацию Действия.
// По соглашению, Действие может быть связано с Инструментом с тем же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async (call, tool, context) => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Схема соответствующего Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Получает текущую погоду для указанного места.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы выполнения: Скрытый и Явный

Система поддерживает два принципиально разных режима выполнения :term[Вызова]{canonical="Call"} для :term[Инструмента]{canonical="Tool"}:

- **Скрытое выполнение**: Использует способность ИИ к рассуждению. Агент «продумывает» задачу и выдаёт результат напрямую, в том же сеансе. Это режим по умолчанию, если для :term[Инструмента]{canonical="Tool"} не найдено :term[Действие]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное выполнение**: Передаёт :term[Вызов]{canonical="Call"} на исполнение детерминированному коду. Для вычисления результата вызывается функция :term[Действия]{canonical="Activity"}. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, повторяемой логики.

## Стратегия выбора Действия

Система использует простую стратегию, чтобы определить, какой режим выполнения использовать при :term[Вызове]{canonical="Call"} :term[Инструмента]{canonical="Tool"}. Поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} сигнализирует о намерении использовать явную реализацию. Это поле определяется автоматически во время составления схемы по следующим правилам:

1.  **Явное поле `_activity`**: Если в определении :term[Инструмента]{canonical="Tool"} есть непустая строка `_activity`, её значение используется для поиска :term[Действия]{canonical="Activity"} в реестре.
2.  **Соглашение об одинаковых именах (Рекомендуется)**: Если поля `_activity` в :term[Инструменте]{canonical="Tool"} нет, система проверяет, было ли зарегистрировано :term[Действие]{canonical="Activity"} с **тем же именем**, что и :term[Инструмент]{canonical="Tool"}. Если найдено, поле `_activity` автоматически устанавливается в имя :term[Инструмента]{canonical="Tool"}.
3.  **Запасной вариант (скрытое выполнение)**: Если подходящее :term[Действие]{canonical="Activity"} не найдено по вышеуказанным правилам, поле `_activity` устанавливается в пустую строку, сигнализируя, что :term[Вызов]{canonical="Call"} должен быть выполнен скрыто.

Такой подход, основанный на соглашениях, упрощает разработку:

- **Для настройки «из коробки» регистрируйте ваше :term[Действие]{canonical="Activity"} под тем же именем, что и ваш :term[Инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"} без соответствующего :term[Действия]{canonical="Activity"} автоматически и безопасно переключатся на скрытое выполнение.
- Явное поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} всегда имеет приоритет, что позволяет одному :term[Действию]{canonical="Activity"} реализовывать несколько разных интерфейсов :term[Инструментов]{canonical="Tool"}.

## Взаимодействие с другими системами

:term[Действие]{canonical="Activity"} не выполняется в вакууме. Оно полагается на другие протоколы, чтобы получать свои параметры и контекстную информацию структурированным и безопасным способом.

- **:term[Вызов]{canonical="Call"}:** Аргумент `call` предоставляет :term[Действию]{canonical="Activity"} полный объект вызова. Это не просто словарь параметров, а сложная структура, которая может включать мета-свойства, такие как `_outputPath` для указания, куда сохранить результат, или `_instance` для нацеливания на конкретный элемент в пакетной обработке. Это позволяет :term[Действию]{canonical="Activity"} участвовать в сложных, многошаговых процессах.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
  > - :term[008: Агент/Вывод]{href="./008_agent_output.md"}
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **:term[Области]{canonical="Scope"}:** Аргумент `context` заполняется через протокол :term[Областей]{canonical="Scope"}. Свойство `_scopes` в :term[Вызове]{canonical="Call"} действует как «белый список», указывая, какие сообщения из родительского окружения (например, :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}) следует передать :term[Действию]{canonical="Activity"}. Это обеспечивает контролируемый и явный механизм для доступа :term[Действия]{canonical="Activity"} к необходимой информации, не подвергая его всему, потенциально «шумному», родительскому контексту.

  > Sidenote:
  > - :term[015: Агент/Области]{href="./015_agent_scopes.md"}

## Почему разделение Действий так важно

Без разделения схем :term[Инструментов]{canonical="Tool"} от реализаций :term[Действий]{canonical="Activity"}, определение способности было бы навсегда привязано к логике её выполнения. Чтобы переключиться с реализации на основе ИИ на внешний API, пришлось бы находить и изменять каждого агента, использующего этот :term[Инструмент]{canonical="Tool"}.

Архитектура с двумя реестрами решает эту проблему, сохраняя интерфейсы :term[Инструментов]{canonical="Tool"} стабильными, в то время как их внутренние реализации могут меняться. Агенты взаимодействуют с постоянной схемой :term[Инструмента]{canonical="Tool"}, независимо от того, выполняется ли он скрыто с помощью ИИ или явно с помощью :term[Действия]{canonical="Activity"}. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключиться со скрытого на явное выполнение, не трогая код агента.
- **A/B-тестирование стратегий выполнения**: Вы можете сравнить производительность рассуждений ИИ и внешнего API для одной и той же способности.
- **Постепенное внедрение**: Вы можете развернуть новые реализации :term[Действий]{canonical="Activity"} для части агентов, в то время как другие продолжат использовать старую или скрытый вариант.

## От определения к действию

Разделяя «что» (:term[Инструмент]{canonical="Tool"}) и «как» (:term[Действие]{canonical="Activity"}), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом становится оркестрация: как этими :term[Вызовами]{canonical="Call"} управлять, как их выполнять и в какой последовательности.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, исследует протокол, который управляет этим выполнением, превращая абстрактные определения в конкретные действия с состоянием.
