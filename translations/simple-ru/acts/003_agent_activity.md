# 003: Агент/Действие

> [!DEFINITION] [Действие](./000_glossary.md)
> Это конкретная программа, работающая в фоновом режиме, которая выполняет то, что обещает :term[инструмент]{canonical="Tool"}. Это как мускулы для идеи. Действие нужно для задач, которые требуют связи с внешним миром (например, с другими сайтами), работы с базами данных или любых других дел, которые языковая модель не может просто «придумать».

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

**Протокол Действий** — это правила, которые объясняют, как :term[инструменты]{canonical="Tool"} (идеи о том, что можно сделать) получают свой «движок» — реальный, исполняемый код. Если :term[инструмент]{canonical="Tool"} — это описание способности (например, «умею узнавать погоду»), то :term[действие]{canonical="Activity"} — это сама программа, которая это делает.

## Архитектура с двумя реестрами

Система агентов использует два отдельных списка, чтобы отделить описание того, *что* можно сделать, от того, *как* это делается:

- **:term[Реестр Инструментов]{canonical="Tool"}**: Хранит описания (схемы) :term[инструментов]{canonical="Tool"}.
- **:term[Реестр Действий]{canonical="Activity"}**: Хранит реальный программный код (:term[действия]{canonical="Activity"}), который выполняет работу.

Такое разделение — ключ к гибкости системы. Оно позволяет использовать :term[инструменты]{canonical="Tool"} в режиме «воображения» (когда ИИ сам придумывает результат), а также легко заменять одну программу (:term[действие]{canonical="Activity"}) на другую, не меняя описание :term[инструмента]{canonical="Tool"}. Например, для теста можно использовать одну программу, а для настоящей работы — другую, более мощную.

## Регистрация Действия

Каждое :term[действие]{canonical="Activity"} регистрируется под уникальным именем, чтобы его можно было связать с :term[инструментом]{canonical="Tool"}. Код, который выполняет работу, — это `async` функция, которая получает три вещи:

- **`call`**: Конкретный :term[вызов]{canonical="Call"} с заданием. Здесь содержатся все детали, например, «узнать погоду для Москвы».
- **`tool`**: Описание самого :term[инструмента]{canonical="Tool"}, для которого выполняется работа. Это помогает действию понять, какой результат от него ожидают.
- **`context`**: Часть сообщений из общего диалога, которые нужны для выполнения задачи. Это не вся история переписки, а только избранные, самые важные фрагменты, переданные через протокол :term[контекстов]{canonical="Scope"}. Так действие получает только нужную информацию и не путается в лишних деталях.

Результат работы :term[действия]{canonical="Activity"} может быть разным. Если оно возвращает готовый объект :term[сообщения]{canonical="Message"} (например, :term[сообщение с данными]{canonical="Data Message"}), то :term[цикл выполнения]{canonical="Execution Loop"} просто добавит его в диалог. Это даёт :term[действию]{canonical="Activity"} полный контроль над своим ответом. Если же оно возвращает что-то простое (например, число или текст), цикл сам «упакует» этот ответ в стандартное :term[сообщение с данными]{canonical="Data Message"}, используя `_outputPath` изначального вызова, чтобы определить, куда записать результат.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрируем реализацию Действия.
// По соглашению, Действие можно связать с Инструментом с таким же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async (call, tool, context) => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Соответствующая схема Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Получает текущую погоду для указанного места.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы выполнения: Скрытый и Явный

Система может использовать :term[инструмент]{canonical="Tool"} двумя разными способами:

- **:term[Скрытое выполнение]{canonical="Latent Execution"}**: Использует способности ИИ к рассуждению. Агент «продумывает» задачу и выдаёт результат немедленно, в своём воображении. Это режим по умолчанию, если для :term[инструмента]{canonical="Tool"} не найдено реального :term[действия]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **:term[Явное выполнение]{canonical="Explicit Execution"}**: Передаёт :term[вызов]{canonical="Call"} настоящему коду. Запускается функция :term[действия]{canonical="Activity"}, которая вычисляет результат. Это необходимо для взаимодействия с реальным миром (например, с другими сайтами, базами данных) или для задач, где нужна точность и повторяемость.

## Как система выбирает Действие

Система автоматически решает, какой режим выполнения использовать. Поле `_activity` в схеме :term[инструмента]{canonical="Tool"} указывает на намерение использовать реальный код. Система определяет это по следующим правилам:

1.  **Прямое указание в `_activity`**: Если в описании :term[инструмента]{canonical="Tool"} прямо указано имя в поле `_activity`, система ищет и использует :term[действие]{canonical="Activity"} с этим именем.
2.  **Соглашение об одинаковых именах (Рекомендуется)**: Если поле `_activity` пусто, система проверяет, есть ли :term[действие]{canonical="Activity"} с **таким же именем**, как у :term[инструмента]{canonical="Tool"}. Если есть, поле `_activity` заполняется автоматически.
3.  **:term[Скрытый режим]{canonical="Latent"} по умолчанию**: Если :term[действие]{canonical="Activity"} не найдено ни одним из способов выше, поле `_activity` остаётся пустым. Это сигнал, что :term[вызов]{canonical="Call"} нужно выполнить в режиме «воображения».

Такой подход упрощает разработку:

- **Для автоматической настройки просто назовите ваше :term[действие]{canonical="Activity"} так же, как и :term[инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"}, для которых нет соответствующего :term[действия]{canonical="Activity"}, безопасно переключатся в скрытый режим.
- Прямое указание `_activity` в схеме :term[инструмента]{canonical="Tool"} всегда имеет приоритет. Это позволяет одному :term[действию]{canonical="Activity"} выполнять работу для нескольких разных :term[инструментов]{canonical="Tool"}.

## Взаимодействие с другими системами

:term[Действие]{canonical="Activity"} работает не в одиночку. Оно получает информацию от других протоколов:

- **:term[Call]{canonical="Call"}:** Аргумент `call` предоставляет :term[действию]{canonical="Activity"} всю информацию о задании. Это не просто параметры, а целая структура, которая может включать мета-свойства вроде `_outputPath` (куда записать результат) или `_instance` (для работы с конкретным элементом в группе). Это позволяет :term[действию]{canonical="Activity"} участвовать в сложных, многошаговых процессах.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
  > - :term[008: Агент/Вывод]{href="./008_agent_output.md"}
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **:term[Scopes]{canonical="Scope"}:** Аргумент `context` заполняется с помощью протокола :term[контекстов]{canonical="Scope"}. Свойство `_scopes` в :term[вызове]{canonical="Call"} работает как список разрешений: оно указывает, какие сообщения из общего диалога (например, текущее :term[состояние]{canonical="State"} или :term[входные данные]{canonical="Input"}) нужно передать :term[действию]{canonical="Activity"}. Это безопасный способ дать :term[действию]{canonical="Activity"} доступ только к той информации, которая ему действительно нужна.

  > Sidenote:
  > - :term[015: Агент/Контексты]{href="./015_agent_scopes.md"}

- **Обработка ветвлений:** Способность :term[действия]{canonical="Activity"} возвращать полноценное :term[сообщение]{canonical="Message"} — ключ к обработке ошибок и другой сложной логике. Путь `_outputPath` в :term[вызове]{canonical="Call"} теперь служит контрактом. Когда :term[действие]{canonical="Activity"} получает вызов с выражением ветвления, например, `_outputPath: '†state.success || †state.error'`, его внутренняя логика может определить результат, а затем создать и вернуть правильное :term[сообщение с данными]{canonical="Data Message"}, чтобы записать результат по выбранному пути (например, сообщение, содержащее `{ data: { success: { ... } } }`). Это дает детерминированному коду полный контроль над управлением потоком выполнения плана.

## Почему разделение Действий важно

Если не отделять схемы :term[инструментов]{canonical="Tool"} от реализаций :term[действий]{canonical="Activity"}, то описание способности будет навсегда привязано к коду, который её выполняет. Чтобы переключиться от ответа, придуманного ИИ, к ответу от реального сайта, пришлось бы искать и изменять каждого агента, использующего этот :term[инструмент]{canonical="Tool"}.

Архитектура с двумя реестрами решает эту проблему. Описания :term[инструментов]{canonical="Tool"} остаются неизменными, а их «движки» могут меняться. Агенты работают с одним и тем же описанием :term[инструмента]{canonical="Tool"} независимо от того, выполняется ли он в «воображении» ИИ или с помощью реального кода :term[действия]{canonical="Activity"}. Это означает:

- **Изменения в коде не ломают агентов**: Можно переключиться со скрытого режима на явный, не трогая код агента.
- **Тестирование разных подходов**: Можно сравнить, что работает лучше для конкретной задачи — рассуждения ИИ или обращение к внешнему сайту.
- **Постепенное внедрение**: Можно запустить новый код :term[действия]{canonical="Activity"} только для части агентов, в то время как остальные будут использовать старый код или воображаемый режим.

## От описания к действию

Разделяя «что» (:term[инструмент]{canonical="Tool"}) и «как» (:term[действие]{canonical="Activity"}), система становится невероятно гибкой. Но это лишь часть истории. Когда описания и реализации готовы, остаётся последний элемент — управление всем этим: как :term[вызовы]{canonical="Call"} запускаются, выполняются и выстраиваются в правильном порядке.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, рассказывает о протоколе, который управляет этим исполнением, превращая абстрактные описания в конкретные, осмысленные действия.
