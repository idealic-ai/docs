# 003: Агент/Действие

> [!DEFINITION] [Действие](./000_glossary.md)
> Это как настоящая «инструкция-программа», которая выполняет работу для :term[инструмента]{canonical="Tool"}. Она нужна, когда нужно сделать что-то реальное, например, запросить данные из интернета, поработать с базой данных или выполнить любую задачу, с которой ИИ не может справиться просто «в уме» (в своём :term[скрытом состоянии]{canonical="Latent Space"}).

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

**Протокол Действий** объясняет, как :term[Инструменты]{canonical="Tool"} превращаются из простого описания в работающий код. Если :term[Инструмент]{canonical="Tool"} — это как кнопка на пульте с надписью «узнать погоду», то :term[Действие]{canonical="Activity"} — это сложная схема внутри пульта, которая на самом деле отправляет запрос и получает ответ.

## Архитектура с двумя реестрами

В системе агентов используются два дополняющих друг друга реестра, чтобы отделить «что делает» возможность от «как она это делает»:

- **:term[Реестр Инструментов]{canonical="Tool"}**: Хранит «чертежи» :term[Инструментов]{canonical="Tool"}.
- **:term[Реестр Действий]{canonical="Activity"}**: Хранит сам программный код (:term[Действия]{canonical="Activity"}), который выполняет работу для :term[Инструментов]{canonical="Tool"}.

Это разделение — главный секрет гибкости системы. Оно позволяет использовать :term[Инструменты]{canonical="Tool"} в режиме «в уме» (когда ИИ сам придумывает ответ), а также легко заменять одну реализацию :term[Действия]{canonical="Activity"} на другую (например, тестовую на настоящую), не меняя при этом сам :term[Инструмент]{canonical="Tool"}.

## Регистрация Действия

:term[Действие]{canonical="Activity"} регистрируется под уникальным именем, которое используется для его связи с :term[Инструментом]{canonical="Tool"}.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрируем реализацию Действия.
// По соглашению, Действие может быть связано с Инструментом с тем же именем.
// Типы данных автоматически берутся из Инструмента.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Схема соответствующего Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Получает текущую погоду для указанного места.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы выполнения: скрытый и явный

Система поддерживает два совершенно разных способа выполнения :term[Вызова]{canonical="Call"} :term[Инструмента]{canonical="Tool"}:

- **Скрытое выполнение**: Использует способность ИИ к рассуждению. Агент «продумывает» задачу и выдаёт результат сразу, за один проход. Это режим по умолчанию, если для :term[Инструмента]{canonical="Tool"} не найдено соответствующее :term[Действие]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное выполнение**: Передаёт :term[Вызов]{canonical="Call"} настоящему коду. Вызывается функция :term[Действия]{canonical="Activity"} для получения результата. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, предсказуемой логики.

## Как система выбирает режим

Система сама решает, какой режим выполнения использовать, когда вызывается :term[Инструмент]{canonical="Tool"}. Поле `_activity` в описании :term[Инструмента]{canonical="Tool"} указывает на намерение использовать код. Система определяет это по следующим правилам:

1.  **Поле `_activity` задано вручную**: Если в описании :term[Инструмента]{canonical="Tool"} есть поле `_activity` с названием, система ищет :term[Действие]{canonical="Activity"} с этим названием.
2.  **Договорённость об именах (рекомендуется)**: Если поля `_activity` нет, система проверяет, есть ли :term[Действие]{canonical="Activity"}, зарегистрированное с **тем же именем**, что и :term[Инструмент]{canonical="Tool"}. Если есть, система автоматически связывает их.
3.  **Переход в скрытый режим**: Если по первым двум правилам :term[Действие]{canonical="Activity"} не найдено, поле `_activity` остаётся пустым, и это означает, что :term[Вызов]{canonical="Call"} будет выполнен «в уме» ИИ.

Такой подход, основанный на договорённости, упрощает разработку:

- **Чтобы всё работало автоматически, регистрируйте :term[Действие]{canonical="Activity"} под тем же именем, что и ваш :term[Инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"} без соответствующего :term[Действия]{canonical="Activity"} автоматически и безопасно будут выполняться «в уме».
- Если вы вручную укажете `_activity` в схеме :term[Инструмента]{canonical="Tool"}, это всегда будет иметь приоритет. Так одно :term[Действие]{canonical="Activity"} может выполнять работу для нескольких :term[Инструментов]{canonical="Tool"}.

## Зачем вообще разделять Действия

Если бы описание :term[Инструмента]{canonical="Tool"} и код :term[Действия]{canonical="Activity"} были одним целым, то определение возможности было бы навсегда привязано к её реализации. Чтобы переключиться с ответа, сгенерированного ИИ, на настоящий запрос к внешнему сервису, пришлось бы найти и изменить каждого агента, использующего этот :term[Инструмент]{canonical="Tool"}.

Архитектура с двумя реестрами решает эту проблему. Она позволяет описаниям :term[Инструментов]{canonical="Tool"} оставаться стабильными, в то время как код, стоящий за ними, может меняться. Агенты всегда работают с одним и тем же «чертежом» :term[Инструмента]{canonical="Tool"}, независимо от того, выполняется ли он «в уме» ИИ или с помощью реального кода :term[Действия]{canonical="Activity"}. Это означает:

- **Изменения в коде не ломают агентов**: Можно переключиться со скрытого на явное выполнение, не трогая код агента.
- **Можно тестировать разные подходы**: Сравнивать, что работает лучше для одной и той же задачи — рассуждения ИИ или запрос к внешнему API.
- **Постепенное внедрение**: Можно запустить новый код :term[Действия]{canonical="Activity"} для части агентов, в то время как остальные продолжат использовать старый код или скрытое выполнение.

## От описания к действию

Разделяя «что» (:term[Инструмент]{canonical="Tool"}) и «как» (:term[Действие]{canonical="Activity"}), система становится невероятно гибкой. Но это лишь часть истории. Когда у нас есть описания и реализации, остаётся последний элемент — управление всем этим: как :term[Вызовы]{canonical="Call"} запускаются, выполняются и выстраиваются в цепочку.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, расскажет о протоколе, который управляет этим исполнением, превращая абстрактные описания в конкретные, осмысленные действия.
