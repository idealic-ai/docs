# 009: Агент/Модуль

> **Модуль**: Это как специальный набор правил для работы в «чистой комнате». Когда команда (`Call`) использует свойство `_module`, она запускает задачу (`Activity`) или новый запрос (`Request`) в изолированном пространстве. Чтобы передать что-то в эту комнату, используется свойство `_imports`, которое даёт контролируемый доступ к данным извне. — [Словарь](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

В прошлых документах мы разобрались, как работают отдельные Инструменты (`Tools`). Теперь **Протокол Модулей** решает важную задачу: как соединять и развивать эти способности. Он позволяет запускать Инструменты в изолированных «чистых комнатах». Это не даёт разным задачам мешать друг другу и позволяет использовать одни и те же инструменты в разных местах.

Представь, что ты строишь что-то из LEGO. Вместо того чтобы высыпать все детали в одну огромную кучу, ты собираешь маленькие готовые части (машину, домик), а потом соединяешь их вместе. Модули — это и есть такие готовые части. Система может поручить команду (`Call`) внешнему модулю — другой «Идее» (`Idea`) или задаче (`Activity`) — и таким образом строить сложное поведение из независимых и самодостаточных компонентов.

## Проблема: Гигантские инструменты и «смешение контекста»

Когда у агента появляется всё больше способностей, хранить все его Инструменты в одной большой «коробке» становится неудобно.

1.  **Слишком большие инструкции**: У «мозга» системы (LLM) есть предел того, сколько информации он может обработать за раз. Если смешать множество сложных Инструментов, инструкция станет такой огромной, что он запутается и не сможет правильно выбрать нужный инструмент.
2.  **Смешение контекста**: Представь, что ты пытаешься испечь торт, а на той же странице поваренной книги есть инструкция по ремонту машины. Ты можешь случайно отвлечься и перепутать шаги. Точно так же, когда все Инструменты лежат в одной куче, «мозг» может запутаться в ненужной информации и выбрать не тот инструмент или использовать его неправильно.
3.  **Сложно использовать повторно**: Инструмент, созданный для одного агента, нельзя просто так взять и отдать другому. Придётся тащить с собой всю «коробку», в которой он лежал.

Протокол Модулей решает эти проблемы, вводя **Область Видимости Модуля** — способ передать команду (`Call`) во внешнюю, изолированную среду для выполнения.

## Свойство `_module`

Чтобы указать, что Инструмент работает в отдельной «чистой комнате», в его описании (схеме) используется свойство `_module`. Это свойство говорит системе, что команду (`Call`) нужно не выполнять на месте, а отправить внешнему модулю.

Свойство `_module` — это просто текст (`string`), который можно использовать двумя способами:

- **Указать на «Идею» (`Idea`)**: В тексте может быть ссылка на отдельную, самодостаточную «Идею» — это как файл с инструкциями, в котором есть свой контекст и свои инструменты. Это позволяет одному Инструменту поручить свою работу совершенно другому набору правил. Ссылка может выглядеть так:
  - Путь к файлу на компьютере (например, `../ideas/my-idea.json`).
  - Специальная интернет-ссылка `idea://`.

  > Sidenote:
  > Сохранённый, многоразовый [001: Агент/Запрос](./001_agent_request.md) — это самая распространённая форма «Идеи» (`Idea`). Протокол Модулей является основным механизмом для объединения этих «Идей» в более сложные системы. Подробнее см. в [101: Концепция/Идея](./101_concept_idea.md).

- **Создать анонимный модуль**: Если написать просто слово `'anonymous'`, это создаст временную «чистую комнату» для одной конкретной задачи. Это полезно, когда нужна изоляция, но нет смысла создавать и сохранять для этого целую новую «Идею».

## Работа в «чистой комнате»

Модуль предоставляет «чистую комнату» для выполнения задачи. Вместо того чтобы работать в общем шумном пространстве родительского агента, команда (`Call`) выполняется в новом, изолированном под-запросе. Контекст для этого под-запроса не наследуется, а создаётся с нуля.

И здесь становится важен [Протокол Импорта](./008_agent_imports.md). Свойство `_imports` в описании Инструмента работает как пропускной пункт. Оно явно указывает, какие именно данные из родительского контекста нужно «пронести» в «чистую комнату» модуля. Это даёт родительскому агенту полный контроль над тем, что видит модуль, и предотвращает «смешение контекста».

> Sidenote:
> - [008: Агент/Импорты](./008_agent_imports.md)

## Работа с огромными результатами

Протокол Модулей также помогает, когда Инструмент должен произвести очень большой или сложный результат. Вместо того чтобы загромождать основной запрос гигантским описанием возможного результата (`_output`), можно определить Инструмент только с параметрами для входа (`input`) и ссылкой `_module`.

«Мозг» агента сможет спланировать команду (`Call`), зная только то, что нужно подать на вход. А сложный результат будет создан уже внутри изолированной «чистой комнаты» модуля. Это позволяет агенту планировать последовательность сложных действий, не видя всех мельчайших деталей каждого шага одновременно. Он просто доверяет модулю, что тот вернёт правильный результат, который можно будет использовать дальше.

## Когда модуль вступает в игру? Стратегии разрешения

Инструмент становится Модулем, как только в его описании появляется свойство `_module`. Это сигнал, что работу нужно передать кому-то другому. Главный вопрос — *когда* система решает, что это за модуль и как он работает. Есть две стратегии, которые позволяют выбирать между безопасностью и гибкостью.

### 1. Разрешение во время выполнения (по умолчанию)

Самый гибкий подход — определять, что такое модуль, **в момент выполнения**, уже после того, как агент сгенерировал команду (`Call`).

Этот метод позволяет делать то, что невозможно в обычном программировании: **«мозг» (LLM) выступает в роли умного «переводчика»**. Агент может создать команду (`Call`) с параметрами, которые не совсем точно совпадают с тем, что ожидает модуль. Во время выполнения система собирает вместе контекст модуля и данные от вызывающего, а «мозг» внутри модуля пытается соединить одно с другим.

Это огромное преимущество. Модули могут обновляться и меняться независимо друг от друга. Даже если у модуля поменяется структура входа, вызывающие его агенты не сломаются. «Мозг» попытается адаптировать старый формат команды к новым требованиям, создавая гибкость, которой нет в других системах.

Процесс выглядит так:

1.  Агент генерирует команду (`Call`) для модульного Инструмента.
2.  Исполнитель видит свойство `_module` и запускает протокол.
3.  **Сборка контекста**: Исполнитель находит «Идею» модуля (если он не анонимный) и создаёт базовый контекст. Затем он использует `_imports`, чтобы добавить данные от вызывающего.
4.  **Сопоставление входа**: Параметры из команды (`Call`) упаковываются во «Входящее сообщение» и добавляются в контекст. Именно здесь «мозг» выступает «переводчиком», используя эти входные данные для выполнения логики модуля, даже если их формат не совпадает идеально.
5.  **Выполнение**: Создаётся новый, изолированный Запрос (`Request`) с объединённым контекстом. Результат этого запроса возвращается как итог исходной команды (`Call`).

### 2. Предварительное разрешение (опционально)

В ситуациях, где нужна стопроцентная надёжность, модуль можно разрешить **заранее**, ещё до того, как основной Запрос (`Request`) будет отправлен агенту.

В этом режиме система заранее загружает «Идею» модуля и объединяет его требования к входу (`input`) с описанием параметров Инструмента. Это позволяет «мозгу» агента сразу видеть точные требования модуля и сгенерировать идеально правильную команду (`Call`). Что важно, при таком подходе можно также включить и описание результата (`_output`), создавая строгий контракт: «на вход подаём вот это, на выходе получаем вот то».

Этот подход даёт безопасность, как в классических API, где и вход, и выход заранее известны и проверяются. Но он жертвует гибкостью, которая есть при разрешении во время выполнения. Его лучше использовать для критически важных задач, где всё должно быть чётко и предсказуемо.

## Композиция и повторное использование: Композитор и Звукорежиссёр

Модули позволяют создавать мощные комбинации, где одни «Идеи» выступают как самостоятельные сервисы, которыми управляют другие агенты. Это создаёт понятную иерархию: высокоуровневые агенты могут заниматься общей организацией, поручая узкоспециализированные задачи низкоуровневым, многоразовым модулям.

Представь себе процесс создания музыки с двумя специалистами-модулями: **`Композитором`** и **`Звукорежиссёром`**.

- **`Звукорежиссёр`** — это низкоуровневый эксперт. Это отдельная «Идея» (`idea://sound-designer`), которая знает всё о физике звука и умеет управлять синтезаторами для создания конкретных аудиофайлов.

- **`Композитор`** — специалист среднего уровня. Его работа — сочинять музыку. Он использует свои внутренние инструменты, чтобы создать мелодию и структуру песни. Затем, чтобы воплотить свою идею в жизнь, он отправляет команды (`Calls`) модулю `Звукорежиссёра` для синтеза реальных звуков.

Такая двухуровневая система — обычное дело. Но настоящая сила модулей проявляется в том, как их можно по-разному комбинировать в зависимости от задачи.

Теперь давай добавим высокоуровневого агента-**`Продюсера`**. Его цель — выпустить готовую пластинку. В зависимости от задачи, `Продюсер` может управлять своими модулями по-разному:

> Sidenote:
> Такая схема позволяет гибко управлять процессом. Высокоуровневый Продюсер может поручить задачу Композитору, который, в свою очередь, использует Звукорежиссёра. Однако Продюсер также может обойти Композитора и напрямую взаимодействовать со Звукорежиссёром для выполнения конкретных задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> SoundDesigner(Звукорежиссёр)
>     Композитор --> SoundDesigner(Звукорежиссёр)
> ```
>

- **Иерархическое управление**: Чтобы создать песню, `Продюсер` может сделать одну команду (`Call`) модулю `Композитора`. `Продюсер` даёт общее направление («Мне нужна грустная баллада»), а `Композитор` выполняет всю свою внутреннюю работу, включая свои собственные вызовы к `Звукорежиссёру`. `Продюсеру` в этом случае даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельное управление**: Если `Продюсеру` также нужны особые звуковые эффекты для записи (например, шум дождя), он может отправлять команды (`Calls`) напрямую модулю `Звукорежиссёра` для этих задач, одновременно с тем, как `Композитор` пишет музыку.

Это показывает главный принцип: комбинация модулей не является жёстко заданной. `Продюсер` может относиться к `Композитору` как к «чёрному ящику» или напрямую взаимодействовать с его составными частями (`Звукорежиссёром`), в зависимости от того, что требуется в данный момент. Эта гибкость позволяет одним и тем же модулям-экспертам объединяться в самые разные схемы, создавая глубоко настраиваемую и мощную систему.

## От модулей к памяти

Модули отлично подходят для изоляции отдельных способностей, но для сложных, многошаговых процессов нужна память. Агенту нужен способ сохранять своё состояние между командами (`Calls`), чтобы отслеживать прогресс, учиться на прошлом опыте и выполнять долгосрочные планы. Это мостик от отдельных действий к осмысленному, последовательному поведению.

Следующий документ, [010: Агент/Состояние](./010_agent_state.md), описывает протокол для управления этим постоянным состоянием.
