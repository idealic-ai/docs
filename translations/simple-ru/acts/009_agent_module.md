# 009: Агент/Модуль

> **Модуль**: Это правило, которое позволяет выполнять задачу в изолированном пространстве. Когда в `Вызове` появляется свойство `_module`, оно запускает `Действие` или новый `Запрос` в своего рода «чистой комнате». А свойство `_imports` даёт этой комнате строго определённый доступ к информации извне. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Мы уже знаем, как работают отдельные `Инструменты`. Теперь **протокол Модулей** решает важную задачу: как соединять много таких инструментов вместе, чтобы они не мешали друг другу. Он позволяет запускать `Инструменты` в изолированных «чистых комнатах». Это не даёт информации из разных задач смешиваться и позволяет использовать одни и те же компоненты в разных местах.

Представь, что агент — это конструктор. Модули — это как отдельные, уже собранные и работающие части (например, мотор или колёса), которые можно легко подключать к разным моделям, чтобы создавать что-то по-настоящему сложное.

## Проблема: Гигантские инструменты и путаница в данных

Когда у агента появляется всё больше способностей, хранить все его `Инструменты` в одном большом «ящике» становится неудобно.

1.  **Слишком сложные схемы**: ИИ-модели, как и люди, могут запутаться, если дать им слишком много инструкций сразу. Если смешать десятки сложных `Инструментов`, ИИ может просто не понять, какой из них выбрать.
2.  **Путаница в данных**: Когда все `Инструменты` работают в одном общем пространстве, ИИ может случайно использовать не ту информацию, что приведёт к ошибкам. Это как если бы ты пытался делать уроки, а в той же комнате громко работал телевизор — легко отвлечься и ошибиться.
3.  **Неудобство повторного использования**: `Инструмент`, созданный для одного агента, трудно просто так взять и использовать в другом — придётся тащить за собой кучу связанной с ним информации.

Протокол Модулей решает эти проблемы, создавая для каждой задачи своё изолированное пространство.

## Свойство `_module`

Это свойство — как специальная инструкция в схеме `Инструмента`. Она говорит системе: «Не выполняй эту задачу прямо здесь. Отправь её в отдельный Модуль».

Свойство `_module` — это просто текст (`string`), и его можно использовать двумя способами:

- **Указать на готовый `Запрос`**: Можно дать ссылку на JSON-файл, в котором описан самостоятельный `Запрос` со своими правилами. Это всё равно что сказать: «Для этой задачи вызови специалиста из соседнего отдела».

  > Sidenote:
  > Сохранённый, готовый к повторному использованию [001: Агент/Запрос](./001_agent_request.md) — это самая распространённая форма `Идеи`. Протокол Модулей — это основной способ собирать эти `Идеи` в более сложные системы. Подробности в документе [101: Концепция/Идея](./101_concept_idea.md).

- **Создать анонимный модуль**: Можно написать просто `'anonymous'`. Это создаёт новую, пустую и изолированную «комнату» прямо на месте, без необходимости готовить для неё отдельный файл. Идеально для быстрых, одноразовых задач.

## Работа в «чистой комнате»

Модуль предоставляет ту самую «чистую комнату» для выполнения задачи. Вместо того чтобы работать в общем шумном зале, где трудятся все остальные части агента, `Вызов` отправляется в новое, изолированное место. Контекст (информация для работы) для этой задачи не наследуется автоматически, а создаётся с нуля.

И тут на сцену выходит [Протокол Импортов](./008_agent_imports.md). Свойство `_imports` в `Инструменте` работает как пропуск. Оно чётко указывает, какие именно данные из родительского контекста можно «пронести» в эту чистую комнату. Это даёт полный контроль над тем, что «видит» модуль, и предотвращает путаницу.

> Sidenote:
> - [008: Агент/Импорты](./008_agent_imports.md)

## Работа с огромными схемами

Модули также помогают, когда у `Инструмента` очень сложный или большой результат работы. Вместо того чтобы вписывать гигантскую схему результата (`_output`) в общий `Запрос` (что может «забить эфир» для других инструментов), можно определить `Инструмент` только с параметрами для входа и ссылкой `_module`.

ИИ сможет спланировать `Вызов`, зная только то, что нужно подать на вход. А сложный результат будет создан уже внутри модуля, в его изолированном пространстве. Это позволяет агенту планировать длинные цепочки действий, не видя сразу всех мельчайших деталей каждого шага. Он просто доверяет модулю, что тот вернёт правильный результат, который можно будет использовать дальше.

## Способы подключения модулей

`Инструмент` становится `Модулем`, как только в его схеме появляется свойство `_module`. Это сигнал, что задачу нужно передать дальше. Главный вопрос: *когда* именно подключается этот модуль? Есть два способа, которые позволяют выбирать между безопасностью и гибкостью.

### 1. Подключение во время выполнения (по умолчанию)

Это основной и самый гибкий способ. Модуль подключается уже **после того**, как агент решил его использовать и создал `Вызов`.

Этот метод позволяет ИИ работать как умному «клею». Агент может сделать `Вызов` с параметрами, которые не совсем точно совпадают со схемой модуля. Во время выполнения система собирает вместе правила модуля и данные от агента, и уже другой ИИ (внутри модуля) пытается «понять», как соединить одно с другим.

Это огромное преимущество. Модули могут меняться и обновляться, а агенты, которые их вызывают, не сломаются сразу. ИИ постарается адаптировать старый `Вызов` под новые правила, создавая очень гибкую и устойчивую систему.

Процесс выглядит так:

1.  Агент создаёт `Вызов` для модульного `Инструмента`.
2.  Система видит свойство `_module` и запускает протокол.
3.  **Сборка контекста**: Система находит файл с описанием модуля, готовит для него «чистую комнату» и с помощью `_imports` добавляет туда нужные данные от вызвавшего агента.
4.  **Передача данных**: Параметры из `Вызова` упаковываются в `Сообщение` и тоже добавляются в комнату. Здесь и происходит «магия склеивания»: ИИ модуля использует эти данные для своей работы, даже если они описаны немного иначе, чем он ожидал.
5.  **Выполнение**: Запускается новый, изолированный `Запрос` с собранным контекстом. Его результат возвращается как итог первоначального `Вызова`.

### 2. Подключение заранее (опционально)

В ситуациях, где нужна стопроцентная надёжность, модуль можно подключить **заранее**, ещё до того, как основной `Запрос` будет отправлен агенту.

В этом режиме система заранее загружает описание модуля и объединяет его схему со схемой `Инструмента`. Благодаря этому ИИ-агент с самого начала видит точные требования модуля и может создать идеально правильный `Вызов`. Что важно, так можно заранее узнать и схему результата (`_output`), получив строгий контракт: «вот что я тебе даю, а вот что я получу в ответ».

Этот подход похож на работу с классическими API, где всё строго определено. Он менее гибкий, но идеально подходит для критически важных задач, где сюрпризы нежелательны.

## Композиция и повторное использование: Композитор и Звукорежиссёр

Модули позволяют собирать сложные системы, где одни агенты управляют другими. Появляется понятная иерархия: высокоуровневые агенты занимаются общей координацией, а специализированные задачи поручают многоразовым модулям.

Представь себе процесс создания музыки с двумя модулями-специалистами: **`Композитором`** и **`Звукорежиссёром`**.

- **`Звукорежиссёр`** — это узкий специалист. Он знает всё о физике звука и умеет работать с синтезаторами, чтобы создавать конкретные аудиофайлы. Это полностью самостоятельный модуль.

- **`Композитор`** — специалист уровнем выше. Его работа — сочинить песню. Он использует свои внутренние инструменты, чтобы придумать мелодию и структуру. А чтобы эта музыка зазвучала, он делает `Вызовы` к модулю `Звукорежиссёра`.

Это простая двухуровневая система. Но настоящая сила модулей — в их гибкости.

А теперь введём **`Продюсера`** — высокоуровневого агента. Его цель — выпустить готовую пластинку. В зависимости от задачи `Продюсер` может использовать свои модули по-разному:

> Sidenote:
> Такая структура позволяет гибко управлять процессом. Высокоуровневый `Продюсер` может поручить задачу `Композитору`, который, в свою очередь, использует `Звукорежиссёра`. Но `Продюсер` также может обойти `Композитора` и обратиться к `Звукорежиссёру` напрямую для выполнения определённых задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> Звукорежиссёр
>     Композитор --> Звукорежиссёр
> ```

- **Иерархическое управление**: Чтобы создать песню, `Продюсер` может сделать один `Вызов` к `Композитору`, дав ему общую установку («нужна грустная баллада»). Дальше `Композитор` сам выполнит всю свою работу, включая вызовы к `Звукорежиссёру`. `Продюсеру` в этом случае даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельное управление**: Если для пластинки `Продюсеру` нужны ещё и звуковые эффекты (например, шум дождя), он может обратиться за ними напрямую к `Звукорежиссёру`, параллельно с тем, как `Композитор` пишет музыку.

Это показывает главный принцип: структура не зашита намертво. `Продюсер` может относиться к `Композитору` как к «чёрному ящику» или напрямую работать с его компонентами (`Звукорежиссёром`), в зависимости от того, что требуется в данный момент. Это позволяет комбинировать одни и те же модули-эксперты в разных связках, создавая по-настоящему гибкую и мощную систему.

## От модулей к памяти

Модули отлично подходят для отдельных, изолированных задач. Но для сложных, многошаговых процессов агенту нужна память. Ему нужен способ сохранять своё состояние между `Вызовами`, чтобы отслеживать прогресс, учиться на ошибках и выполнять долгосрочные планы.

Именно об этом пойдёт речь в следующем документе, [010: Агент/Состояние](./010_agent_state.md), который описывает протокол управления памятью.
