# 011: Агент/Экземплирование

> [!DEFINITION] :term[Экземплирование]{canonical="Instancing"}
> Это набор правил, который позволяет группировать сообщения, давая им общую уникальную метку. Так в одном запросе создаются отдельные :term[Экземпляры]{canonical="Instance"}, что позволяет компьютеру делать много вещей одновременно.

> Sidenote:
> - Требуется: :term[009: Агент/Состояние]{href="/009_agent_state.md"}
> - Совместимо:
>   - :term[007: Агент/Ввод]{href="/007_agent_input.md"}
>   - :term[013: Агент/Области]{href="/013_agent_scopes.md"}
>   - :term[010: Агент/План]{href="/010_agent_plan.md"}

**Протокол Экземплирования** — это мощный способ ускорить работу агентов, позволяя им выполнять множество задач параллельно в рамках одного запроса. Представь, что агент — это повар. Без этого протокола ему пришлось бы готовить каждое блюдо по очереди. С Экземплированием он может одновременно нарезать овощи для десяти разных салатов, не путая ингредиенты. Агенту не нужно меняться — он просто применяет свои умения к разным «рабочим пространствам» сразу. Это достигается путем присвоения сообщениям с данными, таким как :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}, уникальных меток-экземпляров. В результате один и тот же :term[План]{canonical="Plan"} можно использовать для множества задач одновременно, что сильно повышает скорость и качество работы.

## Как работает механизм экземплярования

Экземплирование позволяет обрабатывать множество независимых наборов данных. Для этого оно работает поверх сообщений, которые несут в себе информацию, например :term[Состояние]{href="/009_agent_state.md"}. Вместо одного сообщения :term[Состояние]{canonical="State"}, запрос может содержать целый список таких сообщений, где каждое представляет собой отдельную задачу или :term[Экземпляр]{canonical="Instance"}.

Чтобы управлять этими параллельными задачами, каждому сообщению :term[Состояние]{canonical="State"} присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы — короткие уникальные метки (например, `①`, `②`), которые помогают ИИ понять, к какой задаче относится та или иная операция.

Экземплирование — это опция, которую можно включить по желанию. Добавляя свойство `_instance` к сообщению с данными, например :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}, мы говорим: «Считай это отдельной задачей, не смешивай её с другими». Если метки `_instance` нет, сообщение считается общим для всех задач.

У этого подхода есть большие плюсы:

- **Скорость**: Он в разы увеличивает производительность системы, обрабатывая много задач в одном запросе к ИИ.
- **Качество**: Позволяя ИИ видеть сразу несколько похожих задач, он помогает создавать более логичные и качественные планы.

## Совместная работа с сообщениями контекста

Сила этого протокола в том, как метка `_instance` влияет на разные типы сообщений.

- **:term[Состояние]{canonical="State"}:** Сообщение :term[Состояние]{canonical="State"} — это основа протокола. Каждый :term[Экземпляр]{canonical="Instance"} — это отдельное сообщение :term[Состояние]{canonical="State"} со своей уникальной меткой `_instance`. Это как отдельный холст для рисования, который гарантирует, что дела в одной задаче не повлияют на другие.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="/009_agent_state.md"}

- **:term[Ввод]{canonical="Input"}:** Сообщение :term[Ввод]{canonical="Input"} можно использовать двумя способами. Общее сообщение :term[Ввод]{canonical="Input"} (без метки `_instance`) даёт настройки сразу для всех задач. А целевое сообщение :term[Ввод]{canonical="Input"} (с меткой `_instance`) передаёт данные для конкретной задачи, перекрывая общие настройки.

  > Sidenote:
  > - :term[007: Агент/Ввод]{href="/007_agent_input.md"}

- **:term[Области]{canonical="Scope"}:** Метка `_instance` обеспечивает изоляцию данных для :term[Областей]{canonical="Scope"}. Когда :term[Вызов]{canonical="Call"} нацелен на конкретный экземпляр, его `_scopes` (области видимости) тоже ограничиваются только данными этого экземпляра. Это позволяет :term[Делегату]{canonical="Delegate"} видеть только ту информацию, которая нужна для его маленькой задачи, даже когда он работает как часть большого запроса с множеством экземпляров.

  > Sidenote:
  > - :term[013: Агент/Области]{href="/013_agent_scopes.md"}

:::details{title="Пример: Модерация комментариев в большом масштабе"}

Экземплирование превращает агента, выполняющего одну задачу, в мощную систему для пакетной обработки. Представим агента, который должен проверять комментарии пользователей на соответствие правилам сообщества.

Без экземплярования агент работал бы последовательно. Чтобы проверить 100 комментариев, ему потребовалось бы 100 отдельных :term[Запросов]{canonical="Request"}. Это не только медленно, но и неэффективно: агент оценивает каждый комментарий в изоляции и может принимать противоречивые решения по похожему контенту.

С **Протоколом Экземплирования** вся работа выполняется параллельно в рамках одного :term[Запроса]{canonical="Request"}.

1.  **Пакетный ввод**: Агент получает `context` со списком из 100 сообщений :term[Ввод]{canonical="Input"}. Каждому сообщению присваивается уникальный идентификатор `_instance`, и в каждом содержится свой комментарий.

    ```json
    // Пакет сообщений Ввода, переданный ИИ
    [
      {
        "type": "input",
        "_instance": "①",
        "comment": "Это отличный пост!"
      },
      {
        "type": "input",
        "_instance": "②",
        "comment": "Я с этим не согласен..."
      },
      {
        "type": "input",
        "_instance": "③",
        "comment": "Это спам."
      }
      // ... и ещё 97 экземпляров комментариев
    ]
    ```

2.  **Параллельное выполнение плана**: Теперь ИИ видит всю партию. Он может использовать один :term[План]{canonical="Plan"}, который описывает два шага: сначала проанализировать тон комментария, а затем проверить его на наличие запрещённых слов. Этот план применяется ко всем экземплярам сразу.

3.  **Целевой вывод**: В :term[решении]{canonical="Solution"} агента будет содержаться общий список :term[Вызовов]{canonical="Call"}, но каждый `Вызов` будет направлен на конкретный комментарий с помощью свойства `_instance`.

    ```json
    // Решение, сгенерированное ИИ
    {
      "calls": [
        {
          "_tool": "moderateComment",
          "_instance": "①",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "②",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "③",
          "decision": "reject"
        }
        // ... и ещё 97 вызовов модерации
      ]
    }
    ```

Такой подход даёт два главных преимущества:

- **Производительность**: То, что раньше требовало 100 обращений к ИИ, теперь делается за один раз.
- **Качество**: Видя всю партию целиком, ИИ получает больше контекста. Он может принимать более взвешенные решения и даже замечать закономерности (например, скоординированную спам-атаку), которые были бы невидимы при обработке комментариев по одному.

:::

:::::details{title="Глобальный ввод с экземплярами состояния"}

Этот пример показывает, как общее сообщение `Ввод` может направить внимание агента на конкретный экземпляр в большой партии. Это позволяет гибко управлять параллельными процессами, превращая простой обработчик в сложного дирижёра, похожего на менеджера, который раздаёт поручения отдельным сотрудникам.

::::columns
:::column{title="Контекст"}

Эта ситуация похожа на то, как менеджер руководит сотрудниками. Одно общее сообщение `input` — это как приказ сверху, а несколько сообщений `state` с метками экземпляров — это сотрудники со своими задачами. Это показывает, как агент, созданный для управления одним объектом, легко масштабируется для управления многими, при этом его основная логика не меняется.

```json
[
  // Общая инструкция для конкретного сотрудника
  {
    "type": "input",
    "instruction": "Дай сотруднику B новую срочную задачу: 'Завершить квартальный отчёт'."
  },

  // Текущее состояние всех сотрудников
  {
    "type": "state",
    "_instance": "employee_A",
    "task": "Подготовить черновик предложения",
    "status": "В работе"
  },
  {
    "type": "state",
    "_instance": "employee_B",
    "task": "Проверить отчёты команды",
    "status": "Заблокирован"
  }
]
```

:::
:::column{title="Целевое решение"}

Несмотря на то, что `Ввод` общий, ИИ правильно понимает инструкцию на обычном языке. Он создаёт `Вызов`, который точно нацелен на `employee_B` с помощью свойства `_instance`. Это показывает его способность разумно распределять команды. Другой «сотрудник» остаётся нетронутым.

```json
{
  "calls": [
    {
      "_tool": "updateTask",
      "_instance": "employee_B",
      "newTask": "Завершить квартальный отчёт",
      "newStatus": "Высокий приоритет",
      "output": "†state"
    }
  ]
}
```

:::
::::
:::::

## Совместная работа с другими протоколами

Экземплирование работает вместе с другими протоколами для управления процессом выполнения.

- **:term[Вызовы]{canonical="Call"}:** Свойство `_instance` в :term[Вызове]{canonical="Call"} — это главный механизм, который направляет его действие. Оно гарантирует, что все операции с состоянием — будь то запись в `_outputPath` или чтение данных из состояния для использования в качестве входных — применяются к правильному :term[Экземпляру]{canonical="Instance"}.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="/004_agent_call.md"}

- **:term[План]{canonical="Plan"}:** Сообщение :term[План]{canonical="Plan"} не подвержено экземплярованию; оно действует как единый, общий шаблон для рабочего процесса. Его можно комбинировать с несколькими сообщениями :term[Состояние]{canonical="State"}, имеющими экземпляры, что позволяет выполнять один и тот же план одновременно для множества независимых задач в одном запросе.

  > Sidenote:
  > - :term[010: Агент/План]{href="/010_agent_plan.md"}

## От плана к процессу

:term[План]{canonical="Plan"} — это многоразовый шаблон для работы, :term[Экземплирование]{canonical="Instancing"} — это механизм для его масштабного выполнения, а **:term[Идея Процесса]{href="/203_idea_process.md"}** — это результат, который всё это объединяет. Это полная, самодостаточная запись стратегического плана и его текущего состояния выполнения по всем экземплярам.