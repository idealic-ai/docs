# 103: Концепция/Идеатор

> [!DEFINITION] [Идеатор](./000_glossary.md)
> Это «Идея», которая умеет принимать данные извне. Её можно узнать по специальному сообщению в контексте: `type: "input"`. Она работает как функция: превращает входящие данные в исходящие.

> Sidenote:
> - Требует:
>   - [101: Концепция/Идея](./101_concept_idea.md)
>   - [007: Агент/Ввод](./007_agent_input.md)
> - Делает возможным:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [102: Концепция/Суверенитет](./102_concept_sovereignty.md)

## Введение

Этот документ объясняет правила работы для **Идеаторов** и **Трансформеров Идей** — программ, которые можно запустить и использовать как сервисы. Он основан на документе [101: Концепция/Идея](./101_concept_idea.md), где описывается, из чего состоит сама «Идея». Здесь же мы разберемся, как «Идея» превращается в нечто функциональное, что можно вызвать и заставить работать.

Больше о разных способах их запуска и размещения можно прочитать в документе [102: Концепция/Суверенитет](./102_concept_sovereignty.md).

## От Идеи к Идеатору

**Идеатор** — это не какая-то отдельная сущность, а скорее роль, которую может играть любая `Идея`. Представь его как волшебную коробочку. Ты что-то в неё кладёшь (вход), а она, поразмыслив в своём «скрытом пространстве», выдаёт что-то новое (выход). Это означает, что её логика не обязательно записана в виде привычного кода. Вместо этого она руководствуется богатым `контекстом` самой `Идеи` — её схемами, примерами и инструкциями на обычном языке, которые понимает и выполняет большая языковая модель (ИИ).

Главный признак того, что `Идея` — это Идеатор, — это наличие у неё сообщения в `контексте` с типом `type: "input"`. В этом сообщении описывается, какие данные Идеатор ожидает получить. У *исполняемого* Идеатора также может быть сообщение `type: "code"`, указывающее на конкретный программный код для выполнения.

### Трансформер Идей: Частный случай

Очень частый и полезный случай — это когда Идеатор на вход получает не просто данные, а другую `Идею`. Такой Идеатор мы называем **Трансформером Идей**. Именно они позволяют выстраивать цепочки, в которых одни Идеи обрабатывают и развивают другие.

## Реализации и Композиция

Принципы, описанные в этом документе, определяют **правила поведения** для любого сервиса-Идеатора. Это не инструкция для одной конкретной программы, а скорее стандарт, который позволяет разным программам понимать друг друга. Благодаря этому можно создавать множество разных реализаций, которые будут работать вместе.

### Множество реализаций

Сервис-Идеатор должен соблюдать одно главное правило: принимать на вход `Идею` и возвращать другую `Идею`. Это позволяет создавать разные типы сервисов для разных задач:

- **Управляемые сервисы**: Провайдер может предложить готовый сервис в облаке. Тебе не нужно думать о серверах и настройках — всё уже сделано за тебя, как описано в [Протоколе Суверенитета](./102_concept_sovereignty.md).
- **Собственные серверы**: Разработчик может запустить свою версию сервиса на своём компьютере или сервере, полностью всё контролируя.
- **Локальные реализации**: Для тестов и разработки логику Идеатора можно запустить прямо в памяти компьютера как обычную функцию, вообще без использования сети, но соблюдая те же основные правила.

### Композиция и Системы высшего порядка

В этой системе нет такого понятия, как «приватный» или «закрытый» сервис. Все Идеаторы созданы, чтобы общаться друг с другом через свои публичные, стандартные интерфейсы.

Более сложные сервисы, которые можно назвать **Системами высшего порядка**, создаются путём объединения других, более простых `Идеаторов`. Логика такого сложного сервиса заключается в том, что он внутри себя обращается к другим публичным `Идеаторам`.

Например, система **Реактор** — это `Идеатор` высшего порядка. Для управления игрой он может:

1.  Принять `Идею` с состоянием игры через свой публичный интерфейс.
2.  Внутри себя обратиться к публичному сервису `Игрок`, чтобы создать и управлять профилями игроков.
3.  Затем обратиться к публичному сервису `Хранилище`, чтобы записать историю игры.
4.  Вернуть `Идею` с новым состоянием игры через свой публичный интерфейс.

Снаружи Реактор выглядит как обычный Идеатор. Вся его сложность скрыта внутри, и он просто использует другие независимые публичные сервисы. Это делает всю систему гибкой, понятной и легко расширяемой.
