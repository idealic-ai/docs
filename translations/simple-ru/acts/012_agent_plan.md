# 012: Агент/План

> [!DEFINITION] [План](./000_glossary.md)
> Это как рецепт для агента. Это сообщение, в котором описана вся последовательность действий (:term[Вызовов инструментов]{canonical="Tool Call"}) в виде схемы. План передаётся от шага к шагу, чтобы агент мог выполнять задачу поэтапно и подстраиваться под изменения.

> Sidenote:
> - Требуется:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
>   - :term[009: Агент/Состояние]{href="./009_agent_state.md"}
>   - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

Сообщение :term[План]{canonical="Plan"} — это главный способ заставить агента работать над задачей шаг за шагом, запоминая, что он уже сделал. Хотя система может выполнять и простые, одноразовые команды, наличие `Плана` в контексте означает, что мы переключаемся на более длительный процесс. Когда агент видит `План`, его :term[Цикл выполнения]{canonical="Execution Loop"} понимает: «Ага, этот план и все результаты (:term[Состояние]{canonical="State"}) нужно запомнить и использовать на следующих шагах».

Эта «память» очень важна для создания умных агентов, которые могут адаптироваться. Когда языковая модель (LLM) получает текущий :term[План]{canonical="Plan"} вместе с актуальным объектом :term[Состояния]{canonical="State"}, она полностью понимает, что происходит и на каком она этапе. Это позволяет ей с умом следовать существующему плану, добавлять в него новые :term[Вызовы инструментов]{canonical="Tool Call"} или даже полностью отбросить старый план и придумать новый, если что-то пошло не так. Без сообщения `План` любая команда считается разовой, и никакой информации о стратегии или результатах на следующие шаги не переносится.

## Как формируется План

Связи между шагами в этом рецепте создаются не с помощью прямых «стрелочек», а через очень простой и умный способ обмена данными с помощью объекта :term[Состояние]{canonical="State"}.

- **Узлы (:term[Вызовы инструментов]{canonical="Tool Call"}):** Каждый шаг в процессе — это :term[Вызов инструмента]{canonical="Tool Call"}, то есть какое-то действие, которое нужно выполнить.
- **Рёбра (Объект :term[Состояние]{canonical="State"}):** Связи между шагами появляются, когда один инструмент что-то записывает в общее «хранилище» — объект :term[Состояние]{canonical="State"}, — а другой оттуда читает. Один :term[Инструмент]{canonical="Tool"} записывает свой результат по определённому адресу в :term[Состоянии]{canonical="State"}, используя специальное свойство :term[Путь для вывода]{canonical="Output Path"}. А следующий :term[Инструмент]{canonical="Tool"} может использовать этот результат как входные данные, просто сославшись на тот же адрес с помощью **:term[Ссылки на переменную]{canonical="Variable Reference"}**.

  > Sidenote:
  > - [008: Агент/Вывод](./008_agent_output.md)

Так устанавливается чёткая зависимость: второй :term[Вызов инструмента]{canonical="Tool Call"} не может начаться, пока первый не закончит свою работу и не запишет результат в :term[Состояние]{canonical="State"}.

Например, :term[План]{canonical="Plan"}, чтобы получить профиль пользователя, а затем сделать его краткое описание, будет состоять из двух :term[Вызовов инструментов]{canonical="Tool Call"}:

:::div{.limited-width}

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

> Sidenote:
> ```mermaid
> graph TD
>     state_var{{"состояние.профиль_пользователя"}}
>
>     Call1["получитьПрофиль"]
>     Call2["сделатьКраткийОбзор"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```

:::

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, что создаёт план из двух шагов. Эту зависимость можно представить в виде простой схемы.

## Содержимое Плана: Граф потока данных

Содержимое сообщения :term[План]{canonical="Plan"} — это граф потока данных. Представь себе схему, где кружочки — это действия, а стрелочки показывают, как результаты одного действия передаются другому. Эта структура используется, чтобы показать стратегию агента как последовательность связанных :term[Вызовов инструментов]{canonical="Tool Call"}. Представляя процесс в виде графа, система может чётко определить зависимости между шагами. Такая форма в виде графа — это понятная для компьютера структура, которую :term[Цикл выполнения]{canonical="Execution Loop"} агента может прочитать и выполнить.

> Sidenote:
> :term[План]{canonical="Plan"} не ограничивается линейными последовательностями. Он может представлять сложные рабочие процессы с условной логикой, где путь выполнения зависит от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Узнать погоду] --> B{Солнечно?};
>     B -- состояние.солнечно --> C[Найти парк];
>     B -- состояние.не_солнечно --> D[Найти кино];
>     C -- состояние.предложение --> E[Предложить вариант];
>     D -- состояние.предложение --> E[Предложить вариант];
> ```

Но такая структура в виде графа подходит не только для описания планов действий. Агента можно попросить создать граф :term[Вызовов инструментов]{canonical="Tool Call"}, который представляет что-то совсем другое — например, схему связей в социальной сети, рабочий процесс для GitHub Actions или структуру базы данных.

Очень важно отличать такие результаты от :term[Плана]{canonical="Plan"}. Хотя они используют ту же структуру графа, они не являются «планами» в архитектурном смысле, пока их не передадут в следующий :term[Запрос]{canonical="Request"} как контекстное сообщение :term[План]{canonical="Plan"} с намерением его выполнить. Это различие помогает не путать создание схемы существующей системы с созданием стратегии, которую нужно выполнить.

Хотя содержимое :term[Плана]{canonical="Plan"} может быть мощным инструментом для мозгового штурма, обсуждений и «размышлений вслух», его основное применение в этой системе — определять выполняемые рабочие процессы. Для этой цели мы используем особый тип графа, который называется **Направленный ациклический граф (НАГ)**, где каждый узел — это :term[Вызов инструмента]{canonical="Tool Call"}.

У НАГ есть несколько ключевых свойств, которые делают его идеальным для выполнения задач:

- **Граф:** «Граф» — это всё содержимое сообщения :term[План]{canonical="Plan"}: совокупность всех :term[Вызовов инструментов]{canonical="Tool Call"} (узлов) и зависимостей по данным, которые их связывают (рёбер).
- **Направленный:** Связи односторонние, как улица с односторонним движением. Они определяются потоком данных. Шаг, который создаёт данные, должен идти *перед* шагом, который их использует.
- **Ациклический:** В процессе не может быть круговых зависимостей, что гарантирует наличие чёткого начала и конца. Это как в игре-бродилке, где нельзя, пройдя по кругу, вернуться на старт. Это очень важная мера безопасности, чтобы языковая модель случайно не создала бесконечный цикл. Система проверяет, что :term[План]{canonical="Plan"} является ациклическим, прежде чем его выполнять.

> Sidenote:
> Чтобы реализовать итеративную логику, такую как цикл «for», используется шаблон вложенного, делегированного выполнения. Внешний :term[План]{canonical="Plan"} управляет состоянием цикла (например, счётчиком итераций) и для каждой итерации вызывает подзапрос через :term[Делегата]{canonical="Delegate"}. Этот подзапрос содержит свой собственный отдельный, ациклический :term[План]{canonical="Plan"}, который выполняет логику для одной итерации. Это гарантирует, что циклы создаются явно и безопасно.

## Стратегии планирования и выполнения

Самая мощная особенность этой архитектуры — это связь между декларативным `Планом` и его выполнением. Это контролируется свойством `mode` (режим) внутри самого сообщения `План`, что позволяет использовать разные стратегии.

Языковая модель (LLM) всегда выступает в роли планировщика. А режим `mode` определяет, должна ли LLM также немедленно выполнять внутренние задачи.

### Нетерпеливое выполнение (по умолчанию)

По умолчанию `План` работает в `eager` (нетерпеливом) режиме. В этом режиме **планирование — это и есть выполнение**. Нет никакой паузы между созданием плана и действием. Когда LLM создаёт `решение`, она выполняет единый, непрерывный процесс размышления и выполнения для любых внутренних шагов, которые она может решить на месте.

- Если задача требует внутреннего инструмента (например, кратко пересказать текст), LLM сгенерирует и `вызов`, и его `_output` (результат) в одном потоке мыслей.
- Если задача требует внешнего :term[Действия]{canonical="Activity"}, LLM генерирует `вызов`, который затем немедленно отправляется исполнителю действий через организатор :term[Цикла выполнения]{canonical="Execution Loop"}.

Этот режим оптимизирован для скорости и самостоятельности. Главный компромисс, особенно на **первом шаге** плана, заключается в том, что любая логика с ветвлением решается немедленно. Схема инструмента может позволять ветвление `_outputPath` (например, `†state.sunny || †state.rainy`), но в режиме `eager` непрерывный процесс мышления LLM сводит эту возможность к одному конкретному пути в `решении`, которое она генерирует.

Поэтому `решение` на первом шаге нетерпеливого выполнения никогда не будет содержать внутренний вызов с неразрешённым ветвлением. Выбор делается как часть начального шага планирования/выполнения. Именно это делает выполнение на данном этапе линейным. На последующих шагах LLM имеет доступ к состоянию, созданному предыдущими шагами, и может принимать более сложные решения о ветвлении на основе этого существующего состояния.

### Ленивое выполнение (Обдуманное планирование)

Пользователь может выбрать более обдуманный рабочий процесс, установив `mode` в `lazy` (ленивый). Эта стратегия вводит строгое разделение между планированием и выполнением. В этом режиме LLM получает инструкцию действовать исключительно как планировщик.

- Она **не будет** выполнять внутренние задачи.
- Её единственная цель — сгенерировать полный, декларативный граф потока данных из :term[Вызовов инструментов]{canonical="Tool Call"}. Если схема инструмента допускает ветвление `_outputPath`, LLM сохранит это выражение в плане, отложив выбор до этапа выполнения.

Результатом является чистая структура данных, представляющая всю стратегию, которая не выполняется сразу. Это создаёт важную точку контроля, где план можно:

- **Проверить:** Система может проверить граф на наличие циклических зависимостей или других структурных ошибок.
- **Сымитировать:** Можно провести «пробный запуск», чтобы предсказать поведение рабочего процесса.
- **Представить на утверждение:** :term[План]{canonical="Plan"} можно показать человеку для проверки, изменения или одобрения перед выполнением (:term[Участие человека]{canonical="HITL (Human-in-the-Loop)"}).

Выполнением занимается :term[Цикл выполнения]{canonical="Execution Loop"}, который интерпретирует сообщение :term[План]{canonical="Plan"} и запускает :term[Вызовы инструментов]{canonical="Tool Call"} в правильном порядке на основе их зависимостей, заполняя объект :term[Состояние]{canonical="State"} по мере продвижения.

## План как развивающаяся стратегия

:term[План]{canonical="Plan"} — это не что-то статичное; это живая стратегия, которую можно адаптировать на каждом шаге цикла выполнения. Важное различие заключается в том, что `План` — это не любой результат работы LLM. Когда агент впервые генерирует набор :term[Вызовов инструментов]{canonical="Tool Call"}, это просто предлагаемая последовательность действий. Она становится настоящим :term[Планом]{canonical="Plan"} только тогда, когда передаётся как контекстное сообщение в *следующий* запрос в цикле.

Этот цикл превращает одноразовый результат в постоянную стратегию:

- **:term[Контекст]{canonical="context"}** для запроса содержит объект :term[Состояние]{canonical="State"} и сообщение :term[План]{canonical="Plan"} с предыдущего шага.
- **:term[Решение]{canonical="Solution"}**, сгенерированное LLM, содержит новый набор :term[Вызовов инструментов]{canonical="Tool Call"}, который становится **новым :term[Планом]{canonical="Plan"}** для следующего шага.

Этот итеративный процесс позволяет агенту быть одновременно и проактивным, и реактивным. Он может следовать существующему :term[Плану]{canonical="Plan"}, но также может изменять его в ответ на результаты предыдущего шага. Например, если :term[Вызов инструмента]{canonical="Tool Call"} завершается с ошибкой, агент может сгенерировать новый :term[План]{canonical="Plan"}, включающий шаги по обработке ошибок. Это делает систему устойчивой и адаптивной.

:::::details{title="Пример: Планирование на один шаг вперёд"}

Этот пример показывает, как `План` задаёт «идеальный сценарий», который направляет агента, не давая ему отклониться от стандартной процедуры, даже когда доступны другие правдоподобные действия.

**Сценарий:** Агенту поддержки клиентов нужно обработать возврат средств. Стандартная процедура, запущенная запросом пользователя, — сначала проверить историю платежей для контекста, а затем оформить возврат.

**1. Начальный запрос**

Цикл начинается с запроса клиента. На основе этого `ввода` LLM формулирует стандартный двухэтапный `План` для обработки возврата. Это представляет собой идеальный, наиболее распространённый рабочий процесс.

::::columns
:::column{title="Контекст и схема для запроса"}

```json
// Agent.Request(config, schema, context)
{
  "schema": {
    "type": "object",
    "properties": {
      "calls": { "type": "array" },
      "output": {
        "type": "object",
        "nullable": true,
        "properties": {
          "confirmationId": { "type": "string" },
          "message": { "type": "string" }
        }
      }
    }
  },
  "context": [
    {
      "type": "input",
      "request": "Я бы хотел вернуть деньги за последний заказ.",
      "customerId": "cust_123",
      "amount": 50.0
    }
  ]
}
```

:::
:::column{title="`Решение` LLM"}

```json
{
  "calls": [
    {
      "_tool": "checkBillingHistory",
      "customerId": "†input.customerId"
    },
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": null
}
```

:::
::::

**2. Следующий запрос в цикле**

:term[Цикл выполнения]{canonical="Execution Loop"} выполняет вызов `checkBillingHistory` и заполняет :term[Состояние]{canonical="State"}. История показывает некоторые сложности (например, предыдущий возвратный платёж). На этом этапе агент без чётких указаний мог бы с большой вероятностью выбрать другой доступный инструмент, `escalateToSupervisor` (передать супервайзеру).

Однако сообщение `План` в контексте обеспечивает необходимую структуру. Сопоставляя то, что он *знает* (сложное `Состояние`), с тем, что он *должен делать* (`План`), LLM точно понимает свою позицию в рабочем процессе и придерживается «идеального сценария».

::::columns
:::column{title="Контекст"}

```json
[
  {
    "type": "state",
    "billingHistory": {
      "orders": 5,
      "lastChargeback": "2025-09-10"
    }
  },
  {
    "type": "plan",
    "plan": [
      {
        "_tool": "checkBillingHistory",
        "customerId": "†input.customerId"
      },
      {
        "_tool": "issueRefund",
        "customerId": "†input.customerId",
        "amount": "†input.amount"
      }
    ]
  }
]
```

:::
:::column{title="`Решение` LLM"}

```json
{
  "calls": [
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": {
    "confirmationId": "refund_xyz789",
    "message": "Возврат был успешно обработан."
  }
}
```

:::
::::

`План` обеспечивает последовательность процедуры, предотвращая преждевременную эскалацию и удерживая агента на намеченном пути.

:::::

:::::details{title="Пример: Корректировка плана"}

Этот пример показывает, как агент может изменить существующий :term[План]{canonical="Plan"} в ответ на новую информацию, выбрав другой инструмент.

::::columns
:::column{title="Контекст"}

Агенту даётся существующий «идеальный» `План` и новый `Ввод` от пользователя, который вводит новое ограничение.

```ts
[
  { type: 'tool', tool: Tool.bookFlight },
  { type: 'tool', tool: Tool.bookHotel },
  { type: 'tool', tool: Tool.findPetFriendlyHotel },
  {
    type: 'plan',
    plan: [
      {
        _tool: 'bookFlight',
        destination: '†input.destination',
      },
      {
        _tool: 'bookHotel',
        destination: '†input.destination',
      },
    ],
  },
  {
    type: 'input',
    destination: 'Berlin',
    instruction: "Кстати, я поеду со своей собакой.",
  },
];
```

:::
:::column{title="`Решение` LLM"}

LLM понимает, что первоначальный план больше не подходит. Он отбрасывает старый план и генерирует новый, заменяя `bookHotel` на более специализированный инструмент.

```json
{
  "calls": [
    {
      "_tool": "bookFlight",
      "destination": "†input.destination"
    },
    {
      "_tool": "findPetFriendlyHotel",
      "destination": "†input.destination"
    }
  ],
  "output": null
}
```

:::
::::

Агент не просто меняет параметр; он коренным образом изменяет свою стратегию, выбирая более подходящий инструмент (`findPetFriendlyHotel`) на основе новых требований. Этот новый набор `Вызовов инструментов` становится `Планом` для следующего шага в :term[Цикле выполнения]{canonical="Execution Loop"}.

:::::

:::::details{title="Пример: Обработка сбоя"}

Этот пример показывает, как агент может отклониться от «идеального» :term[Плана]{canonical="Plan"}, столкнувшись с неожиданным сбоем. Процесс показан в два этапа: начальный «идеальный» план и перепланирование, которое происходит после сбоя инструмента.

**1. Начальный план**

Агенту предоставляется набор инструментов и вводные данные от пользователя. Он генерирует оптимистичный, двухэтапный «идеальный» план, который не учитывает возможность сбоя.

::::columns
:::column{title="Начальный контекст"}

```ts
Agent.Request(config, {
  schema: {
    type: 'object',
    properties: {
      calls: { type: 'array' },
      output: {
        type: 'object',
        nullable: true,
        properties: {
          status: {
            type: 'string',
            enum: ['Success', 'Failed'],
          },
        },
      },
    },
  },
  context: [
    { type: 'tool', tool: 'Tool.processPayment' },
    { type: 'tool', tool: 'Tool.confirmOrder' },
    { type: 'tool', tool: 'Tool.reportFailure' },
    { type: 'input', amount: 50.0 },
  ],
});
```

:::
:::column{title="Начальное решение"}

```json
{
  "calls": [
    {
      "_tool": "processPayment",
      "amount": "†input.amount",
      "_outputPath": "†state.receipt || †state.error"
    },
    {
      "_tool": "confirmOrder",
      "receipt": "†state.receipt"
    }
  ],
  "output": null
}
```

:::
::::

**2. Сбой и перепланирование**

:term[Цикл выполнения]{canonical="Execution Loop"} пытается запустить `processPayment`, но инструмент даёт сбой. Система заносит ошибку в `†state.error`. На следующей итерации LLM видит это новое состояние ошибки вместе с исходным (теперь устаревшим) планом и генерирует новое решение для обработки сбоя.

::::columns
:::column{title="Контекст для следующего запроса"}

```json
[
  {
    "type": "state",
    "error": { "code": "card_declined", "message": "Ваша карта отклонена." }
  },
  // Оригинальный, теперь устаревший план всё ещё в контексте
  {
    "type": "plan",
    "plan": [
      { "_tool": "processPayment", "_outputPath": "†state.receipt || †state.error" },
      { "_tool": "confirmOrder", "receipt": "†state.receipt" }
    ]
  }
]
```

:::
:::column{title="Новое решение (перепланированное)"}

```json
{
  "calls": [
    {
      "_tool": "reportFailure",
      "error": "†state.error"
    }
  ],
  "output": { "status": "Failed" }
}
```

:::
::::

Агент распознал `ошибку` в `Состоянии`, проигнорировал устаревший «идеальный» `План` и сгенерировал новый, одношаговый план для `сообщения о сбое`. Это демонстрирует способность агента реагировать на неожиданные результаты.

:::::

:::::details{title="Пример: Планирование по схеме"}

Этот пример показывает, как предоставление `схемы` для объекта :term[Состояние]{canonical="State"} действует как чертёж, направляя LLM к созданию структурно правильного :term[Плана]{canonical="Plan"}.

::::columns
:::column{title="Контекст со схемой состояния"}

Вызывающая сторона предоставляет `Ввод` и сообщение `Состояние`, которое содержит только `схему`. Эта схема определяет предполагаемый поток данных, указывая «переменные», которые должен использовать план.

```json
[
  { "type": "tool", "tool": "Tool.detectLanguage" },
  { "type": "tool", "tool": "Tool.isEnglish" },
  { "type": "tool", "tool": "Tool.translateText" },
  {
    "type": "input",
    "text": "Bonjour le monde"
  },
  {
    "type": "state",
    "schema": {
      "type": "object",
      "properties": {
        "language": { "type": "string" },
        "isEnglish": { "type": "boolean" },
        "translatedText": { "type": "string" }
      }
    }
  }
]
```

:::
:::column{title="`Решение` LLM"}

LLM использует схему `Состояния` как руководство для построения действительного плана, правильно связывая :term[Путь для вывода]{canonical="Output Path"} одного инструмента со входом следующего.

```json
{
  "calls": [
    {
      "_tool": "detectLanguage",
      "text": "†input.text",
      // LLM знает, что нужно использовать этот путь из схемы.
      "_outputPath": "†state.language"
    },
    {
      "_tool": "isEnglish",
      // Она правильно ссылается на вывод предыдущего шага.
      "language": "†state.language",
      "_outputPath": "†state.isEnglish"
    },
    {
      "_tool": "translateText",
      "text": "†input.text",
      "isEnglish": "†state.isEnglish",
      "_outputPath": "†state.translatedText"
    }
  ],
  "output": null
}
```

:::
::::

Предоставляя `схему`, вызывающая сторона даёт LLM чёткий чертёж для потока данных. LLM не нужно угадывать имена переменных или последовательность; она просто заполняет предопределённые ячейки, что приводит к более надёжному и предсказуемому `Плану`.

:::::

Этот итеративный цикл планирования и выполнения является ядром :term[Процесса]{href="./203_idea_process.md"}. Он представляет собой самодостаточный снимок рабочего процесса, фиксирующий доступные :term[Инструменты]{canonical="Tool"}, текущее :term[Состояние]{canonical="State"} и сам :term[План]{canonical="Plan"}.

## От единого плана к многоразовым рабочим процессам

Сообщение :term[План]{canonical="Plan"} определяет последовательность действий для конкретной задачи. Чтобы сделать эти рабочие процессы по-настоящему мощными, нам нужен способ упаковывать их в многоразовые компоненты, которые можно вызывать из других :term[Планов]{canonical="Plan"}.

Протокол для такого параллельного выполнения описан в :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}.
