# 011: Агент/План

> [!DEFINITION] [План](./000_glossary.md)
> Это специальное сообщение, которое несёт в себе схему действий (:term[Вызовов Инструментов]{canonical="Tool Call"}), похожую на карту сокровищ. Эта карта — стратегия агента. Он передаёт её между шагами, чтобы не сбиться с пути и подстраиваться под ситуацию.

> Sidenote:
> - Требуется:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
>   - :term[009: Агент/Состояние]{href="./009_agent_state.md"}
>   - :term[012: Агент/Экземплирование]{href="./013_agent_instancing.md"}

Сообщение с :term[Планом]{canonical="Plan"} — это ключ к тому, чтобы агент мог действовать шаг за шагом. Когда нейросеть получает текущий :term[План]{canonical="Plan"} вместе с живым объектом :term[Состояния]{canonical="State"}, она точно понимает, на каком этапе работы находится. Это знание о ситуации и позволяет агенту быть по-настоящему гибким. Он может следовать существующему плану, придумывать новые :term[Вызовы Инструментов]{canonical="Tool Call"}, чтобы его расширить, или вовсе отбросить старый план и составить новый, если что-то пошло не так. Это создаёт очень гибкую модель работы: от строгого следования инструкции до свободного исследования.

## Как формируется План

Связи в этой «карте» создаются не с помощью стрелок, а через простое и умное правило обмена данными через объект :term[Состояния]{canonical="State"}.

- **Узлы (:term[Вызовы Инструментов]{canonical="Tool Call"}):** Каждый шаг в работе — это :term[Вызов Инструмента]{canonical="Tool Call"}, то есть команда выполнить какое-то действие.
- **Рёбра (Объект :term[Состояния]{canonical="State"}):** Связи между шагами создаются, когда один инструмент что-то записывает в объект :term[Состояния]{canonical="State"}, а другой оттуда это читает. Один :term[Инструмент]{canonical="Tool"} записывает свой результат по определённому адресу в :term[Состоянии]{canonical="State"}, используя специальное свойство `:term[Путь для Вывода]{canonical="Output Path"}`. Следующий :term[Инструмент]{canonical="Tool"} может использовать этот результат, просто указав тот же адрес с помощью **:term[Ссылки на Переменную]{canonical="Variable Reference"}**.

  > Sidenote:
  > - [008: Агент/Вывод](./008_agent_output.md)

Так устанавливается чёткая зависимость: второй :term[Вызов Инструмента]{canonical="Tool Call"} не может начаться, пока первый не закончит работу и не запишет результат в :term[Состояние]{canonical="State"}.

Например, :term[План]{canonical="Plan"} по получению профиля пользователя и его краткому пересказу будет состоять из двух :term[Вызовов Инструментов]{canonical="Tool Call"}:

:::div{.limited-width}

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

> Sidenote:
> ```mermaid
> graph TD
>     state_var{{"state.user.profile"}}
>
>     Call1["fetchUserProfile"]
>     Call2["summarizeProfile"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```

:::

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, создавая двухшаговый план. Эту связь можно представить в виде простой схемы.

## Содержание Плана: Схема Потока Данных

Содержимое сообщения с :term[Планом]{canonical="Plan"} — это граф потока данных. Эта структура используется, чтобы представить стратегию агента как последовательность связанных между собой :term[Вызовов Инструментов]{canonical="Tool Call"}. Представляя рабочий процесс в виде графа, система может чётко определить зависимости между шагами, где результат одного :term[Вызова Инструмента]{canonical="Tool Call"} становится входными данными для другого. Этот формат на основе графа предоставляет ясную, понятную для машины структуру, которую :term[Цикл Исполнения]{canonical="Execution Loop"} агента может интерпретировать и выполнить.

> Sidenote:
> :term[План]{canonical="Plan"} не ограничивается линейными последовательностями. Он может представлять сложные рабочие процессы с условной логикой, где путь выполнения зависит от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Узнать погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти фильм];
>     C -- state.suggestion --> E[Предложить вариант];
>     D -- state.suggestion --> E[Предложить вариант];
> ```

Структура графа не ограничивается только созданием исполняемых рабочих процессов. Агента можно попросить сгенерировать граф :term[Вызовов Инструментов]{canonical="Tool Call"}, который представляет что-то совсем другое — визуализацию социальной сети, рабочий процесс GitHub Actions или схему базы данных.

Очень важно отличать такие результаты от :term[Плана]{canonical="Plan"}. Хотя они используют ту же структуру графа, они не являются «планами» в архитектурном смысле, если только они не передаются в следующий :term[Запрос]{canonical="Request"} как контекстное сообщение :term[Плана]{canonical="Plan"} с намерением быть исполненными. Это различие помогает не путать генерацию представления существующей системы с созданием исполняемой стратегии.

Хотя содержимое :term[Плана]{canonical="Plan"} может быть мощным инструментом для мозгового штурма, обсуждения и «размышлений вслух», его основное применение в этой системе — определять исполняемые рабочие процессы. Для этой цели мы используем особый тип графа, называемый **Направленный Ациклический Граф (DAG)**, где каждый узел — это :term[Вызов Инструмента]{canonical="Tool Call"}.

У DAG есть несколько ключевых свойств, которые делают его идеальным для исполнения:

- **Граф:** «Граф» — это всё содержимое сообщения с :term[Планом]{canonical="Plan"}: совокупность всех :term[Вызовов Инструментов]{canonical="Tool Call"} (узлов) и зависимостей по данным, которые их соединяют (рёбер).
- **Направленный:** Связи односторонние и определяются потоком данных. Шаг, создающий данные, должен идти _перед_ шагом, который их использует.
- **Ациклический:** В рабочем процессе не может быть круговых зависимостей, что гарантирует наличие чёткого начала и конца. Это критически важная мера безопасности, чтобы нейросеть не создала процесс с бесконечным циклом. Система проверяет :term[План]{canonical="Plan"} на ацикличность перед исполнением.

> Sidenote:
> Чтобы реализовать циклические действия, вроде цикла «for», используется модель вложенного, делегированного исполнения. Внешний :term[План]{canonical="Plan"} управляет состоянием цикла (например, счётчиком итераций) и на каждой итерации вызывает подзапрос через :term[Делегата]{canonical="Delegate"}. Этот подзапрос содержит свой собственный, отдельный ациклический :term[План]{canonical="Plan"}, который выполняет логику для одной итерации. Это гарантирует, что циклы создаются явно и безопасно.

## Разделение Планирования и Исполнения

Самая мощная особенность этой архитектуры — полное разделение планирования и исполнения. Поскольку :term[План]{canonical="Plan"} — это просто декларативная структура данных, агент может сгенерировать весь граф :term[Вызовов Инструментов]{canonical="Tool Call"} _до того_, как будет запущен какой-либо код.

Нейросеть выступает в роли планировщика, собирая массив :term[Вызовов]{canonical="Call"}, который представляет задуманный рабочий процесс. Эту структуру данных затем можно:

- **Проверить:** Система может проверить граф на наличие циклических зависимостей или других структурных ошибок.
- **Сымитировать:** Можно провести «пробный запуск», чтобы предсказать поведение рабочего процесса.
- **Представить на утверждение:** :term[План]{canonical="Plan"} можно показать человеку для проверки, изменения или одобрения перед исполнением, создавая важный слой безопасности и сотрудничества.

Исполнением занимается :term[Цикл Исполнения]{canonical="Execution Loop"}, который интерпретирует сообщение с :term[Планом]{canonical="Plan"} и запускает :term[Вызовы Инструментов]{canonical="Tool Call"} в правильном порядке на основе их зависимостей, по ходу дела заполняя объект :term[Состояния]{canonical="State"}.

## План как Развивающаяся Стратегия

:term[План]{canonical="Plan"} не статичен; это живая стратегия, которую можно адаптировать на каждом шаге цикла исполнения. Важно понимать, что `План` — это не просто любой результат работы нейросети. Когда агент впервые генерирует набор :term[Вызовов Инструментов]{canonical="Tool Call"}, это всего лишь предлагаемая последовательность действий. Она становится настоящим :term[Планом]{canonical="Plan"} только тогда, когда передаётся как контекстное сообщение в _следующий_ запрос в цикле.

Этот цикл превращает одноразовый результат в постоянную стратегию:

- **:term[Контекст]{canonical="context"}** для запроса содержит объект :term[Состояния]{canonical="State"} и сообщение с :term[Планом]{canonical="Plan"} из предыдущего шага.
- **:term[Решение]{canonical="Solution"}**, сгенерированное нейросетью, содержит новый набор :term[Вызовов Инструментов]{canonical="Tool Call"}, который становится **новым :term[Планом]{canonical="Plan"}** для следующего шага.

Этот пошаговый процесс позволяет агенту быть одновременно и проактивным, и реактивным. Он может следовать существующему :term[Плану]{canonical="Plan"}, но также может изменять его в ответ на результаты предыдущего шага. Например, если :term[Вызов Инструмента]{canonical="Tool Call"} завершился неудачей, агент может сгенерировать новый :term[План]{canonical="Plan"}, включающий шаги по обработке ошибки. Это делает систему устойчивой и адаптивной.

:::::details{title="Пример: Планирование на один шаг вперёд"}

Этот пример показывает, как `План` задаёт основной «правильный путь», который направляет агента и не даёт ему отклониться от стандартной процедуры, даже если есть другие возможные действия.

**Ситуация:** Агенту службы поддержки нужно оформить возврат средств. Стандартная процедура, запущенная по просьбе пользователя, — сначала проверить историю платежей для получения контекста, а затем оформить возврат.

**1. Первоначальный Запрос**

Цикл начинается с запроса клиента. На основе этого `ввода` нейросеть формулирует стандартный двухэтапный `План` для обработки возврата. Это представляет собой идеальный, наиболее распространённый рабочий процесс.

::::columns
:::column{title="Контекст и Схема для Запроса"}

```json
// Agent.Request(config, schema, context)
{
  "schema": {
    "type": "object",
    "properties": {
      "calls": { "type": "array" },
      "output": {
        "type": "object",
        "nullable": true,
        "properties": {
          "confirmationId": { "type": "string" },
          "message": { "type": "string" }
        }
      }
    }
  },
  "context": [
    {
      "type": "input",
      "request": "Я бы хотел вернуть деньги за последний заказ.",
      "customerId": "cust_123",
      "amount": 50.0
    }
  ]
}
```

:::
:::column{title="`Решение` от нейросети"}

```json
{
  "calls": [
    {
      "_tool": "checkBillingHistory",
      "customerId": "†input.customerId"
    },
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": null
}
```

:::
::::

**2. Следующий Запрос в Цикле**

:term[Цикл Исполнения]{canonical="Execution Loop"} выполняет вызов `checkBillingHistory` и заполняет :term[Состояние]{canonical="State"}. История показывает некоторые сложности (например, предыдущий возвратный платёж). В этот момент агент без чётких указаний мог бы с большой вероятностью выбрать другой доступный инструмент, `escalateToSupervisor` (передать старшему).

Однако сообщение `План` в контексте обеспечивает необходимую структуру. Сопоставляя то, что он _знает_ (сложное `Состояние`), с тем, что он _должен делать_ (`План`), нейросеть понимает своё точное положение в рабочем процессе и придерживается «правильного пути».

::::columns
:::column{title="Контекст"}

```json
[
  {
    "type": "state",
    "billingHistory": {
      "orders": 5,
      "lastChargeback": "2025-09-10"
    }
  },
  {
    "type": "plan",
    "plan": [
      {
        "_tool": "checkBillingHistory",
        "customerId": "†input.customerId"
      },
      {
        "_tool": "issueRefund",
        "customerId": "†input.customerId",
        "amount": "†input.amount"
      }
    ]
  }
]
```

:::
:::column{title="`Решение` от нейросети"}

```json
{
  "calls": [
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": {
    "confirmationId": "refund_xyz789",
    "message": "Возврат был успешно обработан."
  }
}
```

:::
::::

`План` обеспечивает последовательность действий, предотвращая преждевременную эскалацию и удерживая агента на намеченном пути.

:::::

:::::details{title="Пример: Корректировка Плана"}

Этот пример показывает, как агент может изменить существующий :term[План]{canonical="Plan"} в ответ на новую информацию, выбрав другой инструмент.

::::columns
:::column{title="Контекст"}

Агенту даётся существующий «правильный путь» в виде `Плана` и новые `Входные данные` от пользователя, которые вводят новое ограничение.

```ts
[
  { type: 'tool', tool: Tool.bookFlight },
  { type: 'tool', tool: Tool.bookHotel },
  { type: 'tool', tool: Tool.findPetFriendlyHotel },
  {
    type: 'plan',
    plan: [
      {
        _tool: 'bookFlight',
        destination: '†input.destination',
      },
      {
        _tool: 'bookHotel',
        destination: '†input.destination',
      },
    ],
  },
  {
    type: 'input',
    destination: 'Berlin',
    instruction: "Кстати, я поеду со своей собакой.",
  },
];
```

:::
:::column{title="`Решение` от нейросети"}

Нейросеть понимает, что первоначальный план больше не подходит. Она отбрасывает старый план и генерирует новый, заменяя `bookHotel` более специализированным инструментом.

```json
{
  "calls": [
    {
      "_tool": "bookFlight",
      "destination": "†input.destination"
    },
    {
      "_tool": "findPetFriendlyHotel",
      "destination": "†input.destination"
    }
  ],
  "output": null
}
```

:::
::::

Агент не просто меняет параметр; он коренным образом меняет свою стратегию, выбирая более подходящий инструмент (`findPetFriendlyHotel`) на основе новых требований. Этот новый набор `Вызовов Инструментов` становится `Планом` для следующего шага в :term[Цикле Исполнения]{canonical="Execution Loop"}.

:::::

:::::details{title="Пример: Обработка Неудачи"}

Этот пример показывает, как агент может отклониться от «правильного пути» :term[Плана]{canonical="Plan"}, когда сталкивается с неожиданным сбоем. Процесс показан в два этапа: первоначальный план «правильного пути» и перепланирование, которое происходит после сбоя инструмента.

**1. Первоначальный План**

Агенту даётся набор инструментов и ввод от пользователя. Он создаёт оптимистичный двухэтапный план «правильного пути», который не учитывает возможность сбоя.

::::columns
:::column{title="Начальный Контекст"}

```ts
Agent.Request(config, {
  schema: {
    type: 'object',
    properties: {
      calls: { type: 'array' },
      output: {
        type: 'object',
        nullable: true,
        properties: {
          status: {
            type: 'string',
            enum: ['Success', 'Failed'],
          },
        },
      },
    },
  },
  context: [
    { type: 'tool', tool: 'Tool.processPayment' },
    { type: 'tool', tool: 'Tool.confirmOrder' },
    { type: 'tool', tool: 'Tool.reportFailure' },
    { type: 'input', amount: 50.0 },
  ],
});
```

:::
:::column{title="Начальное Решение"}

```json
{
  "calls": [
    {
      "_tool": "processPayment",
      "amount": "†input.amount",
      "_outputPath": "†state.receipt || †state.error"
    },
    {
      "_tool": "confirmOrder",
      "receipt": "†state.receipt"
    }
  ],
  "output": null
}
```

:::
::::

**2. Сбой и Перепланирование**

:term[Цикл Исполнения]{canonical="Execution Loop"} пытается выполнить `processPayment`, но инструмент даёт сбой. Движок записывает информацию в `†state.error`. На следующей итерации нейросеть видит это новое состояние ошибки вместе с исходным (теперь устаревшим) планом и генерирует новое решение для обработки сбоя.

::::columns
:::column{title="Контекст для Следующего Запроса"}

```json
[
  {
    "type": "state",
    "error": { "code": "card_declined", "message": "Ваша карта отклонена." }
  },
  // Оригинальный, теперь устаревший план всё ещё в контексте
  {
    "type": "plan",
    "plan": [
      { "_tool": "processPayment", "_outputPath": "†state.receipt || †state.error" },
      { "_tool": "confirmOrder", "receipt": "†state.receipt" }
    ]
  }
]
```

:::
:::column{title="Новое Решение (Перепланированное)"}

```json
{
  "calls": [
    {
      "_tool": "reportFailure",
      "error": "†state.error"
    }
  ],
  "output": { "status": "Failed" }
}
```

:::
::::

Агент распознал `ошибку` в `Состоянии`, проигнорировал устаревший «правильный путь» `Плана` и сгенерировал новый, одношаговый план для `сообщения о сбое`. Это демонстрирует способность агента реагировать на неожиданные результаты.

:::::

:::::details{title="Пример: Планирование по Схеме"}

Этот пример показывает, как предоставление `схемы` для объекта :term[Состояния]{canonical="State"} действует как чертёж, направляя нейросеть к созданию структурно правильного :term[Плана]{canonical="Plan"}.

::::columns
:::column{title="Контекст со Схемой Состояния"}

Вызывающий предоставляет `Входные данные` и сообщение `Состояние`, которое содержит только `схему`. Эта схема определяет предполагаемый поток данных, указывая «переменные», которые должен использовать план.

```json
[
  { "type": "tool", "tool": "Tool.detectLanguage" },
  { "type": "tool", "tool": "Tool.isEnglish" },
  { "type": "tool", "tool": "Tool.translateText" },
  {
    "type": "input",
    "text": "Bonjour le monde"
  },
  {
    "type": "state",
    "schema": {
      "type": "object",
      "properties": {
        "language": { "type": "string" },
        "isEnglish": { "type": "boolean" },
        "translatedText": { "type": "string" }
      }
    }
  }
]
```

:::
:::column{title="`Решение` от нейросети"}

Нейросеть использует схему `Состояния` как руководство для построения правильного плана, корректно связывая `:term[Путь для Вывода]{canonical="Output Path"}` одного инструмента с входом другого.

```json
{
  "calls": [
    {
      "_tool": "detectLanguage",
      "text": "†input.text",
      // Нейросеть знает, что нужно использовать этот путь из схемы.
      "_outputPath": "†state.language"
    },
    {
      "_tool": "isEnglish",
      // Она правильно ссылается на вывод предыдущего шага.
      "language": "†state.language",
      "_outputPath": "†state.isEnglish"
    },
    {
      "_tool": "translateText",
      "text": "†input.text",
      "isEnglish": "†state.isEnglish",
      "_outputPath": "†state.translatedText"
    }
  ],
  "output": null
}
```

:::
::::

Предоставляя `схему`, вызывающий даёт нейросети чёткий чертёж потока данных. Нейросети не нужно угадывать имена переменных или последовательность; она просто заполняет предопределённые ячейки, что приводит к более надёжному и предсказуемому `Плану`.

:::::

Этот итеративный цикл планирования и исполнения является ядром :term[Процесса]{href="./203_idea_process.md"}. Это автономный снимок рабочего процесса, фиксирующий доступные :term[Инструменты]{canonical="Tool"}, текущее :term[Состояние]{canonical="State"} и сам :term[План]{canonical="Plan"}.

## От Единичного Плана к Многоразовым Процессам

Сообщение с :term[Планом]{canonical="Plan"} определяет последовательность действий для конкретной задачи. Чтобы сделать эти рабочие процессы по-настоящему мощными, нам нужен способ упаковывать их в многоразовые компоненты, которые можно вызывать из других :term[Планов]{canonical="Plan"}.

Протокол для такого параллельного выполнения описан в :term[012: Агент/Экземплирование]{href="./013_agent_instancing.md"}.
