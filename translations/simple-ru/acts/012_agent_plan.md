# 012: Агент/План

> **План:** Это как карта или схема, которая показывает шаги для выполнения какой-то задачи. Эта карта нарисована в виде графа — как схема метро, где станции — это действия, а линии — связи между ними. План может быть чем угодно: от списка команд для компьютера до схемы идей для школьного проекта. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [010: Агент/Состояние](./010_agent_state.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ рассказывает о **Протоколе Плана**. Он помогает агенту (нашей умной программе) перейти от простых реакций «вижу-делаю» к сложным задачам, состоящим из многих шагов. `План` — это как список дел для агента, где каждое дело — это `Вызов Инструмента`. Но это не строгий список, а гибкая схема. Связи между делами появляются сами собой, когда одно дело что-то записывает в общую «память» (`Состояние`), а другое оттуда читает.

Благодаря этому, `Состояние` (общая память) превращается в доску, на которой агент рисует свой план действий, чтобы достичь цели.

## Что такое План?

`План` — это универсальный и мощный инструмент, чтобы думать схемами. Он помогает представить в виде понятной структуры любую систему связанных идей — от общей задумки до детального технического чертежа. Такая схема-граф — это очень эффективный способ «упаковать» много сложной информации так, чтобы большие языковые модели (ИИ) поняли её гораздо легче, чем длинный текст.

> Sidenote:
> `План` не ограничен простыми последовательностями. Он может представлять сложные процессы с условиями, где дальнейшие шаги зависят от результата предыдущего:
>
> ```mermaid
> graph TD
>     A[Узнать погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти кино];
>     C -- state.suggestion --> E[Предложить вариант];
>     D -- state.suggestion --> E[Предложить вариант];
> ```

Протокол `Плана` нужен не только для выполнения задач. С его помощью можно создавать любые схемы в ответ на запрос пользователя. Например, один `Инструмент` может взять таблицу контактов и сделать `План`, который покажет, кто с кем дружит. Другой может создать `План`, изображающий полную схему работы для GitHub или чертёж для новой базы данных.

Хотя `План` отлично подходит для мозгового штурма и «размышлений вслух», его главное применение — это определение последовательности действий, которую можно выполнить. Для этого мы используем особый вид графа, который называется **Направленный Ациклический Граф (DAG)**. Каждый его узел — это `Вызов Инструмента`.

У такого графа есть несколько ключевых свойств, которые делают его идеальным для исполнения:

- **Граф:** «Граф» — это и есть весь `План`: набор всех `Вызовов Инструментов` (узлы) и потоки данных, которые их соединяют (рёбра).
- **Направленный:** Связи идут только в одну сторону, как по реке. Шаг, который создаёт данные, всегда должен идти *перед* шагом, который их использует.
- **Ациклический:** В плане не может быть замкнутых кругов, как в гонке по кругу. У него всегда есть чёткое начало и конец.

## Как формируется План

Связи в схеме создаются не стрелочками, а простым и элегантным способом — через общую «память», объект `Состояние`.

- **Узлы (`Вызовы Инструментов`):** Каждый шаг в работе — это `Вызов Инструмента`, то есть какое-то действие.
- **Рёбра (Объект `Состояние`):** Связи между шагами появляются, когда один инструмент записывает данные в `Состояние`, а другой их оттуда читает. Один `Инструмент` записывает свой результат по определённому адресу в `Состоянии` с помощью мета-свойства `_outputPath`. Следующий `Инструмент` может использовать этот результат, просто сославшись на тот же адрес с помощью **ссылки на переменную**.

Так устанавливается чёткая зависимость: второй `Вызов Инструмента` не может начаться, пока первый не закончит свою работу и не запишет результат в `Состояние`.

Например, `План` для получения и анализа профиля пользователя будет состоять из двух `Вызовов Инструментов`:

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, создавая план из двух шагов. Эту связь можно представить в виде простой схемы:

> Sidenote:
> ```mermaid
> graph TD
>     state_var("state.user.profile")
>
>     Call1["fetchUserProfile"]
>     Call2["summarizeProfile"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```
>
> - [010: Агент/Состояние](./010_agent_state.md)

## Разделение планирования и исполнения

Самая сильная сторона этой системы — полное разделение составления плана и его выполнения. Поскольку `План` — это просто описание данных (инструкция), агент может составить всю схему `Вызовов Инструментов` *до того*, как начнёт выполняться хоть какой-то код.

ИИ (LLM) выступает в роли планировщика, собирая список `Вызовов`, который представляет собой задуманный порядок действий. Эту инструкцию можно:

- **Проверить:** Система может проверить схему на ошибки, например, на наличие замкнутых кругов.
- **Сымитировать:** Можно сделать «пробный запуск», чтобы предсказать, как поведёт себя план.
- **Показать человеку:** `План` можно показать пользователю для проверки, изменения или одобрения перед запуском. Это создаёт важный уровень безопасности и совместной работы.

За выполнение отвечает **[Цикл Агента](./005_agent_loop.md)**, который читает `План` и запускает `Вызовы Инструментов` в правильном порядке, заполняя `Состояние` по ходу дела.

## План как развивающаяся стратегия

`План` — это не что-то застывшее; это живая стратегия, которую можно менять на каждом шаге. Обычно `План` сам является частью информации, которую получает ИИ на каждом витке цикла.

- **`context` (контекст)** содержит `Состояние` и `План` с предыдущего шага.
- **`solution` (решение)**, которое генерирует ИИ, — это **новый `План`** на текущий шаг.

Этот повторяющийся процесс позволяет агенту быть одновременно и дальновидным, и быстрым в реакциях. Он может следовать существующему `Плану`, но также может изменить его в ответ на результаты предыдущего шага. Например, если `Вызов Инструмента` не удался, агент может создать новый `План` со шагами для обработки ошибки. Это делает систему надёжной и гибкой.

> [!HEADSUP] Внимание
> Этот цикл планирования и исполнения — основа **[203: Идеи/Процесса](./203_idea_process.md)**. Это самодостаточный снимок рабочего процесса, который включает в себя доступные `Инструменты`, текущее `Состояние` и сам `План`.

## Из чего состоит

Протокол Плана — это дирижёр высокого уровня, который управляет несколькими другими важными протоколами.

- **Вызов:** `Вызовы Инструментов` — это кирпичики, из которых строится `План`. Свойство `_outputPath` в `Вызове` позволяет ему участвовать в `Плане`, изменяя общее `Состояние`.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Состояние:** Объект `Состояние` — это холст, на котором рисуется `План`. Он служит «проводами», которые соединяют независимые `Вызовы Инструментов` в единую рабочую схему.

  > Sidenote:
  > - [010: Агент/Состояние](./010_agent_state.md)

- **Цикл:** `Цикл` выполнения — это двигатель, который оживляет `План`. Он обрабатывает `Вызовы` из `Плана`, управляет потоком данных через `Состояние` и позволяет постоянно перестраивать план, делая систему динамичной.

  > Sidenote:
  > - [005: Агент/Цикл](./005_agent_loop.md)

- **Инстансинг:** Протокол `Плана` полностью совместим с `Инстансингом` (созданием множества экземпляров). Один `План` может служить шаблоном для массовой операции, применяясь к целому списку объектов `Состояния`. Система `Инстансинга` гарантирует, что у каждого параллельного выполнения будет своя изолированная «память», что позволяет безопасно и стабильно выполнять сложный процесс сразу для множества элементов.

  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

## От Плана к Процессу

`План` содержит конкретные, тактические шаги для достижения цели. Это стратегия агента, записанная в виде схемы `Вызовов`. Этот `План` является центральной частью **[Идеи-Процесса](./203_idea_process.md)**, которая представляет собой полный, самодостаточный и запоминающий состояние рабочий процесс. `План` — это «как», а `Идея-Процесс` — это полная запись о том, «что, почему и как».
