# 012: Агент/План

> **План:** Это как подробная карта или рецепт, который показывает, как выполнить задачу, какая у тебя идея или как устроена какая-то система. Эта карта состоит из соединённых между собой шагов. Её можно использовать для разных целей: чтобы составить последовательность действий для компьютера, нарисовать схему для размышлений или даже создать чертёж для базы данных. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [010: Агент/Состояние](./010_agent_state.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **Протокол Плана**. Он помогает искусственному интеллекту (ИИ) переходить от простых, одномоментных реакций к выполнению сложных задач, состоящих из множества шагов.

`План` — это структура данных, обычно список из `Вызовов Инструментов`, который описывает последовательность действий. Это не жёсткий сценарий, а скорее гибкая схема, похожая на паутину. Связи между шагами появляются сами собой, когда один `Вызов` записывает результат в общую «записную книжку» под названием `Состояние`, а другой `Вызов` читает этот результат.

Благодаря этому подходу, `Состояние` становится своего рода холстом для планирования. ИИ может создавать и выполнять на нём сложные последовательности действий, чтобы достичь своей цели.

## Что такое План?

`План` — это простой и очень мощный способ «думать» с помощью схем. Он позволяет представить в виде связанных точек любую систему идей: от общего замысла до детального технического чертежа. Такая структура в виде схемы — очень эффективный способ сжать сложную информацию в формат, который большие языковые модели (ИИ) понимают гораздо легче, чем длинные тексты.

> Sidenote:
> `План` не обязан быть простой последовательностью. Он может описывать сложные процессы с условиями, где дальнейшие действия зависят от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Узнать погоду] --> B{Солнечно?};
>     B -- Да --> C[Найти парк];
>     B -- Нет --> D[Найти фильм];
>     C --> E[Предложить вариант];
>     D --> E[Предложить вариант];
> ```

Протокол `Плана` нужен не только для выполнения задач. С его помощью можно создавать любые схемы в ответ на просьбу пользователя. Например, один `Инструмент` может взять таблицу с именами друзей и построить `План` в виде схемы, показывающей, кто с кем дружит. Другой — создать `План`, который будет целым рабочим процессом для программистов, или чертёж для новой базы данных.

Хотя `План` — отличный инструмент для размышлений и обсуждений, его главное применение в нашей системе — это создание последовательности действий, которую компьютер может выполнить. Для этого мы используем особый вид схемы — **Направленный Ациклический Граф (DAG)**. В нём каждая точка — это `Вызов Инструмента`.

У такой схемы есть несколько ключевых свойств, которые делают её идеальной для выполнения задач:

- **Граф (Схема):** Это весь `План` целиком — все `Вызовы Инструментов` (точки) и данные, которые их связывают (линии).
- **Направленный:** Связи идут только в одну сторону. Шаг, который создаёт какие-то данные, всегда должен идти _перед_ шагом, который эти данные использует.
- **Ациклический (Без циклов):** В схеме не может быть замкнутых кругов, где одно действие зависит от другого, которое, в свою очередь, зависит от первого. Это гарантирует, что у процесса всегда есть начало и конец.

## Как создаётся План

Связи в схеме создаются не с помощью явных указателей, а очень простым и умным способом — через общую «записную книжку», объект `Состояние`.

- **Точки (`Вызовы Инструментов`):** Каждый шаг в процессе — это `Вызов Инструмента`, то есть какое-то действие, которое нужно выполнить.
- **Линии (Объект `Состояние`):** Связи между шагами создаются, когда один инструмент записывает что-то в `Состояние`, а другой читает оттуда. Один `Инструмент` записывает свой результат по определённому адресу в `Состоянии` с помощью специального свойства `_outputPath`. Следующий `Инструмент` может использовать этот результат, просто сославшись на тот же адрес.

Так появляется чёткая зависимость: второй `Вызов Инструмента` не может начаться, пока первый не закончит свою работу и не запишет результат в `Состояние`.

Например, `План` для того, чтобы найти профиль пользователя и затем кратко его пересказать, будет состоять из двух `Вызовов Инструментов`:

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

Здесь вызов `summarizeProfile` зависит от результата работы `fetchUserProfile`, создавая план из двух шагов. Эту связь можно представить в виде простой схемы:

> Sidenote:
>
> ```mermaid
> graph TD
>     state_var("user.profile")
>
>     Call1["Вызов А<br/>_outputPath: '†state.user.profile'"]
>     Call2["Вызов Б<br/>userId: '†state.user.profile'"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```
>
> - [010: Агент/Состояние](./010_agent_state.md)

## Разделение планирования и выполнения

Самая сильная сторона этой системы — полное разделение планирования и выполнения. Поскольку `План` — это просто описание действий (данные), а не сама программа, ИИ может составить всю схему `Вызовов Инструментов` _до того_, как начнётся какая-либо работа.

ИИ выступает в роли планировщика: он собирает список `Вызовов`, который представляет собой задуманный процесс. Эту структуру данных потом можно:

- **Проверить:** Система может проверить схему на наличие ошибок, например, нет ли в ней замкнутых кругов.
- **Просимулировать:** Можно сделать «пробный запуск», чтобы предсказать, как поведёт себя процесс.
- **Показать человеку для одобрения:** `План` можно показать пользователю, чтобы он его проверил, изменил или одобрил перед запуском. Это создаёт важный слой безопасности и позволяет работать совместно.

За выполнение отвечает **[Цикл Агента](./005_agent_loop.md)**. Он читает `План` и запускает `Вызовы Инструментов` в правильном порядке, основываясь на их зависимостях, и по ходу дела заполняет `Состояние` результатами.

## План как развивающаяся стратегия

`План` не статичен. Это живая стратегия, которая может меняться на каждом шаге рабочего цикла. В обычном процессе сам `План` является частью информации, которую ИИ получает на каждом шаге.

- **`context` (Контекст)** содержит `Состояние` и `План` с предыдущего шага.
- **`solution` (Решение)**, которое генерирует ИИ, — это **новый `План`** на следующий шаг.

Этот повторяющийся процесс позволяет ИИ быть одновременно и дальновидным, и быстрым в реакции. Он может следовать существующему `Плану`, но также может изменить его, если результаты предыдущего шага оказались неожиданными. Например, если `Вызов Инструмента` не сработал, ИИ может создать новый `План`, в котором будут шаги для исправления ошибки. Это делает систему устойчивой и гибкой.

> [!HEADSUP] Heads up
> Этот цикл планирования и выполнения — сердце **[Идеи-Процесса](./203_idea_process.md)**. `Идея-Процесс` — это полный «снимок» рабочего процесса, который содержит доступные `Инструменты`, текущее `Состояние` и сам `План`.

## Из чего состоит

Протокол Плана — это как дирижёр, который управляет несколькими другими важными протоколами.

- **Вызов:** `Вызовы Инструментов` — это кирпичики, из которых строится любой `План`. Именно свойство `_outputPath` в `Вызове` позволяет ему участвовать в `Плане`, изменяя общее `Состояние`.

  > Sidenote:
  >
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Состояние:** Объект `Состояние` — это холст, на котором рисуется `План`. Он как провода, которые соединяют отдельные `Вызовы Инструментов` в единый рабочий процесс.

  > Sidenote:
  >
  > - [010: Агент/Состояние](./010_agent_state.md)

- **Цикл:** `Цикл` выполнения — это двигатель, который оживляет `План`. Он обрабатывает `Вызовы` из `Плана`, управляет потоком данных через `Состояние` и позволяет постоянно перепланировать действия, делая систему живой.

  > Sidenote:
  >
  > - [005: Агент/Цикл](./005_agent_loop.md)

- **Инстансинг:** Протокол `Плана` полностью совместим с `Инстансингом`. Один и тот же `План` можно использовать как шаблон для обработки множества элементов сразу, применяя его к целой пачке объектов `Состояния`. Система `Инстансинга` следит за тем, чтобы у каждого параллельного процесса была своя изолированная «записная книжка» (`Состояние`). Это позволяет безопасно и одинаково выполнять сложный процесс для множества элементов одновременно.

  > Sidenote:
  >
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

## От Плана к Процессу

`План` описывает конкретные шаги для достижения цели. Это стратегия ИИ, записанная в виде схемы `Вызовов`. Этот `План` является центральной частью **[Идеи-Процесса](./203_idea_process.md)**, которая представляет собой полный, самостоятельный рабочий процесс со своим состоянием. `План` — это ответ на вопрос «как?», а `Идея-Процесс` — это полная запись о том, «что, почему и как» делается.
