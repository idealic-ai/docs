# 006: Агент/Данные

> [!DEFINITION] Сообщение с данными
> Это «долгоживущее» сообщение в памяти агента, в котором есть сами `данные` (информация) и, необязательно, `схема` (объяснение, что эти данные значат). Оно не исчезает после одного шага работы, а остаётся, чтобы у агента всегда была под рукой стабильная и понятная информация.

> Sidenote:
> - Требует:
>   - [001: Агент/Запрос](./001_agent_request.md)
> - Делает возможным:
>   - [007: Агент/Ввод](./007_agent_input.md)
>   - [009: Агент/Состояние](./009_agent_state.md)
> - Дополняется:
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [011: Агент/Экземплирование](./011_agent_instancing.md)

Этот документ рассказывает о «Протоколе Данных» — это как базовый язык, на котором система передаёт информацию в понятной и структурированной форме. Он как фундамент, который используют другие части системы, например, «Ввод» и «Состояние», чтобы управлять информацией в «контексте» (рабочей памяти) агента. В отличие от обычных сообщений, которые появляются и тут же исчезают, сообщения с данными — постоянные. Они сохраняются между шагами работы агента, создавая надёжную основу для выполнения сложных задач, состоящих из нескольких этапов.

## Сообщение с данными

> Sidenote:
> - [001: Агент/Запрос](./001_agent_request.md)

Сообщение с данными — это простой, но очень мощный способ добавить в «Запрос» понятную информацию. Представь, что это контейнер со следующими свойствами:

- **`data`**: Любые данные в формате JSON (например, текст, число, объект, список), то есть само содержимое.
- **`schema`**: Необязательная «инструкция» (схема JSON), которая объясняет, что из себя представляют `данные` и какой у них смысл.
- **`kind`**: Необязательная метка (например, `"state"` или `"input"`), которая говорит о роли этого сообщения. Это помогает и системе, и ИИ-модели различать разные типы данных в общей памяти.

Когда мы передаём данные вместе со схемой, мы делаем их понятными для машины. Схема — это как чертёж, который объясняет ИИ-модели, что означает каждое поле, какого оно типа и какие у него правила. Это не только направляет «мысли» модели, но и служит документацией для людей, показывая, что можно изменить или настроить.

## Слияние и идентичность

Протокол устроен так, чтобы работать с несколькими сообщениями с данными в одном `контексте`. Если система видит, что несколько сообщений относятся к одной и той же сущности, она объединяет их в одно целое. Это очень удобно, например, когда нужно применить несколько небольших изменений к состоянию.

То, к какой сущности относится сообщение, определяется в основном его меткой `kind`. Например, все сообщения с `kind: "state"` считаются частью одной и той же сущности. Эту идентичность можно уточнить с помощью других протоколов, в первую очередь «Экземплирования», которое позволяет запускать несколько процессов параллельно в разных контекстах.

> Sidenote:
> - [011: Агент/Экземплирование](./011_agent_instancing.md)

Когда в памяти оказывается несколько объединяемых сообщений (например, несколько объектов `state`, каждый из которых — небольшое изменение), система может поступить двумя способами. Во-первых, «Цикл выполнения» агента может сам сложить их в один целый объект состояния, прежде чем показать ИИ. Это упрощает задачу для модели. Во-вторых, ИИ-модель может сама «мысленно» объединить эту информацию в своём скрытом пространстве, понимая, что разные сообщения — это просто части одного целого.

:::::details{title="Пример того, как ИИ-модель видит сообщения с данными" open=false}

- Сообщение `text` передаётся как есть.
- Сообщения `data` объединяются и превращаются в одно сообщение `text`.

::::columns
:::column{title="Как выглядит код"}

```typescript
Agent.Request(config, schema, [
  {
    type: 'text',
    text: "Update the user's city to Austin",
  },

  // Схема передаётся, чтобы ИИ понял смысл данных
  {
    type: 'data',
    kind: 'user',
    description: 'Represents the current user.',
    data: { name: 'John Doe' },
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' },
        city: { type: 'string' },
      },
    },
  },

  // Второе сообщение `user` сольётся с первым
  {
    type: 'data',
    kind: 'user',
    data: { age: 30 },
  },
]);
```

:::
:::column{title="Что видит ИИ-модель"}

```typescript
[
  {
    role: 'user',
    content: {
      type: 'text',
      text: "Update the user's city to Austin",
    },
  },
  {
    role: 'user',
    content: {
      type: 'text',
      text: `
        ## Data: ¶user
        {
          "name": "John Doe",
          "age": 30
        }
        Represents the current user.
        Schema for ¶user:
        {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "age": { "type": "number" },
            "city": { "type": "string" }
          }
        }`,
    },
  },
];
```

:::
::::
:::::

## Взаимодействие с другими протоколами

Протокол Данных — это базовый строительный блок, который используется и расширяется другими, более сложными протоколами.

- **«Цикл»:** «Цикл выполнения» использует сообщения с данными для сохранения непрерывности работы. Сообщение «Состояние», которое является особым видом сообщения с данными, — это главный способ хранить информацию между шагами «Цикла».

  > Sidenote:
  > - [005: Агент/Цикл](./005_agent_loop.md)

- **«Состояние»:** Протокол «Состояние» использует сообщение с данными для представления постоянной, меняющейся памяти рабочего процесса. `Схема` этого сообщения определяет структуру объекта состояния, включая то, какие свойства и «Переменные» в нём доступны.

  > Sidenote:
  > - [010: Агент/Состояние](./010_agent_state.md)

- **«Экземплирование»:** Все сообщения с данными подчиняются правилам «Экземплирования». Свойство `_instance` работает как ключ, который привязывает данные к определённому потоку выполнения в рамках большой задачи. Сообщения с данными с разными `_instance` не будут объединяться, что обеспечивает изоляцию данных между параллельными процессами.

  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md)

- **«Ввод»:** Протокол «Ввод» использует сообщение с данными, чтобы официально объявить, какие параметры принимает «Запрос». Именно этот механизм превращает статичный «Запрос» в многоразовый компонент, похожий на функцию.

  > Sidenote:
  > - [007: Агент/Ввод](./007_agent_input.md)

## От данных к динамическим связям

Протокол Данных предоставляет нам универсальный контейнер для структурированной информации. Заложив этот фундамент, мы можем перейти к изучению того, как динамически связывать эти кусочки данных между собой. Это важнейший шаг, который позволяет агенту создавать рабочие процессы, где результат одного шага становится входными данными для другого.

Следующий документ, [008: Агент/Переменные](./008_agent_variables.md), описывает протокол, который делает такие динамические связи возможными.
