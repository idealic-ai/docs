# 006: Агент/Данные

> [!DEFINITION] Сообщение с данными
> Это сообщение-«записка», которое не исчезает и хранится в памяти агента. Внутри у него есть сами `данные` (data) и, по желанию, их описание или «инструкция» (`схема` - schema). Агент держит эту «записку» под рукой, пока выполняет свою задачу, чтобы у него всегда был понятный и стабильный набор информации.



Этот документ рассказывает о **«Правиле Данных»** — простом, но важном способе передавать информацию так, чтобы она сама себя объясняла. Это как фундамент, на котором строятся другие части системы, например [«Ввод» (Input)](./007_agent_input.md) и [«Состояние» (State)](./009_agent_state.md). Они используют это правило, чтобы управлять информацией в «рабочей области» (`context`) агента.

В отличие от сообщений-однодневок, которые быстро исчезают, «Сообщения с данными» остаются надолго. Они сохраняются между шагами работы агента, создавая надёжную «память» для выполнения сложных задач.

## Сообщение с данными



«Сообщение с данными» — это простой, но очень полезный способ добавить структурированную информацию к [«Запросу» (Request)](./001_agent_request.md). Представь, что это контейнер с тремя отсеками:

*   `data`: Здесь лежит сама информация — что угодно, записанное в формате JSON (например, текст, число, список или целый объект).
*   `schema`: Это необязательная «инструкция по применению» для данных. Она объясняет, что именно лежит в отсеке `data`, как оно устроено и какой смысл имеет. Это как этикетка на коробке, которая описывает её содержимое.
*   `kind`: Это необязательная «бирка», которая говорит, для чего эти данные нужны (например, `"state"` для хранения состояния или `"input"` для входных данных). Так и система, и ИИ понимают, какая у данных роль.

Когда у данных есть такая «инструкция» (`schema`), они становятся понятными для машины. ИИ может прочитать её и точно понять, что означает каждое поле и как с ним работать. Это не только помогает ИИ думать, но и служит документацией для людей, показывая, что можно менять или настраивать.

## Объединение данных

Это правило позволяет хранить в «рабочей области» (`context`) сразу несколько «Сообщений с данными». Если система видит, что несколько сообщений относятся к одной и той же сущности, она объединяет их в одно целое. Это удобно, например, когда нужно применить несколько небольших изменений к одному большому состоянию.

К какой сущности относится сообщение, определяется в первую очередь по его «бирке» (`kind`). Например, все сообщения с `kind: "state"` считаются частью одного большого «состояния». Эту принадлежность можно уточнить с помощью других правил, в первую очередь [011: Агент/Инстансинг](./011_agent_instancing.md), которое позволяет агенту работать над несколькими задачами одновременно, но в разных, изолированных друг от друга «комнатах».



Когда появляется несколько сообщений, которые нужно объединить (например, несколько правок для `state`), система может поступить двумя способами. Первый — самому заранее «склеить» все части в единое целое, прежде чем показывать ИИ. Это уменьшает путаницу. Второй — отдать всё как есть ИИ, который сам мысленно их объединит, поняв, что все эти кусочки описывают одну и ту же вещь с разных сторон.

## Как это работает с другими правилами

«Правило Данных» — это база, на основе которой работают другие, более сложные правила.

*   **Цикл (Loop):** Рабочий цикл агента опирается на «Сообщения с данными», чтобы не терять информацию между шагами. Сообщение «Состояние» (State) — это особый вид «Сообщения с данными», который отвечает за «память» агента.



*   **Состояние (State):** Правило «Состояния» использует «Сообщение с данными» для хранения информации, которая меняется в процессе работы. Инструкция `schema` в этом сообщении описывает, какие именно данные могут храниться в этой «памяти».



*   **Инстансинг (Instancing):** Это правило применяется ко всем «Сообщениям с данными». Специальное свойство `_instance` работает как ключ от комнаты, привязывая данные к конкретной задаче, если агент выполняет несколько дел параллельно. Данные с разными ключами `_instance` никогда не смешаются, что обеспечивает порядок.



*   **Ввод (Input):** Правило «Ввода» использует «Сообщение с данными», чтобы официально объявить, какую информацию ожидает получить «Запрос». Это превращает обычный статический «Запрос» в многоразовый инструмент, похожий на функцию в программировании.



## От данных к динамическим связям

«Правило Данных» даёт нам универсальный «контейнер» для хранения информации. Теперь, когда у нас есть этот фундамент, мы можем научиться соединять эти кусочки данных между собой. Это важнейший шаг, который позволит агенту создавать сложные процессы, где результат одного действия становится началом для другого.

Следующий документ, **[008: Агент/Переменные](./008_agent_variables.md)**, расскажет, как создавать такие динамические связи.