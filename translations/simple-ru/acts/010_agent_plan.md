# 010: Агент/План

> [!DEFINITION] [План](./000_glossary.md)
> Представь себе карту сокровищ или схему сборки. План — это такая же карта, только для задач, идей или систем. Он показывает, как разные части связаны друг с другом. С его помощью можно нарисовать что угодно: от последовательности шагов, которые должен выполнить компьютер (`Вызовы Инструментов`), до схемы для мозгового штурма.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [008: Агент/Переменные](./008_agent_variables.md)
>   - [009: Агент/Состояние](./009_agent_state.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ объясняет, как работает **Протокол Плана**. Он объединяет понятия «Состояния» и «Переменных», чтобы компьютер мог выполнять сложные, многошаговые задачи. `План` — это структура данных, обычно список `Вызовов Инструментов`, который описывает последовательность действий, как будто это схема с потоками данных.

Благодаря этому подходу объект `Состояние` превращается в черновик для планирования. Агент может набросать и выполнить сложную цепочку действий, чтобы достичь своей цели.

## Как создаётся План

Связи в этой схеме (или графе) создаются не с помощью прямых указателей, а очень просто — через общую «рабочую доску», которой является объект `Состояние`.

- **Узлы (`Вызовы Инструментов`):** Каждый шаг в работе — это `Вызов Инструмента`, то есть какое-то действие, которое нужно совершить.
- **Рёбра (Объект `Состояние`):** Связи между шагами появляются, когда один инструмент что-то записывает на «рабочую доску» (`Состояние`), а другой оттуда это читает. Один `Инструмент` записывает свой результат в определённое место в `Состоянии` с помощью специального свойства `_outputPath`. Следующий `Инструмент` может использовать этот результат как входные данные, просто сославшись на то же самое место с помощью **ссылки-переменной**.

Так возникает понятная зависимость: второй `Вызов Инструмента` не может начаться, пока первый не закончит свою работу и не оставит результат в `Состоянии`.

Например, `План` для получения профиля пользователя и его краткого пересказа будет состоять из двух `Вызовов Инструментов`:

:::div{.limited-width}

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

> Sidenote:
> ```mermaid
> graph TD
>     state_var{{"state.user.profile"}}
>
>     Call1["получитьПрофиль"]
>     Call2["сделатьКраткийПересказ"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```

:::

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, создавая план из двух шагов. Эту связь можно представить в виде простой схемы.

## Что такое План?

`План` — это универсальный и мощный инструмент для мышления схемами. Он даёт чёткий формат для изображения любой системы взаимосвязанных идей: от общей задумки до детального технического чертежа. Такая структура в виде схемы (графа) — очень эффективный способ сжать сложную информацию в формат, который большие языковые модели (LLM) понимают гораздо легче, чем длинные тексты.

> Sidenote:
> `План` не ограничен простыми последовательностями. Он может представлять сложные сценарии с условиями, где дальнейшие действия зависят от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Узнать погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти фильм];
>     C -- state.suggestion --> E[Предложить вариант];
>     D -- state.suggestion --> E[Предложить вариант];
> ```

Протокол `Плана` не ограничен только выполнением задач. Его можно использовать для создания любых схем в ответ на запрос пользователя. Например, один `Инструмент` может взять таблицу контактов и создать `План`, который покажет сеть друзей. Другой может сгенерировать `План`, представляющий собой готовый сценарий для GitHub Actions, или чертёж для новой базы данных.

Хотя `План` может быть отличным инструментом для мозгового штурма, обсуждений и «размышлений вслух», его главное применение в этой системе — определять сценарии, которые можно выполнить. Для этого мы используем особый вид схем, который называется **Направленный Ациклический Граф (DAG)**, где каждый узел — это `Вызов Инструмента`.

У такого графа есть несколько ключевых свойств, которые делают его идеальным для выполнения задач:

- **Граф:** Это и есть весь `План` — совокупность всех `Вызовов Инструментов` (узлы) и связей между ними (рёбра).
- **Направленный:** Связи идут только в одну сторону, как течёт вода. Шаг, который создаёт данные, всегда должен идти *перед* шагом, который их использует.
- **Ациклический:** В сценарии не может быть замкнутых циклов. Это гарантирует, что у него есть чёткое начало и конец, и он не будет выполняться вечно.

## Разделение планирования и выполнения

Самая сильная сторона этой системы — полное разделение планирования и выполнения. Поскольку `План` — это просто описание того, что нужно сделать (декларативная структура данных), агент может составить всю схему `Вызовов Инструментов` *до того*, как будет запущен хоть какой-то код.

Представь, что языковая модель — это стратег. Она составляет список `Вызовов`, который представляет собой задуманный сценарий. Эту структуру данных потом можно:

- **Проверить:** Система может проверить схему на наличие ошибок, например, нет ли в ней замкнутых циклов.
- **Просимулировать:** Можно сделать «пробный запуск», чтобы предсказать, как поведёт себя сценарий.
- **Показать человеку:** `План` можно показать человеку для проверки, изменения или одобрения перед запуском. Это создаёт важный уровень безопасности и совместной работы.

За выполнение отвечает **[Цикл Агента](./005_agent_loop.md)**, который читает `План` и запускает `Вызовы Инструментов` в правильном порядке, заполняя объект `Состояние` по мере продвижения.

## План как развивающаяся стратегия

`План` — это не что-то застывшее. Это живая стратегия, которую можно менять на каждом шаге цикла выполнения. В обычном рабочем процессе сам `План` является частью информации (`контекста`), которая передаётся языковой модели.

- **`контекст`** содержит объект `Состояние` и `План` с предыдущего шага.
- **`решение`**, которое генерирует языковая модель, — это **новый `План`** на текущий шаг.

Этот повторяющийся процесс позволяет агенту действовать и наперёд, и по ситуации. Он может следовать существующему `Плану`, но также может изменить его в ответ на результаты предыдущего шага. Например, если `Вызов Инструмента` не удался, агент может создать новый `План`, который включает шаги для обработки ошибки. Это делает систему устойчивой и гибкой.

Этот цикл планирования и выполнения — ядро документа [203: Идея/Процесс](./203_idea_process.md). Он представляет собой самодостаточный снимок рабочего процесса, включающий доступные `Инструменты`, текущее `Состояние` и сам `План`.

## От одного Плана к многоразовым сценариям

`План` определяет последовательность действий для одной конкретной задачи. Чтобы сделать эти сценарии по-настоящему мощными, нам нужен способ упаковывать их в компоненты, которые можно использовать снова и снова, вызывая их из других `Планов`.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает протокол для такого параллельного выполнения.
