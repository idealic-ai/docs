# 011: Агент/Инстансинг

> **Инстансинг:** Это процесс, когда ты обрабатываешь сразу несколько независимых заданий (каждое со своим «рабочим столом» и уникальным номером) в рамках одного запроса к агенту.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует: [Агент/Состояние](./010_agent_state.md)
> - Совместимо с:
> - [Агент/Ввод](./007_agent_input.md)
> - [Агент/Импорты](./008_agent_imports.md)
> - [Агент/План](./013_agent_plan.md)

Этот документ описывает, как можно за один раз обработать много независимых заданий, используя умную систему, основанную на «состояниях».

## 1. Основа всего: Система Состояний

Главное, что нужно для работы инстансинга, — это **Система Состояний**. Представь, что это правило, которое заставляет тебя сначала составить полный план действий, а уже потом начать что-то делать. Она строго разделяет планирование и исполнение.

**Объект Состояния** (`State Object`) — это мостик между этими двумя этапами. Это как твой личный черновик или рабочая область в формате JSON, у которой есть две важные задачи:

1.  **Поле для работы**: Это холст, на котором работают инструменты. Каждый раз, когда вызывается инструмент (`Tool Call`), у него есть специальное указание `_outputPath` — это инструкция, в какое место на «холсте» нужно записать результат своей работы.
2.  **Источник данных**: Инструмент может взять нужную ему информацию прямо с этого «холста». Это позволяет создавать целые цепочки зависимостей, где один инструмент использует результат работы другого.

## 2. Как работает Инстансинг

Настоящая магия этой системы раскрывается, когда нужно выполнить много однотипных заданий сразу. Система Состояний делает это очень легко.

### 2.1. Номерки для заданий

Чтобы обработать несколько заданий за один раз, система получает список сообщений. Каждое сообщение — это отдельное задание, и ему присваивается **уникальный номерок** с помощью специального свойства `_instance`. Эти номерки — короткие и уникальные значки (например, цифры в кружочках: `①`, `②`), которые легко видит искусственный интеллект (ИИ), но которые не несут никакого смысла, кроме как быть меткой.

### 2.2. Точечные операции

Этот номерок `_instance` затем используется, чтобы все операции относились только к своему заданию. Все технические параметры для вызова инструмента (`Tool Call`) начинаются с нижнего подчеркивания (`_`), а его обычные параметры (`params`) находятся прямо внутри объекта вызова.

- **Связь с вызовом инструмента**: У каждого вызова `Tool Call` в плане указан `_instance` того задания, над которым он должен работать.
- **Автоматическое разделение**: Номерок `_instance` автоматически «привязывает» все операции с путями (`_outputPath` и ссылки на входные данные) к правильному «холсту». Это значит, что когда инструмент читает или записывает данные, он делает это в пределах рабочего пространства именно своего задания.

Благодаря этому механизму, сами инструменты остаются очень простыми. Им не нужно знать, что они работают в многозадачном режиме. Номерок сам следит за тем, чтобы все не перепуталось.

### 2.3. Пример

Допустим, в одном запросе нужно проанализировать настроение в двух разных текстах. Мы можем задать схему, чтобы подсказать ИИ, какие данные у нас есть и куда записать результат.

```json
{
  "context": [
    {
      "_instance": "①", // Задание номер один
      "type": "state",
      "state": { "text": "Это просто чудесно!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "Это ужасно." } } // Задание номер два
  ]
}
```

ИИ обрабатывает оба задания за один раз и создает единый план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①", // Применить к заданию №1
      "text": "†state.text", // Взять текст из его состояния
      "_outputPath": "sentiment" // Результат записать в поле sentiment
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②", // Применить к заданию №2
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

После этого система-исполнитель просто выполняет этот план, записывая результаты в «холсты» соответствующих заданий.

## 3. Помощник: План работ

Хотя это и не обязательно для инстансинга, **Система Планирования** идеально дополняет этот подход, позволяя создавать очень предсказуемые и многоразовые рабочие процессы.

**План** — это шаблон для какого-то процесса, описанный в виде схемы (`DAG`) из вызовов инструментов (`Tool Call`). Эта схема строится на основе того, как инструменты зависят друг от друга — кто что читает и кто куда что записывает в **Объекте Состояния**.

Самое главное, что такой план можно создать и отладить _до_ начала выполнения. Когда план готов, его можно передать агенту как одно из сообщений. И тогда, обрабатывая множество заданий, агент будет просто следовать этому готовому плану для каждого **Объекта Состояния**. Это гарантирует, что результат будет одинаково качественным и предсказуемым для всех.

**Объект Состояния** для каждого задания в таком случае работает как закладка в книге, показывая, на каком шаге общего плана оно сейчас находится.

## 4. Почему это круто

Такой подход к выполнению заданий дает огромные преимущества:

- **Эффективность**: Он позволяет обрабатывать множество заданий за один запрос к ИИ. Это как отправить один большой заказ на 100 пицц вместо того, чтобы звонить 100 раз. Всё происходит намного быстрее и дешевле.
- **Стабильность и качество**: ИИ видит все похожие задания одновременно, он может заметить общие закономерности и составить более качественный и единообразный план для всех сразу.
- **Предсказуемость**: Если использовать заранее готовый **План**, система становится полностью предсказуемой. Один и тот же план с одними и теми же входными данными всегда даст одинаковый результат. Никаких сюрпризов.
