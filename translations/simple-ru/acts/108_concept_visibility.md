# 108: Концепция/Видимость

> [!DEFINITION] :term[Видимость]{canonical="Visibility"}
> Это набор правил, которые определяют, какая версия :term[Идеи]{canonical="Idea"} будет найдена и показана в определённой ситуации. Видимость зависит от истории версий :term[Идеи]{canonical="Idea"}, её веток и пути поиска, который использует запрашивающий.



Чтобы система из постоянно меняющихся и связанных друг с другом :term[Идей]{canonical="Idea"} была полезной, нужен понятный и предсказуемый способ определять, какая версия :term[Идеи]{canonical="Idea"} будет показана — или **видима** — в любой момент. Этот документ описывает модель из двух частей, которая управляет видимостью: систему версий, которая создаёт возможные состояния :term[Идеи]{canonical="Idea"}, и механизм выбора, который решает, какое состояние станет видимым.

## Управление версиями: Создание состояний для показа

Прежде чем выбрать версию, она должна существовать. **Иерархическое версионирование** — это способ создавать и отслеживать различные состояния :term[Идеи]{canonical="Idea"} с течением времени. Версия — это не просто число, а целая иерархия, разделённая точками, которая рассказывает историю развития :term[Идеи]{canonical="Idea"}.

Версии состоят из **целочисленных ревизий** для последовательных публичных выпусков (например, `1.2`) и **ревизий в ветках** для именованных направлений разработки (например, `feature-x`). Например, версия `1.2.feature-x.3` говорит нам, что это третья ревизия в ветке `feature-x`, которая была создана на основе версии `1.2`.

Правила изменения версий:

- **Совместимые изменения**: Небольшое исправление, которое ничего не ломает, например, добавление нового необязательного поля в схему, создаёт новую минорную ревизию (например, `1.2` становится `1.2.1`).
- **Несовместимые изменения**: Серьёзное изменение, которое нарушает обратную совместимость, например, удаление поля или изменение его типа. В этом случае новая версия не может просто заменить старую. Такое изменение должно «подняться» на более высокий уровень иерархии версий. Изменение, нарушающее совместимость с `1.2`, создаст новую версию `1.3`. Система автоматически обнаруживает такие несовместимости, анализируя изменения в схеме, что гарантирует точное отражение границ совместимости без ручного вмешательства.

## Выбор: Какое состояние сделать видимым

Когда у нас есть богатая история версий, нужен механизм, чтобы выбрать правильную. Это решается чётким разделением между тем, как `Идея` публикуется, и тем, как она запрашивается. Процесс имеет два измерения для поиска: **пространственное** (в каких разделах искать) и **временное** (на какой момент времени).

### Ветки: Публикация и разделение

> [!DEFINITION] :term[Ветка]{canonical="Branch"}
> Это именованная метка, которая делит пространство видимости, создавая параллельное, изолированное окружение для разработки и экспериментов. Привязка :term[Идеи]{canonical="Idea"} к ветке является актом публикации.

Например, каждая версия :term[Идеи]{canonical="Idea"} в базе данных связана с одной или несколькими ветками, такими как `["main", "feature/new-billing"]`. Этот акт публикации делает :term[Идею]{canonical="a Idea"} доступной в этих конкретных разделах, обеспечивая безопасный рабочий процесс.

Это даёт два фундаментальных преимущества:

- **Изоляция**: Работа над новой функцией (например, в ветке `feature/new-billing`) не мешает стабильной ветке `main`. Это предотвращает попадание незавершённой или ошибочной работы в рабочие системы.
- **Эксперименты**: Ветки легко и дёшево создавать. Это поощряет эксперименты, позволяя разработчикам отбросить ветку, если эксперимент не удался, без какого-либо влияния на основную систему.

### Путь Поиска: Приоритетный поиск

> [!DEFINITION] :term[Путь Поиска]{canonical="Search Path"}
> Это упорядоченный список имён веток, который определяет механизм поиска. Он говорит системе, в каких разделах и в каком порядке искать, создавая каскадную систему наложения.

Этот механизм поиска является ключевым для рабочего процесса разработки и отвечает на **пространственный** вопрос. Например, типичный путь поиска разработчика может быть установлен на `['feature/my-new-idea', 'staging', 'main']`.

Такая конфигурация создаёт каскадную систему наложения для поиска:

1.  Сначала ищем подходящую :term[Идею]{canonical="Idea"} в разделе `feature/my-new-idea`.
2.  Если не найдено, ищем в разделе `staging`.
3.  И наконец, в качестве запасного варианта ищем в разделе `main`.

Это позволяет разработчику видеть определённую, задуманную им реальность, состоящую из его локальных изменений, которые плавно накладываются поверх стабильной системы.

### Время отсечения: Временной поиск

> [!DEFINITION] :term[Время отсечения]{canonical="Cutoff Time"}
> Метка времени, которая сопровождает запрос на поиск, указывая системе найти версию :term[Идеи]{canonical="Idea"}, которая считалась последней на тот конкретный момент времени.

Второе измерение поиска — **временное**. Каждый запрос на поиск выполняется относительно состояния системы, каким оно было в определённый момент. Это контролируется **Временем Отсечения**.

Если время отсечения не указано, по умолчанию используется текущее время (`now()`), и находятся самые свежие видимые версии. Однако, указав метку времени из прошлого, вы можете выполнить «запрос в прошлое». Это даёт команду системе найти версию :term[Идеи]{canonical="Idea"} — и всех её зависимостей — которая была последней согласно пути поиска в тот самый момент. Эта возможность является технической основой для идеальной воспроизводимости.



## От модели к применению

В этой главе мы определили теоретическую модель видимости — механизмы для создания различных состояний и выбора между ними. Теперь, когда модель готова, последним элементом является практический язык для взаимодействия с ней.

Следующий документ, :term[109: Концепция/Адресация]{href="./109_concept_addressing.md"}, представляет схему URI `idea:`, конкретный синтаксис, используемый для запроса определённого представления и навигации по этой богатой, версионированной и разветвлённой реальности.
