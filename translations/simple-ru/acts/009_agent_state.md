# 009: Агент/Состояние

> [!DEFINITION] [Сообщение состояния](./000_glossary.md)
> Это специальное сообщение типа `Данные`, которое работает как живая, постоянно меняющаяся память для рабочего процесса. Оно похоже на блокнот с записями, что позволяет выполнять сложные задачи, состоящие из нескольких шагов.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent/call.md)
>   - [006: Агент/Данные](./006_agent/data.md)
> - Открывает возможности для:
>   - [010: Агент/План](./010_agent/plan.md)
> - Дополняется:
>   - [011: Агент/Экземплирование](./011_agent/instancing.md)
>   - [012: Агент/Делегат](./012_agent/delegate.md)
>   - [013: Агент/Области видимости](./013_agent/scopes.md)

Эта статья описывает **сообщение Состояния** — особый вид сообщения :term[Данных], который служит постоянной памятью для агента во время его :term[Цикла выполнения]. Если :term[Переменные] — это «провода», соединяющие инструменты, то объект :term[Состояния] — это «блокнот», где результаты этих соединений записываются и хранятся на протяжении всех шагов задачи.

Объект :term[Состояния] — это как файл сохранения в видеоигре. Он содержит всю правду о текущем статусе задачи, что позволяет ставить процесс на паузу и возобновлять его. Когда начинается новый шаг, агент заглядывает в :term[Состояние] с предыдущего шага. Это даёт ему чёткое понимание, на чём он остановился, и помогает без проблем продолжить работу.

## Направление рабочего процесса с помощью Схемы

Можно задать «схему» для объекта :term[Состояния] — это необязательно, но очень полезно. Схема — это как рецепт: она описывает, какие данные и в каком порядке должны появляться. Это подсказывает ИИ, какие инструменты и как нужно использовать. Получается крепкая обратная связь: зная, какие данные должны быть в :term[Состоянии], ИИ создаёт :term[Вызовы инструментов]{canonical="Call"} с правильными «адресами для сохранения» (`_outputPath`). Это улучшает результат, потому что действия агента становятся более структурированными и соответствуют общему плану.

> Sidenote:
> - [008: Агент/Переменные](./008_agent_variables.md)

## Инструменты из нескольких шагов

Основная задача сообщения :term[Состояния] — позволить разным :term[Инструментам] обмениваться информацией в рамках одного непрерывного процесса. Оно делает возможными многошаговые операции, предоставляя общий «блокнот», куда :term[Инструменты] могут записывать свои результаты.

Это работает очень просто: один :term[Инструмент] записывает свой результат в объект :term[Состояния], а другой :term[Инструмент] на следующем шаге может прочитать эти данные и использовать их как входные. Так создаются цепочки инструментов, где результат работы одного напрямую передаётся другому, и ничего не теряется между шагами.

## Планирование и Выполнение

Комбинация записи в состояние (через `_outputPath`) и чтения из него (с помощью :term[Ссылок на переменные]) — это главный механизм, который позволяет разделить планирование и выполнение. Он даёт агенту возможность построить полную схему потока данных — цепочку :term[Вызовов инструментов]{canonical="Call"}, связанных ссылками, — *ещё до того*, как хотя бы один инструмент будет запущен.

Эту схему можно проверить, использовать повторно и даже симулировать, что идеально подходит для скрытого выполнения задач ИИ. Гибкость системы в том, что можно управлять и входами, и выходами на уровне схемы. Разработчик может либо оставить :term[Ссылки на переменные] (входы) и `_outputPath` (выходы) на усмотрение ИИ, либо задать их жёстко, чтобы обеспечить надёжный и предсказуемый поток данных.

> [!HEADSUP] На заметку
> Когда мы создаём :term[Вызовы инструментов]{canonical="Call"}, связанные друг с другом через :term[Состояние], мы занимаемся планированием. Эта система создаёт для этого техническую основу: постоянное :term[Состояние] служит блокнотом, :term[Ссылки на переменные] и `_outputPath` — проводами, а :term[Цикл] агента — мотором, который всё это крутит. Вместе эти компоненты позволяют агенту построить полную схему потока данных, что и является сутью :term[Плана].
>
> > Sidenote:
> >
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [010: Агент/План](./010_agent_plan.md)

## Взаимосвязи

- **:term[Вызов]:** Система :term[Вызовов] тесно связана с :term[Состоянием] через специальное свойство `_outputPath`. Это свойство превращает :term[Вызов инструмента]{canonical="Call"}, который сам по себе мог бы быть одноразовым действием, в операцию, изменяющую состояние. Указывая `_outputPath`, :term[Вызов] говорит системе записать свой результат в объект :term[Состояния]. Так агент сохраняет итоги своих действий. Это позволяет последовательности :term[Вызовов] опираться друг на друга, создавая цепочку причин и следствий, которая фиксируется в :term[Состоянии].

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **:term[Данные]:** Сообщение :term[Состояния] — это, по сути, особый случай использования системы сообщений :term[Данных] (сообщение :term[Данных] с `kind: "state"`). Оно использует основные возможности сообщений :term[Данных] для создания постоянной памяти агента. Свойство `schema` используется для описания ожидаемой структуры этой памяти, служа чертежом, который направляет действия ИИ. Кроме того, важна способность системы :term[Данных] объединять информацию: это позволяет обновлять :term[Состояние] по частям, а система сама собирает эти части в единое целое.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **:term[Области видимости]:** Система :term[Областей видимости] — это основной способ передать объект :term[Состояния] инструменту, который работает в изолированной среде, например, :term[Делегату]. Когда :term[Вызов] делегируется, свойство `_scopes` может указать, что :term[Состояние] должно быть включено в «чистую комнату» делегата. Это позволяет изолированным инструментам читать данные из основного рабочего процесса и взаимодействовать с его состоянием контролируемым и явным образом.

  > Sidenote:
  > - [013: Агент/Области видимости](./013_agent_scopes.md)

- **:term[Экземплирование]:** Сообщение :term[Состояния] полностью совместимо с системой :term[Экземплирования]. Когда запрос обрабатывает несколько :term[Экземпляров], каждый из них имеет свой собственный, изолированный объект :term[Состояния], определяемый уникальным ключом `_instance`. :term[Ссылки на переменные] (например, `†state.currentUser.id`) автоматически и незаметно направляются к нужному объекту :term[Состояния], соответствующему :term[Экземпляру], на который нацелен :term[Вызов инструмента]{canonical="Call"}. Это позволяет выполнять один и тот же общий :term[План] для множества разных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md)

- **:term[План]:** Хотя :term[Состояние] позволяет создавать простые последовательности инструментов, его настоящая сила раскрывается, когда оно становится основой для системы :term[Планов]. В сообщении :term[Плана] рабочий процесс представлен в виде графа, где :term[Вызовы инструментов]{canonical="Call"} — это узлы. Объект :term[Состояния] обеспечивает связи — рёбра — между этими узлами. Он позволяет одному узлу записывать данные в переменную, а другим — читать их, что делает возможными сложные сценарии, такие как логические ветвления (если-иначе) или параллельное выполнение задач.

  > Sidenote:
  > - [010: Агент/План](./010_agent_plan.md)

## От одного Состояния к управляемым процессам

Сообщение :term[Состояния] предоставляет механизм для управления памятью одного целостного рабочего процесса. Имея постоянный «блокнот» и переменные для соединения инструментов, мы теперь можем проектировать и выполнять сложные многошаговые процессы.

Следующий документ, :term[010: Агент/План]{href="./010_agent_plan.md"}, описывает систему для организации этих процессов в виде графа :term[Вызовов инструментов]{canonical="Call"}.
