# 009: Агент/Состояние

> [!DEFINITION] [Сообщение Состояния (State Message)](./000_glossary.md)
> Это постоянно хранящееся сообщение с :term[данными]{canonical="Data"}, которое представляет собой живую, меняющуюся память рабочего процесса. Оно работает как набор локальных переменных, позволяя выполнять многошаговые операции с сохранением контекста.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Данные](./005_agent_data.md)
> - Делает возможным:
>   - [011: Агент/План](./011_agent_plan.md)
> - Дополняется:
>   - [012: Агент/Экземплирование](./012_agent_instancing.md)
>   - [013: Агент/Делегат](./013_agent_delegate.md)
>   - [014: Агент/Области](./014_agent_scopes.md)

**Сообщение состояния** — это специальное сообщение :term[данных]{canonical="Data"}, которое служит постоянной памятью для :term[цикла выполнения]{canonical="Execution Loop"} агента. Если :term[переменные]{canonical="Variable"} — это «провода», соединяющие инструменты, то объект :term[состояния]{canonical="State"} — это «черновик», куда записываются и сохраняются результаты этих соединений на протяжении многих шагов.

Объект :term[состояния]{canonical="State"} — это главный источник правды о том, что происходит с запросом в данный момент. Он ключ к устойчивости и возобновлению работы. Представь себе, что это как сохранение в видеоигре. Поскольку в нём записан весь контекст задачи в определённый момент времени, процесс можно поставить на паузу и потом продолжить. Когда начинается новый шаг, :term[состояние]{canonical="State"} с предыдущего шага даёт ИИ-модели чёткое понимание, на чём всё остановилось, и работа продолжается без проблем.

## Управление процессом с помощью схемы

Можно задать `схему` для объекта :term[состояния]{canonical="State"} — это необязательный, но очень мощный шаг. Схема — это как шаблон или оглавление для блокнота. Она описывает, какие данные мы ожидаем там увидеть, определяя набор свойств. Это подсказывает, как :term[инструменты]{canonical="Tool"} должны взаимодействовать друг с другом и какой должен быть общий процесс. Это создаёт для ИИ-модели полезную обратную связь: зная, какая информация должна быть в :term[состоянии]{canonical="State"}, она будет создавать :term[вызовы инструментов]{canonical="Call"} с правильными :term[путями вывода]{canonical="Output Path"}. Это улучшает результат, потому что действия агента становятся структурно правильными и соответствуют задуманному процессу.

> Sidenote:
> - [007: Агент/Переменные](./007_agent_variables.md)
> - [008: Агент/Вывод](./008_agent_output.md)

## Многошаговые инструменты

Главная задача сообщения :term[состояния]{canonical="State"} — позволить разным :term[инструментам]{canonical="Tool"} обмениваться информацией в рамках одного непрерывного процесса. Оно делает возможными операции, зависящие от предыдущих шагов, предоставляя общий «черновик», где :term[инструменты]{canonical="Tool"} могут сохранять свои результаты.

Это работает по простому принципу «прочитал-записал»: один :term[инструмент]{canonical="Tool"} может записать свой результат в объект :term[состояния]{canonical="State"}, а другой :term[инструмент]{canonical="Tool"} на следующем шаге может прочитать эти данные, чтобы использовать их в своей работе. Это позволяет создавать цепочки инструментов, где результат работы одного напрямую становится входными данными для другого, и всё это без потери контекста между действиями.

## Планирование и выполнение

Сочетание записи в состояние через :term[путь вывода]{canonical="Output Path"} и чтения из него с помощью :term[ссылок на переменные]{canonical="Variable Reference"} — это основной механизм, который позволяет отделить планирование от выполнения. Он даёт агенту возможность построить полную схему потока данных — цепочку :term[вызовов инструментов]{canonical="Call"}, связанных ссылками — *ещё до того*, как будет запущен хотя бы один инструмент.

Эту схему ссылок можно проверить, использовать повторно и даже симулировать, что делает её полностью совместимой со :term[скрытым выполнением]{canonical="Latent Execution"} ИИ-моделей. Гибкость системы в том, что можно контролировать и входы, и выходы на уровне схемы. Разработчик может оставить :term[ссылки на переменные]{canonical="Variable Reference"} (входы) и :term[путь вывода]{canonical="Output Path"} (выходы) на усмотрение ИИ, а может задать их жёстко, чтобы обеспечить надёжный и предсказуемый поток данных.

> [!HEADSUP] На заметку
> Создание :term[вызовов инструментов]{canonical="Call"}, связанных друг с другом через :term[состояние]{canonical="State"}, — это и есть акт планирования. Эта система создаёт для этого техническую основу: постоянное :term[состояние]{canonical="State"} служит черновиком, :term[ссылки на переменные]{canonical="Variable Reference"} и :term[путь вывода]{canonical="Output Path"} — проводами, а :term[цикл]{canonical="Loop"} агента — двигателем, который всё это повторяет. Вместе эти компоненты позволяют агенту строить полную схему потока данных, что и является сутью :term[плана]{canonical="Plan"}.
>
> > Sidenote:
> >
> > - [010: Агент/Цикл](./010_agent_loop.md)
> > - [011: Агент/План](./011_agent_plan.md)

## Взаимодействие с другими системами

- **:term[Вызов (Call)]{canonical="Call"}:** Система :term[вызовов]{canonical="Call"} тесно связана с :term[состоянием]{canonical="State"} через мета-свойство :term[путь вывода]{canonical="Output Path"}. Это свойство превращает :term[вызов инструмента]{canonical="Call"}, который сам по себе мог бы быть просто действием без памяти, в операцию, изменяющую состояние. Указывая :term[путь вывода]{canonical="Output Path"}, :term[вызов]{canonical="Call"} говорит движку записать свой результат в объект :term[состояния]{canonical="State"}. Так агент запоминает результаты своих действий. Это взаимодействие позволяет последовательности :term[вызовов]{canonical="Call"} строиться друг на друге, создавая цепочку причин и следствий, которая записывается в :term[состоянии]{canonical="State"}.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **:term[Данные (Data)]{canonical="Data"}:** Сообщение :term[состояния]{canonical="State"} — это, по сути, особый случай использования системы сообщений :term[данных]{canonical="Data"}, а именно сообщение :term[данных]{canonical="Data"} с `kind: "state"`. Оно использует основные возможности сообщений :term[данных]{canonical="Data"}, чтобы создать постоянную память для агента. Свойство `schema` используется для определения ожидаемой структуры этой памяти, предоставляя «чертёж», который направляет действия ИИ. Кроме того, критически важна возможность слияния :term[данных]{canonical="Data"}, которая позволяет обновлять :term[состояние]{canonical="State"} по частям, а система сама собирает эти части в единое целое.

  > Sidenote:
  > - [005: Агент/Данные](./005_agent_data.md)

- **:term[Области (Scopes)]{canonical="Scope"}:** Система :term[областей]{canonical="Scope"} — это основной способ передать объект :term[состояния]{canonical="State"} :term[инструменту]{canonical="Tool"}, работающему в изолированной среде, например, :term[делегату]{canonical="Delegate"}. Когда :term[вызов]{canonical="Call"} делегируется, свойство `_scopes` может указать, что :term[состояние]{canonical="State"} должно быть включено в «чистую комнату» делегата. Это позволяет изолированным инструментам читать и взаимодействовать с состоянием основного процесса контролируемым и явным образом.

  > Sidenote:
  > - [014: Агент/Области](./014_agent_scopes.md)

- **:term[Экземплирование (Instancing)]{canonical="Instancing"}:** Сообщение :term[состояния]{canonical="State"} полностью совместимо с системой :term[экземплирования]{canonical="Instancing"}. Когда запрос обрабатывает несколько :term[экземпляров]{canonical="Instance"}, каждый из них имеет свой собственный изолированный объект :term[состояния]{canonical="State"}, идентифицированный уникальным ключом `_instance`. :term[Ссылки на переменные]{canonical="Variable Reference"} (например, `†state.currentUser.id`) автоматически и прозрачно направляются к правильному объекту :term[состояния]{canonical="State"}, соответствующему тому :term[экземпляру]{canonical="Instance"}, на который нацелен :term[вызов инструмента]{canonical="Call"}. Это позволяет выполнять один общий `План` для множества разных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote:
  > - [012: Агент/Экземплирование](./012_agent_instancing.md)

- **:term[План (Plan)]{canonical="Plan"}:** Хотя :term[состояние]{canonical="State"} позволяет создавать простые последовательности инструментов, его полная мощь раскрывается, когда оно используется как основа системы :term[планирования]{canonical="Plan"}. В сообщении :term[плана]{canonical="Plan"} рабочий процесс представлен в виде графа, где :term[вызовы инструментов]{canonical="Call"} — это узлы. Объект :term[состояния]{canonical="State"} обеспечивает связи — рёбра — между этими узлами. Он позволяет одному узлу записывать данные в переменную, а другим — читать их, что делает возможными сложные схемы, такие как логические ветвления (если-то) или параллельное выполнение задач.

  > Sidenote:
  > - [011: Агент/План](./011_agent_plan.md)

## От одного состояния к организованным процессам

Сообщение :term[состояния]{canonical="State"} предоставляет механизм для управления памятью одного целостного рабочего процесса. Имея постоянный черновик и переменные для соединения инструментов, мы теперь можем проектировать и выполнять сложные, многошаговые задачи.

Следующий документ, :term[011: Агент/План]{href="./011_agent_plan.md"}, описывает систему для организации этих процессов в виде графа :term[вызовов инструментов]{canonical="Call"}.
