# 009: Агент/Состояние

> [!DEFINITION] [Сообщение состояния](./000_glossary.md)
> Это специальное сообщение типа `Данные`, которое работает как живая, постоянно меняющаяся память для рабочего процесса. Оно похоже на блокнот с записями, что позволяет выполнять сложные задачи, состоящие из нескольких шагов.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent/call.md)
>   - [006: Агент/Данные](./006_agent/data.md)
> - Открывает возможности для:
>   - [010: Агент/План](./010_agent/plan.md)
> - Дополняется:
>   - [011: Агент/Экземплирование](./011_agent/instancing.md)
>   - [012: Агент/Делегат](./012_agent/delegate.md)
>   - [013: Агент/Области видимости](./013_agent/scopes.md)

Эта статья описывает **сообщение Состояния** — особый вид сообщения :term[Данных]{canonical="Data"}, который служит постоянной памятью для агента во время его :term[Цикла выполнения]{canonical="Execution Loop"}. Если :term[Переменные]{canonical="Variable"} — это «провода», соединяющие инструменты, то объект :term[Состояния]{canonical="State"} — это «блокнот», где результаты этих соединений записываются и хранятся на протяжении всех шагов задачи.

Объект :term[Состояния]{canonical="State"} — это как файл сохранения в видеоигре. Он содержит всю правду о текущем статусе задачи, что позволяет ставить процесс на паузу и возобновлять его. Когда начинается новый шаг, агент заглядывает в :term[Состояние]{canonical="State"} с предыдущего шага. Это даёт ему чёткое понимание, на чём он остановился, и помогает без проблем продолжить работу.

## Направление рабочего процесса с помощью Схемы

Можно задать «схему» для объекта :term[Состояния]{canonical="State"} — это необязательно, но очень полезно. Схема — это как рецепт: она описывает, какие данные и в каком порядке должны появляться. Это подсказывает ИИ, какие инструменты и как нужно использовать. Получается крепкая обратная связь: зная, какие данные должны быть в :term[Состоянии]{canonical="State"}, ИИ создаёт :term[Вызовы инструментов]{canonical="Call"} с правильными «адресами для сохранения» (`_outputPath`). Это улучшает результат, потому что действия агента становятся более структурированными и соответствуют общему плану.

> Sidenote:
> - [008: Агент/Переменные](./008_agent_variables.md)

## Инструменты из нескольких шагов

Основная задача сообщения :term[Состояния]{canonical="State"} — позволить разным :term[Инструментам]{canonical="Tool"} обмениваться информацией в рамках одного непрерывного процесса. Оно делает возможными многошаговые операции, предоставляя общий «блокнот», куда :term[Инструменты]{canonical="Tool"} могут записывать свои результаты.

Это работает очень просто: один :term[Инструмент]{canonical="Tool"} записывает свой результат в объект :term[Состояния]{canonical="State"}, а другой :term[Инструмент]{canonical="Tool"} на следующем шаге может прочитать эти данные и использовать их как входные. Так создаются цепочки инструментов, где результат работы одного напрямую передаётся другому, и ничего не теряется между шагами.

## Планирование и Выполнение

Комбинация записи в состояние (через `_outputPath`) и чтения из него (с помощью :term[Ссылок на переменные]{canonical="Variable Reference"}) — это главный механизм, который позволяет разделить планирование и выполнение. Он даёт агенту возможность построить полную схему потока данных — цепочку :term[Вызовов инструментов]{canonical="Call"}, связанных ссылками, — *ещё до того*, как хотя бы один инструмент будет запущен.

Эту схему можно проверить, использовать повторно и даже симулировать, что идеально подходит для скрытого выполнения задач ИИ. Гибкость системы в том, что можно управлять и входами, и выходами на уровне схемы. Разработчик может либо оставить :term[Ссылки на переменные]{canonical="Variable Reference"} (входы) и `_outputPath` (выходы) на усмотрение ИИ, либо задать их жёстко, чтобы обеспечить надёжный и предсказуемый поток данных.

> [!HEADSUP] На заметку
> Когда мы создаём :term[Вызовы инструментов]{canonical="Call"}, связанные друг с другом через :term[Состояние]{canonical="State"}, мы занимаемся планированием. Эта система создаёт для этого техническую основу: постоянное :term[Состояние]{canonical="State"} служит блокнотом, :term[Ссылки на переменные]{canonical="Variable Reference"} и `_outputPath` — проводами, а :term[Цикл]{canonical="Loop"} агента — мотором, который всё это крутит. Вместе эти компоненты позволяют агенту построить полную схему потока данных, что и является сутью :term[Плана]{canonical="Plan"}.
>
> > Sidenote:
> >
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [010: Агент/План](./010_agent_plan.md)

## Взаимосвязи

- **:term[Вызов]{canonical="Call"}:** Система :term[Вызовов]{canonical="Call"} тесно связана с :term[Состоянием]{canonical="State"} через специальное свойство `_outputPath`. Это свойство превращает :term[Вызов инструмента]{canonical="Call"}, который сам по себе мог бы быть одноразовым действием, в операцию, изменяющую состояние. Указывая `_outputPath`, :term[Вызов]{canonical="Call"} говорит системе записать свой результат в объект :term[Состояния]{canonical="State"}. Так агент сохраняет итоги своих действий. Это позволяет последовательности :term[Вызовов]{canonical="Call"} опираться друг на друга, создавая цепочку причин и следствий, которая фиксируется в :term[Состоянии]{canonical="State"}.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **:term[Данные]{canonical="Data"}:** Сообщение :term[Состояния]{canonical="State"} — это, по сути, особый случай использования системы сообщений :term[Данных]{canonical="Data"} (сообщение :term[Данных]{canonical="Data"} с `kind: "state"`). Оно использует основные возможности сообщений :term[Данных]{canonical="Data"} для создания постоянной памяти агента. Свойство `schema` используется для описания ожидаемой структуры этой памяти, служа чертежом, который направляет действия ИИ. Кроме того, важна способность системы :term[Данных]{canonical="Data"} объединять информацию: это позволяет обновлять :term[Состояние]{canonical="State"} по частям, а система сама собирает эти части в единое целое.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **:term[Области видимости]{canonical="Scope"}:** Система :term[Областей видимости]{canonical="Scope"} — это основной способ передать объект :term[Состояния]{canonical="State"} инструменту, который работает в изолированной среде, например, :term[Делегату]{canonical="Delegate"}. Когда :term[Вызов]{canonical="Call"} делегируется, свойство `_scopes` может указать, что :term[Состояние]{canonical="State"} должно быть включено в «чистую комнату» делегата. Это позволяет изолированным инструментам читать данные из основного рабочего процесса и взаимодействовать с его состоянием контролируемым и явным образом.

  > Sidenote:
  > - [013: Агент/Области видимости](./013_agent_scopes.md)

- **:term[Экземплирование]{canonical="Instancing"}:** Сообщение :term[Состояния]{canonical="State"} полностью совместимо с системой :term[Экземплирования]{canonical="Instancing"}. Когда запрос обрабатывает несколько :term[Экземпляров]{canonical="Instance"}, каждый из них имеет свой собственный, изолированный объект :term[Состояния]{canonical="State"}, определяемый уникальным ключом `_instance`. :term[Ссылки на переменные]{canonical="Variable Reference"} (например, `†state.currentUser.id`) автоматически и незаметно направляются к нужному объекту :term[Состояния]{canonical="State"}, соответствующему :term[Экземпляру]{canonical="Instance"}, на который нацелен :term[Вызов инструмента]{canonical="Call"}. Это позволяет выполнять один и тот же общий :term[План]{canonical="Plan"} для множества разных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md)

- **:term[План]{canonical="Plan"}:** Хотя :term[Состояние]{canonical="State"} позволяет создавать простые последовательности инструментов, его настоящая сила раскрывается, когда оно становится основой для системы :term[Планов]{canonical="Plan"}. В сообщении :term[Плана]{canonical="Plan"} рабочий процесс представлен в виде графа, где :term[Вызовы инструментов]{canonical="Call"} — это узлы. Объект :term[Состояния]{canonical="State"} обеспечивает связи — рёбра — между этими узлами. Он позволяет одному узлу записывать данные в переменную, а другим — читать их, что делает возможными сложные сценарии, такие как логические ветвления (если-иначе) или параллельное выполнение задач.

  > Sidenote:
  > - [010: Агент/План](./010_agent_plan.md)

## От одного Состояния к управляемым процессам

Сообщение :term[Состояния]{canonical="State"} предоставляет механизм для управления памятью одного целостного рабочего процесса. Имея постоянный «блокнот» и переменные для соединения инструментов, мы теперь можем проектировать и выполнять сложные многошаговые процессы.

Следующий документ, :term[010: Агент/План]{href="./010_agent_plan.md"}, описывает систему для организации этих процессов в виде графа :term[Вызовов инструментов]{canonical="Call"}.
