# 013: Агент/Области видимости

> [!DEFINITION] :term[Область видимости]
> Механизм, который позволяет передать для выполнения заданную часть информации (контекста) из родительской среды. Свойство `_scopes` работает как «белый список», определяя ограниченный и безопасный набор данных, к которым может получить доступ :term[Вызов].


> Sidenote:
> - Требуется:
>   - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Паттерн **:term[контекста с ограниченной областью видимости]{canonical="scope"}** — это основной способ управления информацией, доступной для :term[Вызова]. В сложных системах с множеством агентов :term[Вызов] редко работает в вакууме; ему часто нужна информация из родительской среды — например, то, что ввёл пользователь, текущее состояние системы или результаты предыдущих шагов. Области видимости обеспечивают безопасный и ясный способ контроля этого потока информации.

Ограничивая контекст, области видимости повышают безопасность, предотвращают случайные утечки данных и помогают ИИ-модели (LLM) сосредоточиться, что делает её работу более предсказуемой и экономичной. Этот контролируемый контекст также является ключом к модульности, позволяя таким компонентам, как :term[Идеи] и :term[Действия], быть по-настоящему автономными и многоразовыми. Этот документ объясняет, как работает этот паттерн и как он взаимодействует с другими возможностями агента.

## Предоставление и запрос контекста

Схема свойства `_scopes` определяет, как предоставляется контекст: статически (**заранее**) или динамически (**по запросу**) во время выполнения.

> Sidenote:
> ```mermaid
> graph TD
>     subgraph Родительский контекст
>         direction LR
>         input("ввод")
>         state("состояние")
>     end
>
>     subgraph Вызов инструмента
>         direction LR
>         filter{{"_scopes: ['input']"}}
>     end
>
>     input --> filter
>     state -.-> filter
>
>     subgraph Предоставленный контекст
>         Execute(Выполнить инструмент)
>     end
>
>     filter --> HITL{{Одобрение человеком}}
>     HITL --> Execute
>
>     classDef unused stroke-dasharray: 5, 5, stroke:#aaa, color:#aaa
>     class state unused
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

- **Статические области видимости (Предоставление контекста)**: Схема `_scopes` может быть постоянным значением (`const`), что означает, что контекст **предоставляется** заранее. Разработчик жёстко прописал, какую именно информацию может видеть инструмент.

  ```json
  {
    "_scopes": {
      "const": ["input"]
    }
  }
  ```

- **Динамические области видимости (Запрос контекста)**: Схема `_scopes` может быть более гибкой, позволяя **запрашивать** контекст. ИИ-модель сама решает, какие из доступных областей ей нужны для создания :term[Вызова].

  ```json
  {
    "_scopes": {
      "type": "array",
      "items": {
        "enum": ["state", "input"]
      }
    }
  }
  ```

  Этот динамический подход особенно полезен, когда в процесс вовлечён человек для утверждения действий, что обеспечивает дополнительный уровень прозрачности и контроля.

## Роль областей видимости в композиции вызовов

Свойство `_scopes` — это главный механизм управления контекстом, доступным для :term[Вызова]. Оно действует как «белый список», фильтруя родительскую среду и предоставляя для выполнения ограниченный и сфокусированный набор данных. Этот контролируемый контекст играет ключевую роль в обработке :term[Вызова] и адаптируется для поддержки модели композитного выполнения, где сочетаются разные возможности: явная логика, экземплирование и модульность.

- **Скрытое выполнение**: При стандартном скрытом выполнении `_scopes` служат «подсказкой», чтобы сфокусировать внимание ИИ-модели на нужных частях родительского контекста. Это скорее рекомендация, а не строгий фильтр, но она крайне важна для повышения надёжности и экономичности работы ИИ, так как убирает шум от лишних данных. См. пример [Устранение неоднозначности с помощью областей видимости](#example-disambiguation-with-scopes).

  > Sidenote:
  > - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}.

- **Явное выполнение (`_activity`)**: Когда :term[Вызов] подкреплён детерминированным :term[Действием], роль областей видимости становится более прямой. Контекст из области видимости целиком передаётся функции :term[Действия] как дополнительный параметр. Это даёт :term[Действию] полный доступ к нужным данным, даже если ИИ не использовал их напрямую для генерации основных параметров :term[Вызова]. См. пример [Предоставление контекста для Действия](#example-providing-context-to-an-activity).

  > Sidenote:
  > - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.

- **Экземплирование (`_instance`)**: При запросе с несколькими экземплярами, когда агент обрабатывает пакет однотипных объектов, области видимости начинают «знать» об экземплярах. Протокол гарантирует, что :term[Вызов], нацеленный на конкретный экземпляр, получит контекст только для *этого* экземпляра. Это критически важно для сохранения целостности данных и предотвращения «утечки» контекста между параллельными выполнениями.

  > Sidenote:
  > - :term[011: Агент/Экземплирование]{href="./011_agent_instancing.md"}

- **Изолированное делегирование (`_delegate`)**: Когда :term[Вызов] делегируется внешнему :term[Делегату], области видимости становятся стражами контекста. Они определяют, что из родительской среды будет *добавлено* к собственному внутреннему контексту делегата, создавая итоговый контекст для изолированного подзапроса. Ничто из родительской среды не будет доступно, если это явно не указано в области видимости, что обеспечивает полную инкапсуляцию. См. примеры [Определение области видимости для контекста Делегата](#example-scoping-a-delegates-context) и [Экземплирование с делегатами в областях видимости](#example-instancing-with-scoped-delegates).

  > Sidenote:
  > - :term[012: Агент/Делегат]{href="./012_agent_delegate.md"}

_scopesСвойство `_scopes` — это мост, по которому :term[Вызов] получает контекст. В этой главе мы показали, как этот единый механизм адаптируется к разным режимам выполнения — от мягкого направления скрытого вызова до строгого определения всего контекста для делегированного. Именно эта гибкость делает его основой для создания сложных, безопасных и модульных агентных систем.

## Примеры

:::::details{title="Пример: Устранение неоднозначности с помощью областей видимости"}

::::columns
:::column{title="Неоднозначный контекст"}

В этом примере контекст неоднозначен. В нём есть два разных пользователя: `currentUser` в `state` и `mentionedUser` в `input`. Агенту нужно отправить сообщение, но неясно, кому.

```json
[
  {
    "type": "state",
    "currentUser": { "id": "user_A", "name": "Алиса" }
  },
  {
    "type": "input",
    "mentionedUser": { "id": "user_B", "name": "Борис" },
    "instruction": "Отправь приветственное сообщение упомянутому выше пользователю."
  }
]
```

:::
:::column{title="`Вызов` с областью видимости"}

Добавляя `_scopes: ["input"]`, вызывающий даёт важную подсказку. Он говорит ИИ-модели сосредоточиться на данных из `input`, что устраняет неоднозначность и гарантирует, что сообщение будет отправлено правильному получателю — Борису.

```json
{
  "_tool": "sendMessage",
  "_scopes": ["input"],
  "recipientId": "user_B",
  "message": "Добро пожаловать, Борис!"
}
```

:::
::::
:::::

:::::details{title="Пример: Предоставление контекста для Действия"}

Здесь :term[Действию] нужен доступ к контекстной информации, которая не является прямым параметром инструмента. Инструмент `logEvent` принимает только `eventName`, но для правильной работы базовому действию также нужно знать `userId`.

::::columns
:::column{title="`Вызов` с областью видимости"}


:term[Вызов] прост и содержит только `eventName`. Однако свойство `_scopes: ["state"]` указывает исполняющей среде передать объект `state` действию.


```json
{
  "_tool": "logEvent",
  "_scopes": ["state"],
  "eventName": "user_login"
}
```

:::
:::column{title="Реализация Действия (TypeScript)"}

:term[Действие] регистрируется с функцией, которая извлекает свои параметры напрямую из вызова и контекста области видимости. Это обеспечивает чистый и прямой доступ как к `eventName`, так и к `userId`.

```typescript
// Параметры деструктурируются для прямого доступа к 'eventName'
// из вызова и 'state' из контекста области видимости.
Activity.register('logEvent', async ({ eventName }, { state }) => {
  const userId = state.userId;
  await analytics.track(eventName, { userId });
});
```

:::
::::
:::::

:::::details{title="Пример: Определение области видимости для контекста Делегата"}

При делегировании `_scopes` определяют, какая часть родительского контекста будет *добавлена* к собственному внутреннему контексту делегата. Здесь высокоуровневый `Оркестратор` делегирует задачу, передавая весь объект `state` специализированному делегату `Summarizer`.

::::columns
:::column{title="Родительский `Вызов` с областью видимости"}

У агента `Оркестратор` есть свой собственный контекст. Он делает `Вызов`, который определяет `state` для включения в контекст делегата.

```json
// Контекст и вызов Оркестратора
[
  {
    "type": "state",
    "articleText": "Длинная и сложная статья..."
  },
  {
    "_tool": "summarizeArticle",
    "_delegate": "SummarizerAgent",
    "_scopes": ["state"]
  }
]
```

:::
:::column{title="Контекст подзапроса Делегата"}

Среда выполнения `Summarizer` состоит из его собственного внутреннего контекста и данных, полученных из родительской области видимости. Это обеспечивает модульность, предоставляя при этом необходимую информацию.

```json
// Контекст, созданный для подзапроса Summarizer
[
  // Внутренний контекст Summarizer
  {
    "type": "system",
    "message": "Ты — эксперт в составлении кратких summarizing."
  },
  // Добавляется контекст из родительской области видимости
  {
    "type": "state",
    "articleText": "Длинная и сложная статья..."
  }
]
```

:::
::::
:::::

:::::details{title="Пример: Экземплирование с делегатами в областях видимости"}

Этот пример показывает, как `_scopes` и `_instance` взаимодействуют, позволяя одному агенту организовывать несколько изолированных вызовов делегатов параллельно.

::::columns
:::column{title="Родительский контекст и решение"}

У родительского агента есть два отдельных экземпляра `State`. Он генерирует `решение` с двумя `Вызовами` к `translatorDelegate`. Каждый вызов нацелен на свой экземпляр и правильно ограничивает область видимости только `state` для этого экземпляра.

```json
// РОДИТЕЛЬСКИЙ КОНТЕКСТ
[
  { "type": "state", "_instance": "①", "text": "Привет" },
  { "type": "state", "_instance": "②", "text": "Bonjour" }
]

// РЕШЕНИЕ ИИ-МОДЕЛИ
{
  "calls": [
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "①",
      "_scopes": ["state"]
    },
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "②",
      "_scopes": ["state"]
    }
  ]
}
```

:::
:::column{title="Контексты подзапросов делегатов"}

Исполняющая среда создаёт два независимых подзапроса. Свойства `_instance` и `_scopes` работают вместе, чтобы каждый делегат получил только свой, правильно ограниченный `state`.

```json
// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ①
[
  { "type": "system", "message": "Ты — переводчик." },
  { "type": "state", "text": "Привет" }
]

// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ②
[
  { "type": "system", "message": "Ты — переводчик." },
  { "type": "state", "text": "Bonjour" }
]
```

:::
::::
:::::
