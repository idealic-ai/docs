# 012: Агент/Делегирование

> [!DEFINITION] [Делегат](./000_glossary.md)
> Протокол для изоляции контекста исполнения. Вызывается свойством `_delegate` в `Call`. Он исполняет `Действие` или новый `Запрос` в среде «чистой комнаты», а свойство `_scopes` предоставляет контролируемый доступ к родительскому контексту.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [013: Агент/Области видимости](./013_agent_scopes.md)

В предыдущих документах мы разобрались, как работают отдельные «инструменты» (`Tools`). А **Протокол Делегирования** решает более сложную задачу: как объединять и масштабировать эти инструменты. Он позволяет запускать их в изолированных средах — «чистых комнатах». Это не даёт разным задачам мешать друг другу и позволяет использовать одни и те же инструменты в разных местах.

Представь, что агент — это главный менеджер. Вместо того чтобы выполнять всю работу самому, он может «делегировать» задачу, то есть поручить её другому специалисту. Этим специалистом может быть другой агент или просто отдельное действие. Так система может строить сложное поведение из маленьких, независимых и самодостаточных блоков.

## Проблема: Гигантские инструменты и путаница в данных

Когда у агента появляется всё больше способностей, хранить все его «инструменты» в одном большом ящике становится неудобно.

1.  **Слишком большие схемы**: У нейросетей есть предел того, сколько информации об инструментах они могут обработать за раз. Если смешать кучу сложных инструментов, нейросеть может запутаться и не сможет правильно выбрать нужный.
2.  **Путаница в данных**: Когда все инструменты лежат в одном месте, нейросеть может случайно использовать информацию из одной задачи при выполнении другой. Это как если бы ты, делая домашку по математике, отвлёкся на учебник истории, лежащий рядом, и начал вставлять даты в уравнения.
3.  **Трудно использовать повторно**: Инструмент, созданный для одного агента, сложно передать другому, не захватив с собой кучу лишних данных, с которыми он был связан.

Протокол Делегирования решает эти проблемы, вводя **Делегирование** — способ поручить задачу внешней, изолированной среде исполнения.

## Свойство `_delegate`

Чтобы поручить задачу, мы используем специальное свойство `_delegate` в схеме Инструмента. Это свойство — как записка «Не делай это здесь, передай специалисту».

Свойство `_delegate` — это строка, которую можно использовать двумя способами:

*   **Ссылка на готовый `Запрос`**: Строка может быть адресом файла, в котором описан готовый к работе специалист (`Запрос`). Это позволяет Инструменту поручить свою работу совершенно отдельной инструкции.

    > Sidenote:
    > Сохранённый и готовый к повторному использованию [001: Агент/Запрос](./001_agent_request.md) — это самая распространённая форма `Идеи`. Протокол Делегирования — основной механизм для объединения таких `Идей` в более сложные системы. Подробнее см. в [101: Концепция/Идея](./101_concept_idea.md).

*   **Создание анонимного специалиста**: Если в строке написано `'anonymous'`, это сигнал создать временного специалиста для одного поручения. Это полезно, когда нужно быстро выполнить что-то в изоляции, не создавая для этого отдельный файл. Система автоматически создаст для этой задачи пустую, чистую «комнату».

## Исполнение в «чистой комнате»

Делегат предоставляет «чистую комнату» для работы. Вместо того чтобы выполнять задачу в шумном и забитом вещами «кабинете» главного агента, она выполняется в новом, изолированном пространстве.

Именно здесь становится важен [Протокол Областей Видимости (Scopes)](./013_agent_scopes.md). Свойство `_scopes` в схеме Инструмента — это как пропуск, который явно указывает, какие именно документы из «кабинета» главного агента можно взять с собой в «чистую комнату». Это даёт полный контроль над тем, что видит делегат, и предотвращает путаницу.

> Sidenote:
> - [013: Агент/Области видимости](./013_agent_scopes.md)

## Работа с очень большими данными

Протокол Делегирования также помогает, когда инструмент должен выдать очень большой и сложный результат. Вместо того чтобы подробно описывать этот гигантский результат в общем списке задач (занимая место других инструментов), можно просто сказать агенту: «Вот параметры для задачи, а выполнять её будет вот этот делегат».

Нейросеть планирует вызов, зная только то, что нужно *подать на вход*. А сложный результат будет создан уже внутри изолированной «комнаты» делегата. Это позволяет агенту планировать длинные цепочки действий, не пытаясь загрузить в голову чертежи каждой детали на каждом шаге. Нейросеть просто доверяет, что специалист сделает свою работу правильно.

## Способы вызова делегата

Любой Инструмент становится Делегатом, как только у него появляется свойство `_delegate`. Вопрос лишь в том, *когда* система обращается к этому специалисту. Есть два способа, которые позволяют выбирать между безопасностью и гибкостью.

### 1. Вызов во время исполнения (по умолчанию)

Самый гибкий подход — найти и вызвать специалиста уже **во время исполнения**, после того как агент решил его использовать.

Этот метод позволяет делать то, что невозможно в обычном программировании: **нейросеть выступает в роли умного «переводчика»**. Агент может попросить специалиста что-то сделать, даже если его просьба не совсем точно соответствует инструкции специалиста. Во время исполнения система берёт запрос агента и инструкцию специалиста, и уже другая нейросеть (внутри «чистой комнаты») пытается понять, как выполнить эту просьбу, даже если форматы не совпадают.

Это огромное преимущество. Специалисты могут меняться и обновляться, но агенты, которые их вызывают, не сломаются. Нейросеть попытается адаптировать старый запрос к новой инструкции. Это делает систему очень устойчивой.

Процесс выглядит так:

1.  Агент решает вызвать модульный Инструмент.
2.  Исполнитель видит свойство `_delegate` и запускает протокол.
3.  **Сборка контекста**: Исполнитель находит файл делегата и готовит для него «чистую комнату». Затем он использует `_scopes`, чтобы передать туда нужные данные от родительского агента.
4.  **Передача данных**: Параметры из запроса агента упаковываются и передаются делегату. Здесь и происходит «магия»: нейросеть-помощник внутри «комнаты» использует эти данные, чтобы выполнить задачу, даже если их формат не совпадает идеально.
5.  **Исполнение**: Запускается новый, изолированный `Запрос`. Его результат возвращается как ответ на первоначальный вызов.

### 2. Предварительный вызов (опционально)

В ситуациях, где нужна строгая надёжность, делегата можно подготовить **заранее**, ещё до того, как основной запрос попадёт к агенту.

В этом режиме система заранее загружает инструкцию делегата и «склеивает» её с описанием Инструмента. Так нейросеть главного агента сразу видит точные требования специалиста и может подготовить идеально правильный запрос. Что важно, таким же образом можно заранее узнать, какой именно результат вернёт делегат.

Этот подход похож на строгий контракт в программировании, где всё известно наперёд. Он менее гибкий, но очень надёжный и подходит для критически важных задач, где сюрпризы нежелательны.

## Композиция и повторное использование: Композитор и Звукорежиссёр

Делегаты позволяют создавать удивительные комбинации. Каждый `Запрос` может работать как отдельный сервис, а другие агенты могут управлять ими. Это создаёт иерархию: агенты высокого уровня занимаются общей стратегией, а специализированные задачи поручают делегатам-экспертам.

Представим себе двух специалистов: **`Композитора`** и **`Звукорежиссёра`**.

*   **`Звукорежиссёр`** — это эксперт низкого уровня. Он знает всё о физике звука и умеет работать с синтезаторами, чтобы создавать конкретные аудиофайлы.

*   **`Композитор`** — специалист среднего уровня. Его работа — сочинять музыку. Он использует свои собственные инструменты, чтобы придумать мелодию и структуру песни. А чтобы эту музыку можно было услышать, он обращается к `Звукорежиссёру`.

Это простая двухуровневая система. Но настоящая сила делегатов в том, как они могут динамически объединяться для решения разных задач.

Теперь добавим **`Продюсера`** — агента высокого уровня. Его цель — выпустить готовую пластинку. В зависимости от задачи, `Продюсер` может управлять своими специалистами по-разному:

> Sidenote:
> Такая структура позволяет гибко выстраивать работу. Продюсер высокого уровня может поручить задачу Композитору, который, в свою очередь, использует Звукорежиссёра. Но Продюсер также может обойти Композитора и обратиться к Звукорежиссёру напрямую для выполнения специфических задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> Звукорежиссёр
>     Композитор --> Звукорежиссёр
> ```
>

- **Иерархическое управление**: Чтобы создать песню, `Продюсер` может просто обратиться к `Композитору` с общей идеей («Нужна грустная баллада»). `Композитор` сам выполнит всю свою работу, включая вызовы `Звукорежиссёра`. В этом случае `Продюсеру` даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельное управление**: Если `Продюсеру`, помимо песни, нужны звуковые эффекты (например, шум дождя), он может обратиться за этим напрямую к `Звукорежиссёру`, пока `Композитор` работает над музыкой.

Это показывает главный принцип: структура работы не зашита в инструментах. `Продюсер` может относиться к `Композитору` как к «чёрному ящику» или напрямую работать с его помощником (`Звукорежиссёром`) — всё зависит от текущей задачи. Это позволяет гибко комбинировать одних и тех же экспертов в разных сочетаниях, создавая очень мощную и адаптивную систему.

## От Делегатов к Памяти

Делегаты отлично подходят для изоляции отдельных задач. Но для сложных, многоэтапных проектов агенту нужна память. Ему нужен способ сохранять состояние между вызовами, чтобы отслеживать прогресс, учиться на ошибках и выполнять долгосрочные планы. Это мостик от отдельных действий к осмысленному, последовательному поведению.

Следующий документ, [009: Агент/Состояние](./009_agent_state.md), описывает, как управлять этой постоянной памятью.
