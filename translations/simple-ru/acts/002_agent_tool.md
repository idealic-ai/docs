# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Это описание способности, которую может использовать агент. Представьте себе кнопку в приложении. Описание говорит ИИ, что эта кнопка делает, какая информация ей нужна для работы, и что произойдёт после нажатия. ИИ «нажимает» на эту кнопку, создавая :term[Вызов]{canonical="Call"} с нужными параметрами. Этот вызов выполняется либо «в уме» самого ИИ (скрытое исполнение), либо с помощью отдельного кусочка кода (:term[Действие]{canonical="Activity"}).

> Sidenote:
> - Требуется: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это как чертёж или инструкция, которая описывает какое-то действие, доступное агенту. Это своего рода строительный блок для всего, что делает агент, позволяющий ИИ понимать и выбирать из «меню» возможных действий.

## Что такое Инструменты?

**Инструменты — это основа** всех действий агента. Они дают ему новую суперспособность: **выбирать действие по ситуации**. Вместо того чтобы всегда использовать один и тот же подход, агент может посмотреть на задачу и выбрать самый подходящий инструмент из своего набора.

Что дают инструменты:

- **Понятные инструкции**: Чётко описанные возможности, которые агенты могут найти и понять.
- **Надёжность**: Ясные правила для того, что подаётся на вход и что получается на выходе. Меньше ошибок.
- **Возможность комбинировать**: Простые инструменты можно соединять вместе, чтобы выполнять сложные задачи.
- **Понятно для ИИ**: Описания сделаны так, чтобы языковая модель могла их проанализировать и выбрать нужный.

Когда агент заполняет все необходимые поля для Инструмента, он создаёт :term[Вызов]{canonical="Call"} — это как бы «заполненная» команда, готовая к исполнению.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Выбирали действия на лету**, в зависимости от ситуации.
- **Выбирали из нескольких вариантов** для достижения цели.
- **Использовали разные способы** для выполнения одной и той же задачи (например, искали информацию в Google или Яндексе).
- **Сочетали «мышление» ИИ с чёткими командами** в процессе принятия решений.

## Схема как инструкция

Система Инструментов построена на простом правиле: **Инструменты — это только описания**, которые говорят, *что* можно сделать, но не *как*. Разделение «что» и «как» — ключ к гибкости всей системы.

Представьте, что `Инструмент` — это рецепт. Любое поле без знака `_` в начале — это ингредиент. А специальные системные поля (с `_`) — это служебная информация, которая помогает системе понять, что это за рецепт и как с ним работать.

Описание (схема) Инструмента полностью объясняет, что он делает:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с функцией в коде для явного исполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Передаёт выполнение инструмента другому, изолированному агенту. См. :term[014: Агент/Делегат]{href="./014_agent_delegate.md"}
> - **`_outputPath`**: Cохраняет результат работы инструмента, делая его «запоминающим». См. :term[008: Агент/Вывод]{href="./008_agent_output.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. См. :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **`title`**: Название блюда (необязательно).
- **`description`**: Описание того, что это за блюдо.
- **`properties`**: «Ингредиенты», которые нужны инструменту.
- **`_tool`**: Уникальный номер рецепта, чтобы не перепутать его с другими.
- **`_output`**: Как должно выглядеть готовое блюдо (результат).
- **`_reasoningForCall`**: Место, куда ИИ может записать, почему он выбрал именно этот рецепт.

Более сложные системы уже на основе этих простых «рецептов» выстраивают целые процессы: управляют этапами готовки, следят за состоянием и решают, что делать дальше.

## Определение Инструмента

Инструменты описываются с помощью схем в формате JSON. Пример ниже показывает `Инструмент` для определения эмоциональной окраски текста. Этот `Инструмент` рассчитан на скрытое исполнение — то есть ИИ сам справляется с задачей, используя своё понимание языка, и ему не нужна внешняя программа.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует эмоциональную окраску текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода от ИИ"}

```json
// Запрос: "Какая эмоциональная окраска у фразы 'Это лучше всех!'"
{
  "_tool": "sentimentAnalysis",
  "text": "Это лучше всех!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Переопределение Инструментов

Инструменты распознаются по их уникальному имени `_tool`. Если в одном запросе встречается несколько описаний для одного и того же инструмента, **приоритет получает самое последнее**.

Это правило «кто последний, тот и прав» позволяет делать интересные вещи:

- **Стандартные и новые правила**: Агенту можно дать набор стандартных инструментов, а потом для конкретной задачи добавить новую, улучшенную версию одного из них.
- **Адаптация под ситуацию**: Прямо во время диалога можно изменить описание инструмента, чтобы он лучше подходил к текущей задаче.

Когда возникает такой конфликт, старое описание просто игнорируется и не показывается ИИ.

## Сборка схем для ИИ

Агент не просто работает с инструментами. Часто ему нужно выдать какой-то финальный, структурированный ответ, когда задача решена. Для этого система берёт схемы всех доступных :term[Инструментов]{canonical="Tool"} и добавляет к ним схему для итогового ответа (`_output schema`). Получается одно большое «меню», которое передаётся ИИ в составе :term[Запроса]{canonical="Request"}.

Это «меню» даёт ИИ выбор, как ответить. В зависимости от задачи, он может:

- **Использовать только инструменты (`meta` и `calls`)**: Если задача сложная и требует нескольких шагов, ИИ будет вызывать инструменты, обновлять версию :term[Идеи]{canonical="Idea"} в `meta`, а поле для финального ответа `output` оставит пустым.
- **Дать сразу ответ (`meta` и `output`)**: Если на вопрос можно ответить сразу, ИИ запишет результат в `output`, обновит `meta`, а список вызовов `calls` оставит пустым.
- **Сделать всё сразу**: Иногда ИИ может выполнить действие и сразу же выдать финальный результат за один шаг.

Чтобы ИИ не путался и не пытался «придумать» лишнего, система умным образом меняет схему инструмента в зависимости от того, как он должен работать.

- Если :term[Инструмент]{canonical="Tool"} **скрытый** (не связан с реальным кодом, :term[Действием]{canonical="Activity"}), то ИИ показывают схему его результата `_output`, потому что именно ИИ должен этот результат сгенерировать.
- Если :term[Инструмент]{canonical="Tool"} **явный** (за ним стоит :term[Действие]{canonical="Activity"}), то его поле `_output` **динамически убирается** из схемы перед отправкой ИИ. Это создаёт чёткое правило: задача ИИ — просто правильно подготовить данные для инструмента. Информация о том, что вернёт инструмент, должна быть в его общем `description`, чтобы ИИ мог планировать свои действия, но не пытался сам заполнить поле с результатом.

Такой подход позволяет одной и той же системе обрабатывать как простые запросы с мгновенным ответом, так и сложные задачи с использованием множества инструментов. Разработчик просто даёт системе схемы :term[Инструментов]{canonical="Tool"} и схему итогового ответа, а система сама собирает их в понятную для ИИ структуру, чтобы он мог решить, как действовать лучше всего.

Пример ниже показывает, как собираются вместе схема :term[Инструмента]{canonical="Tool"} и схема итогового ответа.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Настройки запроса (модель, температура и т.д.)
  {
    // Схема для итогового ответа
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст (доступные инструменты и сам запрос)
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'какой-то запрос здесь' },
  ]
);
```

:::
:::column{title="Собранная схема (для ИИ)"}

```json
{
  "type": "object",
  "properties": {
    "meta": {
      "type": "object",
      "description": "Метаданные об идее, включая версию и идентификатор. Ожидается, что ИИ будет обновлять их, например, повышая версию.",
      "properties": {
        "path": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["meta", "calls", "output"]
}
```

:::
::::

## Расширение Инструментов с помощью мета-свойств

Помимо основных параметров, инструкцию к инструменту можно дополнять прямо в момент его вызова. Это позволяет добавлять новые «слои» поведения к одному и тому же инструменту.

Когда агент решает использовать инструмент, он создаёт :term[Вызов]{canonical="Call"} — конкретную команду. Этот :term[Вызов]{canonical="Call"} содержит параметры для инструмента, но его можно дополнить специальными мета-свойствами (с префиксом `_`), которые дают дополнительные указания для системы. Эти свойства управляют тем, *как* выполнить действие, а не только *что* сделать.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет использовать один и тот же простой инструмент очень гибко. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая говорит, *что* делать (инструмент и его параметры) и *как* это делать (мета-свойства). Теперь остаётся понять, какими способами этот :term[Вызов]{canonical="Call"} может быть исполнен.

## Скрытое и Явное исполнение

Когда :term[Вызов]{canonical="Call"} создан, системе нужно его выполнить. Сам по себе `Инструмент` — это лишь описание, в нём нет кода. Его выполнение может происходить двумя способами. По умолчанию используется **скрытое исполнение**, когда ИИ сам «придумывает» результат, что идеально для задач, связанных с языком или знаниями. Но для действий, которые требуют взаимодействия с внешним миром — например, вызова API или доступа к базе данных — `Инструмент` должен быть соединён с реальной функцией в коде. Такое явное исполнение называется **:term[Действие]{canonical="Activity"}**.

Разделение описания :term[Инструмента]{canonical="Tool"} от кода :term[Действия]{canonical="Activity"} — это ключевой принцип. Он позволяет агенту рассуждать о своих возможностях в общих чертах, в то время как конкретный способ их выполнения можно менять или обновлять независимо. Документ :term[003: Агент/Действие]{href="./003_agent_activity.md"} описывает, как :term[Действия]{canonical="Activity"} обеспечивают реальную логику для :term[Инструментов]{canonical="Tool"}.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
