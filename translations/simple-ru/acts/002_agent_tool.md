# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Это как инструкция, которая описывает, что может делать агент. Она передаётся большому искусственному интеллекту (LLM), чтобы он понял, какое действие можно совершить. Это как меню в ресторане для ИИ. ИИ использует этот инструмент, создавая :term[Вызов]{canonical="Call"} — это как сделать заказ с конкретными пожеланиями. Этот заказ выполняется либо самим ИИ (— это называется скрытое исполнение), либо специальной программой (— это :term[Действие]{canonical="Activity"}).

> Sidenote:
> - Требуется: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это, по сути, чертёж или инструкция (схема), которая описывает, что именно может делать агент. Это как кирпичик, из которого строятся все действия агента. Инструмент даёт ИИ «меню» с возможными действиями, чтобы тот мог понять их и выбрать нужное.

## Что такое Инструменты?

**Инструменты — это фундамент** для всех действий агента. Они дают ему новую суперспособность: **выбирать действие в зависимости от ситуации**. Это позволяет агентам подбирать правильное поведение для каждой конкретной задачи.

Что дают Инструменты:

- **Чёткие инструкции**: Описанные по правилам возможности, которые агенты могут найти и понять.
- **Понятные правила**: Точные «договоры» о том, какие данные нужны на входе и что получится на выходе.
- **Возможность собирать как конструктор**: Отдельные кирпичики можно соединять, чтобы создавать сложное поведение агента.
- **Понятность для ИИ**: Инструкции, которые большие языковые модели могут анализировать и выбирать.

Когда агент заполняет все нужные поля в Инструменте, он создаёт :term[Вызов]{canonical="Call"} — это экземпляр Инструмента со всеми заполненными параметрами. Это как готовая к отправке анкета с конкретной просьбой выполнить действие.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Выбирали действия на лету**, в зависимости от контекста и ситуации.
- **Выбирали из нескольких вариантов** для достижения цели.
- **Использовали разные способы** для одной и той же задачи (например, разные поисковые системы).
- **Совмещали размышления ИИ с точными командами** в процессе принятия решений.

## Схема как интерфейс

Система Инструментов построена на простом правиле: **Инструменты — это только «чертежи»**, которые описывают возможности, но не указывают, как именно их выполнять. Это разделение «что делать» и «как делать» — ключ к гибкости всей системы. Это похоже на пульт от телевизора: на нём есть кнопки (интерфейс), а сам механизм переключения каналов находится внутри телевизора (реализация).

Схема `Инструмента` — это обычный объект JSON Schema. Любое поле без знака подчёркивания в начале считается параметром для инструмента. Система использует специальные мета-поля (начинающиеся с `_`), чтобы задать системные свойства, которые управляют работой инструмента.

Схема Инструмента полностью описывает его интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с функцией в коде для явного выполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Передаёт выполнение инструмента изолированному внешнему исполнителю. См. :term[014: Агент/Делегат]{href="./014_agent_delegate.md"}
> - **`_outputPath`**: Делает инструмент «запоминающим», записывая его результат в постоянный объект данных. См. :term[008: Агент/Вывод]{href="./008_agent_output.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. См. :term[013: Агент/Инстансинг]{href="./013_agent_instancing.md"}

- **`title`**: Понятное человеку название схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`properties`**: Любые поля без знака подчёркивания описывают, какие данные нужны инструменту на входе.
- **`_tool`**: Уникальное имя для идентификации инструмента.
- **`_output`**: Описывает, как должен выглядеть результат работы инструмента.
- **`_reasoningForCall`**: Поле, которое система добавляет, чтобы агент объяснил, почему он выбрал этот инструмент.

Более сложные системы могут управлять целыми цепочками задач, состояниями и правилами выполнения, опираясь на эти простые «кирпичики».

## Определение Инструмента

Инструменты описываются с помощью JSON-схем. В примере ниже показан `Инструмент` для анализа тональности текста. Этот `Инструмент` рассчитан на скрытое исполнение, так как он полагается на собственное понимание языка ИИ и не требует внешней программы.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода от ИИ"}

```json
// Запрос: "Какая тональность у фразы 'Это лучше всего!'"
{
  "_tool": "sentimentAnalysis",
  "text": "Это лучше всего!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Сборка схем для ИИ

Агент не просто использует инструменты. Часто ему нужно выдать конечный, аккуратно оформленный результат, когда задача выполнена. Для этого система берёт инструкции всех доступных :term[Инструментов]{canonical="Tool"} и добавляет к ним схему для финального ответа, которую задаёт пользователь. В итоге получается одна большая, общая схема, которая передаётся ИИ в :term[Запросе]{canonical="Request"}.

Эта общая схема даёт ИИ выбор, как ответить. В зависимости от задачи, он может:

- **Создать только `meta` и `calls`:** Если для ответа нужно сначала сделать какие-то шаги, ИИ вызовет один или несколько инструментов, обновит версию :term[Идеи]{canonical="Idea"} в объекте `meta` и оставит поле `output` пустым (`null`).
- **Создать только `meta` и `output`:** Если на вопрос можно ответить сразу, без инструментов, ИИ предоставит конечный результат в поле `output`, обновит `meta` и оставит `calls` пустым.
- **Создать всё сразу:** В некоторых случаях ИИ может выполнить действие и сразу же выдать финальный ответ за один шаг, обновив `meta`.

Чтобы избежать путаницы и ошибок со стороны ИИ, система умно изменяет схему инструмента в зависимости от того, как он будет выполняться.

- Если :term[Инструмент]{canonical="Tool"} **скрытый** (за ним не стоит конкретная программа — :term[Действие]{canonical="Activity"}), его схема `_output` включается в запрос как есть, ведь результат генерирует сам ИИ.
- Если :term[Инструмент]{canonical="Tool"} **явный** (связан с :term[Действием]{canonical="Activity"}), то его свойство `_output` **автоматически удаляется** из схемы перед отправкой ИИ. Это создаёт чёткое правило: единственная задача ИИ — предоставить правильные входные данные для инструмента. Информация о том, что вернёт инструмент, должна быть в его описании (`description`), чтобы помочь ИИ планировать свои действия, но не давать ему поле, которое он может по ошибке заполнить.

Этот механизм позволяет использовать единый подход как для простых ответов в один шаг, так и для сложных задач, требующих нескольких инструментов. Разработчик просто предоставляет схемы :term[Инструментов]{canonical="Tool"} и схему для финального ответа, а система объединяет их в структуру, которую ИИ может использовать для принятия наилучшего решения.

Пример ниже показывает, как собираются вместе схема :term[Инструмента]{canonical="Tool"} и схема для ответа.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация запроса (например, модель, температура)
  {
    // Схема для ответа
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то запрос' },
  ]
);
```

:::
:::column{title="Собранная Схема (для ИИ)"}

```json
{
  "type": "object",
  "properties": {
    "meta": {
      "type": "object",
      "description": "Метаданные об идее, включая версию и идентификатор. Ожидается, что ИИ обновит их, например, увеличив версию.",
      "properties": {
        "path": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["meta", "calls", "output"]
}
```

:::
::::

## Улучшение Инструментов с помощью мета-свойств

Помимо основных параметров, инструмент можно «улучшить» прямо в момент его вызова. Это другой способ сборки, когда к одному инструменту добавляются новые «слои» поведения.

Когда агент решает использовать инструмент, он создаёт :term[Вызов]{canonical="Call"} — конкретный экземпляр этого инструмента. :term[Вызов]{canonical="Call"} включает в себя параметры для инструмента, но его также можно дополнить специальными мета-свойствами (начинающимися с `_`), которые дают дополнительные инструкции системе выполнения. Эти свойства управляют тем, как именно будет работать инструмент, выходя за рамки его базового описания.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет использовать простую базовую схему инструмента множеством мощных и гибких способов. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последний кусочек пазла — понять, какими способами :term[Вызов]{canonical="Call"} может быть выполнен.

## Скрытое и явное исполнение

Когда :term[Вызов]{canonical="Call"} создан, система должна его выполнить. Схема `Инструмента` — это всего лишь описание, она не содержит кода для выполнения. Вместо этого, выполнение может происходить двумя способами. По умолчанию используется **скрытое исполнение**, когда ИИ использует свои собственные знания для генерации результата — это идеально подходит для задач, связанных с языком или знаниями. Для действий, которые требуют взаимодействия с внешним миром — например, вызова API или доступа к базе данных — `Инструмент` должен быть связан с конкретной функцией в коде. Такое явное исполнение называется **:term[Действием]{canonical="Activity"}**.

Разделение интерфейса :term[Инструмента]{canonical="Tool"} и его реализации в виде :term[Действия]{canonical="Activity"} — это ключевой принцип системы. Он позволяет описывать и продумывать возможности агента в общих чертах, в то время как код, который их выполняет, можно менять или обновлять независимо. Следующий документ, :term[003: Агент/Действие]{href="./003_agent_activity.md"}, описывает, как :term[Действия]{canonical="Activity"} предоставляют конкретную логику для :term[Инструментов]{canonical="Tool"}.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
