# 012: Агент/Экземплирование

> [!DEFINITION] [Экземплирование](./000_glossary.md)
> Это правило, по которому похожие задачки можно сгруппировать, дав каждой свой уникальный номер. Так создаются отдельные :term[экземпляры]{canonical="Instance"} в рамках одного большого запроса, что позволяет выполнять много вычислений одновременно, не путая их между собой.

> Sidenote:
> - Требует: :term[009: Агент/Состояние]{href="./009_agent_state.md"}
> - Совместим с:
>   - :term[006: Агент/Входные данные]{href="./006_agent_input.md"}
>   - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}
>   - :term[011: Агент/План]{href="./012_agent_plan.md"}

**Протокол Экземплирования** — это очень крутой способ ускорить работу агентов, позволяя им выполнять много задач одновременно в рамках одного запроса. Представь, что агент — это повар, который готовит сразу несколько блюд по одному рецепту. Каждое блюдо — это отдельный «экземпляр». Агенту не нужно менять свой основной рецепт (логику), чтобы работать с каждым блюдом отдельно. Это достигается тем, что мы связываем сообщения с контекстом, такие как :term[Состояние]{canonical="State"} или :term[Входные данные]{canonical="Input"}, с уникальными номерами экземпляров. В результате один и тот же :term[План]{canonical="Plan"} можно выполнять для множества экземпляров параллельно. Этот протокол очень гибкий и поддерживает любые комбинации сообщений, что сильно повышает скорость и качество работы.

## Как работает Экземплирование

Экземплирование позволяет обрабатывать много разных наборов данных одновременно, просто добавляя новый слой к сообщениям, которые несут эти данные, например, к :term[Состоянию]{href="./009_agent_state.md"}. Вместо того чтобы передавать одно сообщение о :term[состоянии]{canonical="State"}, запрос может содержать целый список таких сообщений, где каждое описывает отдельный :term[экземпляр]{canonical="Instance"} задачи.

Чтобы управлять этими одновременными задачами, каждому сообщению о :term[состоянии]{canonical="State"} присваивается **уникальный номер** через специальное свойство `_instance`. Эти номера — короткие и уникальные значки (например, `①`, `②`), которые позволяют ИИ понимать, какая операция к какому :term[экземпляру]{canonical="Instance"} относится.

Экземплирование — это опция, которую можно включить для каждого сообщения отдельно. Добавляя свойство `_instance` к сообщению с данными, например :term[Состоянию]{canonical="State"} или :term[Входным данным]{canonical="Input"}, отправитель говорит: «Это сообщение — отдельная, независимая задача». Если `_instance` не указан, сообщение считается общим для всех экземпляров.

Такой подход дает большие преимущества:

- **Скорость**: Он многократно увеличивает производительность системы, обрабатывая множество экземпляров за один запрос к ИИ.
- **Качество**: Позволяя ИИ видеть сразу несколько похожих экземпляров, он помогает создавать более последовательные и качественные планы.

## Совместная работа с сообщениями контекста

Вся сила протокола в том, как номер `_instance` влияет на поведение разных типов сообщений.

- **:term[Состояние]{caonical="State"}:** Сообщение о :term[состоянии]{canonical="State"} — это основа всего. Каждый :term[экземпляр]{canonical="Instance"} — это отдельное сообщение о :term[состоянии]{canonical="State"} со своим уникальным номером `_instance`. Это как отдельный холст для каждой задачи, что гарантирует, что параллельные процессы не будут мешать друг другу.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Входные данные]{canonical="Input"}:** Сообщение с :term[входными данными]{canonical="Input"} можно использовать двумя способами. Общее сообщение (без номера `_instance`) задает настройки сразу для всех экземпляров. А целевое сообщение (с номером `_instance`) передает данные для конкретного :term[состояния]{canonical="State"}, заменяя собой общие настройки.

  > Sidenote:
  > - :term[006: Агент/Входные данные]{href="./006_agent_input.md"}

- **:term[Области видимости]{canonical="Scope"}:** Номер `_instance` очень важен для изоляции данных в :term[областях видимости]{canonical="Scope"}. Когда :term[Вызов]{canonical="Call"} нацелен на конкретный экземпляр, его `_scopes` (данные, которые он может видеть) тоже ограничиваются только этим экземпляром. Именно поэтому :term[Делегат]{canonical="Delegate"} видит только ту информацию, которая нужна для его маленькой задачи, даже если он работает как часть большого запроса с множеством экземпляров.

  > Sidenote:
  > - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}

:::details{title="Пример: Модерация комментариев в большом объеме"}

Экземплирование превращает агентов, выполняющих одну задачу, в мощные машины для массовой обработки. Представь себе агента, который проверяет комментарии пользователей на соответствие правилам сообщества.

Без экземплярования агент работал бы по очереди. Чтобы проверить 100 комментариев, ему понадобилось бы 100 отдельных :term[запросов]{canonical="Request"}. Это не только медленно, но и неэффективно: агент оценивает каждый комментарий в отрыве от других, что может приводить к разным решениям по похожим комментариям.

С **Протоколом Экземплирования** вся работа выполняется параллельно в рамках одного :term[запроса]{canonical="Request"}.

1.  **Пакет данных**: Агент получает `context`, в котором лежит список из 100 сообщений с :term[входными данными]{canonical="Input"}. Каждому сообщению присвоен уникальный номер `_instance` и в нем содержится один комментарий пользователя.

    ```json
    // Пакет сообщений с входными данными, переданный ИИ
    [
      {
        "type": "input",
        "_instance": "①",
        "comment": "Это отличный пост!"
      },
      {
        "type": "input",
        "_instance": "②",
        "comment": "Я не согласен с этим..."
      },
      {
        "type": "input",
        "_instance": "③",
        "comment": "Это спам."
      }
      // ... и еще 97 экземпляров комментариев
    ]
    ```

2.  **Параллельное выполнение плана**: Теперь ИИ видит всю пачку комментариев сразу. Он может использовать один :term[план]{canonical="Plan"}, который описывает два шага: сначала проанализировать настроение, а потом проверить по списку запрещенных слов. Этот один и тот же план применяется ко всем экземплярам.

3.  **Целевой результат**: :term[Решение]{canonical="Solution"} агента будет содержать один плоский список :term[вызовов]{canonical="Call"}, но каждый `Call` будет направлен на конкретный комментарий с помощью свойства `_instance`.

    ```json
    // Решение, сгенерированное ИИ
    {
      "calls": [
        {
          "_tool": "moderateComment",
          "_instance": "①",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "②",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "③",
          "decision": "reject"
        }
        // ... и еще 97 вызовов для модерации
      ]
    }
    ```

Такой подход дает два огромных плюса:

- **Скорость**: То, что раньше требовало 100 отдельных обращений к ИИ, теперь делается за одно.
- **Качество**: Видя всю пачку комментариев, ИИ получает больше контекста. Он может принимать более взвешенные решения и даже замечать закономерности (например, скоординированную спам-атаку), которые были бы невидимы при обработке по одному.

:::

:::::details{title="Общие входные данные и отдельные состояния"}

Этот пример показывает, как общее сообщение `Input` может направить внимание агента на один конкретный экземпляр из большой группы. Это позволяет гибко управлять параллельными задачами, превращая простой обработчик в сложного дирижера, похожего на менеджера, который раздает указания отдельным сотрудникам.

::::columns
:::column{title="Контекст"}

Представим себе менеджера, который руководит сотрудниками. Одно общее сообщение `input` — это как общая команда, а несколько сообщений `state` с номерами — это как сотрудники со своими личными задачами. Эта схема показывает, как агент, созданный для управления одним объектом, легко может управлять многими, не меняя своей основной логики.

```json
[
  // Общая инструкция для конкретного сотрудника
  {
    "type": "input",
    "instruction": "Дай сотруднику B новую, срочную задачу 'Завершить квартальный отчет'."
  },

  // Текущее состояние всех сотрудников
  {
    "type": "state",
    "_instance": "employee_A",
    "task": "Написать черновик предложения",
    "status": "В процессе"
  },
  {
    "type": "state",
    "_instance": "employee_B",
    "task": "Проверить сданные отчеты",
    "status": "Заблокирован"
  }
]
```

:::
:::column{title="Целевое решение"}

Хотя сообщение `Input` было общим, ИИ правильно понял команду, написанную обычным языком. Он создал `Call`, который точно нацелен на `employee_B` с помощью свойства `_instance`, показывая свою способность грамотно распределять команды. Другой «сотрудник» вообще не был затронут.

```json
{
  "calls": [
    {
      "_tool": "updateTask",
      "_instance": "employee_B",
      "newTask": "Завершить квартальный отчет",
      "newStatus": "Высокий приоритет",
      "output": "†state"
    }
  ]
}
```

:::
::::
:::::

## Взаимодействие с другими системами

Экземплирование работает вместе с другими протоколами для управления ходом выполнения.

- **:term[Вызовы]{canonical="Call"}:** Свойство `_instance` в :term[вызове]{canonical="Call"} — это главный механизм, который направляет его действие. Оно гарантирует, что все изменения состояния — будь то запись результата в :term[выходной путь]{canonical="Output Path"} или чтение данных из состояния для использования — будут применены к нужному :term[экземпляру]{canonical="Instance"}.

  > Sidenote:
  > - [008: Агент/Выходные данные](./008_agent_output.md)

- **:term[План]{canonical="Plan"}:** Сообщение с :term[планом]{canonical="Plan"} не делится на экземпляры; оно работает как единый, общий шаблон для всего процесса. Его можно использовать вместе с несколькими сообщениями о :term[состоянии]{canonical="State"} с номерами, что позволяет один и тот же план выполнять одновременно для множества разных наборов данных за один раз.

  > Sidenote:
  > - :term[011: Агент/План]{href="./012_agent_plan.md"}

## От Плана к Процессу

Если :term[План]{canonical="Plan"} — это многоразовый шаблон для работы, а :term[Экземплирование]{canonical="Instancing"} — это способ выполнить его в большом масштабе, то **:term[Идея-Процесс]{href="./203_idea_process.md"}** — это то, что получается в итоге. Это полная, самостоятельная запись о плане и его текущем состоянии выполнения по всем экземплярам.
