# 013: Агент/Делегат

> [!DEFINITION] [Делегат](./000_glossary.md)
> Это способ выполнить задачу в отдельной, изолированной «песочнице». Он запускается, когда у :term[Вызова]{canonical="Call"} есть свойство `_delegate`. Этот способ позволяет выполнить :term[Действие]{canonical="Activity"} или новый :term[Запрос]{canonical="Request"} в своей собственной среде, а свойство `_scopes` даёт контролируемый доступ к данным родительского агента.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
> - Дополняется:
>   - :term[014: Агент/Области видимости]{href="./014_agent_scopes.md"}

Принцип **Делегирования** решает важную задачу: как расширять возможности агентов и собирать их вместе, словно из кубиков конструктора. Он даёт мощный механизм для выполнения :term[Инструментов]{canonical="Tool"} в изолированных «песочницах», чтобы они не путались в информации друг друга и их можно было использовать снова и снова. Передавая (делегируя) :term[Вызов]{canonical="Call"} внешнему делегату — будь то другой :term[Запрос]{canonical="Request"} или :term[Действие]{canonical="Activity"} в подзапросе — система может создавать сложное поведение агентов из маленьких, независимых и самодостаточных частей.

## Проблема: Огромные инструменты и путаница в данных

Когда у агента появляется всё больше способностей, хранить все его :term[Инструменты]{canonical="Tool"} в одном большом файле становится неудобно и неэффективно.

1.  **Слишком большие инструкции**: У больших языковых моделей есть предел того, сколько информации они могут понять за раз. Если дать им слишком много сложных :term[Инструментов]{canonical="Tool"} одновременно, они могут запутаться и не смогут правильно выбрать нужный.
2.  **Путаница в данных**: Когда все :term[Инструменты]{canonical="Tool"} работают в одной общей среде, модель может отвлечься на ненужную информацию и сделать ошибку: выбрать не тот :term[Инструмент]{canonical="Tool"} или неправильно его использовать.
3.  **Сложно использовать повторно**: :term[Инструмент]{canonical="Tool"}, созданный для одного агента, трудно «пересадить» другому, не захватив с собой всю его старую среду.

Делегирование решает эти проблемы, вводя **Изоляцию через делегирование** — способ передать :term[Вызов]{canonical="Call"} во внешнюю, изолированную среду для выполнения.

## Как вызвать Делегата

О том, что задачу нужно делегировать, говорит свойство `_delegate` в схеме :term[Инструмента]{canonical="Tool"}. Это свойство — команда для системы, что :term[Вызов]{canonical="Call"} нужно не выполнять на месте, а передать внешнему исполнителю — делегату.

Свойство `_delegate` — это `строка`, и его можно использовать двумя способами:

- **Указать на сохранённый :term[Запрос]{canonical="Request"}**: Строка может быть путём или ссылкой на JSON-файл, который описывает готовый :term[Запрос]{canonical="Request"} — со своими `context` и `schema`. Это позволяет :term[Инструменту]{canonical="Tool"} передать свою работу совершенно другому набору инструкций.

  > Sidenote:
  > Сохранённый, многоразовый :term[Запрос]{href="./001_agent_request.md"} — это самая распространённая форма :term[Идеи]{canonical="Idea"}. Принцип Делегирования — это основной механизм для сборки этих :term[Идей]{canonical="Idea"} в более сложные системы. Подробнее смотрите в :term[101: Концепция/Идея]{href="./101_concept_idea.md"}.

- **Создать анонимного делегата**: Если в строке написано `'anonymous'`, это сигнал создать анонимного делегата. Так можно создать новую, чистую среду для выполнения :term[Вызова Инструмента]{canonical="Tool Call"} «на лету», без необходимости создавать отдельный JSON-файл. Система автоматически создаст для :term[Вызова]{canonical="Call"} новый, пустой контекст.

## Выполнение в изолированной среде

Делегат предоставляет «чистую комнату» для работы. Вместо того чтобы выполняться в шумном и занятом окружении родительского агента, :term[Вызов]{canonical="Call"} обрабатывается в новой, обособленной сессии. Контекст для этого подзапроса не наследуется, а тщательно создаётся с нуля.

Именно здесь ключевую роль играет :term[контекст с ограниченной областью видимости]{canonical="scope" href="./014_agent_scopes.md"}. Свойство `_scopes` в схеме :term[Инструмента]{canonical="Tool"} работает как мост, явно указывая, какие именно части родительского контекста нужно «пропустить» в рабочую область делегата. Это даёт родительскому агенту точный контроль над тем, что видит делегат, предотвращая путаницу в данных и обеспечивая настоящую изоляцию.

> Sidenote:
> - :term[014: Агент/Области видимости]{href="./014_agent_scopes.md"}

## Работа с большими инструкциями

Делегирование также помогает управляться с :term[Инструментами]{canonical="Tool"}, которые возвращают очень много данных. Вместо того чтобы включать огромную схему `_output` в основной запрос (что может «забить» всё место), можно описать :term[Инструмент]{canonical="Tool"} только с его входными параметрами `input` и указателем `_delegate`.

Нейросеть сможет спланировать :term[Вызов]{canonical="Call"}, зная только, что нужно подать на вход, а вся сложная работа по генерации результата произойдёт внутри изолированного подзапроса делегата. Это позволяет агенту продумывать последовательность сложных действий, не видя подробных инструкций для каждого шага в одном окне. Нейросеть просто доверяет, что делегат вернёт правильный результат, который она получит и сможет использовать дальше.

## Как система находит делегатов

:term[Инструмент]{canonical="Tool"} становится :term[Делегатом]{canonical="Delegate"}, как только в его схеме появляется свойство `_delegate`. Это сигнал, что :term[Вызов]{canonical="Call"} нужно передать дальше. Главный вопрос — *когда* система находит и подключает этого делегата. Есть два способа, которые позволяют выбирать между строгой безопасностью и гибкостью.

### 1. Подключение во время выполнения (по умолчанию)

Самый гибкий и стандартный подход — находить делегата **во время выполнения**, уже после того, как агент сгенерировал :term[Вызов]{canonical="Call"}.

Этот метод позволяет делать то, что невозможно в обычном программировании: **нейросеть выступает в роли умного «клея»**. Агент может сгенерировать :term[Вызов]{canonical="Call"} с параметрами, которые не совсем точно совпадают с тем, что ожидает делегат в своей схеме `input`. Во время выполнения система собирает контекст делегата и данные от вызывающего агента, и уже нейросеть внутри подзапроса должна будет «сообразить», как их сопоставить.

Это большое преимущество, так как делегаты могут обновляться и развиваться независимо. Даже если делегат изменит свои входные параметры, агенты, которые его вызывают, не сломаются сразу. Нейросеть постарается адаптировать старый формат :term[Вызова]{canonical="Call"} к новой схеме `input`, создавая устойчивость и слабую связанность, уникальную для этой архитектуры.

Процесс выглядит так:

1.  Агент генерирует :term[Вызов]{canonical="Call"} к модульному :term[Инструменту]{canonical="Tool"}.
2.  Исполнитель видит свойство `_delegate` и начинает процесс делегирования.
3.  **Сборка контекста**: Исполнитель загружает файл с описанием делегата (если он не анонимный) и собирает его базовый контекст. Затем он использует `_scopes`, чтобы добавить нужные данные из контекста вызывающего агента.
4.  **Сопоставление входа**: Параметры из :term[Вызова]{canonical="Call"} упаковываются во :term[Входящее Сообщение]{canonical="Input Message"} и добавляются в контекст. Именно здесь и проявляется способность нейросети быть «клеем»: она будет использовать эти данные для выполнения логики делегата, даже если их структура не совпадает идеально.
5.  **Выполнение**: Создаётся новый, изолированный :term[Запрос]{canonical="Request"} с объединённым контекстом. Результат возвращается как итог исходного :term[Вызова]{canonical="Call"}.

### 2. Подключение заранее (опционально)

В ситуациях, где нужны более строгие правила, делегата можно подключить **заранее**, ещё до того, как первоначальный :term[Запрос]{canonical="Request"} будет отправлен агенту.

В этом режиме система заранее загружает описание :term[Запроса]{canonical="Request"} делегата и объединяет его схему `input` со схемой параметров самого :term[Инструмента]{canonical="Tool"}. Это позволяет нейросети агента сразу увидеть точные требования делегата и сгенерировать идеально правильный и корректный :term[Вызов]{canonical="Call"}. Важно, что при таком объединении можно также включить и схему `_output` делегата, обеспечив строгий «договор» о том, какой результат ожидать.

Этот подход даёт надёжность, как в традиционных API, где и входные, и выходные данные известны и проверены заранее. Но при этом теряется гибкость, поэтому такой способ лучше использовать для критически важных и чётко определённых задач, где «свобода творчества» нейросети не нужна.

:::::details{title="Пример: Гибкое сопоставление данных во время выполнения"}

Этот пример показывает, как работает концепция «нейросеть как клей», когда делегат может быть успешно выполнен, даже если :term[Вызов]{canonical="Call"} от агента не идеально совпадает с его ожидаемой схемой `input`. Это поведение по умолчанию, при подключении во время выполнения.

::::columns
:::column{title="Что видит вызывающий агент"}

Агенту-оркестратору нужно отправить сообщение. Он знает об :term[Инструменте]{canonical="Tool"} `sendMessage`, который передаёт задачу внешнему агенту по ссылке. Он создаёт :term[Вызов]{canonical="Call"} с параметрами `userId` и `text`, не зная, какие именно данные нужны тому внешнему агенту.

```json
// ВЫЗОВ, СГЕНЕРИРОВАННЫЙ ОРКЕСТРАТОРОМ
{
  "_tool": "sendMessage",
  "_delegate": "http://example.com/agents/speaker_EN",
  "userId": "u_123",
  "text": "Hello, world!"
}
```

:::
:::column{title="Что видит делегат и итоговый контекст"}

Делегат `speaker_EN` — это отдельное описание :term[Запроса]{canonical="Request"}. Во время выполнения система упаковывает параметры от вызывающего агента в свойство `input` :term[Входящего Сообщения]{canonical="Input Message"}. Но самое главное, она также включает собственную `schema` делегата, которая *не совпадает* с предоставленным `input`. Теперь задача нейросети делегата — преодолеть этот смысловой разрыв, умно догадавшись, что `userId` — это `recipientId`, а `text` — это `messageBody`. Это не программное преобразование, а смысловое сопоставление, которое происходит внутри нейросети.

```json
// ИТОГОВЫЙ КОНТЕКСТ ДЛЯ ПОДЗАПРОСА
[
  {
    "type": "system",
    "message": "Ты — эксперт по отправке сообщений на английском."
  },
  {
    "type": "input",
    // Это сырые данные, которые прислал вызывающий агент.
    "input": {
      "userId": "u_123",
      "text": "Hello, world!"
    },
    // А это формат, который ожидает делегат
    "schema": {
      "type": "object",
      "properties": {
        "recipientId": { "type": "string" },
        "messageBody": { "type": "string" }
      }
    }
  }
]
```

:::
::::
:::::

:::details{title="Пример: Создатели музыки"}

Делегаты позволяют создавать мощные комбинации, превращая описания :term[Запросов]{canonical="Request"} в самостоятельные сервисы, которыми могут управлять другие агенты. Это создаёт понятную и гибкую иерархию: агенты высокого уровня могут заниматься организацией процесса, передавая узкоспециализированные задачи агентам-делегатам более низкого уровня.

Представим процесс с двумя специалистами-делегатами: **`Композитором`** и **`Звукорежиссёром`**.

- **`Звукорежиссёр`** — это эксперт низкого уровня. Это самодостаточное описание :term[Запроса]{canonical="Request"}, которое знает всё о физике звука и умеет управлять синтезаторами для создания конкретных аудиофайлов.

- **`Композитор`** — специалист среднего уровня. Его главная задача — написать песню. Он использует свои собственные инструменты, чтобы придумать мелодию и структуру песни. Чтобы воплотить свою идею в жизнь, он делает :term[Вызовы]{canonical="Call"} к делегату `Звукорежиссёр`, чтобы тот создал настоящие звуки.

Такая двухуровневая иерархия — обычное дело. Но настоящая сила делегатов — в их динамичной, гибкой организации.

Теперь введём высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую музыкальную запись. В зависимости от задачи `Продюсер` может по-разному организовывать работу своих делегатов:

> Sidenote:
> Такая схема позволяет гибко управлять процессом. Высокоуровневый `Продюсер` может делегировать задачу `Композитору`, который в свою очередь использует `Звукорежиссёра`. Однако `Продюсер` также может обойти `Композитора` и напрямую взаимодействовать со `Звукорежиссёром` для выполнения определённых задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> Звукорежиссёр
>     Композитор --> Звукорежиссёр
> ```

- **Иерархическая организация**: Чтобы создать песню, `Продюсер` может сделать один :term[Вызов]{canonical="Call"} к делегату `Композитор`. `Продюсер` даёт общее направление («Мне нужна грустная баллада»), а `Композитор` выполняет всю свою внутреннюю работу, включая свои собственные вложенные :term[Вызовы]{canonical="Call"} к `Звукорежиссёру`. `Продюсеру` в этом случае даже не нужно знать о существовании `Звукорежиссёра`.

- **Параллельная организация**: Если `Продюсеру` также нужны особые звуковые эффекты для записи (например, шум шагов или фоновый звук), он может делать :term[Вызовы]{canonical="Call"} напрямую к `Звукорежиссёру` для этих задач, параллельно с тем, как он обращается к `Композитору`.

Это показывает главный принцип: структура взаимодействия не зашита в самих инструментах. `Продюсер` может либо рассматривать `Композитора` как «чёрный ящик», либо напрямую взаимодействовать с его составными частями (`Звукорежиссёром`) — всё зависит от текущей задачи. Эта гибкость позволяет одним и тем же экспертам-делегатам объединяться в разные комбинации, создавая невероятно гибкую и мощную систему.

:::

## От Делегирования к Областям видимости

Делегирование предоставляет изолированную среду, но чтобы она была полезной, делегату нужен способ получать информацию от своего родителя. Свойство `_scopes` как раз и является таким механизмом, работая как контролируемый мост между контекстами. Подробнее о том, как устроен этот мост, описано в правиле о :term[контексте с ограниченной областью видимости]{canonical="scope" href="./014_agent_scopes.md"}.
