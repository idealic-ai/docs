# 014: Агент/Мета

> [!DEFINITION] [Мета-свойства](./000_glossary.md)
> Это как «паспорт» для любого :term[Запроса]{canonical="Request"}. Он содержит всю важную информацию: имя, версию, дату создания и к каким версиям он относится. Этот «паспорт» помогает компьютерам точно знать, что это за запрос, откуда он взялся и как его найти.



Некоторые задачи для искусственного интеллекта (ИИ) — как короткий разговор: спросил, получил ответ и забыл. Но для сложных проектов, где нужно помнить, что было раньше, нам нужен способ отслеживать каждый :term[запрос]{href="./001_agent_request.md"} и его :term[решение]{href="./001_agent_request.md"}. Для этого и существует объект **`Мета`**.

Представь, что `Мета` — это визитная карточка запроса. На ней записана вся ключевая информация, которая помогает сохранять, обновлять и находить его. Самое интересное, что ИИ не просто использует эту «визитку», он сам может создавать новые или делать их копии для новых версий. Так простой ответ превращается в акт творения — создание чего-то нового и уникального.

## Объект `Мета` в жизненном цикле Запроса

Объект `Мета` — главный участник всего процесса работы с :term[Запросом]{href="./001_agent_request.md"}. Он появляется в `контексте`, чтобы ИИ знал, с чем работает, и в `схеме` как обязательная часть `решения`.

- **В `контексте`**: Сообщение `мета` сообщает ИИ «паспортные данные» задачи, которую он сейчас обновляет.
- **В `схеме`**: Правила (`схема`) требуют, чтобы у `решения` был `мета`-объект. Это заставляет ИИ подумать и обновить «паспортные данные» как часть своей работы.
- **В `решении`**: ИИ создаёт новый `мета`-объект, обычно с обновлённой версией, показывая, что задача развилась и перешла на новый этап.

Этот круговорот превращает ИИ из простого исполнителя в активного участника, который помогает развивать долгоживущие и версионируемые проекты.

> [!HEADSUP] На заметку: От Запроса к Идее
> Весь этот процесс — `контекст` (включая `Мета`), `схема` и итоговое `решение` — образует единое целое. Когда мы сохраняем этот «пакет», система называет его :term[Идеей]{href="./101_concept_idea.md"}. Именно `Мета`-объект является ключом, который превращает одноразовый `Запрос` в постоянную, адресуемую `Идею`.
>
> > Sidenote:
> > :term[101: Концепция/Идея]{href="./101_concept_idea.md"}

::::columns
:::column{title="Пример структуры Запроса"}

```json
// ИИ получает текущие мета-данные как контекст
// и должен создать новые в решении.
{
  "context": [
    {
      "type": "meta",
      "meta": {
        "domain": "reactor.ideas.services",
        "path": "/games/321",
        "version": "1.2.3",
        "branches": ["main"],
        "createdAt": "2025-10-26T10:00:00Z"
      }
    },
    {
      "type": "state",
      "state": {
        "...текущее состояние игры..."
      }
    }
  ],
  "schema": {
    "type": "object",
    "properties": {
      "meta": {
        "$ref": "MetaSchema"
      },
      "output": {
        "$ref": "GameSchema"
      }
    }
  }
}
```

:::
:::column{title="Пример Решения"}

```json
// Решение ИИ включает следующее состояние игры
// и повышенную версию в новом мета-объекте.
{
  "meta": {
    "domain": "reactor.ideas.services",
    "path": "/games/321",
    "version": "1.2.4",
    "branches": ["main"],
    "createdAt": "2025-10-26T10:05:00Z"
  },
  "output": {
    "...следующее состояние игры..."
  },
  "calls": []
}
```

:::
::::

## Самостоятельное развитие и версионирование

Одна из ключевых задач `Мета`-объекта — позволить процессам, управляемым агентами, развиваться самостоятельно. Система показывает ИИ текущую версию и ветки в `контексте` и требует создать новую версию в `решении`. Таким образом, ИИ поручается задача «повышения версии». Если ИИ просто делает небольшое изменение, он должен увеличить младшую версию (например, с `1.2.3` на `1.2.4`). Это создаёт новый, неизменяемый «снимок» состояния и логики, формируя полную историю действий агента.


Это создаёт проблему в больших системах. Представь, что два разных процесса одновременно реагируют на разные события. Оба могут попытаться обновить версию с `1.2.3` до `1.2.4`. Кто из них будет первым? Это называется «состояние гонки».

Система решает эту проблему с помощью механизма ветвления. Когда нужно начать новую линию разработки, процесс создаёт новую «ветку» (например, `["main", "my-feature"]`). Теперь у каждой ветки своя нумерация версий, например, `1.2.3.branch-A.1` и `1.2.3.branch-B.1`. Это позволяет им развиваться параллельно, не мешая друг другу. Позже эти ветки можно будет снова объединить.


## Связь «паспорта» и «адреса»

Информация внутри `Мета`-объекта даёт нам всё необходимое, чтобы присвоить :term[Запросу]{canonical="Request"} уникальный глобальный адрес. Это как почтовый адрес для письма: он позволяет найти, направить или сослаться на конкретную версию запроса и его решения.


Процесс нахождения нужной версии связывает динамический запрос с конкретным, неизменяемым результатом. Вот как это работает:

- **Мета**: «Паспортные данные» конкретной версии.
  - _meta.domain:_ `my-project.com`
  - _meta.path:_ `bob`
  - _meta.version:_ `1.2.staging.1`
  - _meta.branches:_ `['staging']`
  - _meta.createdAt:_ `2025-10-26T10:00:00Z`

- **Ссылка**: Динамический запрос (что мы ищем).
  - `idea://my-project.com/bob?1.2`
  - _Искать в ветках:_ `['staging']`
  - _Не позднее даты:_ `2025-10-26T10:00:00Z` (взято из `createdAt`)

- **Найдено**: Постоянный, однозначный адрес, указывающий на найденный ресурс.
  - `idea://my-project.com/~:staging/bob?1.2:1.2.staging.1`
  - _Ветка:_ `~:staging`
    - _просили:_ любую ветку из списка для поиска
    - _получили_: `staging`
  - _Версия:_ `1.2:1.2.staging.1`
    - _просили:_ последнюю, совместимую с `1.2`
    - _получили:_ `1.2.staging.1`

Таким образом, весь «пакет» запрос-решение становится самоописываемым и легко находимым.