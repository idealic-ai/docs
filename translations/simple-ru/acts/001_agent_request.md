# 001: Агент/Запрос

> [!DEFINITION] [Запрос](./000_glossary.md)
> Единоразовый, полностью самостоятельный вызов большой языковой модели (ИИ). Он берёт :term[контекст]{canonical="context"} и :term[схему]{canonical="schema"}, а на выходе даёт :term[решение]{canonical="Solution"}.

> Sidenote:
> - Что включает:
>   - :term[101: Концепция/Идея]{href="./101_concept_idea.md"}
> - Ссылки:
>   - [NPM: @idealic/agent](https://www.npmjs.com/package/@augceo/agent)

:term[Запрос]{canonical="Request"} (Request) — это как отдельное, законченное задание для искусственного интеллекта (ИИ). Представь, что это не просто короткий вопрос, а целая папка с заданием. В этой папке есть вся необходимая информация (:term[контекст]{canonical="context"}) и чёткая форма для ответа (:term[схема]{canonical="schema"}). ИИ берёт эту папку и возвращает идеально заполненную форму (:term[решение]{canonical="Solution"}). Эта надёжная система является двигателем для всех более сложных способностей нашего агента.

## Контекст: цепочка сообщений

> [!DEFINITION] Контекст
> Тщательно подобранный набор сообщений, который даёт ИИ всю необходимую информацию — инструкции, данные и историю переписки — для выполнения конкретной задачи.

> Sidenote:
> ИИ обработает :term[контекст]{canonical="context"}, чтобы создать :term[решение]{canonical="Solution"}, которое соответствует :term[схеме]{canonical="schema"}.
>
> ```mermaid
> graph TD
>     subgraph Ввод пользователя
>         direction LR
>         Context[\Контекст\]
>         Schema[\Схема\]
>     end
>
>     Process{{"Запрос"}}
>
>     subgraph Вывод ИИ
>         direction LR
>         Solution[/Решение/]
>     end
>
>     Context --> Process
>     Schema --> Process
>     Process --> Solution
>     Schema -.-> Solution
>
>     linkStyle 2 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
>     linkStyle 3 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
> ```

Основа любого :term[Запроса]{canonical="Request"} — это его :term[контекст]{canonical="context"}: набор сообщений. Каждое сообщение — это простая структура с `ролью` (например, `«system»`, `«user»` или `«assistant»`) и `содержимым`. Это позволяет представить ИИ целый диалог.

В обычном чате сообщения просто добавляются в конец истории. Здесь же всё иначе. :term[Контекст]{canonical="context"} для каждого :term[Запроса]{canonical="Request"} — это отдельный, подготовленный пакет информации. Он создаётся для конкретной задачи и не содержит ничего лишнего из прошлых разговоров. Ответы ИИ не добавляются в него автоматически; для каждой новой задачи :term[контекст]{canonical="context"} собирается заново. Это гарантирует, что у ИИ всегда будет только нужная информация, и он ничего не «забудет».

Именно через эти сообщения ИИ получает все инструкции, подсказки и данные, которые нужны ему для работы (кроме финальной :term[схемы]{canonical="schema"}).

Вот как может выглядеть простой набор сообщений:

```json
[
  { "role": "system", "content": "Ты — полезный помощник." },
  { "role": "user", "content": "Какая столица Франции?" }
]
```

Наша система идёт дальше: в поле `content` может быть не только текст, но и специальные объекты, которые мы называем **пользовательскими типами содержимого**. Например, вместо простой строки там может быть объект вроде `{ "type": "input", "input": { ... } }`.

> Sidenote:
> Пользовательские типы сообщений описаны в Актах:
>
> - :term[005: Агент/Данные]{href="./005_agent_data.md"} - передаёт ИИ данные и их смысл
> - :term[006: Агент/Ввод]{href="./006_agent_input.md"} - структурированная инструкция для ИИ
> - :term[009: Агент/Состояние]{href="./009_agent_state.md"} - информация, которая сохраняется между шагами
> - :term[011: Агент/План]{href="./011_agent_plan.md"} - готовый план для выполнения сложных задач
> - :term[015: Агент/Мета]{href="./015_agent_meta.md"} - передаёт ИИ информацию о самой Идее

Благодаря этому :term[контекст]{canonical="context"} становится главным элементом для расширения возможностей системы.

Каждый такой пользовательский тип обрабатывается своей программой. Перед отправкой :term[Запроса]{canonical="Request"} ИИ, эти программы обрабатывают каждое сообщение в :term[контексте]{canonical="context"}. Они могут на лету изменять ключевые части :term[Запроса]{canonical="Request"}:

- **Настройки ИИ**: менять модель, «температуру» (креативность) и другие параметры.
- **:term[Схему]{canonical="schema"}**: изменять JSON-схему, по которой должен быть построен финальный ответ.
- **:term[Контекст]{canonical="context"}**: менять финальный список сообщений для ИИ, например, превращая сложный объект в понятный для модели текст или добавляя новые сообщения.

Этот мощный механизм позволяет агенту работать со сложными, структурированными идеями, каждый раз создавая идеальное задание для ИИ.

## Схема: направляя к решению

> [!DEFINITION] Схема
> JSON-схема, которая точно описывает структуру желаемого :term[решения]{canonical="Solution"}. Она похожа на шаблон, который ИИ должен заполнить, чтобы ответ всегда был правильным и предсказуемым.

> Sidenote:
> - Подробнее на [json-schema.org](https://json-schema.org/)

:term[Схема]{canonical="schema"} — это как анкета или бланк, который должен заполнить ИИ. Она точно описывает, как должно выглядеть :term[решение]{canonical="Solution"}. Благодаря этому можно получить что угодно: от простого слова до сложных, вложенных друг в друга данных. ИИ обязан следовать этой схеме, так что его ответ всегда будет иметь нужную нам структуру.

Когда схемы становятся сложными, они начинают направлять не только результат, но и сам процесс мышления ИИ. Например, в :term[схеме]{canonical="schema"} можно сделать поля для самого ответа, и отдельные поля, где ИИ должен описать свои рассуждения или ход мыслей. Так схема становится активным инструментом, который формирует ответ.

Ключевой принцип этой системы — возможность собирать сложные схемы из более простых, как конструктор. Это позволяет создавать новые способности агента легко и быстро.

## Выполнение и Решение

> [!DEFINITION] Решение
> Структурированный JSON-документ, который возвращает ИИ. Он полностью соответствует предоставленной :term[схеме]{canonical="schema"}. Это и есть финальный, правильно оформленный результат :term[Запроса]{canonical="Request"}.

После обработки :term[контекста]{canonical="context"}, финальный набор сообщений и :term[схема]{canonical="schema"} отправляются ИИ одним пакетом. Ответ ИИ и есть :term[решение]{canonical="Solution"} — структурированный JSON-документ, который строго соответствует :term[схеме]{canonical="schema"}.

Этот процесс похож на написание короткого рассказа. Поскольку ИИ предсказывает следующее слово, он создаёт :term[решение]{canonical="Solution"} сверху вниз, следуя структуре :term[схемы]{canonical="schema"}. Поэтому порядок полей в схеме напрямую влияет на то, что «расскажет» ИИ.

Например, если в схеме сначала идёт поле для размышлений (например, `"ход_мыслей"`), а потом поле для ответа, ИИ сначала будет вынужден описать логику, и только потом дать ответ. Эти размышления станут частью информации, которая повлияет на итоговый результат. Так мы можем направлять «мысли» ИИ и получать более качественные ответы.

> [!HEADSUP] На заметку
> Весь этот процесс — :term[контекст]{canonical="context"}, :term[схема]{canonical="schema"} и итоговое :term[решение]{canonical="Solution"} — образует единое, повторяемое целое. Когда мы сохраняем его, система называет это :term[101: Концепция/Идея]{href="./101_concept_idea.md"}.

## От структурированных ответов к действиям

:term[Запрос]{canonical="Request"} — это надёжный способ получить от ИИ один чётко структурированный :term[ответ]{canonical="Solution"}. Но чтобы строить по-настоящему умных агентов, нам нужно больше. Нам нужен способ предложить ИИ целое «меню» возможностей — разных действий, из которых он может выбирать для достижения цели. Для этого нужна система, которая позволит описывать эти действия как отдельные, выбираемые элементы.

> Sidenote:
> - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

Следующий документ, :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}, описывает, как определять такие возможности.
