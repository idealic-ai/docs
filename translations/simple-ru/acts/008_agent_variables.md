# 008: Агент/Переменные

> [!DEFINITION] [Ссылка на переменную](./000_glossary.md)
> Это специальная строка (например, `†вход.имя`), которую агент использует в командах, чтобы сослаться на нужную информацию, не копируя её целиком.

**Переменные** — это развитие системы [Данных](./006_agent_data.md), которое позволяет информации «ожить» и перемещаться между разными частями агента. Представь их как ярлыки или закладки для данных.

У них есть две главные задачи:

*   **Чтение:** Сослаться на информацию, которая уже есть у агента (например, на то, что ввёл пользователь), не перепечатывая её каждый раз.
*   **Запись:** Сохранить результат работы инструмента в специальном «блокноте» (`Состоянии`), чтобы его можно было использовать на следующих шагах.

## Чтение из контекста

Когда агент вызывает инструмент, вместо того чтобы вставлять в команду большой кусок данных, он может использовать **ссылку на переменную** — специальную строчку, которая работает как компьютерный ярлык. Она просто указывает, где лежат нужные данные.

Это намного лучше, чем заставлять нейросеть копировать информацию. Копирование — это долго, дорого и можно случайно что-то исказить. А ссылка — это просто, быстро и надёжно.

Ссылка выглядит так: `†<тип>.<путь>`. Например, `†вход.имяПользователя`.

*   Знак кинжала (`†`) говорит: «Эй, это ссылка!»
*   `<тип>` — это где искать данные (например, `вход` или `состояние`).
*   `<путь>` — это «адрес» внутри этих данных, как путь к файлу на компьютере.

> Sidenote:
> *   Wikipedia: [Кинжал (типографика)](<https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D0%BD%D0%B6%D0%B0%D0%BB_(%D1%82%D0%B8%D0%BF%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0)>)

::::columns
:::column{title="Параметры инструмента с переменными"}

```json
{
  "_tool": "поприветствоватьПользователя",
  "userName": "†вход.userName"
}
```

::: 
:::column{title="Что-то похожее в коде"}

```typescript
поприветствоватьПользователя({
  userName: вход.userName,
});
```

::: 
::::

## Запись в контекст

Чтобы сохранить результат работы инструмента, в команду можно добавить специальное свойство `_outputPath` (путь для вывода). Это как написать на коробке адрес, куда её нужно доставить. Агент видит этот адрес и сохраняет результат в указанное место, чтобы его можно было использовать позже.

Чаще всего результаты сохраняют в `Состояние` (например, `†состояние.сводка_о_пользователе`).

> Sidenote:
> *   [004: Агент/Вызов](./004_agent_call.md)

Адрес для сохранения можно задать двумя способами:

*   **Гибкий (решает нейросеть):** Дать нейросети свободу самой придумать, куда сохранить результат.
*   **Жёсткий (заранее определён):** Заранее прописать в правилах инструмента, что результат можно сохранить только по этому конкретному адресу или выбрать из нескольких разрешённых.

## Декларативное соединение

Главная сила переменных в том, что они позволяют описывать действия с данными, которых ещё нет. Это как составить рецепт пирога, не имея под рукой ни муки, ни яиц. Ты просто пишешь шаги: «возьми муку», «добавь яйца». Рецепт будет готов, а продукты можно будет принести позже.

Точно так же можно соединять инструменты в цепочку. Один инструмент может использовать как входные данные то, что *должен будет* создать предыдущий инструмент. Так строится целый конвейер обработки данных, где выход одного шага становится входом для следующего.

Особенно мощно это работает, когда мы описываем возможные исходы:

*   **Развилки (Ветвление):** Если в адресе для сохранения использовать `||` (означает «ИЛИ»), например: `"†состояние.успех || †состояние.провал"`, то инструмент сам решит, по какому пути сохранить результат. Он как бы говорит: «Я попробую что-то сделать, и если получится — положу результат сюда, а если нет — то туда».
*   **Параллельные пути (Размножение):** Если использовать `&&` (означает «И»), например: `"†состояние.профильПользователя && †журнал.записьАудита"`, то один и тот же результат будет скопирован и сохранён сразу в несколько мест.

Благодаря этому нейросеть может заранее составить полный план действий, включая сложные развилки и параллельные задачи, ещё до того, как начнётся реальная работа. Этот план можно проверить, одобрить и даже использовать повторно. Такая удивительная способность к планированию появляется благодаря тому, как переменные сочетаются с другими частями системы.

> Sidenote:
> *   [010: Агент/План](./010_agent_plan.md)

## Взаимодействие с другими частями

*   **Данные:** Переменные — это то, что заставляет `Данные` работать. С помощью ссылок (`†`) мы читаем `Данные` (например, `Ввод` или `Состояние`), а с помощью путей вывода (`_outputPath`) — записываем в них что-то новое. Получается замкнутый круг, где информация постоянно обновляется и используется.

    > Sidenote:
    > *   [006: Агент/Данные](./006_agent_data.md)

*   **Ввод:** Ссылки на переменные могут указывать на `Ввод`, то есть на информацию от пользователя. Это позволяет создавать универсальные планы, которые работают одинаково, но с разными данными на входе. Как рецепт, который можно использовать для приготовления и яблочного, и вишнёвого пирога.

    > Sidenote:
    > *   [007: Агент/Ввод](./007_agent_input.md)

*   **Состояние:** `Состояние` — это главный «блокнот» для агента в сложных задачах. Именно сюда чаще всего сохраняются результаты с помощью `_outputPath`, потому что `Состояние` не очищается между шагами. То, что записано на одном шаге, будет доступно на следующем.

    > Sidenote:
    > *   [009: Агент/Состояние](./009_agent_state.md)

*   **План:** Переменные — это фундамент, на котором строятся `Планы`. `План` — это схема из инструментов, соединённых друг с другом. А соединяются они как раз с помощью переменных: ссылка одного инструмента указывает на результат работы другого. Это позволяет агенту описать весь рабочий процесс в виде единой понятной схемы.

    > Sidenote:
    > *   [010: Агент/План](./010_agent_plan.md)

## От временных связей к постоянной памяти

Переменные позволяют соединять инструменты и данные в рамках одного короткого задания. Но чтобы строить агентов, которые решают большие задачи в несколько этапов, нужна более надёжная память — тот самый «блокнот», где можно хранить промежуточные результаты и возвращаться к ним снова и снова.

Следующий документ, **[009: Агент/Состояние](./009_agent_state.md)**, как раз и рассказывает о том, как работает эта постоянная память.
