# 008: Агент/Переменные

> [!DEFINITION] [Ссылка на переменную](./000_glossary.md)
> Это специальная строка (текст), которая выглядит как `†<тип>.<путь>`. Она используется в параметрах :term[Вызова инструмента]{canonical="Вызов"}, чтобы агент мог быстро найти нужную информацию в своей памяти, не копируя её целиком.

:term[Переменные] работают поверх системы [Данных](./006_agent_data.md) и позволяют информации двигаться и меняться. Они делают данные «живыми» с помощью двух основных действий:

- **Чтение:** Ссылка на информацию, которая уже есть у агента (например, в :term[Состоянии] или во :term[Входных данных]), без необходимости переписывать её в параметры :term[Вызова инструмента]{canonical="Вызов"}.
- **Запись:** Сохранение результата работы инструмента в объект :term[Данных] (чаще всего в :term[Состояние]), чтобы его можно было использовать на следующих шагах работы агента.

## Чтение из контекста

Вместо того чтобы класть в параметр :term[Вызова инструмента]{canonical="Вызов"} сами данные, можно положить туда **ссылку на переменную**. Это специальная строка, которая указывает, где эти данные лежат. Представь, что вместо того, чтобы пересказывать другу целую книгу, ты просто даёшь ему ссылку на неё в интернете. Это избавляет ИИ от необходимости копировать большие объёмы информации, что часто бывает медленно и может привести к ошибкам. Использовать ссылку быстрее, дешевле и надёжнее, так как ИИ случайно не исказит данные при копировании.

Ссылка — это простая строка, которая начинается со знака кинжала (`†`). Её формат: `†<тип>.<путь>`, где `<тип>` — это вид сообщения с :term[Данными] (например, `state` для состояния или `input` для входных данных), а `<путь>` — это «адрес» нужной информации внутри этого сообщения.

> Sidenote:
> - Википедия: [Кинжал (типографика)](https://ru.wikipedia.org/wiki/Кинжал_(типографика))

::::columns
:::column{title="Параметры инструмента с переменными"}

```json
{
  "_tool": "greetUser",
  "userName": "†input.userName"
}
```

:::
:::column{title="Как бы это выглядело в коде"}

```typescript
// "Поприветствуй пользователя,
// имя которого лежит во входных данных по адресу userName"
greetUser({
  userName: input.userName,
});
```

:::
::::

## Запись в контекст

Чтобы сохранить результат работы инструмента, :term[Вызов] может содержать специальное свойство `_outputPath`. Эта строка — **Путь для вывода** — говорит системе, куда именно положить результат, чтобы он был доступен на следующих шагах. Обычно результат сохраняют в объект :term[Состояния] (например, по пути `†state.user.summary`).

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

`_outputPath` можно определить двумя способами. Это позволяет гибко настраивать, как будет работать инструмент.

::::columns{.examples}
:::column{title="Гибкий путь (решает ИИ)"}

В этом режиме ИИ сам решает, куда сохранить результат во время работы. Это делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую
// строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Жёсткий путь (прописан заранее)"}

Этот подход заставляет инструмент всегда записывать результат в одно и то же, заранее определённое место. Это делает его работу предсказуемой.

```json
// Схема инструмента закрепляет
// одно конкретное значение для _outputPath
{
  "_outputPath": {
    "type": "string",
    "const": "†state.user.summary"
  }
}
```

:::
::::

## Декларативная связь

Главная сила :term[Переменных] в том, что они позволяют описывать действия с данными, которых ещё нет. Например, можно создать :term[Вызов инструмента]{canonical="Вызов"}, который будет работать с информацией из :term[Входных данных], даже если эти данные ещё не получены. Это позволяет создавать универсальные, как бы «шаблонные» цепочки действий.

Эта идея позволяет связывать :term[Вызовы инструментов]{canonical="Вызов"} друг с другом. Один :term[Вызов инструмента]{canonical="Вызов"} может использовать :term[ссылку на переменную], которая указывает на `_outputPath` (результат) *предыдущего* вызова в той же цепочке. Так создаётся поток данных, где результат работы одного инструмента становится входными данными для следующего.

Такая «сборка наперёд» становится особенно мощной, когда `Пути для вывода` используются для описания возможных исходов событий.

::::columns
:::column{title="Альтернативные пути (Ветвление)"}
Использование `||` (означает «ИЛИ») в `_outputPath` позволяет инструменту объявить, какие у него могут быть результаты. Логика самого инструмента решит, по какому пути записать ответ.

```json
// Если `verifyUser` (проверка пользователя) пройдёт успешно,
// результат запишется в `state.user.verified`;
// в противном случае — в `state.user.failed`.
{
  "_tool": "verifyUser",
  "userId": "perfect-stranger",
  "_outputPath": "†state.user.verified || †state.user.failed"
}
```

:::
:::column{title="Одновременные пути (Разделение)"}
Использование `&&` (означает «И») в `_outputPath` даёт команду записать один и тот же результат сразу в несколько мест.

```json
// Записываем результат одновременно
// в объекты `user` и `audit` внутри состояния.
{
  "_tool": "generateSummary",
  "text": "Длинный текст здесь...",
  "_outputPath": "†state.user.summary && †state.audit.summary"
}
```

:::
::::

Эта возможность описать целую последовательность действий — включая сложные ветвления и разделения потоков — с данными, которых ещё нет, и лежит в основе декларативного планирования. Она позволяет ИИ составить полный план действий (граф потока данных), который можно проверить, одобрить и использовать повторно ещё до того, как будет запущен реальный код. Эта мощная способность к планированию возникает из того, как :term[Переменные] сочетаются с другими ключевыми понятиями:

> Sidenote:
> - [010: Агент/План](./010_agent_plan.md)

## Взаимодействие с другими частями системы

- **:term[Данные]:** Переменные — это механизм, который делает сообщения с :term[Данными] интерактивными. :term[Ссылки на переменные] читают из сообщений (таких как :term[Входные данные] или :term[Состояние]), а `Пути для вывода` записывают данные обратно, создавая цикл, в котором информацию можно постоянно получать и изменять.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **:term[Входные данные]:** :term[Ссылки на переменные] могут указывать на :term[Входные данные], что позволяет делать цепочки действий настраиваемыми. Это как создать рецепт, в котором сказано «возьмите фрукт», не уточняя, какой именно. Структура действий та же, а конкретные данные можно подставить во время выполнения.

  > Sidenote:
  > - [007: Агент/Входные данные](./007_agent_input.md)

- **:term[Состояние]:** Объект :term[Состояния] — это главный «черновик» для переменных в многошаговых задачах. Именно в него чаще всего записывают результаты (`Пути для вывода`), потому что он сохраняется между шагами работы агента. Это позволяет одному шагу оставить результат, который сможет прочитать следующий.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md)

- **:term[План]:** Переменные — это основа, на которой работает система :term[Планов]. Сообщение с :term[Планом] содержит схему :term[Вызовов инструментов]{canonical="Вызов"}, где связи между ними создаются с помощью :term[ссылок на переменные], указывающих на `Пути для вывода`. Это позволяет агенту описать целый рабочий процесс в виде единой и понятной структуры данных.

  > Sidenote:
  > - [010: Агент/План](./010_agent_plan.md)

## От временных связей к постоянной памяти

:term[Переменные] позволяют связывать данные с инструментами в рамках одного конкретного запроса. Но чтобы создавать сложных агентов, которые выполняют задачи в несколько шагов, нужна более надёжная память — «черновик», где результаты могут храниться и быть доступны в течение всей работы агента.

Следующий документ, [009: Агент/Состояние](./009_agent_state.md), описывает правила управления этой постоянной памятью.