# 801: Пакет/Агент

> [!DEFINITION] [Агент](./000_glossary.md)
> Это готовый «движок», построенный по правилам **:term[Актов Становления]{canonical="Acts of Emergence"}**. Он позволяет запускать :term[ИИ-центричные]{canonical="AI-Native"} процессы, управляемые схемами — от простейших :term[Запросов]{canonical="Request"} до сложных :term[Агентов]{canonical="Agent"}, которые помнят свои прошлые действия.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

Библиотека `@augceo/agent` — это главная реализация архитектуры агентов, описанной в Актах. В отличие от других систем, где главное — правильно составить текстовый запрос (промпт), для нас важнее всего **соблюдение протокола**. Это похоже на игру по строгим правилам: каждое действие заранее описано, понятно и отделено от других.

## Акты (Наши правила)

Эта библиотека построена точно по «чертежам», которые описаны в **Актах**. Каждая её возможность — это отдельный документ с правилами.

Такое устройство из модулей похоже на конструктор. Вместо одного огромного робота у нас есть много разных деталей. Каждый Акт описывает отдельную способность. Ты можешь брать только те детали, которые тебе нужны — будь то простое использование :term[Инструмента]{canonical="Tool"} или сложная система из нескольких агентов, которые помнят свои действия и могут поручать задачи друг другу.

### Основные элементы

- **:term[001: Агент/Запрос]{href="./001_agent_request.md"}**: Самая маленькая частичка работы.
  - Превращает :term[Контекст]{canonical="Context"} и :term[Схему]{canonical="Schema"} в структурированное :term[Решение]{canonical="Solution"}.
  - Позволяет получать несколько решений одновременно.
  - Это основа для всех более сложных действий агента.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md"}**: Описание того, что агент умеет делать.
  - Задаёт «что» делать, но не говорит «как».
  - Позволяет нейросети выбирать нужные действия на основе их описания.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md"}**: Конкретный код, который выполняет то, что описано в :term[Инструменте]{canonical="Tool"}.
  - Соединяет абстрактное описание :term[Инструмента]{canonical="Tool"} с реальным кодом.
  - Поддерживает принцип разделения «интерфейса» и «реализации».
- **:term[004: Агент/Вызов]{href="./004_agent_call.md"}**: Конкретный приказ агенту использовать один из своих :term[Инструментов]{canonical="Tool"}.
  - Это запрос на выполнение действия с конкретными параметрами.
  - Стандартный способ передать команду от нейросети к исполняющей системе.

### Данные и Состояние

- **:term[005: Агент/Данные]{href="./005_agent_data.md"}**: Правила для хранения информации в :term[контексте]{canonical="context"}.
  - Создаёт единую «упаковку» для всех сообщений, которые нужно запомнить.
  - Позволяет правильно объединять разную информацию.
- **:term[006: Агент/Входные данные]{href="./006_agent_input.md"}**: Превращает обычный :term[Запрос]{canonical="Request"} в многоразовую функцию.
  - Определяет чёткие входные параметры для :term[Запроса]{canonical="Request"}.
  - Позволяет автоматически создавать интерфейсы и безопасно вызывать команды.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md"}**: Память, которая сохраняется между шагами.
  - Работает как общая «записная книжка» для всего процесса.
  - Позволяет продолжать работу с того же места и выполнять многошаговые задачи.
- **:term[016: Агент/Метаданные]{href="./016_agent_meta.md"}**: Хранит информацию о происхождении агента.
  - Отслеживает версии, ветки и автора.
  - Позволяет агентам самостоятельно развиваться и обновлять свои версии.

### Связи и Потоки

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md"}**: Способ ссылаться на данные.
  - Использует специальный синтаксис `†тип.путь` для связи результатов с входными данными.
  - Позволяет :term[Инструментам]{canonical="Tool"} читать данные из контекста, не копируя их.
- **:term[008: Агент/Результат]{href="./008_agent_output.md"}**: Механизм записи результата.
  - Через `_outputPath` указывает, куда сохранить результат работы :term[Инструмента]{canonical="Tool"}.
  - Позволяет выстраивать цепочки операций, передавая данные через :term[состояние]{canonical="state"}.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md"}**: Логика внутри потока данных.
  - Позволяет делать выбор (`||`), если что-то пошло не так.
  - Позволяет выполнять действия параллельно (`&&`), отправляя данные в несколько мест сразу.

### Управление (Оркестрация)

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md"}**: Движок, который всё запускает.
  - Повторяет :term[Запросы]{canonical="Request"} до тех пор, пока цель не будет достигнута.
  - Управляет процессом: даёт команду, выполняет её и обновляет информацию.
- **:term[012: Агент/План]{href="./012_agent_plan.md"}**: Стратегия действий, описанная заранее.
  - Представляет задачу как схему из :term[Вызовов]{canonical="Call"} :term[Инструментов]{canonical="Tool"}.
  - Разделяет **планирование** (что делать) и **исполнение** (как делать).
- **:term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}**: Способ выполнять много задач параллельно.
  - Группирует сообщения по ID, чтобы запускать несколько процессов одновременно.
  - Позволяет одному :term[Плану]{canonical="Plan"} обрабатывать неограниченное количество данных.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md"}**: Возможность собирать агентов из других агентов.
  - Изолирует выполнение задач в «песочнице» — отдельном подзапросе.
  - Позволяет агентам вызывать других агентов как свои :term[Инструменты]{canonical="Tool"}.
- **:term[015: Агент/Области видимости]{href="./015_agent_scopes.md"}**: Контроль над доступом к данным.
  - С помощью `_scopes` строго определяет, какую информацию видит :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает утечку данных и делает систему безопаснее.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md"}**: Специальный помощник для размышлений.
  - Добавляет «персонажей», которые помогают агенту подумать, **прежде чем** действовать.
  - Может давать советы и направлять основного агента.

## Основные идеи (Концепции)

Если «Акты» — это детали конструктора, то следующие идеи — это философия, которая объясняет, как и почему мы его собираем именно так:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}**: По умолчанию «Без кода».
  - Если у :term[Инструмента]{canonical="Tool"} нет готового кода (:term[Действия]{canonical="Activity"}), Агент не сдаётся. Он использует своё «воображение» (внутреннее пространство нейросети), чтобы представить, каким был бы результат.
  - Это позволяет придумывать сложные процессы, используя только схемы, а настоящий код добавлять позже, когда он понадобится.

- **Единство планирования и исполнения**:
  - В этой системе **планирование — это и есть исполнение**.
  - Агент не составляет план заранее, а потом слепо ему следует.
  - На каждом шаге он заново смотрит на ситуацию и решает, что делать дальше. Это как ехать по навигатору, который постоянно обновляет маршрут в зависимости от пробок.

- **Человек в курсе дела (HITL)**:
  - :term[Агент]{canonical="Agent"} даёт возможность системе перехватить каждый его шаг.
  - Это позволяет человеку проверить и одобрить каждый :term[Вызов Инструмента]{canonical="Tool Call"}, прежде чем он будет выполнен.
  - Если человек что-то меняет, агент получает эту информацию и корректирует свой план.

- **Восстановление после ошибок**:
  - Ошибки — это не конец света. Если :term[Инструмент]{canonical="Tool"} не сработал, ошибка записывается как сообщение в :term[контекст]{canonical="context"}.
  - На следующем шаге :term[Агент]{canonical="Agent"} «видит» эту ошибку и пытается её исправить (например, пробует ещё раз с другими данными или выбирает другой путь).

## Агент и Запрос: в чём разница?

В нашей библиотеке есть два уровня: низкоуровневый **Запрос** и высокоуровневый **Агент**.

### Запрос (Низкий уровень)

:term[Запрос]{canonical="Request"} — это однократное обращение к нейросети. Как один вопрос, на который ты получаешь один ответ.

- **Контроль:** Он не повторяется. Выполняется ровно один раз.
- **Варианты:** Может предложить несколько вариантов решения на один и тот же запрос.
- **Обработка в реальном времени:** У него есть механизм, который позволяет перехватывать и обрабатывать части ответа (например, :term[вызовы]{canonical="call"} :term[инструментов]{canonical="tool"}) по мере их поступления, даже пока нейросеть ещё генерирует остальное.

### Агент (Высокий уровень)

:term[Агент]{canonical="Agent"} — это **цикл**, который управляет последовательностью :term[Запросов]{canonical="Request"}.

- **Повторение:** Он постоянно делает :term[Запросы]{canonical="Request"}, выполняет полученные команды и добавляет результат обратно в :term[контекст]{canonical="context"}.
- **Остановка:** Он работает до тех пор, пока не будет получен финальный результат (`output`).
- **Цель:** Обычно задача считается выполненной, когда агент смог заполнить поле `output` в своей схеме.

### Единая структура результата

Чтобы не было путаницы, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} выдают результат в одинаковом формате. Ваше итоговое решение всегда находится внутри поля `output`.

- **Запрос:** Возвращает массив решений `Data<T>[]` (обычно с одним элементом).
- **Агент:** Возвращает одно финальное решение `Data<T>`.

## Наша цель: полная безопасность типов

Эта библиотека использует **Схимию**, чтобы обеспечить полную согласованность типов данных без необходимости генерировать код. Цель в том, чтобы типы в коде (TypeScript) точно отражали то, что происходит с данными во время работы агента.

### Проблема

В системе с агентами финальная схема, которая отправляется нейросети, редко бывает простой. Обычно это **комбинация** из:

1. Вашей схемы (цели).
2. Системных возможностей (вызовы :term[Инструментов]{canonical="Tool"}, советы от :term[Советников]{canonical="Advisor"}, метаданные).

Эти возможности включаются специальными **обработчиками сообщений**. Например, если добавить в :term[контекст]{canonical="context"} сообщение от :term[Советника]{canonical="Advisor"}, обработчик добавит в финальную схему массив `advisors`.

### Решение: конвейер преобразования типов

Мы придумали систему типов, которая работает как конвейер и повторяет логику работы программы. Так же, как обработчики сообщений меняют схему данных во время выполнения, они должны **преобразовывать и тип в коде**.

Это работает так:

1. **Вывод типа:** Ваша схема превращается в тип `T`.
2. **Преобразование:** Каждый активный обработчик сообщений дополняет или изменяет тип `T`.
   - _Обработчик :term[Советника]{canonical="Advisor"}:_ добавляет `{ advisors: Advisor[] }`
   - _Обработчик :term[Инструмента]{canonical="Tool"}:_ добавляет `{ calls: Call[] }`
   - _Обработчик метаданных:_ добавляет `{ meta: Meta }`
3. **Сборка:** Итоговый тип — это точное сочетание вашего замысла и возможностей системы.

### Расширяемость

Эта архитектура открыта для дополнений.

- **Свои обработчики:** Вы можете создавать собственные обработчики сообщений. Они смогут изменять схему (во время выполнения) и участвовать в преобразовании типов (во время написания кода).
- **Реестр :term[Инструментов]{canonical="Tool"}:** :term[Инструменты]{canonical="Tool"} регистрируются глобально. Это определяет, «что» умеет делать система.
- **Реестр :term[Действий]{canonical="Activity"}:** Реализации (:term[Действия]{canonical="Activity"}) регистрируются отдельно. Это определяет, «как» система выполняет задачу.
- **Реестр :term[Советников]{canonical="Advisor"}:** (Планируется) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, что позволит подключать разных «персонажей» для помощи любому агенту.
- **Реестр схем:** Схемы можно регистрировать в :term[Схимии]{canonical="Schemistry"} и ссылаться на них по имени (например, `"$ref": "МояСхема"`), что позволяет повторно использовать типы по всей системе.

Считая схему единственным источником правды и позволяя типам данных следовать за ней, мы гарантируем: если код компилируется, значит, он соответствует протоколу.
