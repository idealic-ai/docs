# 801: Пакет/Агент

> [!DEFINITION] [Агент](./000_glossary.md)
> Это готовая программа-«движок», которая работает по правилам **«Актов Становления»**. Она выполняет любые задачи, основанные на ИИ и схемах: от простейших :term[Запросов]{canonical="Request"} до сложных :term[Агентов]{canonical="Agent"}, которые помнят свои прошлые действия.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Request"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Loop"}

Библиотека `@augceo/agent` — это основная программа, которая воплощает в жизнь архитектуру, описанную в «Актах». В отличие от других инструментов, которые заставляют постоянно придумывать хитрые текстовые подсказки для ИИ, эта библиотека ценит **строгое следование правилам**. Она работает как очень точный механизм, где каждое действие чётко определено, описано по схеме и отделено от других.

## «Акты» (наши правила)

Эта библиотека построена точно по инструкциям, которые описаны в **«Актах»**. Каждая её возможность соответствует определённому документу с правилами.

Такое устройство, похожее на конструктор, позволяет легко **собирать и расширять** систему. Вместо одной огромной и сложной программы, каждый «Акт» описывает отдельную способность. Ты можешь брать только те детали, которые тебе нужны — будь то простое использование :term[Инструментов]{canonical="Tool"} или создание сложной системы из множества агентов, которые помнят информацию и могут поручать задачи друг другу.

### Основные «детали» конструктора

- **:term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Request"}**: Самая маленькая частичка работы.
  - Превращает «Контекст» (что известно) и «Схему» (что нужно получить) в готовое «Решение».
  - Может создавать несколько решений одновременно.
  - Это основа для всех более сложных действий агента.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md" canonical="Tool"}**: Описание какой-либо способности в виде схемы.
  - Объясняет, **что** инструмент умеет делать, но не говорит, **как**.
  - Позволяет ИИ выбирать нужные действия, читая их описание.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md" canonical="Activity"}**: Настоящий программный код, который выполняет то, что описано в :term[Инструменте]{canonical="Tool"}.
  - Связывает абстрактную схему :term[Инструмента]{canonical="Tool"} с реальным кодом.
  - Позволяет отделить «что делать» от «как делать».
- **:term[004: Агент/Вызов]{href="./004_agent_call.md" canonical="Call"}**: Конкретный момент использования :term[Инструмента]{canonical="Tool"}.
  - Это команда на выполнение действия с определёнными параметрами.
  - Служит универсальным «языком» между желанием ИИ и действием системы.

### Данные и Память

- **:term[005: Агент/Данные]{href="./005_agent_data.md" canonical="Data"}**: Правила для хранения информации в памяти агента.
  - Упаковывает все сообщения в единый формат, как в конверт.
  - Позволяет правильно смешивать разную информацию.
- **:term[006: Агент/Ввод]{href="./006_agent_input.md" canonical="Input"}**: Превращает обычный :term[Запрос]{canonical="Request"} в многоразовую функцию, как рецепт.
  - Определяет, какие «ингредиенты» (параметры) нужны для :term[Запроса]{canonical="Request"}.
  - Позволяет автоматически создавать меню и безошибочно вызывать :term[Запросы]{canonical="Request"}.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md" canonical="State"}**: Долгосрочная память, которая сохраняется между шагами.
  - Работает как **общий черновик** для агента.
  - Позволяет продолжать работу с того места, где она остановилась.
- **:term[016: Агент/Метаданные]{href="./016_agent_meta.md" canonical="Meta"}**: «Паспорт» агента, где записана его личность и история.
  - Отслеживает **версии, изменения и происхождение**.
  - Позволяет агентам самостоятельно развиваться и обновлять свои версии.

### Связи и Потоки

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md" canonical="Variables"}**: Способ ссылаться на данные.
  - Использует специальный синтаксис `†тип.путь`, чтобы связывать результаты одних действий с входом других.
  - Позволяет :term[Инструментам]{canonical="Tool"} **читать** данные из памяти, не копируя их.
- **:term[008: Агент/Вывод]{href="./008_agent_output.md" canonical="Output"}**: Механизм для записи результатов.
  - Использует `_outputPath`, чтобы указать, куда положить результат работы :term[Инструмента]{canonical="Tool"}.
  - Позволяет **выстраивать цепочки** из операций.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md" canonical="Expressions"}**: Логика внутри потока данных.
  - Позволяет делать **выбор** (`||`): «попробуй это, а если не получится, то вот это».
  - Позволяет делать **распараллеливание** (`&&`): «отправь эти данные и сюда, и туда».

### Управление процессом

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Loop"}**: «Мотор», который заставляет агента работать.
  - Повторяет :term[Запросы]{canonical="Request"} до тех пор, пока цель не будет достигнута.
  - Управляет процессом: придумать действие, выполнить его, обновить память.
- **:term[012: Агент/План]{href="./012_agent_plan.md" canonical="Plan"}**: Стратегия действий, записанная как данные.
  - Представляет задачу как **карту потоков данных** между :term[Вызовами]{canonical="Call"} :term[Инструментов]{canonical="Tool"}.
  - Разделяет **планирование** (размышление) и **выполнение** (действие).
- **:term[013: Агент/Экземплирование]{href="./013_agent_instancing.md" canonical="Instancing"}**: Выполнение одной задачи для множества данных одновременно.
  - Группирует сообщения по номеру `_instance`, чтобы запускать параллельные процессы.
  - Позволяет применить один :term[План]{canonical="Plan"} к неограниченному числу элементов.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md" canonical="Delegate"}**: Поручение задачи другому агенту.
  - Изолирует выполнение задачи в **«песочнице» — специальном подзапросе**.
  - Позволяет вкладывать агентов друг в друга (Агенты как :term[Инструменты]{canonical="Tool"}).
- **:term[015: Агент/Области видимости]{href="./015_agent_scopes.md" canonical="Scopes"}**: Контроль над информацией.
  - Использует `_scopes`, чтобы строго ограничить, какие данные может видеть :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает путаницу в данных и повышает безопасность.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md" canonical="Advisor"}**: Обдумывание перед действием.
  - Подключает специальных «советников», которые размышляют **перед** тем, как агент начнёт действовать.
  - Они могут голосовать за лучшее решение и давать стратегические подсказки основному агенту.

## Идеи

Если «Акты» описывают _как всё работает_, то эти идеи описывают _почему_ всё работает именно так:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md" canonical="Latent"}**: «Без кода» по умолчанию.
  - Если у :term[Инструмента]{canonical="Tool"} нет готового кода (:term[Действия]{canonical="Activity"}), :term[Агент]{canonical="Agent"} переходит в режим **скрытого исполнения**.
  - Он использует воображение ИИ, чтобы представить, какой результат дал бы этот инструмент.
  - Это позволяет быстро проверять сложные идеи, просто описывая их, и добавлять код только тогда, когда это действительно нужно.

- **Единство Планирования и Выполнения**:
  - В этой системе **планирование — это и есть выполнение**.
  - :term[Агент]{canonical="Agent"} не создаёт большой :term[План]{canonical="Plan"} заранее, а потом слепо ему следует.
  - На каждом шаге он создаёт _новый_ маленький :term[План]{canonical="Plan"} (на следующий шаг), постоянно корректируя свой курс на основе свежей информации.

- **Человек в деле (Human-in-the-Loop)**:
  - У :term[Агента]{canonical="Agent"} есть специальная пауза `confirm()`.
  - Это позволяет человеку-оператору перехватывать, проверять и одобрять каждый **:term[Вызов]{canonical="Call"} :term[Инструмента]{canonical="Tool"}** до его выполнения.
  - Если человек отклоняет или изменяет :term[Вызов]{canonical="Call"}, эта информация возвращается агенту, чтобы он скорректировал свой :term[План]{canonical="Plan"}.

- **Восстановление после ошибок**:
  - Ошибки — это не конец света. Если :term[Инструмент]{canonical="Tool"} ломается, ошибка записывается как **Сообщение об ошибке** в память.
  - На следующем шаге :term[Агент]{canonical="Agent"} «видит» эту ошибку и использует свой разум, чтобы исправить ситуацию (например, попробовав ещё раз с другими параметрами или выбрав другой путь).

## Агент и Запрос: в чём разница?

Библиотека различает низкоуровневый **:term[Запрос]{canonical="Request"}** и высокоуровневого **:term[Агента]{canonical="Agent"}**.

### Запрос (низкий уровень)

:term[Запрос]{canonical="Request"} — это одна-единственная, простейшая операция с ИИ. Он предполагает, что на один набор входных данных и одну схему будет один ответ.

- **Контроль:** Он не повторяется. Он выполняет ровно один шаг.
- **Множественный выбор:** Он может сгенерировать несколько вариантов решения из одного и того же набора данных.
- **Потоковая передача:** Он позволяет перехватывать и обрабатывать части ответа (например, :term[Вызовы]{canonical="Call"} инструментов) по мере их поступления, даже пока ИИ ещё не закончил генерировать весь ответ.

### Агент (высокий уровень)

:term[Агент]{canonical="Agent"} — это **управляющий :term[Цикл]{canonical="Loop"}**, который организует целую последовательность :term[Запросов]{canonical="Request"}.

- **Повторение:** Он постоянно вызывает :term[Запросы]{canonical="Request"}, выполняет полученные от них :term[Вызовы]{canonical="Call"} :term[Инструментов]{canonical="Tool"} и добавляет результат обратно в свою память.
- **Завершение:** Он продолжает работать, пока система не решит, что финальный `output` (результат) готов.
- **Достижение цели:** По правилам, желаемый результат должен находиться в поле `output`. :term[Цикл]{canonical="Loop"} считает свою работу выполненной только тогда, когда это поле заполнено.

### Единая структура ответа

Чтобы не было путаницы, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} возвращают ответ в одинаковом формате. Ваша схема всегда упаковывается в свойство `output`.

- **:term[Запрос]{canonical="Request"}:** Возвращает `Data<T>[]` (список решений, обычно из одного элемента).
- **:term[Агент]{canonical="Agent"}:** Возвращает `Data<T>` (финальное состояние после всех шагов).

## Идея безопасности типов

Эта библиотека использует **Схимию** для обеспечения полной предсказуемости и безопасности без написания лишнего кода. Цель в том, чтобы типы в коде (TypeScript) идеально отражали то, как агент изменяет данные во время работы.

### Проблема

В системе с агентами финальная схема, которая отправляется ИИ, — это не просто то, что вы написали. Это **комбинация** из:

1. Вашей схемы (цели).
2. Системных возможностей (вызовы инструментов, советники, метаданные).

Эти возможности включаются **обработчиками сообщений**. Например, если добавить в память сообщение о :term[Советнике]{canonical="Advisor"}, то обработчик добавит в финальную схему массив `advisors`.

### Решение: конвейер типов

Мы представляем систему типов как конвейер, который работает точно так же, как и сам агент. Как обработчики сообщений меняют схему JSON во время работы, так же они должны **изменять и уточнять тип TypeScript** в коде.

Это работает так:

1.  **Вывод типа:** Ваша схема превращается в тип `T`.
2.  **Уточнение:** Каждый активный обработчик сообщений дополняет или изменяет `T`.
    -   _Обработчик :term[Советников]{canonical="Advisor"}:_ Добавляет `{ advisors: Advisor[] }`
    -   _Обработчик :term[Инструментов]{canonical="Tool"}:_ Добавляет `{ calls: Call[] }`
    -   _Обработчик метаданных:_ Добавляет `{ meta: Meta }`
3.  **Сборка:** Финальный тип — это точное пересечение вашего замысла и возможностей системы.

### Расширяемость

Эта архитектура создана открытой.

- **Свои обработчики:** Пользователи могут добавлять свои обработчики сообщений, которые будут изменять и схему (во время работы), и типы (во время написания кода).
- **Реестр :term[Инструментов]{canonical="Tool"}:** :term[Инструменты]{canonical="Tool"} регистрируются глобально. Это определяет, _что_ они могут делать.
- **Реестр :term[Действий]{canonical="Activity"}:** Код для инструментов регистрируется отдельно. Это определяет, _как_ они это делают.
- **Реестр :term[Советников]{canonical="Advisor"}:** (В планах) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, позволяя подключать к любому агенту определённые «личности» для размышлений.
- **Реестр схем:** Схемы можно регистрировать в :term[Схимии]{canonical="Schemistry"} и ссылаться на них по имени, что позволяет повторно использовать типы по всей системе.
- **Пресеты:** Готовые наборы конфигураций, которые объединяют сообщения, настройки и обработчики. Их можно зарегистрировать и вызывать прямо в потоке сообщений. Это позволяет легко собирать сложное поведение агента (например, «совет директоров» из советников) без сложного кода.

Считая схему единственным источником правды, мы гарантируем, что если код компилируется, значит, он работает по правилам.

## Идея наблюдаемости и стандартизации

Мы хотим ввести строгие стандарты для наблюдения за работой агентов, чтобы всё было одинаково, независимо от того, какой LLM используется.

### Нормализация токенов

Разные провайдеры по-разному считают использование ресурсов. Мы планируем привести все эти отчёты к единому виду, который отслеживает:

- **Входные токены**: Сколько памяти использовано.
- **Выходные токены**: Сколько контента сгенерировано.
- **Токены на размышление**: Сколько ресурсов потрачено на внутренние рассуждения.

### Прозрачность процесса мышления

Так как модели всё чаще показывают свой «ход мыслей», мы считаем это важной частью протокола:

- **Доступ**: Предоставление прямого доступа к потоку мыслей модели.
- **Бюджет**: Стандартизация «бюджета на размышления» для разных провайдеров, чтобы агенты могли запрашивать нужную глубину рассуждений независимо от модели.

## Архитектура с учётом кэширования

Мы добавляем поддержку **кэширования контекста**, чтобы резко снизить задержки и стоимость для долго работающих агентов.

Представьте, что агенту не нужно каждый раз перечитывать всю историю с самого начала. Он может просто заглянуть в свою «краткосрочную память» (кэш), чтобы вспомнить, что было несколько шагов назад. Это намного быстрее и дешевле.

### Метрики токенов

Мы будем отслеживать использование кэша, чтобы показать экономию:

- **Токены, прочитанные из кэша**: То, что агент вспомнил.
- **Токены, записанные в кэш**: То новое, что агент запомнил.

### Оптимизация на дозапись

Чтобы кэш работал максимально эффективно, библиотека использует специальные режимы, которые не сбрасывают его:

- **Дописывать, а не перезаписывать**: Вместо того чтобы заменять всю память, агент предпочитает дописывать новые данные в конец.
- **Умное слияние**: Использует естественное поведение :term[Данных]{canonical="Data"} и :term[Советников]{canonical="Advisor"}, чтобы обновлять состояние, просто добавляя новое.
- **Последовательный вывод**: Структурирует результаты так, чтобы они линейно продолжали историю диалога.

### Управление контекстом

Чтобы найти баланс между использованием кэша и лимитом памяти, мы предоставим настраиваемое **Сжатие Контекста**:

- **Ленивое сжатие**: Умный алгоритм, который «архивирует» старую историю в краткий пересказ только тогда, когда это действительно необходимо, сохраняя кэш как можно дольше.
- **Настройка**: Переключатель «Оптимизировано для кэша», который включает это поведение в зависимости от того, что важнее — скорость или цена.