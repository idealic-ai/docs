# 801: Пакет/Агент

> [!DEFINITION] [Агент](./000_glossary.md)
> Это образцовая программа, которая работает по правилам, описанным в «**Актах Становления**». Она служит движком для выполнения задач, управляемых схемами, в мире ИИ. Может выполнять как простейшие :term[Запросы]{canonical="Request"}, так и управлять сложными :term[Агентами]{canonical="Agent"}, которые помнят свою историю.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

Библиотека `@augceo/agent` — это главная программа, которая воплощает в жизнь архитектуру агентов, описанную в Актах. В отличие от других систем, которые больше заботятся о том, как правильно составить :term[запрос]{canonical="prompt"} для ИИ, эта библиотека ставит на первое место **строгое соблюдение правил (протоколов)**.

Она работает как очень точный механизм, где каждое действие чётко определено, следует заранее заданной схеме и отделено от других.

## Акты (Правила)

Эта библиотека построена точно по чертежам, которые описаны в **Актах**. Каждая её возможность соответствует отдельному документу с правилами.

Такая модульная структура похожа на конструктор: её легко **собирать и расширять**. Вместо одного огромного и неповоротливого механизма, каждый Акт описывает одну конкретную способность. Ты можешь подключать только те функции, которые тебе нужны — будь то простое использование :term[Инструментов]{canonical="Tool"} или сложная система из нескольких агентов, которые помнят информацию и могут передавать друг другу задачи.

### Основные элементы

- **:term[001: Агент/Запрос]{href="./001_agent_request.md"}**: Самая маленькая частичка работы.
  - Превращает исходные данные (`Контекст`) и правила (`Схему`) в структурированный ответ (`Решение`).
  - Поддерживает **мультиплексирование** (умеет создавать несколько решений сразу).
  - Это основа, на которой строятся все более сложные действия агента.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md"}**: Схема, описывающая какую-либо способность.
  - Определяет **внешний вид** действия отдельно от того, как оно работает внутри.
  - Позволяет ИИ выбирать нужные действия, читая их структурированные описания.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md"}**: Это конкретный программный код, который выполняет то, что обещано в :term[Инструменте]{canonical="Tool"}.
  - Связывает абстрактные схемы :term[Инструментов]{canonical="Tool"} с настоящим кодом.
  - Поддерживает **двойную регистрацию** (отделяет описание от реализации).
- **:term[004: Агент/Вызов]{href="./004_agent_call.md"}**: Команда на использование :term[Инструмента]{canonical="Tool"} с конкретными параметрами.
  - Это как заполненная заявка на выполнение действия.
  - Служит единым «языком» для передачи команд от ИИ к системе.

### Данные и Состояние

- **:term[005: Агент/Данные]{href="./005_agent_data.md"}**: Правила для структурированной информации в контексте.
  - Предоставляет единый «конверт» для всех сообщений, которые хранятся в памяти.
  - Позволяет правильно объединять информацию из разных источников.
- **:term[006: Агент/Ввод]{href="./006_agent_input.md"}**: Превращает обычный :term[Запрос]{canonical="Request"} в многоразовую функцию.
  - Определяет строгие **входные параметры** для :term[Запроса]{canonical="Request"}.
  - Позволяет автоматически создавать интерфейсы и безопасно вызывать функции.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md"}**: Память, которая сохраняется между разными шагами работы.
  - Работает как **общий черновик** для всего процесса.
  - Позволяет продолжать работу с того же места и создавать процессы, которые помнят, что было раньше.
- **:term[016: Агент/Мета]{href="./016_agent_meta.md"}**: Отвечает за «личность» и происхождение агента.
  - Отслеживает **версии, ветки и откуда что взялось**.
  - Позволяет агентам самостоятельно развиваться и обновлять свои версии.

### Связи и Потоки

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md"}**: Динамические ссылки.
  - Использует специальный синтаксис `†kind.path`, чтобы связывать выходы одних операций со входами других.
  - Позволяет :term[Инструментам]{canonical="Tool"} **читать** данные из контекста, не копируя их.
- **:term[008: Агент/Вывод]{href="./008_agent_output.md"}**: Механизм для записи результатов.
  - С помощью `_outputPath` указывает, куда сохранить результат работы :term[Инструмента]{canonical="Tool"}.
  - Позволяет **выстраивать в цепочку** разные операции, передавая результаты через общее состояние.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md"}**: Логика внутри потока данных.
  - Поддерживает **ветвление** (`||`) для выбора одного из путей или запасного варианта.
  - Поддерживает **разветвление** (`&&`) для параллельной отправки данных.

### Оркестрация

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md"}**: Движок выполнения.
  - Повторяет :term[Запросы]{canonical="Request"} снова и снова, пока не достигнет цели.
  - Управляет циклом: даёт команду, выполняет её, обновляет информацию.
- **:term[012: Агент/План]{href="./012_agent_plan.md"}**: Стратегия, описанная в виде данных.
  - Представляет весь процесс работы в виде **графа потоков данных** из вызовов :term[Инструментов]{canonical="Tool"}.
  - Разделяет **планирование** (размышление) и **исполнение** (действие).
- **:term[013: Агент/Экземпляры]{href="./013_agent_instancing.md"}**: Масштабирование через параллельное выполнение.
  - Группирует сообщения по ID `_instance`, чтобы запускать параллельные процессы.
  - Позволяет применить один :term[План]{canonical="Plan"} к неограниченному количеству данных.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md"}**: Модульная сборка.
  - Изолирует выполнение в **«песочницах» — безопасных подзапросах**.
  - Позволяет вкладывать агентов друг в друга (Агенты как :term[Инструменты]{canonical="Tool"}).
- **:term[015: Агент/Области]{href="./015_agent_scopes.md"}**: Контроль контекста.
  - Использует `_scopes`, чтобы строго определить, какие данные может видеть :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает утечку информации и повышает безопасность.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md"}**: Структурированное обдумывание.
  - Добавляет специальные «личности» для размышления **перед** тем, как действовать.
  - Обеспечивает взвешенное голосование и даёт стратегические советы основному агенту.

## Концепции

Если Акты выше описывают, _как всё работает_, то следующие концепции объясняют _почему_ всё устроено именно так:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}**: Режим «Без Кода» по умолчанию.
  - Если у :term[Инструмента]{canonical="Tool"} нет прописанного кода (:term[Действия]{canonical="Activity"}), :term[Агент]{canonical="Agent"} переходит в режим **скрытого исполнения**.
  - Он использует внутренние «мысли» ИИ, чтобы представить, каким был бы результат работы этого инструмента.
  - Это позволяет создавать сложные процессы, используя только схемы, а код добавлять только тогда, когда это действительно нужно.

- **Единство Планирования и Исполнения**:
  - В этой архитектуре **планирование — это и есть исполнение**.
  - :term[Агент]{canonical="Agent"} не создаёт один большой :term[план]{canonical="Plan"} заранее, чтобы потом его выполнить.
  - На каждом шаге он создаёт _новый_ небольшой :term[план]{canonical="Plan"} (следующее действие), постоянно перепланируя свои шаги на основе последней информации.

- **Человек в процессе (HITL)**:
  - `Agent` предоставляет специальную функцию `confirm()`.
  - Это позволяет человеку или другой системе перехватывать, проверять и одобрять каждый **вызов :term[инструмента]{canonical="Tool"}** перед его выполнением.
  - Если человек отклоняет или изменяет вызов, эта информация возвращается агенту, чтобы он скорректировал свой план.

- **Восстановление после ошибок**:
  - Ошибки — это не конец света. Если :term[Инструмент]{canonical="Tool"} ломается, ошибка записывается как **Сообщение об ошибке** в контекст.
  - На следующем шаге :term[Агент]{canonical="Agent"} «видит» эту ошибку и использует свой интеллект, чтобы исправить ситуацию (например, попробовав ещё раз с другими параметрами или выбрав другой путь).

## Агент и Запрос

Библиотека различает низкоуровневый **:term[Запрос]{canonical="Request"}** и высокоуровневого **:term[Агента]{canonical="Agent"}**.

### Запрос (низкий уровень)

:term[Запрос]{canonical="Request"} — это одна-единственная, неделимая операция с ИИ. Он предполагает, что на один вход (контекст и схема) будет один выход (решение).

- **Управление:** Он не работает в цикле. Он выполняет ровно один шаг.
- **Мультиплексирование:** Он может создавать несколько вариантов решения из одного и того же контекста (с помощью параметра `n`).
- **Потоковая передача:** Он позволяет перехватывать и обрабатывать части ответа (например, вызовы :term[инструментов]{canonical="Tool"}) по мере их поступления, в реальном времени, пока ИИ ещё генерирует остальную часть.

### Агент (высокий уровень)

:term[Агент]{canonical="Agent"} — это **цикл выполнения**, который управляет последовательностью :term[Запросов]{canonical="Request"}.

- **Цикличность:** Он постоянно вызывает :term[Запросы]{canonical="Request"}, выполняет полученные вызовы :term[Инструментов]{canonical="Tool"} и добавляет результат обратно в контекст.
- **Завершение:** Он продолжает работать, пока система не решит записать финальный `output`.
- **Сходимость:** По правилам, желаемый результат оборачивается в свойство `output`. Цикл считает свою работу завершённой, только когда это свойство заполнено.

### Единая структура вывода

Чтобы не было путаницы, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} приводят свой результат к одному виду. Ваша схема всегда помещается в свойство `output`.

- **:term[Запрос]{canonical="Request"}:** Возвращает `Data<T>[]` (массив решений, обычно из одного элемента).
- **:term[Агент]{canonical="Agent"}:** Возвращает `Data<T>` (конечное, итоговое состояние).

## Идея безопасности типов

Эта библиотека использует **:term[Схимию]{canonical="Schemistry"}**, чтобы обеспечить полную безопасность типов без генерации кода. Цель в том, чтобы типы в коде (TypeScript) точно отражали то, что происходит с данными во время работы агента.

### Проблема

В системе с агентами финальная схема, которая отправляется ИИ, почти никогда не является просто схемой пользователя. Это **комбинация** из:

1. Схемы пользователя (цель).
2. Системных функций (вызовы :term[Инструментов]{canonical="Tool"}, :term[Советники]{canonical="Advisor"}, мета-свойства).

Эти функции включаются **обработчиками сообщений**. Например, если добавить сообщение `:term[Советник]{canonical="Advisor"}` в контекст, специальный обработчик добавит в финальную схему массив `advisors`.

### Решение: конвейер преобразования типов

Мы хотим создать систему типов, которая работает так же, как и логика выполнения. Как обработчики сообщений меняют JSON-схему во время работы, так же они должны **изменять и уточнять тип** в коде.

Процесс выглядит так:

1. **Вывод типа:** Схема пользователя превращается в тип `T`.
2. **Уточнение:** Каждый активный обработчик сообщений дополняет или изменяет `T`.
   - _Обработчик :term[Советника]{canonical="Advisor"}:_ Добавляет `{ advisors: Advisor[] }`
   - _Обработчик :term[Инструмента]{canonical="Tool"}:_ Добавляет `{ calls: Call[] }`
   - _Обработчик Мета-данных:_ Добавляет `{ meta: Meta }`
3. **Сборка:** Финальный тип — это точное пересечение того, что хотел пользователь, и того, что умеет система.

### Расширяемость

Эта архитектура создана открытой.

- **Свои обработчики:** Пользователи могут регистрировать свои обработчики сообщений. Они могут менять схему (во время выполнения) и участвовать в уточнении типов (во время компиляции).
- **Реестр :term[Инструментов]{canonical="Tool"}:** :term[Инструменты]{canonical="Tool"} регистрируются глобально. Это определяет _что_ умеет делать система.
- **Реестр :term[Действий]{canonical="Activity"}:** Реализации регистрируются отдельно. Это определяет, _как_ система это делает (код).
- **Реестр :term[Советников]{canonical="Advisor"}:** (Планируется) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, позволяя подключать разные «личности» и модели мышления к любому агенту.
- **Реестр Схем:** Схемы можно регистрировать через **:term[Схимию]{canonical="Schemistry"}** и ссылаться на них, что позволяет повторно использовать типы по всей системе.

Считая схему единственным источником правды, мы гарантируем: если код скомпилировался, значит, он соответствует правилам.

## Идея наблюдаемости и стандартизации

Мы стремимся ввести строгие стандарты для рабочих процессов агента, чтобы всё работало одинаково с разными ИИ-моделями.

### Нормализация токенов

Разные модели по-разному считают использование ресурсов. Мы планируем привести эту статистику к единому виду, отслеживая:

- **Входные токены**: Сколько использовано памяти для контекста.
- **Выходные токены**: Сколько сгенерировано контента.
- **Токены на размышление**: Сколько ресурсов потрачено на внутренние рассуждения.

### Прозрачность процесса мышления

Модели всё чаще показывают свои внутренние рассуждения. Мы считаем это важной частью протокола:

- **Доступ**: Предоставление прямого доступа к потоку «мыслей» модели.
- **Бюджет**: Стандартизация параметров «бюджета на размышления» для разных моделей. Это позволит агентам запрашивать нужную глубину рассуждений независимо от того, какой ИИ используется.

## Архитектура с учётом кэширования

Мы добавляем поддержку **кэширования контекста**, чтобы значительно уменьшить задержки и стоимость для долго работающих агентов.

### Метрики токенов

Мы будем отслеживать использование кэша, чтобы показать экономию:

- **Токены, прочитанные из кэша**: Данные, взятые из памяти.
- **Токены, записанные в кэш**: Новые данные, добавленные в память.

### Оптимизация через дозапись

Чтобы кэш работал максимально эффективно, библиотека использует режимы, которые не сбрасывают его:

- **Дозапись вместо перезаписи**: Предпочтение отдаётся добавлению новых данных, а не замене всего контекста.
- **Логика слияния**: Использование естественного слияния :term[Данных]{canonical="Data"} и :term[Советников]{canonical="Advisor"} для постепенного обновления состояния.
- **Режим вывода**: Структурирование вывода так, чтобы он линейно продолжал историю диалога.

### Управление контекстом

Чтобы найти баланс между использованием кэша и ограничениями памяти, мы предоставим настраиваемое **Сжатие Контекста**:

- **Ленивое сжатие**: Оптимизированный процесс, который сворачивает историю в один снимок только при необходимости, сохраняя кэш как можно дольше.
- **Настройка**: Переключатель «Оптимизация кэша» для включения этих функций в зависимости от требований к скорости и стоимости.
