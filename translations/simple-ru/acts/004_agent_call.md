# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Конкретный, готовый к исполнению экземпляр :term[Инструмента]{canonical="Tool"} с определёнными значениями для его `параметров`. Это сфокусированный на действии запрос о том, *что нужно сделать*.

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Используется в:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [014: Агент/Области видимости](./015_agent_scopes.md)
>   - [012: Агент/Экземплирование](./013_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [013: Агент/Делегат](./014_agent_delegate.md)

Протокол :term[Инструментов]{canonical="Tool"} создаёт базовый интерфейс, который помогает агентам понимать свои возможности. Протокол **:term[Вызова]{canonical="Call"}** развивает эту идею, определяя, как именно эти возможности будут исполняться.

:term[Вызов]{canonical="Call"} — это как взятый с полки :term[Инструмент]{canonical="Tool"}, в который уже вставили батарейки (указали параметры) и который готов к работе. Если :term[Инструменты]{canonical="Tool"} описывают, *что можно сделать* в принципе, то :term[Вызовы]{canonical="Call"} определяют, *как это будет сделано* прямо сейчас.

> [!HEADSUP] На заметку
> :term[Запрос]{href="./001_agent_request.md"}, результатом которого становится набор :term[Вызовов]{canonical="Call"}, называется :term[Носителем]{href="./202_idea_vessel.md"}. :term[Носитель]{canonical="Vessel"} представляет собой один «момент принятия решения», когда агент выбирает доступные :term[Инструменты]{canonical="Tool"}, чтобы сформировать ответ.
>
> > Sidenote:
> >
> > - [001: Агент/Запрос](./001_agent_request.md)
> > - [202: Идея/Носитель](./202_idea_vessel.md)

## Результаты вызова и Финальный результат

> [!DEFINITION] [Финальный результат](./000_glossary.md)
> Конечное поле `output` в объекте :term[Решения]{canonical="Solution"}, которое полностью соответствует цели, поставленной перед агентом. Оно создаётся только тогда, когда агент считает свою задачу выполненной.

Когда мы отправляем :term[Запрос]{canonical="Request"}, наша цель — получить **:term[Финальный результат]{canonical="Final Output"}**. ИИ-модель анализирует всю имеющуюся у неё информацию (контекст) и решает:

- Если информации достаточно, она сразу создаёт :term[Финальный результат]{canonical="Final Output"} и завершает работу.
- Если информации не хватает, ИИ-модель понимает, что нужно узнать что-то ещё. Тогда она не выдаёт результат, а вместо этого создаёт набор :term[Вызовов]{canonical="Call"}, чтобы собрать недостающие данные.

После того как эти :term[Вызовы]{canonical="Call"} выполнятся, их результаты добавляются к общей информации. Затем агент делает новый :term[Запрос]{canonical="Request"} с этим обновлённым контекстом, давая ИИ-модели ещё одну попытку создать :term[Финальный результат]{canonical="Final Output"}. Этот цикл из запросов и вызовов повторяется, пока цель не будет достигнута.

> Sidenote:
> - [010: Агент/Цикл](./010_agent_loop.md)

Именно это чёткое разделение между промежуточными результатами (которые сохраняются через :term[Путь вывода]{canonical="Output Path"}) и конечным, целевым результатом позволяет создавать сложных агентов, способных выполнять многошаговые задачи.

## Взаимодействие с другими системами

Сам по себе :term[Вызов]{canonical="Call"} — это простая структура данных. Его сила раскрывается, когда он работает вместе с другими протоколами, управляющими его выполнением. Эти протоколы включаются с помощью специальных мета-свойств (они начинаются с `_`) в схеме :term[Инструмента]{canonical="Tool"}, что позволяет одному объекту :term[Вызова]{canonical="Call"} запускать самые разные действия.

Наделяя эти мета-свойства ясным смыслом, мы позволяем ИИ-модели активно участвовать в построении логики. Она может размышлять о различных комбинациях этих свойств, чтобы создавать сложные и новые цепочки выполнения. Она переходит от простого выбора инструментов к динамическому управлению целыми рабочими процессами. Это взаимодействие между :term[Вызовами]{canonical="Call"} и различными протоколами исполнения — основа способности агента выполнять сложные, многоэтапные задачи.

> [!TIP]
> Следующий раздел объясняет связи с другими частями системы, которые будут подробно описаны позже. Не нужно забегать вперёд, мы всё рассмотрим в логическом порядке. Вы сможете вернуться к этому разделу позже.

- **Явное выполнение (`_activity`)**: Самое базовое расширение — это связь :term[Вызова]{canonical="Call"} с конкретной функцией в коде. Свойство `_activity` говорит о том, что :term[Вызов]{canonical="Call"} должен быть выполнен не ИИ-моделью, а специальной :term[Активностью]{canonical="Activity"}.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное выполнение (`_delegate`)**: :term[Вызов]{canonical="Call"} можно передать для выполнения внешнему :term[Делегату]{canonical="Delegate"}. Свойство `_delegate` обычно содержит ссылку на сохранённый :term[Запрос]{canonical="Request"} (часто в виде пути к файлу JSON), что позволяет вызывать этот запрос как многоразовый инструмент. Это создаёт изолированное пространство для выполнения, предотвращая смешивание данных и обеспечивая настоящую независимость компонентов.

  > Sidenote:
  > - [013: Агент/Делегат](./014_agent_delegate.md).

- **Управление контекстом (`_scopes`)**: Протокол :term[ОбластейВидимости]{canonical="Scope"} контролирует, какая информация доступна для :term[Вызова]{canonical="Call"}. Его основная задача — сфокусировать внимание ИИ-модели во время скрытого выполнения, указав, какие части общего контекста она должна учитывать. Это предотвращает путаницу и ведёт к более надёжным результатам. При использовании с `_delegate` его роль становится ещё важнее: он строго определяет *весь* контекст для изолированного выполнения делегата.

  > Sidenote:
  > - [014: Агент/Области видимости](./015_agent_scopes.md).

- **Выполнение с сохранением состояния (`_outputPath`)**: :term[Вызов]{canonical="Call"} можно сделать «запоминающим», указав ему, куда записывать свой результат. Свойство :term[ПутьВывода]{canonical="Output Path"} определяет путь внутри постоянного :term[Состояния]{canonical="State"}, где должен быть сохранён результат :term[Вызова]{canonical="Call"}. Это позволяет создавать многошаговые процессы, где результат одного :term[Вызова]{canonical="Call"} может использоваться как входные данные для другого.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md).
  > - [008: Агент/Вывод](./008_agent_output.md).

- **Выполнение экземпляра (`_instance`)**: :term[Вызов]{canonical="Call"} можно направить на работу с конкретным элементом в большой группе данных. Это позволяет одному запросу управлять множеством потоков данных параллельно. Свойство `_instance` работает как уникальный идентификатор, фокусируя все операции этого :term[Вызова]{canonical="Call"} (например, чтение и запись в :term[Состояние]{canonical="State"}) на определённом элементе. Это обеспечивает эффективную параллельную обработку множества данных с одним и тем же набором инструментов.
  > Sidenote:
  > - [012: Агент/Экземплирование](./013_agent_instancing.md).

## От действий к данным

Хотя :term[Вызовы]{canonical="Call"} определяют, что делает агент, это лишь одна половина дела. Вторая половина — это структурированные данные, которые поступают в них и выходят из них. :term[Вызову]{canonical="Call"} нужны данные для работы, а его результаты должны быть сохранены в понятной форме, чтобы следующий :term[Вызов]{canonical="Call"} мог их использовать.

Следующий документ, :term[005: Агент/Данные]{href="./005_agent_data.md"}, описывает базовый протокол для структурирования и управления этими данными в контексте агента.
