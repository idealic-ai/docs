# 004: Агент/Вызов

> **Вызов:** Конкретная, готовая к выполнению версия «Инструмента» с заполненными параметрами. Это запрос на то, *что именно нужно сделать*. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Открывает возможности для:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [008: Агент/Импорты](./008_agent_imports.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [009: Агент/Модуль](./009_agent_module.md)

Документ [002: Агент/Инструмент](./002_agent_tool.md) объяснил, как создать понятные для ИИ-агентов инструкции. Этот документ описывает протокол **004: Агент/Вызов**, который основан на Инструментах и определяет, как именно выполняются действия.

**Вызов** — это как будто мы взяли пустой бланк Инструмента и заполнили все поля. Если Инструмент отвечает на вопрос *«Что можно сделать?»*, то Вызов отвечает на вопрос *«Как это сделать прямо сейчас?»*.

> [!TIP]
> Когда [001: Агент/Запрос](./001_agent_request.md) приводит к созданию набора Вызовов, он становится [202: Идея/Носитель](./202_idea_vessel.md). Носитель — это «моментальный снимок» решения, когда агент выбирает из доступных Инструментов, чтобы сформировать ответ.

## Сочетание и контекст

Сам по себе Вызов — это простая структура данных. Его сила раскрывается, когда он сочетается с другими протоколами, которые управляют его выполнением. Эти протоколы включаются с помощью специальных мета-свойств (они начинаются с `_`) в схеме Инструмента. Благодаря им, один и тот же Вызов может вести себя совершенно по-разному.

Мы дали этим мета-свойствам понятный смысл, чтобы нейросеть (LLM) могла сама участвовать в сборке сложных задач. Она может размышлять о разных комбинациях этих свойств, чтобы создавать новые и сложные цепочки действий. Это уже не просто выбор инструмента, а настоящее дирижирование рабочим процессом.

- **Прямое выполнение (`_activity`)**: Самый простой способ — связать Вызов с конкретной функцией в коде. Свойство `_activity` говорит, что задачу должно выполнить **Действие** (то есть, код), а не нейросеть в своём «воображении».

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Перепоручение задачи (`_module`)**: Вызов можно передать внешнему **Модулю**. Свойство `_module` обычно содержит ссылку на сохранённый [001: Агент/Запрос](./001_agent_request.md). Это как дать задачу другому специалисту, который выполнит её в отдельной «комнате», не отвлекаясь ни на что другое. Это обеспечивает чистоту эксперимента.

  > Sidenote:
  > - [009: Агент/Модуль](./009_agent_module.md).

- **Наведение фокуса (`_imports`)**: Протокол **Импортов** контролирует, какая информация доступна для Вызова. В основном он нужен, чтобы сфокусировать внимание нейросети, указав, какие именно данные из общего контекста ей следует изучить. Это как дать ученику только нужные страницы из учебника, чтобы он не запутался. Когда это используется с Модулем, то становится ещё мощнее: Импорты определяют *вообще всю* информацию, которую получит модуль.

  > Sidenote:
  > - [008: Агент/Импорты](./008_agent_imports.md).

- **Сохранение результата (`_outputPath`)**: Вызов может запоминать результат своей работы. Свойство `_outputPath` указывает, куда именно в специальном **Объекте Состояния** нужно записать результат. Это позволяет создавать многошаговые процессы, где результат одного Вызова становится входными данными для другого.

  > Sidenote:
  > - [010: Агент/Состояние](./010_agent_state.md).

- **Работа с экземпляром (`_instance`)**: Вызов можно направить на конкретный **Экземпляр**, если у нас несколько похожих задач. Свойство `_instance` работает как уникальный ярлычок, который говорит: «Всё, что ты делаешь — чтение данных, запись результата — делай только для этого экземпляра». Это позволяет эффективно и одновременно обрабатывать много задач одним и тем же набором инструментов, не путая их между собой.
  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md).

## Способы выполнения Вызовов

Когда агент создаёт несколько Вызовов, их можно выполнять по-разному, в зависимости от того, что нам нужно:

```typescript
// Выполнить один Вызов
const result = await Tool(call);

// Выполнить все Вызовы и дождаться, пока все завершатся
const results = await Tool.all(calls);

// Выполнить все Вызовы, вернуть результат первого успешного
const result = await Tool.any(calls);

// Выполнить все Вызовы, вернуть результат самого первого, который завершился (неважно, успешно или нет)
const result = await Tool.race(calls);
```

Эти способы позволяют:

- **Точно всё контролировать**: Обрабатывать вызовы по одному, делая что-то между ними.
- **Делать всё разом**: Выполнять независимые вызовы одновременно для максимальной скорости.
- **Быстро получать результат**: Остановиться после первого успеха (`.any()`) или как только что-то завершится (`.race()`).
- **Работать по принципу «всё или ничего»**: Убедиться, что все Вызовы выполнены успешно (`.all()`), если они связаны друг с другом.

## Организация Вызовов в цикле

Эти методы хороши для одной «пачки» Вызовов. Но часто агентам нужно выполнять многошаговые задачи, где результат одного шага нужен для начала следующего. Для этого существует протокол более высокого уровня, который организует Запросы и Вызовы в последовательность.

Следующий документ, [005: Агент/Цикл](./005_agent_loop.md), описывает этот процесс подробно.