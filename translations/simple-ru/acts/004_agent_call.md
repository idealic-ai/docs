# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Представьте, что :term[Инструмент]{canonical="Tool"} — это как рецепт блюда. А :term[Вызов]{canonical="Call"} — это тот же рецепт, но уже с конкретными продуктами и их количеством (`params`), готовый к приготовлению. Это конкретная команда о том, _что нужно сделать_.

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Используется в:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [013: Агент/ОбластиВидимости](./013_agent_scopes.md)
>   - [011: Агент/Экземплирование](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [012: Агент/Делегат](./012_agent_delegate.md)

Протокол :term[Инструмента]{canonical="Tool"} создаёт понятный для агентов язык, на котором описывается, что они умеют делать. Этот документ объясняет протокол **:term[Вызова]{canonical="Call"}**, который основан на :term[Инструментах]{canonical="Tool"} и определяет, как именно выполняются действия.

:term[Вызов]{canonical="Call"} — это готовый к работе :term[Инструмент]{canonical="Tool"} с заполненными параметрами. Если :term[Инструменты]{canonical="Tool"} описывают, _что можно сделать_ в принципе, то :term[Вызовы]{canonical="Call"} определяют, _как это будет выполнено_ на деле.

> [!HEADSUP] На заметку
> :term[Запрос]{canonical="Request" href="./001_agent_request.md"}, порождающий набор :term[Вызовов]{canonical="Call"}, называется :term[Носителем]{canonical="Vessel" href="./202_idea_vessel.md"}. :term[Носитель]{canonical="Vessel"} — это как моментальный снимок принятия решения, когда агент выбирает доступные :term[Инструменты]{canonical="Tool"} для формирования ответа.
>
> > Sidenote:
> >
> > - [001: Агент/Запрос](./001_agent_request.md)
> > - [202: Идея/Носитель](./202_idea_vessel.md)

## Композиция и Контекст

Сам по себе :term[Вызов]{canonical="Call"} — это простая структура с данными. Его настоящая сила проявляется, когда он работает вместе с другими протоколами, которые управляют его окружением. Эти протоколы включаются с помощью специальных мета-свойств (они начинаются с `_`) в схеме :term[Инструмента]{canonical="Tool"}. Так один и тот же объект :term[Вызова]{canonical="Call"} может запускать совершенно разные процессы.

Давая этим мета-свойствам чёткий смысл, мы позволяем ИИ-модели активно участвовать в сборке этих процессов. Она может размышлять о разных комбинациях и создавать сложные и новые цепочки выполнения. Это уже не просто выбор инструмента, а динамическое дирижирование целым оркестром задач.

> [!TIP]
> Следующий раздел объясняет связи с другими частями системы, о которых мы подробно поговорим позже. Не нужно забегать вперёд, мы всё рассмотрим по порядку. Вы всегда сможете вернуться к этому разделу.

- **Явное выполнение (`_activity`)**: Самое базовое расширение — это связь :term[Вызова]{canonical="Call"} с конкретной функцией в коде. Свойство `_activity` — это сигнал, что :term[Вызов]{canonical="Call"} должен быть выполнен по чётким инструкциям :term[Действия]{canonical="Activity"}, а не творчески домыслен ИИ-моделью.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное выполнение (`_delegate`)**: :term[Вызов]{canonical="Call"} можно перепоручить внешнему исполнителю — :term[Делегату]{canonical="Delegate"}. Свойство `_delegate` обычно содержит ссылку на сохранённый :term[Запрос]{canonical="Request"} (часто это просто путь к файлу), что позволяет использовать этот запрос как готовый инструмент. Это создаёт изолированную «чистую комнату» для выполнения, предотвращая смешивание контекстов и обеспечивая настоящую независимость.

  > Sidenote:
  > - [012: Агент/Делегат](./012_agent_delegate.md).

- **Наведение фокуса (`_scopes`)**: Протокол :term[ОбластейВидимости]{canonical="Scopes"} контролирует, какая информация доступна для :term[Вызова]{canonical="Call"}. Его основная задача — сфокусировать внимание ИИ-модели во время скрытого выполнения, указав, какие части общего контекста ей следует учитывать. Это предотвращает «растекание мысли» и делает результат более надёжным. При использовании с `_delegate` его роль становится еще важнее: он строго определяет _весь_ контекст для изолированного выполнения делегата.

  > Sidenote:
  > - [013: Агент/ОбластиВидимости](./013_agent_scopes.md).

- **Сохранение результата (`_outputPath`)**: :term[Вызов]{canonical="Call"} может сохранять свой результат, чтобы его можно было использовать позже. Свойство `_outputPath` указывает путь в постоянном :term[Состоянии]{canonical="State"}, куда должен быть записан результат :term[Вызова]{canonical="Call"}. Это позволяет создавать многошаговые процессы, где результат одного :term[Вызова]{canonical="Call"} становится входными данными для другого.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md).

- **Выполнение для экземпляра (`_instance`)**: :term[Вызов]{canonical="Call"} может быть нацелен на конкретный :term[Экземпляр]{canonical="Instance"} в запросе с несколькими экземплярами. Свойство `_instance` работает как уникальный идентификатор, фокусируя все операции этого :term[Вызова]{canonical="Call"} (например, чтение данных из :term[Состояния]{canonical="State"} и запись в него) на определённом контексте. Это позволяет эффективно и параллельно обрабатывать несколько состояний одним и тем же набором инструментов.
  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md).

## Стратегии выполнения Вызовов

Когда агент создаёт несколько :term[Вызовов]{canonical="Call"}, их можно выполнить по-разному, в зависимости от задачи:

```typescript
// Выполнить один Вызов
const result = await Tool(call);

// Выполнить все Вызовы и дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Вызовы и вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Вызовы и вернуть результат самого быстрого (неважно, успешный или нет)
const result = await Tool.race(calls);
```

Эти подходы позволяют:

- **Точечный контроль**: Обрабатывать :term[Вызовы]{canonical="Call"} по одному, добавляя свою логику между ними.
- **Пакетная обработка**: Выполнять независимые :term[Вызовы]{canonical="Call"} параллельно для максимальной скорости.
- **Быстрое завершение**: Останавливаться после первого успеха (`.any()`) или первого же результата (`.race()`).
- **«Всё или ничего»**: Гарантировать, что все :term[Вызовы]{canonical="Call"} в группе выполнятся успешно (`.all()`), сохраняя целостность данных.

## Организация Вызовов в цикле

Хотя эти стратегии управляют выполнением одной пачки :term[Вызовов]{canonical="Call"}, агентам часто нужно решать многошаговые задачи, где результат одного :term[Вызова]{canonical="Call"} влияет на следующий. Для этого существует протокол более высокого уровня, который организует :term[Запросы]{canonical="Request"} и :term[Вызовы]{canonical="Call"} в последовательность.

Следующий документ, :term[005: Агент/Цикл]{canonical="005: Agent/Loop" href="./005_agent_loop.md"}, подробно описывает этот цикл выполнения.