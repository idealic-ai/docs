# 004: Агент/Вызов

> **Вызов:** Это как взять «Инструмент» и сказать ему, что конкретно делать, задав все нужные параметры. Это команда, которая говорит, _что должно быть сделано_.
> 
> — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Открывает возможности для:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [008: Агент/Импорты](./008_agent_imports.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется через:
>   - [009: Агент/Модуль](./009_agent_module.md)

Документ [002: Агент/Инструмент](./002_agent_tool.md) рассказал нам, как агенты понимают, что они умеют делать. А этот документ описывает протокол **004: Агент/Вызов**, который объясняет, как именно они это делают.

**Вызов** — это готовая к исполнению команда для Инструмента, с уже указанными параметрами. Если Инструменты — это список того, _что можно сделать_, то Вызовы — это конкретные указания, _как это сделать_.

> [!TIP]
> Когда [Запрос к Агенту](./001_agent_request.md) превращается в набор «Вызовов», это называется [Носитель Идеи](./202_idea_vessel.md). «Носитель» — это как моментальное решение агента, когда он выбирает нужные «Инструменты» и создаёт из них ответ.

## Как всё работает вместе (Композиция и Контекст)

Сам по себе «Вызов» — это просто набор данных. Его сила в том, как он работает вместе с другими правилами, которые создают для него рабочую среду. Эти правила включаются с помощью специальных мета-свойств (они начинаются со знака `_`). Благодаря им, один и тот же «Вызов» может вести себя совершенно по-разному.

Когда у этих мета-свойств есть чёткий смысл, ИИ (искусственный интеллект) становится не просто исполнителем, а настоящим дирижёром. Он может размышлять о разных комбинациях этих свойств, чтобы создавать сложные и новые цепочки действий. Это уже не просто выбор инструмента, а создание целых сценариев на лету.

- **Чёткое выполнение (`_activity`)**: Самый простой способ — это связать «Вызов» с конкретной функцией в коде. Свойство `_activity` говорит: «Эту команду должна выполнить чёткая программа (**Действие**), а не ИИ, додумывая на ходу».

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Выполнение через Модуль (`_module`)**: «Вызов» можно поручить внешнему **Модулю**. Свойство `_module` обычно указывает на сохранённый [Запрос](./001_agent_request.md). Это позволяет использовать другой запрос как готовый инструмент. Представь, что ты даёшь задание специалисту в отдельной комнате — он работает только со своей задачей, и вы не мешаете друг другу. Это помогает избежать путаницы.

  > Sidenote:
  > - [009: Агент/Модуль](./009_agent_module.md).

- **Подключение контекста (`_imports`)**: Протокол **Импортов** решает, какую информацию увидит «Вызов». В основном это нужно, чтобы сфокусировать внимание ИИ на конкретных данных. Это всё равно что дать ему только нужные страницы из книги, чтобы он не отвлекался. А когда это используется с «Модулем», то «Импорты» точно определяют *всю* информацию, с которой будет работать этот модуль в своей «отдельной комнате».

  > Sidenote:
  > - [008: Агент/Импорты](./008_agent_imports.md).

- **Сохранение результата (`_outputPath`)**: «Вызов» может запоминать свой результат, если указать ему, куда его записать. Свойство `_outputPath` — это адрес в специальном **объекте состояния**, куда сохранится итог работы. Это позволяет создавать цепочки задач, где результат одного шага становится началом для следующего. Как в эстафете, где один передаёт палочку другому.

  > Sidenote:
  > - [010: Агент/Состояние](./010_agent_state.md).

- **Работа с конкретным экземпляром (`_instance`)**: «Вызов» можно нацелить на определённый **экземпляр**, если у нас несколько одинаковых задач. Свойство `_instance` — это как уникальный номер, который говорит: «Все действия этого вызова — чтение данных, запись результатов — относятся только к этому конкретному экземпляру». Это позволяет эффективно и одновременно обрабатывать много похожих задач одними и теми же инструментами.
  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md).

## Способы выполнения Вызовов

Когда агент создаёт несколько «Вызовов» сразу, их можно выполнять по-разному, в зависимости от задачи:

```typescript
// Выполнить один Вызов
const result = await Tool(call);

// Выполнить все Вызовы и дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Вызовы и вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Вызовы и вернуть самый первый результат (неважно, успешный или нет)
const result = await Tool.race(calls);
```

Эти способы позволяют:

- **Точный контроль**: Обрабатывать вызовы по одному, выполняя свою логику между ними.
- **Пакетная обработка**: Выполнять независимые вызовы одновременно для максимальной скорости.
- **Стратегии «быстрого отказа»**: Остановиться после первого успеха (`.any()`) или первого-же завершения (`.race()`), не дожидаясь остальных.
- **Операции «всё или ничего»**: Убедиться, что все вызовы успешно завершились вместе (`.all()`), чтобы сохранить целостность, если они связаны.

## Организация Вызовов в цикле

Эти способы хороши для одной «пачки» вызовов. Но часто агентам нужно выполнять многошаговые задачи, где результат одного вызова нужен для следующего. Для этого существует протокол более высокого уровня, который управляет последовательностью «Запросов» и «Вызовов».

Следующий документ, [005: Агент/Цикл](./005_agent_loop.md), подробно описывает этот цикл выполнения.
