# 010: Агент/Состояние

> **Сообщение о Состоянии:** Это как записная книжка (`Data`), которая помнит всё, что происходит в процессе работы. Она хранит «заметки на полях», позволяя выполнять задачи, состоящие из нескольких шагов, и не забывать, что было сделано на предыдущем. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [006: Агент/Данные](./006_agent_data.md)
> - Открывает возможности для:
>   - [012: Агент/План](./012_agent_plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **сообщение о Состоянии** — механизм, который помогает агенту «помнить», что он делает. Сообщение `State` — это особый вид **Данных** (`Data`), созданный для того, чтобы агент мог выполнять многошаговые задачи. Оно работает как записная книжка, куда агент записывает временные заметки («локальные переменные»), чтобы не терять важную информацию между выполнением разных `Инструментов`.

Объект `State` — это главный источник правды о том, на каком этапе находится задача. Он как сохранение в игре: в нём записан весь контекст. Благодаря этому процесс можно поставить на паузу и возобновить позже. Когда агент начинает новый шаг, он смотрит в `Состояние` с предыдущего шага и сразу понимает, на чём остановился, чтобы продолжить работу.

## Многошаговые Инструменты

Главная задача `Состояния` — позволить разным `Инструментам` обмениваться информацией в рамках одного процесса. Это как конвейер на заводе, где один станок передаёт деталь другому.

Работает это просто: один `Инструмент` записывает свой результат в `Состояние`, а другой `Инструмент` на следующем шаге читает эти данные и использует их для своей работы. Так создаются «цепочки инструментов», где результат работы одного становится началом для другого, и ничего не теряется по пути.

## Входные данные (Как читать из Состояния)

Чтобы прочитать что-то из `Состояния`, используется специальная «ссылка-указатель» (**Variable Reference**). Вместо того чтобы копировать большие объёмы данных, мы просто указываем, где они лежат. Это как создать ярлык для файла на компьютере вместо того, чтобы копировать сам файл — так экономится место и время.

Ссылка — это простая строка, которая начинается с символа кинжала (`†`). Формат такой: `†<тип>.<путь>`, где `<тип>` — это вид данных (например, `state` для состояния или `input` для входных данных), а `<путь>` — адрес нужной информации.

Например, вызов `Инструмента` для получения профиля пользователя может выглядеть так:

```json
{
  "_tool": "fetchUserProfile",
  "userId": "†state.currentUser.id"
}
```

Когда система видит `†state.currentUser.id`, она понимает: «Ага, мне нужно заглянуть в `Состояние`, найти там `currentUser`, потом `id` и использовать это значение как `userId` для инструмента». Она делает это автоматически перед запуском инструмента.

## Выходные данные (Как записывать в Состояние)

Чтобы записать результат работы инструмента в `Состояние`, используется специальное свойство `_outputPath` в `Вызове` (`Call`). Эта строка говорит системе, куда именно в записную книжку `Состояния` положить результат.

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

Если заранее описать структуру (`schema`) `Состояния`, то есть указать, какие «заметки» там должны быть, это поможет нейросети. Она увидит, что в `Состоянии` не хватает какой-то информации, и сама выберет `Инструменты`, которые могут её туда записать, указав нужный `_outputPath`.

### Синтаксис Пути

Строка `_outputPath` может выглядеть по-разному:

- **Обычный путь:** Простая строка, указывающая на одно место. Префикс `†state.` не обязателен, но помогает понять, что запись идёт именно в `Состояние`.
  ```json
  "†state.user.summary"
  ```
- **Альтернативные пути (Ветвление):** Символ `||` означает «или». Результат будет записан в одно из указанных мест. Это похоже на развилку на дороге: пойдёшь налево или направо.
  ```json
  "†state.summary.text || †state.summary.json"
  ```
- **Одновременные пути (Разделение):** Символ `&&` означает «и». Он приказывает записать один и тот же результат сразу в несколько мест. Это как отправить копию письма нескольким людям одновременно.
  ```json
  "†state.user.profile.summary && †state.audit.log.summary"
  ```

### Способы Задания Пути

Как система решает, каким будет `_outputPath`? Это определяется его схемой, так же как в системе **Импортов**:

- **Динамический (решает нейросеть):** Схема для `_outputPath` может быть гибкой (например, `{ "type": "string" }`). Это даёт нейросети свободу самой решать, куда и как записывать результат. Так агент может на ходу создавать новые цепочки инструментов.

  _Схема Инструмента:_

  ```json
  {
    "_outputPath": {
      "type": "string"
    }
  }
  ```

- **Предопределённый (задан жёстко):** С другой стороны, схема может использовать строгие правила, например `const` или `enum`. `const` заставляет инструмент всегда записывать результат в одно и то же место. `enum` предлагает нейросети выбор из нескольких готовых вариантов. Это полезно для создания надёжных процессов, где возможные исходы (например, «успех» или «неудача») известны заранее.

  _Схема Инструмента (выбор между путём для успеха или неудачи):_

  ```json
  {
    "_outputPath": {
      "enum": ["†state.success", "†state.failure"]
    }
  }
  ```

Эта гибкость — ключевая часть системы **Планов**, позволяя разработчику выбирать: дать агенту свободу для творчества или заставить его следовать строгому и надёжному сценарию.

## Планирование и Исполнение

Сочетание записи в состояние (`_outputPath`) и чтения из него («ссылками-указателями») — это главный механизм, который позволяет отделить планирование от выполнения. Агент может сначала построить целый план — цепочку `Вызовов` инструментов, связанных друг с другом через `Состояние`, — и только потом запустить его.

Этот план можно проверить, использовать повторно или даже симулировать, что идеально подходит для работы с нейросетями. Гибкость системы в том, что можно контролировать и входные, и выходные данные на уровне схемы: либо позволить нейросети самой решать, откуда брать данные и куда их класть, либо задать эти правила жёстко.

> [!TIP]
> Создание `Вызовов` инструментов, которые связаны друг с другом через `Состояние`, и есть **планирование**. Эта система даёт для этого все нужные кубики: `Состояние` — это доска, на которой мы строим; «ссылки» и `_outputPath` — это провода, соединяющие кубики; а **Цикл** агента — это моторчик, который всё запускает. Вместе они позволяют агенту построить подробный план действий.
> 
> > Sidenote:
> > 
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [012: Агент/План](./012_agent_plan.md)

## Взаимодействие с другими частями

- **Вызов (`Call`):** Система `Вызовов` тесно связана с `Состоянием` через свойство `_outputPath`. Это свойство превращает обычный вызов инструмента, который мог бы быть одноразовым действием, в операцию, которая меняет «память» агента. Указывая `_outputPath`, `Вызов` приказывает записать свой результат в `Состояние`, позволяя агенту шаг за шагом выстраивать цепочку действий и их последствий.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Данные (`Data`):** `Состояние` — это, по сути, особый случай использования системы `Данных` (сообщение `Data` с типом `kind: "state"`). Оно использует все возможности `Данных` для создания постоянной памяти агента. С помощью `схемы` мы описываем, как эта память должна быть устроена, что направляет действия нейросети. А способность `Данных` к слиянию позволяет обновлять `Состояние` постепенно, небольшими «заплатками», которые система сама собирает в единое целое.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **Импорты (`Imports`):** Система `Импортов` — это основной способ передать `Состояние` инструменту, который работает в изолированной среде, например, в **Модуле**. Когда `Вызов` передаётся в другой модуль, свойство `_imports` может указать, что `Состояние` нужно «пробросить» внутрь. Это позволяет изолированным инструментам безопасно читать и изменять общее состояние всего процесса.

  > Sidenote:
  > - [008: Агент/Импорты](./008_agent_imports.md)

- **План (`Plan`):** Хотя `Состояние` позволяет создавать простые цепочки инструментов, вся его мощь раскрывается в системе **Планов**. В `Плане` рабочий процесс — это сложная схема, где `Вызовы` инструментов — это узлы. `Состояние` обеспечивает связи (рёбра) между этими узлами. Оно позволяет одному узлу записать данные, а другим — прочитать их, создавая сложные сценарии, такие как ветвления (если-то) или параллельное выполнение.

  > Sidenote:
  > - [012: Агент/План](./012_agent_plan.md)

- **Инстансинг (`Instancing`):** `Состояние` полностью совместимо с системой **Инстансинга**. Когда один запрос обрабатывает сразу несколько «сущностей» (`Instances`), у каждой из них есть своё собственное, изолированное `Состояние`. Ссылки (например, `†state.currentUser.id`) автоматически направляются в `Состояние` нужного «экземпляра». Это позволяет выполнять один и тот же `План` для множества разных данных одновременно, но с полной изоляцией.

  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

## От одного Состояния к параллельному выполнению

Сообщение `State` даёт нам способ управлять памятью одного процесса. Но чтобы строить по-настоящему большие системы, агентам нужно уметь выполнять один и тот же сценарий для множества разных данных одновременно. Для этого нужен способ управлять множеством независимых состояний параллельно.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает систему, которая делает такое параллельное выполнение возможным.
