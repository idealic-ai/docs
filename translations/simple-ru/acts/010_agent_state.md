# 010: Агент/Состояние

> **Сообщение о состоянии:** Это особый вид сообщения с данными, которое работает как живая, постоянно обновляющаяся память для рабочего процесса. Представь это как блокнот с заметками, который позволяет выполнять задачи, состоящие из нескольких шагов, не теряя контекста. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [006: Агент/Данные](./006_agent_data.md)
> - Открывает возможности для:
>   - [012: Агент/План](./012_agent_plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **сообщение `Состояние`**, которое служит механизмом для управления памятью в цикле работы агента. `Состояние` — это особый способ использования системы **Данных**, созданный для задач, которые требуют выполнения нескольких шагов подряд.

`Состояние` работает как хранилище «рабочих заметок» для процесса, позволяя сохранять важную информацию между запусками разных `Инструментов`.

Объект `Состояние` — это главный источник правды о том, что происходит с задачей прямо сейчас, и ключ к её надёжности. Поскольку он хранит всю картину работы в определённый момент, процесс можно поставить на паузу и возобновить позже. Когда начинается новый шаг, `Состояние` с предыдущего шага помогает языковой модели (LLM) точно понять, где работа остановилась. Это гарантирует, что следующие действия гладко продолжат начатое.

## Многошаговые инструменты

Основная задача `Состояния` — позволить разным `Инструментам` обмениваться информацией в рамках одного непрерывного процесса. Оно создаёт общую «доску для записей», где `Инструменты` могут оставлять результаты своей работы.

Это работает очень просто: один `Инструмент` может записать свой результат в объект `Состояние`, а другой `Инструмент` на следующем шаге может прочитать эти данные и использовать их в своей работе. Так создаются цепочки инструментов, где результат одного становится основой для работы другого, и всё это происходит без потери контекста.

## Входные данные

Основной способ чтения данных из `Состояния` — это **ссылки на переменные**. Эта система позволяет в любом параметре `Вызова Инструмента` использовать не само значение, а специальную строку, которая указывает на переменную в `Состоянии`. Эта строка-ссылка имеет особый синтаксис. Такой подход очень эффективен, потому что не нужно копировать большие объёмы данных, что экономит место и ресурсы.

Ссылка — это простая строка, которая начинается со знака кинжала (`†`). Синтаксис такой: `†<тип>.<путь>`, где `<тип>` — это тип сообщения (`state`, `input`), а `<путь>` — это путь к нужному значению через точку.

Например, `Вызов Инструмента` для получения профиля пользователя может выглядеть так (в формате JSON):

```json
{
  "_tool": "fetchUserProfile",
  "userId": "†state.currentUser.id"
}
```

Во время выполнения система найдёт значение по ссылке `†state.currentUser.id`, и вызов будет равносилен вот такому коду на TypeScript:

```typescript
fetchUserProfile({
  userId: state.currentUser.id,
});
```

## Выходные данные

Основной способ записи в `Состояние` — это использование специального поля `_outputPath` в `Вызове`. Эта строка указывает системе, куда именно нужно поместить результат работы инструмента.

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

`Схема` сообщения `Состояние` может описывать, какие поля в нём ожидаются. Это создаёт мощную обратную связь для LLM: если `схема` требует определённые поля, LLM будет стараться вызывать те `Инструменты`, чей `_outputPath` совпадает с этими полями. Это помогает строить правильные и логичные цепочки `Инструментов`.

### Синтаксис пути

Строка в `_outputPath` может выглядеть по-разному:

- **Обычный путь:** Простая строка, указывающая на одно место. Префикс `†state.` использовать необязательно, но он помогает понять, что путь ведёт в объект `Состояние`.
  ```json
  "†state.user.summary"
  ```
- **Альтернативные пути (развилка):** Используя `||` для разделения путей, можно указать несколько возможных мест для записи. Результат будет записан в одно из них, а выбор сделает система или следующий шаг рассуждений.
  ```json
  "†state.summary.text || †state.summary.json"
  ```
- **Одновременные пути (разветвление):** Используя `&&`, можно направить результат сразу в несколько мест одновременно.
  ```json
  "†state.user.profile.summary && †state.audit.log.summary"
  ```

### Способы задания

Как именно определяется значение `_outputPath`, задаётся в его схеме. Это похоже на то, как система **Импортов** работает с контекстом:

- **Динамический (решает LLM):** `Схема` для `_outputPath` может быть гибкой (например, `{ "type": "string" }`), давая LLM свободу создавать любой из путей, описанных выше. Это позволяет агенту на лету соединять инструменты и строить новые потоки данных.

  _Схема инструмента:_

  ```json
  {
    "_outputPath": {
      "type": "string"
    }
  }
  ```

- **Предопределённый (задан жёстко):** С другой стороны, `схема` может использовать строгие правила JSON Schema, такие как `const`, `enum` или `oneOf`, чтобы ограничить поведение инструмента. `const` заставит использовать один конкретный путь, а `enum` предложит LLM выбрать из небольшого списка вариантов. Это очень важно для создания стабильных процессов и надёжной обработки ошибок, когда возможные исходы известны заранее.

  _Схема инструмента (выбор между путём успеха и путём ошибки):_

  ```json
  {
    "_outputPath": {
      "enum": ["†state.success", "†state.failure"]
    }
  }
  ```

Это даёт возможность настраивать предсказуемость рабочего процесса: можно начать с гибкого, исследовательского режима, а затем перейти к жёстко заданному и детерминированному, чтобы гарантировать надёжные результаты.

## Планирование и выполнение

Сочетание записи в состояние через `_outputPath` и чтения из него с помощью **ссылок на переменные** — это ключевой механизм, который позволяет отделить планирование от выполнения. Он даёт агенту возможность построить полный граф потока данных — цепочку `Вызовов Инструментов`, связанных ссылками, — *ещё до того*, как хотя бы один инструмент будет запущен.

Этот граф ссылок можно проверить, использовать повторно и даже симулировать, что делает его полностью совместимым со «скрытым» (latent) выполнением LLM. Гибкость системы в том, что можно управлять как входами, так и выходами на уровне схем. Разработчик может оставить **ссылки на переменные** (входы) и **`_outputPath`** (выходы) на усмотрение LLM или же жёстко их задать, чтобы обеспечить строгий и надёжный поток данных.

> [!TIP]
> Создание `Вызовов Инструментов`, связанных друг с другом через `Состояние`, — это и есть процесс планирования. Эта система создаёт для него техническую основу: постоянное `Состояние` служит холстом, **ссылки на переменные** и `_outputPath` — проводами, а **Цикл** агента — движком, который всё это повторяет. Вместе эти компоненты позволяют агенту построить полный граф потока данных, что по сути и является **Планом**.
>
> > Sidenote:
> >
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [012: Агент/План](./012_agent_plan.md)

## Взаимосвязи

- **Вызов:** Система `Вызовов` тесно связана с `Состоянием` через поле `_outputPath`. Это свойство превращает `Вызов Инструмента`, который мог бы быть просто действием без памяти, в операцию, изменяющую состояние. Указывая `_outputPath`, `Вызов` даёт команду записать свой результат в объект `Состояние`. Так агент запоминает результаты своих действий, а последовательность `Вызовов` выстраивается в цепочку причин и следствий, зафиксированную в `Состоянии`.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Данные:** Сообщение `Состояние` — это, по сути, специальное применение системы сообщений `Данные`, с `kind: "state"`. Оно использует ключевые возможности `Данных` для создания постоянной памяти агента. Свойство `schema` используется для описания ожидаемой структуры этой памяти, служа чертежом, который направляет действия LLM. Кроме того, важна способность системы `Данных` объединять информацию: это позволяет обновлять `Состояние` по частям, а система сама собирает эти части в единое целое.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **Импорты:** Система `Импортов` — это основной способ передать объект `Состояние` инструменту, который работает в изолированной среде, например, в **Модуле**. Когда `Вызов` передаётся в модуль, свойство `_imports` может указать, что `состояние` должно быть включено в эту «чистую комнату». Это позволяет изолированным инструментам читать данные из основного `Состояния` и взаимодействовать с ним контролируемым и явным образом.

  > Sidenote:
  > - [008: Агент/Импорты](./008_agent_imports.md)

- **План:** Хотя `Состояние` позволяет создавать простые последовательности инструментов, его полная мощь раскрывается, когда оно становится основой системы `Планов`. В `Плане` рабочий процесс — это граф, где узлы — это `Вызовы Инструментов`. Объект `Состояние` обеспечивает связи — рёбра — между этими узлами. Он позволяет одному узлу записать что-то в переменную, а другим — прочитать её, создавая сложные схемы, такие как логические развилки (если-то) или параллельные разветвления.

  > Sidenote:
  > - [012: Агент/План](./012_agent_plan.md)

- **Инстансинг:** Сообщение `Состояние` полностью совместимо с системой `Инстансинга`. Когда один запрос обрабатывает несколько `экземпляров`, каждый из них имеет своё собственное изолированное `Состояние`, которое определяется уникальным ключом `_instance`. Ссылки на переменные (например, `†state.currentUser.id`) автоматически и незаметно направляются в нужный объект `Состояние`, соответствующий `экземпляру`, для которого выполняется `Вызов Инструмента`. Это позволяет одному общему `Плану` выполняться параллельно для множества разных данных с гарантированной изоляцией.

  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

## От одного состояния к параллельной работе

Сообщение `Состояние` даёт механизм для управления памятью одного рабочего процесса. Но чтобы создавать по-настоящему масштабируемые системы, агенты должны уметь применять один и тот же процесс ко многим разным данным одновременно. Для этого нужен способ управлять множеством независимых состояний параллельно в рамках одного запроса, чтобы операции вроде ссылок на переменные и `_outputPath` правильно направлялись к нужному состоянию.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает систему, которая делает такое параллельное выполнение возможным.
