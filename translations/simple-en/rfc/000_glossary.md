# Словарь терминов

Этот документ объясняет ключевые понятия, которые используются в Протоколе Идей и связанных с ним системах.

- **Идея (Idea)**: Представь себе детальку LEGO. Это не просто кусочек пластика. У неё есть определённая форма (`schema`), она знает, как соединяться с другими детальками (`solution`), и помнит, где находится в построенной модели (`context`). Это такой прочный, самостоятельный «кирпичик» знаний, а не просто мимолётная команда.

- **Идеатор (Ideator)**: А это — как та же деталька LEGO, но с кнопкой. Если нажать на кнопку (то есть дать ей какие-то данные, `input`), она что-то сделает. Например, начнёт светиться или крутиться. Это «Идея», которая умеет принимать что-то на входе и превращать это во что-то на выходе. Как маленькая машинка.

- **Трансформер Идей (Idea Transformer)**: Это особый «Идеатор», который работает как фабрика по переделке деталек LEGO. Ты кладёшь в него одну «Идею» (детальку), а он на выходе выдаёт тебе новую, изменённую «Идею».

- **Входное Сообщение (Input Message)**: Это инструкция, которая объясняет, как пользоваться «Идеатором». В ней написано, какие данные можно ему передать (`schema`) и что именно ты передаёшь прямо сейчас (`input`). Как только у «Идеи» появляется такая инструкция, она понимает, что может принимать команды, и превращается в «Идеатор».

- **Инструмент (Tool)**: Представь себе заклинание в компьютерной игре. Книга заклинаний (`schema`) показывает твоему герою (ИИ), что он умеет делать — например, «Запустить огненный шар» или «Вылечить». Сам ИИ не создаёт магию, но он может выбрать нужное заклинание. Когда он решает его использовать, он произносит команду (`Call`), указывая цель. А уже игровой движок (программный код, `Activity`) создаёт этот огненный шар и запускает его.

- **Вызов (Call)**: Это уже не просто название заклинания, а конкретная команда его использовать. Не просто «Огненный шар» (`Tool`), а «Запустить огненный шар 5-го уровня вон в того гоблина!». Это чёткий приказ, что нужно сделать прямо сейчас.

- **Область (Scope)**: Это место, где выполняется команда.
  - **Внутренняя Область (`Inline Scope`)**: Команда выполняется прямо здесь и сейчас, в текущем процессе. Как если бы ты сам смешивал зелье у себя в комнате.
  - **Внешняя Область (`Module Scope`)**: Выполнение команды поручается кому-то другому, в отдельном месте. Как если бы ты отдал ингредиенты специальной машине для варки зелий (`module`), и она сделала всё сама, не мешая тебе.

- **Метод (Method)**: Это то, *как* выполняется команда.
  - **Явное Исполнение (`Explicit Execution`)**: Команда выполняется по чёткой, заранее написанной инструкции (коду `Activity`). Результат всегда будет одинаковым, как если бы ты готовил по точному рецепту.
  - **Скрытое Исполнение (`Latent Execution`)**: Команду выполняет сам искусственный интеллект (`LLM`), основываясь на своём «опыте». Результат может немного отличаться, как если бы опытный повар готовил блюдо по памяти, немного импровизируя.
    > Sidenote:
    >
    > - [Нормативный Акт 104: Концепция / Скрытое](../rfc/104_concept_latent.md)

- **Модуль (Module)**: Это как отдельный инструмент или прибор, который можно использовать много раз. Например, калькулятор. Тебе не нужно каждый раз заново изобретать, как считать, ты просто берёшь готовый калькулятор (`Module`), вводишь числа и получаешь ответ. Это такой помощник со стороны.

- **Импорт (Import)**: Представь, что ты просишь друга помочь с домашним заданием. Ты не пересказываешь ему весь учебник. Ты просто показываешь ему нужный параграф. Вот этот «параграф» и есть `Import`. Ты даёшь помощнику (будь то ИИ или `Module`) только ту информацию, которая ему нужна для решения конкретной задачи, чтобы он не отвлекался.

- **Цикл (Loop)**: Это похоже на игру «горячо-холодно». Ты делаешь шаг (отправляешь `Запрос`), получаешь подсказку (результат `Call`), думаешь, а потом делаешь следующий шаг (`Запрос`). Ты повторяешь эти действия снова и снова (`Loop`), пока не достигнешь цели и подсказки больше не понадобятся.

- **Сообщение о Состоянии (State Message)**: Это как счёт в игре. После каждого раунда (каждого шага в `Loop`) твой счёт сохраняется и не сбрасывается. Это сообщение (`Message`) хранит всю важную информацию (`state`) о текущем прогрессе, чтобы ничего не забылось на следующем шаге.

- **План (Plan)**: Это как рецепт торта. В нём перечислены все шаги (`Tool Calls`), которые нужно выполнить: «смешать ингредиенты», «поставить в духовку», «остудить». План (`Plan`) показывает, в каком порядке нужно делать эти шаги, ведь нельзя украшать торт, пока он не испечён.

- **Инстансинг (Instancing)**: Это как если бы повар готовил десять разных бургеров одновременно. Задача одна — «приготовить бургеры». Но он работает с каждым бургером (`Instance`) отдельно: у каждого своя котлета, свой сыр, своё место на гриле. Это умение обрабатывать много похожих, но независимых задач за один раз.

- **Инстанс (Instance)**: Это один тот самый бургер из нашего примера. У него есть свой номер заказа, свой набор ингредиентов (`state object`) и он находится на определённой стадии готовности (`context`). Это одна отдельная «единица» работы в большой партии.

- **Реактор (Reactor)**: Представь себе судью или ведущего в настольной игре. После каждого твоего хода он смотрит на игровое поле (это текущее состояние, `Idea`), применяет правила и готовит поле к следующему ходу (создаёт новое состояние, тоже `Idea`). Реактор — это такой универсальный «движок» для пошаговых процессов, который передвигает игру или задачу от одного состояния к другому.