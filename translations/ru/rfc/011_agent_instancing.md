# 011: Агент/Инстансинг

> **Инстансинг:** Процесс обработки нескольких независимых `Экземпляров` (каждый со своим `Объектом Состояния` и уникальным идентификатором) в рамках одного запроса к агенту. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется: [010: Агент/Состояние](./010_agent_state.md)
> - Совместимо:
>   - [007: Агент/Ввод](./007_agent_input.md)
>   - [008: Агент/Импорты](./008_agent_imports.md)
>   - [012: Агент/План](./012_agent_plan.md)

Этот документ описывает протокол для обработки нескольких независимых экземпляров в рамках одного запроса к агенту с использованием архитектуры, управляемой состоянием.

## 1. Фундаментальное требование: Система Состояний

Основным предварительным условием для этого протокола инстансинга является **Система Состояний**, которая явно разделяет планирование действий и их исполнение.

**Объект Состояния** — это мост между этими фазами. Это изменяемый, JSON-подобный объект, который выполняет две критически важные функции:

1.  **Цель для исполнения**: Это полотно, на котором работают инструменты. Каждый `Вызов Инструмента` включает свойство `_outputPath`, которое указывает путь внутри объекта `Состояния`, куда должен быть записан результат работы инструмента во время исполнения.
2.  **Источник для зависимостей**: `Вызов Инструмента` может ссылаться на значение из `Состояния` в качестве одного из своих входов. Это позволяет создавать графы зависимостей.

## 2. Механизм Инстансинга

Истинная мощь этой архитектуры проявляется в её нативной поддержке операций с несколькими экземплярами, что становится возможным благодаря Системе Состояний.

### 2.1. Идентификаторы Состояний

Для обработки нескольких экземпляров в одном запросе система принимает массив контекстных сообщений. Каждому сообщению, представляющему отдельный экземпляр, присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы — короткие, уникальные токены (например, числа в кружках, такие как `①`, `②`), которые легко видны LLM, но не несут семантического значения, кроме как служить ссылкой.

### 2.2. Целевые Операции

Этот `_instance` затем используется для направления всех операций в контекст конкретного экземпляра. Кроме того, все мета-параметры для `Вызова Инструмента` начинаются с символа подчеркивания (`_`), а его `params` встраиваются непосредственно в объект вызова.

- **Связывание `Вызова Инструмента`**: Каждый `Вызов Инструмента` в сгенерированном плане содержит `_instance` того контекста, с которым он должен работать.
- **Неявное Определение Области**: `_instance` в `Вызове Инструмента` неявно ограничивает область всех операций, основанных на путях (`_outputPath` и ссылки на входные данные), внутри этого вызова. Это означает, что когда инструмент читает из объекта состояния или записывает в него, путь является относительным к `_instance` контекста, к которому он принадлежит.

Этот механизм позволяет определениям самих инструментов оставаться простыми и не зависеть от контекста инстансинга. `_outputPath` и ссылки на входные данные в схеме инструмента не требуют обновления; идентификатор четко разделяет операционные контексты.

### 2.3. Пример

Один запрос может содержать два объекта состояния для анализа тональности. Схема для состояния может быть предоставлена для ограничения доступных свойств и направления работы LLM.

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "This is wonderful!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "This is terrible." } }
  ]
}
```

LLM обрабатывает оба в одном контексте и генерирует единый план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      "text": "†state.text",
      "_outputPath": "sentiment"
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

Затем хост-среда выполняет этот план, записывая результаты в соответствующие объекты состояний.

## 3. Дополнительная Система: Граф Планирования

Хотя это и не является строгим требованием для инстансинга, **Система Планирования** работает в симбиозе с этой архитектурой, чтобы создавать предсказуемые и многократно используемые рабочие процессы.

**План** — это шаблон процесса, определенный как направленный ациклический граф (DAG) `Вызовов Инструментов`. Этот граф генерируется путем анализа зависимостей между инструментами, читающими из `Объекта Состояния` и записывающими в него.

Ключевым моментом является то, что этот план можно сгенерировать и усовершенствовать _до_ исполнения. После завершения план можно передать агенту как `Контекстное Сообщение`. При обработке нескольких экземпляров агент может следовать этому предопределенному плану для каждого `Объекта Состояния`, достигая высокой согласованности и предсказуемости результатов для всех вызовов. `Объект Состояния` для каждого экземпляра служит снимком его текущего положения в этом графе исполнения.

## 4. Преимущества этого подхода

Эта модель инстансинга, управляемая состоянием, предоставляет значительные преимущества:

- **Эффективность**: Она умножает пропускную способность системы, обрабатывая множество экземпляров за один запрос к LLM, что значительно повышает скорость и снижает затраты.
- **Согласованность и Качество**: Позволяя LLM видеть несколько связанных экземпляров в одном контексте, она может генерировать более согласованные и качественные планы, используя общие закономерности для всех экземпляров.
- **Предсказуемость**: В сочетании с заранее определенным **Планом**, система может достигать детерминированных результатов. Детерминированный цикл исполнения гарантирует, что после того, как план выполнен, его результат будет надежным и повторяемым для каждого экземпляра.