# 009: Агент/Модуль

> **Модуль**: Внешняя, повторно используемая единица логики (`Действие` или `Идея`), которую можно вызвать через `Вызов` с `Областью видимости Модуля`. Обозначается свойством `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ описывает **Протокол Модуля**, который позволяет выполнять `Инструменты` в изолированном контексте, либо ссылаясь на другую `Идею`, либо вызывая `Действие` в чистом подзапросе. Это основной механизм для создания сложных агентских поведений из самодостаточных, повторно используемых компонентов.

## Проблема: Монолитные Инструменты и Утечка Контекста

По мере роста возможностей агента определять все `Инструменты` в едином, монолитном контексте становится непрактично.

1.  **Большие схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать за один запрос. Объединение множества сложных `Инструментов` может превысить эти лимиты, мешая LLM правильно обработать доступные варианты.
2.  **Утечка контекста**: Когда все `Инструменты` работают в одном и том же контексте, LLM может подвергаться влиянию нерелевантной информации, что приводит к неправильному выбору `Инструмента` или заполнению его параметров.
3.  **Отсутствие возможности повторного использования**: `Инструмент`, определённый для одного агента, нелегко перенести на другой, не перетащив с собой весь его контекст.

Протокол Модуля решает эти проблемы, вводя **Область видимости Модуля** — способ делегировать `Вызов` внешней, изолированной среде выполнения.

## Свойство `_module`

Область видимости Модуля обозначается свойством `_module` в схеме `Инструмента`. Это свойство предписывает системе обрабатывать `Вызов` не как встроенную операцию, а как запрос к внешнему модулю.

Свойство `_module` является `строкой`.

- **`_module: 'idea://<idea-name>'`**: Строка, обычно URI, которая указывает на конкретную `Идею`. Это говорит исполнителю запустить `Вызов` в контексте указанной `Идеи`.
- **`_module: 'anonymous'`**: Буквальная строка, которая сигнализирует об анонимном модуле. Это используется, когда вам нужна изолированная среда выполнения для `Действия` без накладных расходов на полный контекст `Идеи`.

## Выполнение в «Чистой Комнате»

Модуль предоставляет «чистую комнату» для выполнения. Вместо того чтобы работать в оживлённом контексте родительского агента, `Вызов` обрабатывается в новом, изолированном подзапросе. Контекст для этого подзапроса тщательно конструируется, а не наследуется.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** становится критически важным. Свойство `_imports` в схеме `Инструмента` действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в чистую комнату модуля. Это даёт родительскому агенту точный контроль над тем, что может видеть модуль, предотвращая утечку контекста и обеспечивая настоящую инкапсуляцию.

## Композиция и Повторное Использование: Композитор и Звукорежиссёр

Модули обеспечивают мощную композицию, позволяя `Идеям` действовать как автономные сервисы, которыми могут управлять другие агенты.

Рассмотрим агентов `Композитор` и `Звукорежиссёр`.

- **`Звукорежиссёр`** — это самодостаточная `Идея` (`idea://sound-designer`). Его контекст содержит подробные инструкции по использованию синтезатора. Он определяет собственную схему `input` для создания звуков. Это повторно используемый, автономный эксперт.
- Задача агента **`Композитор`** — создать песню. Один из его `Инструментов` — `createMelody`. Этот `Инструмент` сам по себе не реализует логику звукового дизайна. Вместо этого он делегирует задачу эксперту, указывая `_module: 'idea://sound-designer'`.

Когда `Композитор` решает использовать инструмент `createMelody`, он создаёт `Вызов`. Выполнение этого `Вызова` будет следующим:

1.  Создаст новый, изолированный подзапрос.
2.  Загрузит `Идею` `Звукорежиссёр` вместе с его инструкциями по синтезатору.
3.  Использует `_imports`, чтобы внедрить «повествование песни» `Композитора` в контекст `Звукорежиссёра`.
4.  LLM `Звукорежиссёра` теперь видит свои собственные экспертные инструкции в сочетании с конкретными творческими указаниями от `Композитора`.
5.  Он генерирует мелодию, которая возвращается как результат `Вызова` `createMelody`.

`Композитору` не нужно знать, как управлять синтезатором, а `Звукорежиссёру` не нужно знать о существовании `Композитора`. Это независимые модули, объединяемые во время выполнения для достижения сложной цели.

## Обработка Больших Схем

Протокол Модуля также предлагает решение для управления `Инструментами` с очень большими или сложными схемами вывода. Вместо включения огромной схемы `_output` в основной запрос, что потенциально может вытеснить другие инструменты, `Инструмент` можно определить только с его параметрами `input` и указателем `_module`.

LLM может спланировать `Вызов`, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе модуля. Это позволяет агенту рассуждать о последовательности сложных операций, не имея необходимости «видеть» всю детальную схему для каждого шага в одном окне контекста. LLM доверяет, что модуль произведёт правильный результат, который он получит и использует на последующих шагах.