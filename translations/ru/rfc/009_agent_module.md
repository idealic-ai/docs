# 009: Агент/Модуль

> **Модуль**: Внешняя, повторно используемая единица логики (`Действие` или `Идея`), которую можно вызвать через `Call` в `Области видимости Модуля`. Обозначается свойством `_module`.
>
> — [Словарь](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Agent/Call](./004_agent_call.md)
> - Дополняется:
>   - [008: Agent/Imports](./008_agent_imports.md)

Этот документ описывает **Протокол Модулей**, который позволяет выполнять `Инструменты` в изолированном контексте, либо ссылаясь на другую `Идею`, либо вызывая `Действие` в чистом подзапросе. Это основной механизм для создания сложных агентских поведений из автономных, повторно используемых компонентов.

## Проблема: Монолитные Инструменты и Утечка Контекста

По мере роста возможностей агента, определение всех `Инструментов` в едином, монолитном контексте становится непрактичным.

1.  **Большие схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать за один запрос. Объединение множества сложных `Инструментов` может превысить эти лимиты, мешая LLM правильно обработать доступные варианты.
2.  **Утечка контекста**: Когда все `Инструменты` работают в одном и том же контексте, LLM может поддаться влиянию нерелевантной информации, что приводит к неверному выбору `Инструмента` или заполнению параметров.
3.  **Отсутствие повторного использования**: `Инструмент`, определенный для одного агента, нелегко перенести на другой, не захватив с собой весь его контекст.

Протокол Модулей решает эти проблемы, вводя **Область видимости Модуля** — способ делегировать `Call` во внешнюю, изолированную среду выполнения.

## Свойство `_module`

Область видимости Модуля обозначается свойством `_module` в схеме `Инструмента`. Это свойство указывает системе рассматривать `Call` не как встроенную операцию, а как запрос к внешнему модулю.

Свойство `_module` является `строкой`.

- **`_module: 'idea://<idea-name>'`**: Строка, обычно URI, которая указывает на конкретную `Идею`. Это говорит исполнителю, что нужно запустить `Call` в контексте указанной `Идеи`.
- **`_module: 'anonymous'`**: Строковый литерал, который обозначает анонимный модуль. Он используется, когда вам нужна изолированная среда выполнения для `Действия` без лишних затрат на полный контекст `Идеи`.

## Выполнение в «чистой комнате»

Модуль предоставляет «чистую комнату» для выполнения. Вместо того чтобы работать в оживленном контексте родительского агента, `Call` обрабатывается в новом, изолированном подзапросе. Контекст для этого подзапроса тщательно создается, а не наследуется.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** становится критически важным. Свойство `_imports` в схеме `Инструмента` действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в чистую комнату модуля. Это дает родительскому агенту точный контроль над тем, что может видеть модуль, предотвращая утечку контекста и обеспечивая настоящую инкапсуляцию.

> Sidenote:
>
> - [008: Agent/Imports](./008_agent_imports.md)

## Композиция и Повторное Использование: Композитор и Звукорежиссер

Модули обеспечивают мощную композицию, позволяя `Идеям` действовать как автономные сервисы, которыми могут управлять другие агенты. Это создает ясную, динамичную иерархию: высокоуровневые агенты могут сосредоточиться на оркестрации, делегируя специализированные задачи низкоуровневым, повторно используемым модулям.

Рассмотрим рабочий процесс с двумя специализированными модулями: **`Композитором`** и **`Звукорежиссером`**.

- **`Звукорежиссер`** — это низкоуровневый эксперт. Это автономная `Идея` (`idea://sound-designer`), сосредоточенная на физике звука и знающая, как управлять синтезаторами для создания определенных аудиоданных.

- **`Композитор`** — это специалист среднего уровня. Его основная задача — создать песню. Он использует свои собственные встроенные инструменты для генерации мелодии и музыкальной структуры. Чтобы воплотить эту идею, он затем делает `Calls` к модулю `Звукорежиссера` для синтеза реальных звуков.

Эта двухуровневая иерархия — распространенный шаблон. Однако истинная сила модулей заключается в их динамичной, ориентированной на задачу композиции.

Теперь давайте представим высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую запись. В зависимости от конкретной задачи `Продюсер` может по-разному организовывать свои модули:

- **Иерархическая оркестрация**: Для создания песни `Продюсер` может сделать один `Call` к модулю `Композитора`. `Продюсер` дает общие указания («Мне нужна грустная баллада»), а `Композитор` выполняет весь свой внутренний рабочий процесс, включая собственные вложенные `Calls` к `Звукорежиссеру`. В этом случае `Продюсеру` не нужно знать о существовании `Звукорежиссера`.

- **Параллельная оркестрация**: Если `Продюсеру` также нужны определенные звуковые эффекты для записи (например, шумы или эмбиент), он может делать `Calls` напрямую к модулю `Звукорежиссера` для этих задач, параллельно с `Call` к `Композитору`.

Это демонстрирует ключевой принцип: композиция не является фиксированной внутри самих инструментов. `Продюсер` может рассматривать `Композитора` как «черный ящик» или взаимодействовать с его составными частями (`Звукорежиссером`) напрямую, в зависимости от сиюминутных потребностей. Эта гибкость позволяет комбинировать один и тот же набор экспертных модулей в различных аранжировках, создавая глубоко компонуемую и эмерджентную систему.

## Работа с большими схемами

Протокол Модулей также предлагает решение для управления `Инструментами` с очень большими или сложными выходными схемами. Вместо включения огромной схемы `_output` в основной запрос, что может вытеснить другие инструменты, `Инструмент` можно определить только с его `входными` параметрами и указателем `_module`.

LLM может спланировать `Call`, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе модуля. Это позволяет агенту рассуждать о последовательности сложных операций, не «видя» всей детальной схемы для каждого шага в одном окне контекста. LLM доверяет, что модуль произведет правильный результат, который он получит и использует на последующих шагах.

## Стратегии разрешения модулей

`Инструмент` становится `Модулем`, просто включив свойство `_module` в свою схему. Это сигнализирует о том, что `Call` следует делегировать. Ключевой вопрос — *когда* это делегирование разрешается. Система поддерживает две стратегии, позволяя найти компромисс между строгой безопасностью и динамической гибкостью.

### 1. Разрешение во время выполнения (по умолчанию)

Подход по умолчанию и самый гибкий — это разрешать модуль во **время выполнения**, после того как агент уже сгенерировал `Call`.

Этот метод открывает мощную парадигму, невозможную в традиционном коде: **LLM действует как интеллектуальный «связующий слой»**. Агент может сгенерировать `Call` с параметрами, которые не идеально соответствуют ожидаемой `входной` схеме модуля. Во время выполнения система собирает контекст модуля и предоставленные вызывающей стороной входные данные, и LLM в подзапросе получает задачу «заполнить пробел».

Это значительное преимущество, поскольку оно позволяет модулям обновляться и развиваться независимо. Даже если модуль меняет свою входную структуру, вызывающие агенты не «сломаются» немедленно. LLM попытается адаптировать старый формат `Call` к новой `входной` схеме, обеспечивая уровень устойчивости и слабой связанности, уникальный для этой архитектуры.

Процесс выглядит следующим образом:

1.  Агент генерирует `Call` к модульному `Инструменту`.
2.  Исполнитель видит свойство `_module` и инициирует протокол.
3.  **Сборка контекста**: Исполнитель получает `Идею` модуля (если он не анонимный) и собирает базовый контекст. Затем он использует `_imports` для добавления контекста вызывающей стороны.
4.  **Сопоставление входа**: `Параметры` из `Call` упаковываются во `Входное Сообщение` и добавляются в контекст. Именно здесь вступает в игру «связующая» способность LLM, так как она будет использовать эти входные данные для выполнения логики модуля, даже если схемы не совпадают идеально.
5.  **Выполнение**: Создается новый, изолированный `Запрос` с объединенным контекстом. Результат возвращается как вывод исходного `Call`.

### 2. Предварительное разрешение (опционально)

Для сценариев, требующих более строгих гарантий, модуль можно разрешить **заранее**, до отправки первоначального `Запроса` агенту.

В этом режиме система предварительно загружает `Идею` модуля и объединяет ее `входную` схему со схемой параметров `Инструмента`. Это позволяет LLM агента видеть точные требования модуля с самого начала, гарантируя, что сгенерированный `Call` будет идеально сформирован и типобезопасен.

Этот подход обеспечивает безопасность традиционных API-контрактов, но жертвует гибкостью разрешения во время выполнения. Его лучше всего использовать для критически важных, четко определенных интеграций, где слабая связанность не является желаемой особенностью.