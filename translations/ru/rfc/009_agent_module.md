# 009: Агент/Модуль

> **Модуль**: Протокол для изоляции контекста исполнения. Вызывается свойством `_module` в `Вызове` (`Call`) и исполняет `Действие` (`Activity`) или новый `Запрос` (`Request`) в изолированной среде. Свойство `_imports` предоставляет контролируемый доступ к родительскому контексту.

> — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Хотя в предыдущих документах было описано, как определяются и исполняются отдельные `Инструменты`, **Протокол Модулей** решает критическую задачу их масштабирования и композиции. Он предоставляет мощный механизм для выполнения `Инструментов` в изолированных средах, предотвращая смешение контекста и обеспечивая настоящее повторное использование. Делегируя `Вызов` внешнему модулю — другой `Идее` или `Действию` в подзапросе — система может создавать сложные агентные поведения из автономных, независимо разработанных компонентов.

## Проблема: Монолитные Инструменты и Смешение Контекста

По мере роста возможностей агента, определение всех `Инструментов` в едином, монолитном контексте становится непрактичным.

1.  **Большие Схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать в одном запросе. Объединение множества сложных `Инструментов` может превысить эти лимиты, мешая LLM правильно обработать доступные опции.
2.  **Смешение Контекста**: Когда все `Инструменты` работают в одном контексте, LLM может быть подвержена влиянию нерелевантной информации, что приводит к неправильному выбору `Инструмента` или заполнению его параметров.
3.  **Отсутствие Повторного Использования**: `Инструмент`, определённый для одного агента, не так просто перенести в другой, не захватив с собой весь его контекст.

Протокол Модулей решает эти проблемы, вводя **Область Видимости Модуля** — способ делегировать `Вызов` внешней, изолированной среде исполнения.

## Свойство `_module`

Область видимости модуля обозначается свойством `_module` в схеме `Инструмента`. Это свойство указывает системе, что `Вызов` следует рассматривать не как встроенную операцию, а как запрос к внешнему модулю.

Свойство `_module` является строкой (`string`) и может использоваться двумя способами:

- **Ссылка на `Идею`**: Строка может быть ссылкой на автономную `Идею` — JSON-объект, содержащий свойства `context` и `schema`. Это позволяет `Инструменту` делегировать своё исполнение совершенно другому набору инструкций. Ссылка может быть предоставлена как:
  - Путь или URL к JSON-файлу (например, `../ideas/my-idea.json`).
  - Ссылка с протоколом `idea://`.

  > Sidenote:
  > Сохранённый, повторно используемый **[001: Агент/Запрос](./001_agent_request.md)** — это наиболее распространённая форма `Идеи`. Протокол Модулей является основным механизмом для объединения этих `Идей` в более сложные системы. Подробнее см. в **[101: Концепция/Идея](./101_concept_idea.md)**.

- **Создать анонимный модуль**: Строковый литерал `'anonymous'` означает анонимный модуль. Это используется, когда вам нужна изолированная среда исполнения для `Действия` без накладных расходов на полный контекст сохранённого `Запроса`.

## Исполнение в Изолированной Среде

Модуль предоставляет «чистую комнату» (изолированную среду) для исполнения. Вместо того чтобы выполняться в насыщенном контексте родительского агента, `Вызов` обрабатывается в новом, изолированном подзапросе. Контекст для этого подзапроса тщательно конструируется, а не наследуется.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** становится критически важным. Свойство `_imports` в схеме `Инструмента` действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в изолированную среду модуля. Это даёт родительскому агенту точный контроль над тем, что модуль может видеть, предотвращая смешение контекста и обеспечивая настоящую инкапсуляцию.

> Sidenote:
> - [008: Агент/Импорты](./008_agent_imports.md)

## Обработка Больших Схем

Протокол Модулей также предлагает решение для управления `Инструментами` с очень большими или сложными схемами вывода. Вместо того чтобы включать громоздкую схему `_output` в основной запрос, что потенциально может вытеснить другие инструменты, `Инструмент` можно определить только с его `input` параметрами и указателем `_module`.

LLM может спланировать `Вызов`, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе модуля. Это позволяет агенту рассуждать о последовательности сложных операций, не «видя» всей детальной схемы для каждого шага в одном окне контекста. LLM доверяет, что модуль произведёт правильный вывод, который он получит и использует на последующих шагах.

## Стратегии Разрешения Модулей

`Инструмент` становится `Модулем` простым добавлением свойства `_module` в его схему. Это сигнализирует о том, что `Вызов` должен быть делегирован. Ключевой вопрос — *когда* это делегирование разрешается. Система поддерживает две стратегии, позволяя найти компромисс между строгой безопасностью и динамической гибкостью.

### 1. Разрешение во время Исполнения (По умолчанию)

Подход по умолчанию и самый гибкий — разрешать модуль **во время исполнения**, после того как агент уже сгенерировал `Вызов`.

Этот метод открывает мощную парадигму, невозможную в традиционном коде: **LLM выступает в роли интеллектуального связующего звена.** Агент может сгенерировать `Вызов` с параметрами, которые не идеально соответствуют ожидаемой `input` схеме модуля. Во время исполнения система собирает контекст модуля и предоставленные вызывающей стороной входные данные, а LLM в подзапросе получает задачу устранить это несоответствие.

Это значительное преимущество, так как позволяет модулям обновляться и развиваться независимо. Даже если модуль изменит свою структуру ввода, вызывающие его агенты не сломаются сразу. LLM попытается адаптировать старый формат `Вызова` к новой `input` схеме, обеспечивая уровень устойчивости и слабой связанности, уникальный для этой архитектуры.

Процесс выглядит следующим образом:

> Sidenote:
> ```mermaid
> graph TD
>     A[Агент создает Вызов] --> B{Исполнитель};
>     B --> C["1. Сборка Контекста<br/>(Модуль + Импорты)"];
>     C --> D["2. Сопоставление Ввода<br/>(Параметры Вызова)"];
>     D --> E["3. Исполнение<br/>(Новый Запрос)"];
>     E --> F["Внутренняя LLM устраняет<br/>несоответствия"];
>     F --> G[Результат возвращается Агенту];
> ```

1.  Агент генерирует `Вызов` к модульному `Инструменту`.
2.  Исполнитель видит свойство `_module` и инициирует протокол.
3.  **Сборка Контекста**: Исполнитель получает `Идею` модуля (если он не анонимный) и собирает базовый контекст. Затем он использует `_imports` для добавления контекста вызывающей стороны.
4.  **Сопоставление Ввода**: Параметры (`params`) из `Вызова` упаковываются во `Входное Сообщение` и добавляются в контекст. Именно здесь вступает в игру «связующая» способность LLM, так как она будет использовать эти входные данные для выполнения логики модуля, даже если схемы не совпадают идеально.
5.  **Исполнение**: Создаётся новый, изолированный `Запрос` с объединённым контекстом. Результат возвращается как вывод исходного `Вызова`.

### 2. Предварительное Разрешение (Опционально)

Для сценариев, требующих более строгих гарантий, модуль может быть разрешён **предварительно**, до того как исходный `Запрос` будет отправлен агенту.

В этом режиме система заранее извлекает `Идею` модуля и объединяет её `input` схему со схемой параметров `Инструмента`. Это позволяет LLM агента видеть точные требования модуля с самого начала, гарантируя, что сгенерированный `Вызов` будет идеально сформирован и типобезопасен. Важно отметить, что это предварительное слияние может также включать `_output` схему модуля, обеспечивая строгий контракт для ожидаемого результата.

Этот подход обеспечивает безопасность традиционных API-контрактов, где и входные, и выходные данные известны и проверяются. Он жертвует гибкостью разрешения во время исполнения и лучше всего подходит для критически важных, чётко определённых интеграций, где слабая связанность не является желаемой характеристикой.

## Композиция и Повторное Использование: Композитор и Звукорежиссёр

Модули обеспечивают мощную композицию, позволяя `Идеям` выступать в роли автономных сервисов, которые могут быть оркестрованы другими агентами. Это создаёт ясную, динамичную иерархию: высокоуровневые агенты могут сосредоточиться на оркестрации, делегируя специализированные задачи низкоуровневым, повторно используемым модулям.

Рассмотрим рабочий процесс с двумя специализированными модулями: **`Композитором`** и **`Звукорежиссёром`**.

- **`Звукорежиссёр`** — это низкоуровневый эксперт. Это автономная `Идея` (`idea://sound-designer`), сосредоточенная на физике звука и знающая, как управлять синтезаторами для создания конкретных аудиоданных.

- **`Композитор`** — это специалист среднего уровня. Его основная задача — создать песню. Он использует свои собственные встроенные инструменты для генерации мелодии и музыкальной структуры. Чтобы реализовать своё видение, он затем делает `Вызовы` к модулю `Звукорежиссёра` для синтеза реальных звуков.

Эта двухуровневая иерархия — распространённый паттерн. Однако истинная сила модулей заключается в их динамичной, ориентированной на задачу композиции.

Теперь давайте введём высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую запись. В зависимости от конкретной задачи, `Продюсер` может оркестровать свои модули по-разному:

- **Иерархическая Оркестрация**: Для создания песни `Продюсер` может сделать один `Вызов` к модулю `Композитора`. `Продюсер` даёт общее направление («Мне нужна грустная баллада»), а `Композитор` выполняет весь свой внутренний рабочий процесс, включая свои собственные вложенные `Вызовы` к `Звукорежиссёру`. `Продюсеру` в этом случае не нужно знать о существовании `Звукорежиссёра`.

- **Параллельная Оркестрация**: Если `Продюсеру` также нужны конкретные звуковые эффекты для записи (например, фоли или эмбиентный саундскейп), он может делать `Вызовы` напрямую к модулю `Звукорежиссёра` для этих задач, параллельно с `Вызовом` к `Композитору`.

Это демонстрирует ключевой принцип: композиция не зафиксирована внутри самих инструментов. `Продюсер` может либо рассматривать `Композитора` как «чёрный ящик», либо напрямую взаимодействовать с его составными частями (`Звукорежиссёром`), в зависимости от потребностей момента. Эта гибкость позволяет одним и тем же наборам экспертных модулей сочетаться в различных аранжировках, создавая глубоко компонуемую и эмерджентную систему.
