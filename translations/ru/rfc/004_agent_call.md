# 004: Агент/Вызов

> **Вызов —** это конкретный, исполняемый экземпляр `Tool` с заданными значениями для его `params`. Это ориентированный на исполнение запрос о том, _что должно быть сделано_.
>
> — [Глоссарий](./000_glossary.md)

- Требует:
  - [103: Концепция/Идеатор](./103_concept_ideator.md)
- Открывает возможности для:
  - [008: Агент/Импорты](./008_agent_imports.md)
  - [011: Агент/Инстансинг](./011_agent_instancing.md)
  - [202: Идея/Носитель](./202_idea_vessel.md)
  - [203: Идея/Процесс](./203_idea_process.md)
- Расширяется:
  - [009: Агент/Модуль](./009_agent_module.md)

[101: Концепция/Идея](./101_concept_idea.md) определяет мощную, самодостаточную структуру данных для представления знаний и скрытой логики. [002: Агент/Инструмент](./002_agent_tool.md) устанавливает фундаментальный, основанный на схемах интерфейс, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **004: Агент/Вызов**, который строится на основе Инструментов, чтобы определить, как происходит исполнение.

**Вызов** — это конкретный экземпляр Инструмента с заданными значениями параметров, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это исполняется_.

> [!TIP]
> **[001: Агент/Запрос](./001_agent_request.md)**, результатом которого является набор `Вызовов`, представляет собой **[202: Идея/Носитель](./202_idea_vessel.md)**. `Носитель` представляет собой единый, реактивный момент принятия решения, когда агент выбирает из доступных `Инструментов` для формирования ответа.

## Композиция и Контекст

`Вызов` сам по себе является простой структурой данных. Его сила заключается в композиции с другими протоколами, которые управляют его средой исполнения. Эти протоколы активируются специальными мета-свойствами (с префиксом `_`) в схеме `Инструмента`, позволяя одному объекту `Вызова` запускать разнообразные сценарии исполнения.

Придавая этим мета-свойствам четкий семантический смысл, мы позволяем LLM стать активным участником композиции. Она может анализировать различные комбинации этих свойств для создания сложных и новых цепочек исполнения, переходя от простого выбора инструментов к динамической оркестрации рабочих процессов.

- **Явное исполнение (`_activity`)**: Самое фундаментальное расширение — это связывание `Вызова` с детерминированной функцией кода. Свойство `_activity` указывает, что `Вызов` должен быть исполнен **Действием**, а не через скрытое логическое рассуждение LLM.

  - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное исполнение (`_module`)**: `Вызов` может быть делегирован внешнему **Модулю**. Свойство `_module` обычно содержит ссылку на сохраненный **[001: Агент/Запрос](./001_agent_request.md)** (часто в виде пути к файлу JSON), что позволяет вызывать этот запрос как переиспользуемый инструмент. Это обеспечивает изолированную «чистую комнату» для исполнения, предотвращая смешение контекстов и обеспечивая настоящую инкапсуляцию.

  - [009: Агент/Модуль](./009_agent_module.md).

- **Передача контекста (`_imports`)**: Протокол **Импортов** контролирует, какой контекст доступен `Вызову`. Его основное применение — сфокусировать внимание LLM во время скрытого исполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает смешение контекстов и приводит к более надежным результатам. При использовании с `_module` его роль становится еще более мощной: он строго определяет _весь_ контекст для изолированного исполнения модуля.

  - [008: Агент/Импорты](./008_agent_imports.md).

- **Исполнение с состоянием (`_outputPath`)**: `Вызов` можно сделать сохраняющим состояние, указав ему, куда записывать свой результат. Свойство `_outputPath` указывает путь в персистентном **Объекте Состояния**, куда должен быть сохранен результат `Вызова`. Это позволяет создавать многошаговые рабочие процессы, где результат одного `Вызова` может использоваться как вход для другого.

  - [010: Агент/Состояние](./010_agent_state.md).

- **Инстансированное исполнение (`_instance`)**: `Вызов` может быть нацелен на конкретный **Экземпляр** в рамках запроса с несколькими экземплярами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого `Вызова` (например, чтение входных данных из `Объекта Состояния` и запись результатов в него) на определенном контексте. Это обеспечивает эффективную, параллельную обработку нескольких состояний с одним и тем же набором инструментов.
  - [011: Агент/Инстансинг](./011_agent_instancing.md).

## Паттерны исполнения Вызовов

Когда агент генерирует несколько Вызовов, в зависимости от потребностей приложения можно применять различные стратегии исполнения:

```typescript
// Исполнение одного Вызова
const result = await Tool(call);

// Исполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все Вызовы, вернуть первый завершенный результат (успех или неудача)
const result = await Tool.race(calls);
```

Эти паттерны обеспечивают:

- **Тонкая настройка управления**: Обрабатывайте Вызовы индивидуально с пользовательской логикой между исполнениями.
- **Пакетная обработка**: Исполняйте независимые Вызовы параллельно для максимальной производительности.
- **Стратегии быстрого отказа**: Остановитесь при первом успехе (`.any()`) или первом завершении (`.race()`).
- **Операции «всё или ничего»**: Гарантируйте, что все Вызовы завершатся успешно вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы.

## Оркестрация Вызовов в цикле

Хотя эти паттерны управляют исполнением одной пачки `Вызовов`, агентам часто необходимо выполнять многошаговые задачи, где результат одного `Вызова` влияет на следующий. Это решается протоколом более высокого уровня, который организует последовательность `Запросов` и `Вызовов`.

Следующий документ, **[005: Агент/Цикл](./005_agent_loop.md)**, подробно описывает этот цикл исполнения.