# 004: Агент/Вызов

> **Вызов:** Конкретный, исполняемый экземпляр `Tool` с определёнными значениями для его `params`. Это ориентированный на исполнение запрос о том, что _должно быть сделано_. — [Глоссарий](./000_glossary.md)

> Sidenote:
> 
> - Требует: [103: Концепция/Идеатор](./103_concept_ideator.md)
> - Открывает: [008: Агент/Импорты](./008_agent_imports.md), [011: Агент/Инстансинг](./011_agent_instancing.md)

[101: Концепция/Идея](./101_concept_idea.md) определяет мощную, самодостаточную структуру данных для представления знаний и скрытой логики. [002: Агент/Инструмент](./002_agent_tool.md) создаёт базовый, управляемый схемой интерфейс, который позволяет агентам понимать структурированные возможности. Этот документ описывает **Протокол вызова**, который, основываясь на Инструментах, определяет, как происходит выполнение с помощью элементов управления Областью и Методом.

**Вызов** — это конкретный экземпляр Инструмента с определёнными значениями параметров, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это будет исполнено_.

## Конвейер от Идеи к Вызову

1.  **Идея**: Самодостаточный, ориентированный на результат документ, представляющий знание или процесс.
2.  **Инструмент**: `Idea`, преобразованная в ориентированную на интерфейс схему и зарегистрированная в системе инструментов агента (подробнее о схемах Инструментов, регистрации и архитектуре двойного реестра см. в [002: Агент/Инструмент](./002_agent_tool.md)).
3.  **Вызов**: Когда LLM решает использовать `Tool`, она заполняет определённые параметры, создавая **Вызов**. `Call` — это единичный, конкретный экземпляр вызываемого `Tool`.

Основной принцип: **любая Идея может быть преобразована в Инструмент, который затем может быть исполнен как Вызов.**

Подробное объяснение того, как входная схема `Idea` преобразуется в схему параметров `Tool`, смотрите в **[007: Агент/Ввод](./007_agent_input.md)**.

## Элементы управления исполнением: Область и Метод

Исполнение `Call` определяется двумя независимыми свойствами: **Областью** (где он выполняется) и **Методом** (как он выполняется). Эти элементы управления обозначаются специальными свойствами (`_module`, `_activity`, `_output`) в схеме инструмента.

### Две оси исполнения

1.  **Область (Встроенная или Модульная)**
    Область определяет, происходит ли исполнение в текущем контексте агента или делегируется внешнему, изолированному модулю.
    - **Встроенная область**: Режим по умолчанию, при котором `Call` обрабатывается напрямую.
    - **Модульная область**: Обозначается через `_module` и делегирует `Call` внешнему `Activity` или `Idea`.

2.  **Метод (Явный или Скрытый)**
    Метод определяет, генерируется ли результат детерминированным кодом или LLM.
    - **Явный метод**: Обозначается наличием свойства `_activity`; результат `Call` генерируется детерминированным кодом.
    - **Скрытый метод**: Поведение по умолчанию при отсутствии `_activity`. Результат `Call` генерируется LLM. Требует наличия необязательного свойства `_output`.

Эти элементы управления можно комбинировать в различные паттерны исполнения, а их контекст контролировать через импорты. Подробное объяснение того, как эти элементы управления комбинируются и как управляется контекст, см. в **[008: Агент/Импорты](./008_agent_imports.md)**.

## Идея, Инструмент и Вызов: Различия в фокусе

Чтобы понять связь между ними, необходимо уяснить фундаментальное различие в фокусе этих трёх понятий.

- **Идея** **ориентирована на результат**. Её основная цель — представить завершённую мысль или результат. `schema` определяет форму `solution` (результата), который был сгенерирован из `context`. Это запись того, что _было_ или _могло бы быть_.

- **Инструмент** **ориентирован на интерфейс**. Его схема определяет параметры (входные данные) и структуру `_output`. Это абстрактный шаблон для действия — сигнатура функции, ожидающая вызова.

- **Вызов** **ориентирован на исполнение**. Это конкретный, исполняемый экземпляр `Tool`. Он берёт ориентированный на параметры интерфейс `Tool` и заполняет его конкретными значениями, превращая в готовый к выполнению запрос о том, что _должно быть сделано_.

## Идея-контейнер: единый момент принятия решения

Когда агенту нужно принять решение, полный запрос, отправляемый в LLM, структурируется как особый тип `Idea`, который мы называем **Идея-контейнер**. Она представляет собой единый, самодостаточный момент принятия решения.

Идея-контейнер объединяет два ключевых компонента, необходимых LLM для принятия решения:

1.  **Контекст**: Включает всю релевантную информацию, необходимую агенту, например, запрос пользователя, память и другие данные окружения.
2.  **Схема**: Для Идеи-контейнера основная роль схемы — определить «Контейнер», то есть набор возможных `Tools`, которые агент может использовать в данной конкретной ситуации.

LLM обрабатывает всю эту `Idea` — контекст и схему доступных инструментов — и её `solution` является результатом этого решения: массив из нуля или более `Calls` для исполнения.

Эта структура позволяет одной целостной `Idea` представлять сложное, многошаговое действие.

## Паттерны исполнения Вызовов

Когда Идея-контейнер производит несколько Вызовов, можно применять различные стратегии исполнения в зависимости от потребностей приложения:

```typescript
// Выполнение одного Вызова
const result = await Tool(call);

// Выполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Вызовы, вернуть первый завершённый результат (успех или неудача)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Тонкая настройка управления**: Обрабатывать Вызовы по отдельности с пользовательской логикой между исполнениями
- **Пакетная обработка**: Выполнять независимые Вызовы параллельно для максимальной производительности
- **Стратегии быстрого отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «всё или ничего»**: Гарантировать, что все Вызовы успешно завершатся вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы