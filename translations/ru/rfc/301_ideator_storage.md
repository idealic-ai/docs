# 301: Ideator/Хранилище

## 1. Введение

Этот документ определяет **Систему: Хранилище** — основной служебный сервис в экосистеме Idea. Сервис Хранилища функционирует как специализированный **Idea Transformer**, главная цель которого — предоставлять постоянное, контентно-адресуемое хранилище для `Ideas`. Это основополагающий слой для памяти и воспроизведения, позволяющий сохранять и версионировать `Ideas` для последующего использования другими сервисами, такими как [Система: Resolver](./202_ideator_resolver.md).

## 2. Основная концепция: Хранилище как Idea Transformer

Сервис Хранилища следует шаблону `Idea Transformer`, принимая `Idea` на входе и возвращая `Idea` на выходе.

- **Входные данные**: Валидный триплет `Idea` (`schema`, `solution`, `context`).
- **Процесс**: Сервис получает `Idea`, присваивает ему уникальный адресуемый идентификатор (который включает версионирование) и сохраняет его в надёжное хранилище (например, в базу данных PostgreSQL).
- **Выходные данные**: Сервис возвращает исходный `Idea` в качестве подтверждения успешного сохранения. Эти данные могут быть дополнены метаданными, такими как присвоенный идентификатор и версия, подтверждающими его сохранение.

## 3. Хранилище как транзакционная граница

Критически важная роль сервиса Хранилища — действовать как **транзакционная граница**. Когда внешний участник (например, пользователь или другой сервис) отправляет `Idea` и получает успешное подтверждение, первоначальная транзакция считается завершённой.

Это разделение является основой устойчивости и масштабируемости архитектуры. Оно позволяет системе создавать сложные, событийно-ориентированные рабочие процессы. Как только `Idea` зафиксирована в `Storage`, другие сервисы (например, `Watcher` или `Subscriber`) могут реагировать на это изменение, инициируя новые, независимые транзакции для продолжения процесса. Это избавляет от необходимости в длительных монолитных транзакциях и создаёт чёткую, проверяемую передачу управления между различными этапами рабочего процесса.

## 4. Ключевые характеристики

### 4.1. Постоянство «чёрного ящика»

Сервис Хранилища спроектирован как управляемый «чёрный ящик». Пользователи отправляют `Ideas` на хранение, не имея контроля над базовым механизмом хранения (например, типом базы данных, шардингом) или политиками хранения данных. Сервис гарантирует, что `Idea` после принятия будет сохранена и доступна для использования. Конкретные детали реализации остаются на усмотрение поставщика услуг.

### 4.2. Версионирование и неизменяемость

Система построена на принципе неизменяемости. При «обновлении» существующей `Idea` сервис хранилища не изменяет исходную запись. Вместо этого он создаёт и сохраняет новую версию `Idea`, поддерживая полную, неразрывную цепочку её истории. Это гарантирует, что любая ссылка на конкретную версию `Idea` всегда будет указывать на одно и то же содержимое. Ссылки могут указывать на определённую версию или на динамическую ветку (например, `latest`).

### 4.3. Контентно-адресуемое хранение

Хотя точная схема адресации является деталью реализации, основной принцип заключается в том, что каждая сохранённая `Idea` однозначно идентифицируема и может быть получена по своему идентификатору и версии. Это позволяет создать надёжную и децентрализованную систему, в которой на `Ideas` можно ссылаться с высокой точностью.

## 5. Публичный интерфейс

Публичный интерфейс системы Хранилища прост и ориентирован на запись, что соответствует его основной роли «приёмника» для `Ideas`.

- **Основное взаимодействие**: Единственным публичным взаимодействием является отправка `Idea`.

- **Отделение от извлечения данных**: Для поддержания чёткого разделения ответственности сервис Хранилища не предоставляет публичный API для общего извлечения данных или выполнения запросов. Обязанность по получению и обработке `Ideas` явно делегирована сервису **Resolver**. Это позволяет каждому сервису сосредоточиться на одной задаче: Хранилище отвечает за сохранение, а Resolver — за извлечение и композицию.