# 008: Агент/Создание экземпляров

> Sidenote:
>
> - Требуется: [Агент: Состояние](./007_agent_state.md)
> - Совместимо:
>   - [Агент: Ввод](./005_agent_input.md)
>   - [Агент: Импорты](./006_agent_imports.md)
>   - [Агент: План](./009_agent_plan.md)

> **Создание экземпляров:** Процесс обработки нескольких независимых `Instances` (экземпляров), каждый со своим `State Object` (объектом состояния) и уникальным идентификатором, в рамках одного запроса к агенту.
>
> — [Глоссарий](./000_glossary.md)

Этот документ описывает протокол для обработки нескольких независимых экземпляров в рамках одного запроса к агенту, используя архитектуру, управляемую состоянием.

## 1. Основное требование: система состояний

Главное предварительное условие для этого протокола — **система состояний**, которая чётко разделяет планирование действий и их выполнение.

**Объект состояния** (`State Object`) — это связующее звено между этими этапами. Это изменяемый, похожий на JSON объект, который выполняет две ключевые функции:

1.  **Цель для выполнения**: Это «холст», на котором работают инструменты. Каждый вызов инструмента (`Tool Call`) содержит свойство `_outputPath`, которое указывает путь в объекте `State`, куда должен быть записан результат работы инструмента.
2.  **Источник для зависимостей**: `Tool Call` может ссылаться на значение из `State` в качестве одного из своих входных данных. Это позволяет создавать графы зависимостей.

## 2. Механизм создания экземпляров

Истинная сила этой архитектуры раскрывается в её встроенной поддержке операций с несколькими экземплярами, которая стала возможной благодаря системе состояний.

### 2.1. Идентификаторы состояний

Для обработки нескольких экземпляров в одном запросе система принимает массив контекстных сообщений. Каждому сообщению, представляющему отдельный экземпляр, присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы — короткие, уникальные токены (например, числа в кружках: `①`, `②`), которые легко распознаются LLM, но не несут никакого смыслового значения, кроме как служить ссылкой.

### 2.2. Целевые операции

Этот `_instance` затем используется для направления всех операций в контекст конкретного экземпляра. Кроме того, все мета-параметры для `Tool Call` начинаются с подчёркивания (`_`), а его `params` встраиваются непосредственно в объект вызова.

- **Связь с `Tool Call`**: Каждый `Tool Call` в сгенерированном плане содержит `_instance` того контекста, с которым он должен работать.
- **Неявное ограничение области**: `_instance` в `Tool Call` неявно ограничивает область действия всех операций, основанных на путях (`_outputPath` и ссылки на входные данные), внутри этого вызова. Это означает, что когда инструмент читает данные из объекта состояния или записывает в него, путь указывается относительно `_instance` того контекста, к которому он принадлежит.

Этот механизм позволяет сохранять определения самих инструментов простыми и независимыми от контекста экземпляров. Свойства `_outputPath` и ссылки на входные данные в схеме инструмента не требуют обновления; идентификатор чётко разделяет операционные контексты.

### 2.3. Пример

Один запрос может содержать два объекта состояния для анализа тональности. Может быть предоставлена схема состояния, чтобы ограничить доступные свойства и направить работу LLM.

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "This is wonderful!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "This is terrible." } }
  ]
}
```

LLM обрабатывает оба экземпляра в едином контексте и создаёт общий план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      "text": "†state.text",
      "_outputPath": "sentiment"
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

Затем хост-среда выполняет этот план, записывая результаты в соответствующие объекты состояния.

## 3. Дополнительная система: граф планирования

Хотя это и не является строгим требованием для создания экземпляров, **система планирования** работает в тесной связке с этой архитектурой, позволяя создавать очень предсказуемые и многократно используемые рабочие процессы.

**План** — это шаблон процесса, определённый как направленный ациклический граф (DAG) из `Tool Call`. Этот граф создаётся путём анализа зависимостей между инструментами, которые читают данные из `State Object` и записывают в него.

Важно, что этот план можно создать и доработать _до_ выполнения. После завершения план можно передать агенту как `Context Message`. При обработке нескольких экземпляров агент может следовать этому заранее определённому плану для каждого `State Object`, достигая высокой согласованности и предсказуемости результатов при каждом вызове. `State Object` для каждого экземпляра служит снимком его текущего положения в этом графе выполнения.

## 4. Преимущества этого подхода

Эта модель создания экземпляров, управляемая состоянием, даёт значительные преимущества:

- **Эффективность**: Увеличивает пропускную способность системы за счёт обработки множества экземпляров в одном запросе к LLM, что значительно повышает скорость и снижает затраты.
- **Согласованность и качество**: Позволяя LLM видеть несколько связанных экземпляров в одном контексте, модель может создавать более согласованные и качественные планы, используя общие закономерности для всех экземпляров.
- **Предсказуемость**: В сочетании с заранее определённым **планом** система может достигать детерминированных результатов. Детерминированный цикл выполнения гарантирует, что после следования плану его результат будет надёжным и повторяемым для каждого экземпляра.