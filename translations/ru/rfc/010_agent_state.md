# 010: Агент/Состояние

> **Сообщение о состоянии:** Постоянное сообщение `Data`, которое представляет живую, развивающуюся память рабочего процесса. Оно действует как набор локальных переменных, обеспечивая многоэтапные операции с сохранением состояния. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [006: Агент/Данные](./006_agent_data.md)
> - Позволяет:
>   - [012: Агент/План](./012_agent_plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **сообщение State**, которое предоставляет механизм для управления постоянным состоянием в цикле выполнения агента. Сообщение `State` — это специализированное применение системы **Data**, предназначенное для создания многоэтапных рабочих процессов с состоянием. Оно работает как контейнер для «локальных переменных» процесса, позволяя сохранять контекст между последовательными выполнениями `инструментов`.

Объект `State` служит источником истины о текущем статусе запроса и является ключом к отказоустойчивости и возобновлению. Поскольку он фиксирует полный контекст рабочего процесса в определенный момент времени, это позволяет приостанавливать и возобновлять процесс. Когда начинается новая итерация, `State` из предыдущего шага дает LLM четкое понимание того, на чем остановился процесс, обеспечивая бесшовное продолжение работы.

## Многоэтапные Инструменты

Основная функция сообщения `State` — позволить разным `инструментам` обмениваться информацией в рамках единого непрерывного процесса. Оно обеспечивает операции с состоянием, предоставляя общее пространство, где `инструменты` могут сохранять свои результаты.

Это достигается с помощью простого механизма чтения/записи: один `инструмент` может записать свой результат в объект `State`, а другой `инструмент` — прочитать эти данные в качестве входных на следующем шаге. Это позволяет создавать цепочки инструментов, где результат одной операции напрямую используется как входные данные для следующей, и все это без потери контекста между выполнениями.

## Входные данные

Основной механизм для чтения из `State` — это **ссылки на переменные (Variable References)**. Эта система позволяет любому параметру в `вызове инструмента (Tool Call)` быть специальной строкой, которая ссылается на переменную из контекста, а не на само значение. Ссылка представляет собой строку с определенным синтаксисом. Такой подход очень эффективен, так как позволяет избежать дублирования больших объектов данных, экономя место и ресурсы.

Ссылка — это простая строка с префиксом в виде крестика (`†`). Синтаксис выглядит так: `†<kind>.<path>`, где `<kind>` — это тип сообщения `Data` (например, `state`, `input`), а `<path>` — это путь к нужному значению в точечной нотации.

Например, `вызов инструмента` для получения профиля пользователя может выглядеть так:

```json
{
  "_tool": "fetchUserProfile",
  "userId": "†state.currentUser.id"
}
```

Во время выполнения система разрешает эту ссылку, извлекает значение из `state.currentUser.id` и подставляет его как параметр `userId` перед запуском инструмента.

## Выходные данные

Основной механизм для записи в `State` — это мета-свойство `_outputPath` в `Вызове (Call)`. Эта строка указывает исполняющей системе, куда поместить результат работы инструмента.

> Sidenote: [004: Агент/Вызов](./004_agent_call.md)

`Схема` (`schema`) сообщения `State` может использоваться для определения набора ожидаемых свойств. Это создает мощную обратную связь для LLM: когда `схема` требует определенных свойств, LLM направляется на вызов `инструментов`, `_outputPath` которых соответствует этим свойствам, что обеспечивает структурную правильность последовательности `инструментов`.

### Синтаксис пути

Строка `_outputPath` может принимать несколько форм:

- **Обычный путь:** Простая строка, указывающая на одно место. Необязательный префикс `†state.` — это соглашение, уточняющее, что путь нацелен на объект `State`.
  ```json
  "†state.user.summary"
  ```
- **Альтернативные пути (ветвление):** Использование `||` для разделения путей указывает на набор возможных результатов. Вывод будет записан в одно из указанных мест, причем выбор часто определяется исполняющей системой или на последующем шаге рассуждения.
  ```json
  "†state.summary.text || †state.summary.json"
  ```
- **Параллельные пути (разветвление):** Использование `&&` указывает системе выполнить разветвление (fan-out), записывая один и тот же результат по всем указанным путям одновременно.
  ```json
  "†state.user.profile.summary && †state.audit.log.summary"
  ```

### Способы определения

Способ определения значения `_outputPath` задается его схемой — это похоже на то, как система **Imports** обрабатывает контекст:

- **Динамический (определяется LLM):** Схема `инструмента` для `_outputPath` может быть гибкой (например, `{ "type": "string" }`), что дает LLM свободу генерировать любой из вышеуказанных синтаксисов пути. Это позволяет агенту динамически соединять инструменты и создавать новые потоки данных на лету.

  _Схема инструмента:_

  ```json
  {
    "_outputPath": {
      "type": "string"
    }
  }
  ```

- **Предписанный (жестко заданный):** В качестве альтернативы, схема может использовать ограничивающие ключевые слова JSON Schema, такие как `const`, `enum` или `oneOf`, чтобы зафиксировать поведение инструмента. Значение `const` задает один конкретный путь, а `enum` может заставить LLM выбирать из ограниченного набора предопределенных вариантов. Это крайне важно для создания стабильных рабочих процессов и надежных моделей обработки ошибок, когда возможные исходы известны заранее.

  _Схема инструмента (предписывающая выбор путей для успеха/неудачи):_

  ```json
  {
    "_outputPath": {
      "enum": ["†state.success", "†state.failure"]
    }
  }
  ```

Эта гибкость — ключевой элемент системы **План**, позволяющий разработчику рабочего процесса выбирать между предоставлением агенту творческой свободы и принудительным использованием жесткого, надежного потока данных.

## Планирование и выполнение

Сочетание записи в состояние через `_outputPath` и чтения из него с помощью **ссылок на переменные** является основным механизмом, который обеспечивает разделение планирования и выполнения. Это позволяет агенту построить полный граф потока данных — цепочку `вызовов инструментов`, связанных ссылками, — _перед_ запуском любого инструмента.

Этот граф ссылок можно проверять, повторно использовать и даже симулировать, что делает его полностью совместимым со скрытым исполнением LLM. Гибкость этой системы обусловлена возможностью контролировать как входные, так и выходные данные на уровне схемы. Разработчик рабочего процесса может оставить **ссылки на переменные** (входы) и **`_outputPath`** (выходы) динамическими, чтобы их определяла LLM, или же предписать их для обеспечения жесткого и надежного потока данных.

> [!TIP]
> Создание `вызовов инструментов`, связанных друг с другом через `State`, и есть акт планирования. Эта система предоставляет техническую основу для этого процесса: постоянное `состояние` служит холстом, **ссылки на переменные** и `_outputPath` — проводами, а **цикл** агента — итерационным движком. Вместе эти компоненты позволяют агенту построить полный граф потока данных, что и является сутью **Плана (Plan)**.
>
> > Sidenote:
> >
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [012: Агент/План](./012_agent_plan.md)

## Взаимодействие

- **Вызов (Call):** Система `Вызовов` тесно связана с `Состоянием` через мета-свойство `_outputPath`. Это свойство превращает `вызов инструмента`, который в противном случае мог бы быть чистой функцией без состояния, в операцию, изменяющую состояние. Указывая `_outputPath`, `Вызов` направляет систему записать свой результат в объект `State`, что делает его основным механизмом для агента для записи итогов своих действий. Это взаимодействие позволяет последовательности `Вызовов` наслаиваться друг на друга, создавая причинно-следственную цепочку, которая фиксируется в `состоянии`.

  > Sidenote: [004: Агент/Вызов](./004_agent_call.md)

- **Данные (Data):** Сообщение `State` по своей сути является специализированным применением системы сообщений `Data`, используя сообщение `Data` с `kind: "state"`. Оно использует основные возможности сообщений `Data` для создания постоянной памяти для агента. Свойство `schema` используется для определения ожидаемой структуры этой памяти, предоставляя черновик, который направляет действия LLM. Кроме того, критически важны возможности слияния системы `Data`, позволяющие инкрементально обновлять `состояние` через серию патчей, которые система объединяет в единое, целостное представление.

  > Sidenote: [006: Агент/Данные](./006_agent_data.md)

- **Импорты (Imports):** Система `импортов` — это основной механизм для предоставления объекта `State` инструменту, работающему в изолированном контексте, например, в **модуле (Module)**. Когда `Вызов` делегируется, свойство `_imports` может указать, что `состояние` (`state`) должно быть включено в «чистую комнату» модуля. Это позволяет инкапсулированным инструментам читать и взаимодействовать с состоянием основного рабочего процесса контролируемым и явным образом.

  > Sidenote: [008: Агент/Импорты](./008_agent_imports.md)

- **План (Plan):** Хотя `состояние` позволяет создавать простые последовательности инструментов, его полная мощь раскрывается при использовании в качестве основы системы `Планов (Plan)`. В `Плане` рабочий процесс представлен в виде направленного ациклического графа (DAG), где узлами являются `вызовы инструментов`. Объект `State` обеспечивает связи — ребра — между этими узлами. Он позволяет одному узлу записывать в переменную, а другим читать из нее, обеспечивая сложные шаблоны, такие как логические ветвления (if-else) или параллельные разветвления.

  > Sidenote: [012: Агент/План](./012_agent_plan.md)

- **Инстансинг (Instancing):** Сообщение `State` полностью совместимо с системой `инстансинга`. Когда запрос обрабатывает несколько `экземпляров (Instances)`, каждый из них поддерживает свой собственный изолированный объект `State`, идентифицируемый уникальным ключом `_instance`. **Ссылки на переменные** (например, `†state.currentUser.id`) автоматически и прозрачно направляются к правильному объекту `State`, соответствующему `экземпляру`, на который нацелен `вызов инструмента`. Это позволяет выполнять один общий `План` для множества различных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote: [011: Агент/Инстансинг](./011_agent_instancing.md)

## От одного состояния к параллельному выполнению

Сообщение `State` предоставляет механизм для управления памятью единого, целостного рабочего процесса. Однако для создания действительно масштабируемых систем агенты должны уметь применять один и тот же рабочий процесс к множеству различных данных одновременно. Это требует способа управления несколькими независимыми состояниями параллельно в рамках одного запроса, при котором операции вроде **ссылок на переменные** и `_outputPath` правильно направляются к соответствующему состоянию.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает систему, которая делает возможным такое параллельное выполнение.
