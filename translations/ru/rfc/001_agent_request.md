# 001: Агент/Запрос

> **Запрос:** Единичный, самодостаточный вызов LLM, который принимает `context` и `schema` для создания `solution`. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Активирует: [101: Концепция/Идея](./101_concept_idea.md)
>
> NPM: [https://www.npmjs.com/package/@augceo/agent](@idealic-ai/agent)

Этот документ описывает **Протокол Запроса**, который определяет основную единицу взаимодействия с LLM. `Запрос` — это механизм, который делает абстрактную **[101: Концепция/Идея](./101_concept_idea.md)** выполнимой, используя её `context` и `schema` для генерации `solution`.

## Конвейер Запроса

> Sidenote:
> LLM обработает `context` для создания `solution`, соответствующего `schema`.
>
> ```mermaid
> graph TD
>     subgraph Ввод пользователя
>         direction LR
>         Context[Контекст]
>         Schema[Схема]
>     end
>
>     Process{{"Запрос"}}
>
>     subgraph Вывод LLM
>         direction LR
>         Solution[/Решение/]
>     end
>
>     Context --> Process
>     Schema --> Process
>     Process --> Solution
>     Schema -.-> Solution
>
>     linkStyle 2 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
>     linkStyle 3 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
> ```

`Запрос` — это не просто подсказка. Это структурированный конвейер, который преобразует сложный, многосоставный контекст в единый ответ от LLM, соответствующий схеме.

### 1. Контекст: Массив Сообщений

Основой `Запроса` является его `context`, который представляет собой массив объектов `Message`. Это позволяет структурированно передать LLM сложный диалог с несколькими репликами или ролями.

Простой контекст может выглядеть так:

```json
[
  { "role": "system", "content": "Вы — полезный ассистент." },
  { "role": "user", "content": "Какая столица Франции?" }
]
```

### 2. Пользовательские типы содержимого

Система расширяет эту базовую структуру, поддерживая **пользовательские типы содержимого** в сообщениях. Вместо обычной строки, `content` сообщения может быть структурированным объектом, например: `{ "type": "state", "state": { ... } }`.

Эти пользовательские типы определяются и управляются системой `Content` (см. `agent/src/Content/Content.ts`). Каждый такой тип регистрируется с обработчиком, а эти обработчики образуют конвейер обработки. При обработке каждого сообщения его обработчик может изменять три основных компонента `Запроса`:

- **Конфигурация LLM**: Настройка параметров, таких как модель, температура и другие опции.
- **Схема**: Изменение JSON-схемы, которой должен соответствовать конечный результат.
- **Контекст**: Изменение итогового списка сообщений для LLM, например, преобразуя пользовательский тип в текст или добавляя новые сообщения.

Этот мощный механизм конвейера позволяет агенту работать с высокоуровневыми, структурированными концепциями, динамически создавая точный вызов LLM, необходимый для выполнения задачи.

### 3. Схема: Направляя Решение

`schema` — это JSON Schema, которая определяет точную структуру желаемого `solution`. Функция `Request` анализирует возможности заданного провайдера LLM, чтобы определить лучший способ применения схемы:

1.  **Нативный режим JSON Schema**: Если провайдер его поддерживает (как новые модели OpenAI), схема передается напрямую в поле `response_format` API-вызова. Это самый надежный метод.
2.  **Запасной вариант через вызов инструментов**: Если провайдер поддерживает вызов инструментов, но не нативный режим схемы, система оборачивает схему в инструмент-функцию с именем `generate_response` и дает модели команду вызвать этот инструмент.
3.  **Режим JSON с внедрением в подсказку**: В качестве крайней меры для провайдеров, которые поддерживают только общий вывод в JSON, система дает модели команду сгенерировать JSON-объект и вставляет схему в виде строки в системную подсказку.

### 4. Исполнение и Решение

После предварительной обработки финальный массив сообщений и стратегия применения схемы упаковываются в единый API-запрос и отправляются в LLM. Затем LLM генерирует ответ, соответствующий схеме.

Система преобразует этот ответ — полученный из содержимого сообщения или аргументов вызова инструмента — в структурированный объект JavaScript. Этот объект и есть `solution`.

> [!ПОДСКАЗКА]
> Весь этот конвейер `Request` — `context`, `schema` и полученный `solution` — образует самодостаточную, воспроизводимую единицу. В сохраненном виде эта единица и является тем, что система называет **[101: Концепция/Идея](./101_concept_idea.md)**.

`schema` определяет форму `solution`.
