# 001: Агент/Запрос

> **Запрос:** один самостоятельный вызов LLM, который принимает `context` и `schema` и выдаёт `solution`. — [Глоссарий](./000_glossary.md)

> Sidenote: NPM: [https://www.npmjs.com/package/@augceo/agent](@idealic-ai/agent)

Этот документ описывает **Протокол Запроса**, который определяет фундаментальную единицу взаимодействия с LLM. `Request` — это движок, который делает абстрактную **[101: Концепция/Идея](./101_concept_idea.md)** вычислимой, используя `context` и `schema` для создания `solution`.

## Конвейер Запроса

> Sidenote:
> 
> LLM обработает `context` для создания `solution`, которое соответствует `schema`.
> 
> ```mermaid
> graph TD
>     subgraph User Input
>         direction LR
>         Context[\Context\]
>         Schema[\Schema\]
>     end
> 
>     Process{{"Request"}}
> 
>     subgraph LLM Output
>         direction LR
>         Solution[/Solution/]
>     end
> 
>     Context --> Process
>     Schema --> Process
>     Process --> Solution
>     Schema -.-> Solution
> 
>     linkStyle 2 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
>     linkStyle 3 stroke-width:2px,fill:none,stroke:gray,stroke-dasharray: 5 5;
> ```

`Request` — это не просто промпт. Это структурированный конвейер, который преобразует богатый, многосоставной контекст в единый, соответствующий схеме ответ от LLM.

### 1. Контекст: Массив Сообщений

Основой `Request` является его `context`, который предоставляется в виде массива объектов `Message`. Это позволяет представить LLM сложный, многоходовый или многоролевой диалог в структурированном виде.

Простой контекст может выглядеть так:

```json
[
  { "role": "system", "content": "Вы — полезный ассистент." },
  { "role": "user", "content": "Какая столица Франции?" }
]
```

### 2. Пользовательские Типы Контента

Система расширяет эту базовую структуру, позволяя использовать **пользовательские типы контента** в сообщениях. Вместо обычной строки, `content` сообщения может быть структурированным объектом, например `{ "type": "state", "state": { ... } }`.

Эти пользовательские типы определяются и управляются системой `Content` (см. `agent/src/Content/Content.ts`). Каждый пользовательский тип регистрируется с обработчиком, и эти обработчики формируют конвейер обработки. По мере обработки каждого сообщения его обработчик может изменять три основных компонента `Request`:

- **Конфигурация LLM**: Настройка параметров, таких как модель, температура или другие опции.
- **Schema**: Изменение JSON-схемы, которой должен соответствовать конечный результат.
- **Context**: Изменение окончательного списка сообщений, который будет отправлен в LLM, например, путём преобразования пользовательского типа в текстовое представление или добавления новых сообщений.

Этот мощный механизм конвейерной обработки позволяет агенту работать с высокоуровневыми, структурированными концепциями, динамически создавая точный вызов LLM, необходимый для выполнения задачи.

### 3. Schema: Структура для Solution

`schema` — это JSON Schema, которая определяет точную структуру желаемого `solution`. Функция `Request` анализирует возможности целевого провайдера LLM, чтобы определить лучший способ применения схемы:

1.  **Нативный режим JSON Schema**: Если провайдер его поддерживает (как новые модели OpenAI), схема передаётся напрямую в поле `response_format` API-вызова. Это самый надёжный метод.
2.  **Резервный вариант с вызовом инструментов (Tool-Calling)**: Если провайдер поддерживает вызов инструментов, но не нативный режим схемы, система оборачивает схему в инструмент-функцию с именем `generate_response` и даёт модели инструкцию вызвать этот инструмент.
3.  **Режим JSON с внедрением в промпт**: В крайнем случае, для провайдеров, которые поддерживают только общий вывод в формате JSON, система даёт модели инструкцию сгенерировать JSON-объект и внедряет схему в виде строки в системный промпт.

### 4. Выполнение и Solution

После предварительной обработки окончательный массив сообщений и стратегия применения схемы упаковываются в единый API-запрос и отправляются в LLM. Затем LLM генерирует ответ, который соответствует схеме.

Система анализирует (парсит) этот ответ — будь то из содержимого сообщения или из аргументов вызова инструмента — и преобразует его в структурированный объект JavaScript. Этот объект и есть `solution`.

Весь этот конвейер — от обработки сложного контекста до получения `solution`, проверенного по схеме, — позволяет **Идее** функционировать как основной вычислительный примитив в системе.

`schema` определяет форму `solution`.