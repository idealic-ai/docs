# 001: Агент/Запрос

> **Запрос:** Единичный, самодостаточный вызов LLM, который принимает `context` и `schema` и создает `solution`. — [Глоссарий](./000_glossary.md)

> Sidenote: NPM: [https://www.npmjs.com/package/@augceo/agent](@idealic-ai/agent)

Этот документ описывает **Протокол Запроса**, который определяет фундаментальную единицу взаимодействия с LLM. `Request` — это механизм, который делает абстрактную **[101: Концепция / Скрытое](./101_concept_idea.md)** вычислимой, принимая ее `context` и `schema` для создания `solution`.

## Конвейер Запроса

`Request` — это не простой промпт. Это структурированный конвейер, который преобразует богатый, многосоставный контекст в единый, соответствующий схеме ответ от LLM.

### 1. Контекст: Массив Сообщений

Основой `Request` является его `context`, который предоставляется в виде массива объектов `Message`. Это позволяет представлять LLM сложный, многоходовой или многоролевой диалог в структурированном виде.

Простой контекст может выглядеть так:

```json
[
  { "role": "system", "content": "You are a helpful assistant." },
  { "role": "user", "content": "What is the capital of France?" }
]
```

### 2. Пользовательские Типы Содержимого

Система расширяет эту базовую структуру, разрешая использование **пользовательских типов содержимого** в сообщениях. Вместо обычной строки `content` сообщения может быть структурированным объектом, например `{ "type": "state", "state": { ... } }`.

Эти пользовательские типы определяются и управляются системой `Content` (см. `agent/src/Content/Content.ts`). Каждый пользовательский тип регистрируется с обработчиком, и эти обработчики формируют конвейер обработки. При обработке каждого сообщения его обработчик может изменять три основных компонента `Request`:

- **Конфигурация LLM**: Настройка таких параметров, как модель, температура или другие опции.
- **Schema**: Изменение JSON-схемы, которой должен соответствовать конечный результат.
- **Контекст**: Изменение итогового списка сообщений, который будет отправлен в LLM, например, путем преобразования пользовательского типа в текстовое представление или добавления новых сообщений.

Этот мощный механизм конвейера позволяет агенту работать с высокоуровневыми, структурированными концепциями, динамически создавая точный вызов LLM, необходимый для выполнения задачи.

### 3. Schema: Направляя Решение

`schema` — это JSON Schema, которая определяет точную структуру желаемого `solution`. Функция `Request` анализирует возможности целевого провайдера LLM, чтобы определить лучший способ принудительного применения схемы:

1.  **Нативный режим JSON Schema**: Если провайдер поддерживает его (как новые модели OpenAI), схема передается напрямую в поле `response_format` API-вызова. Это самый надежный метод.
2.  **Резервный вариант с вызовом инструментов**: Если провайдер поддерживает вызов инструментов, но не нативный режим схемы, система оборачивает схему в инструмент-функцию с именем `generate_response` и дает модели инструкцию вызвать этот инструмент.
3.  **Режим JSON с внедрением в промпт**: В крайнем случае, для провайдеров, которые поддерживают только общий вывод в формате JSON, система дает модели инструкцию сгенерировать JSON-объект и внедряет схему в виде строки в системный промпт.

### 4. Исполнение и Решение

После предварительной обработки итоговый массив сообщений и стратегия принудительного соблюдения схемы упаковываются в единый API-запрос и отправляются в LLM. Затем LLM генерирует ответ, который соответствует схеме.

Система анализирует этот ответ — будь то из содержимого сообщения или из аргументов вызова инструмента — и преобразует его в структурированный объект JavaScript. Этот объект и является `solution`.

Весь этот конвейер — от обработки сложного контекста до получения решения, проверенного по схеме — позволяет **Концепции** функционировать как основной вычислительный примитив в системе.