# 004: Агент/Вызов

> **Вызов:** Конкретный, исполняемый экземпляр `Tool` с определёнными значениями для его `params`. Это запрос, сфокусированный на исполнении того, что _должно быть сделано_.
> 
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует: [Протокол: Идеаторы](./103_concept_ideator.md)
> - Открывает возможности для: [Протокол Импортов](./006_agent_imports.md), [Протокол Инстансинга](./008_agent_instancing.md)

[Протокол Идей](./101_concept_idea.md) определяет мощную, самодостаточную структуру данных для представления знаний и скрытой логики. [Система Инструментов](./002_agent_tool.md) создаёт базовый интерфейс на основе схем, который позволяет агентам понимать структурированные возможности. Этот документ описывает **Протокол Вызова**, который, основываясь на Инструментах, определяет, как происходит выполнение через управление Областью (Scope) и Методом (Method).

> Sidenote:
>
> - Требует
>   - [Нормативный Акт 1: Инструмент](/) 
> - Открывает возможности для
>   - [Нормативный Акт 9: План](/) 

**Вызов** — это конкретный экземпляр Инструмента с определёнными значениями параметров, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это будет исполнено_.

## От Идеи к Вызову

1.  **Идея**: Самодостаточный, ориентированный на результат документ, представляющий знание или процесс.
2.  **Инструмент**: `Idea`, преобразованная в схему, ориентированную на интерфейс и зарегистрированная в системе инструментов агента (подробнее о схемах Инструментов, регистрации и архитектуре двойного реестра см. в [Системе Инструментов](./002_agent_tool.md)).
3.  **Вызов**: Когда LLM решает использовать `Tool`, она заполняет конкретные параметры, создавая **Вызов**. `Call` — это единичный, конкретный экземпляр вызова `Tool`.

Основной принцип: **любую Идею можно превратить в Инструмент, который затем можно выполнить как Вызов.**

Подробное объяснение того, как входная схема `Idea` преобразуется в схему параметров `Tool`, смотрите в **[Протоколе Ввода](./007_agent_input.md)**.

## Управление исполнением: Область и Метод

Исполнение `Call` определяется двумя независимыми свойствами: **Областью** (где он выполняется) и **Методом** (как он выполняется). Эти элементы управления обозначаются специальными свойствами (`_module`, `_activity`, `_output`) в схеме инструмента.

### Две оси исполнения

1.  **Область (Встроенная vs. Модульная)**
    Область определяет, происходит ли исполнение в текущем контексте агента или делегируется внешнему, изолированному модулю.
    - **Встроенная Область**: Режим по умолчанию, при котором `Call` обрабатывается напрямую.
    - **Модульная Область**: Обозначается свойством `_module` и делегирует `Call` внешнему `Activity` или `Idea`.

2.  **Метод (Явный vs. Скрытый)**
    Метод определяет, генерируется ли результат детерминированным кодом или с помощью LLM.
    - **Явный Метод**: Обозначается наличием свойства `_activity`; результат `Call` генерируется детерминированным кодом.
    - **Скрытый Метод**: Поведение по умолчанию при отсутствии `_activity`. Результат `Call` генерируется с помощью LLM. Требует наличия необязательного свойства `_output`.

Эти элементы управления можно комбинировать для создания различных моделей исполнения, а их контекст можно контролировать через импорты. Подробное объяснение того, как комбинируются эти элементы управления и как управляется контекст, смотрите в **[Протоколе Импортов](./008_agent_imports.md)**.

## Идея, Инструмент и Вызов: Спектр фокуса

Чтобы понять связь между ними, необходимо уяснить фундаментальное различие в фокусе этих трёх концепций.

- **Идея** **ориентирована на результат**. Её основная цель — представить завершённую мысль или итог. `schema` определяет форму `solution` (результата), который был сгенерирован из `context`. Это запись того, что _было_ или _могло бы быть_.

- **Инструмент** **ориентирован на интерфейс**. Его схема определяет параметры (входные данные) и структуру `_output`. Это абстрактный шаблон для действия — сигнатура функции, ожидающая вызова.

- **Вызов** **ориентирован на исполнение**. Это конкретный, исполняемый экземпляр `Tool`. Он берёт ориентированный на параметры интерфейс `Tool` и заполняет его конкретными значениями, превращая его в готовый к выполнению запрос на то, что _должно быть сделано_.

## Идея-контейнер: единый момент принятия решения

Когда агенту нужно принять решение, полный запрос, отправляемый в LLM, структурируется как особый тип `Idea`, который мы называем **Идея-контейнер**. Она представляет собой единый, самодостаточный момент принятия решения.

Идея-контейнер объединяет два ключевых компонента, необходимых LLM для принятия решения:

1.  **Контекст**: Включает всю релевантную информацию, необходимую агенту, такую как запрос пользователя, память и другие данные из окружения.
2.  **Схема**: Для Идеи-контейнера основная роль схемы — определить сам "Контейнер", то есть набор возможных `Tools`, которые агент может использовать в данной конкретной ситуации.

LLM обрабатывает всю эту `Idea` — контекст и схему доступных инструментов — и её `solution` является результатом этого решения: массив из нуля или более `Calls`, которые необходимо выполнить.

Такая структура позволяет одной целостной `Idea` представлять сложное, многошаговое действие.

## Паттерны выполнения Вызовов

Когда Идея-контейнер создаёт несколько Вызовов, можно применять различные стратегии их выполнения в зависимости от потребностей приложения:

```typescript
// Исполнение одного Вызова
const result = await Tool(call);

// Исполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все Вызовы, вернуть первый завершившийся (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны обеспечивают:

- **Детальный контроль**: Обрабатывайте Вызовы по отдельности с собственной логикой между исполнениями
- **Пакетная обработка**: Выполняйте независимые Вызовы параллельно для максимальной производительности
- **Стратегии быстрого отказа**: Останавливайтесь при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции "всё или ничего"**: Гарантируйте, что все Вызовы выполнятся успешно вместе (`.all()`), поддерживая целостность, когда Вызовы логически сгруппированы