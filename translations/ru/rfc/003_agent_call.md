# 003: Агент/Вызов

> Sidenote:
>
> - Требует: [Протокол: Идеаторы](./103_concept_ideator.md)
> - Открывает возможности для: [Протокол импортов](./006_agent_imports.md), [Протокол инстанцирования](./008_agent_instancing.md)

> **Call** — это конкретный, исполняемый экземпляр `Tool` с определёнными значениями для его `params`. Это запрос, ориентированный на вызов и описывающий, что _должно быть сделано_.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует
>   - [RFC 1: Tool](/)
> - Открывает возможности для
>   - [RFC 9: Plan](/)

[Протокол Idea](./101_concept_idea.md) описывает мощную автономную структуру данных для представления знаний и скрытой логики. [Система Tool](./002_agent_tool.md) создаёт базовый интерфейс на основе схем, который позволяет агентам понимать свои возможности. Этот документ описывает **Протокол Call**, который построен на основе Tool и определяет, как происходит выполнение через элементы управления Scope (область) и Method (метод).

**Call** — это конкретный экземпляр Tool с заданными параметрами, готовый к выполнению. Если Tool определяет, _что можно сделать_, то Call определяет, _как это будет выполнено_.

## Конвейер: от Idea к Call

1.  **Idea**: автономный, ориентированный на результат документ, представляющий знание или процесс.
2.  **Tool**: `Idea`, преобразованная в схему, ориентированную на интерфейс, и зарегистрированная в системе инструментов агента (подробности о схемах, регистрации и архитектуре двойного реестра см. в [Системе Tool](./002_agent_tool.md)).
3.  **Call**: Когда LLM решает использовать `Tool`, она заполняет его параметры, создавая **Call** — единичный, конкретный экземпляр вызова `Tool`.

Основной принцип: **любая Idea может быть превращена в Tool, который затем может быть вызван как Call.**

Подробное объяснение того, как входная схема `Idea` инвертируется, чтобы стать схемой параметров `Tool`, см. в **[Протоколе Input](./005_agent_input.md)**.

## Управление выполнением: Scope и Method

Выполнение `Call` определяется двумя независимыми свойствами: **Scope** (где оно выполняется) и **Method** (как оно выполняется). Эти элементы управления задаются специальными свойствами (`_module`, `_activity`, `_output`) в схеме `Tool`.

### Две оси выполнения

1.  **Область (Inline vs. Module)**
    Область определяет, происходит ли выполнение в текущем контексте агента или делегируется внешнему, изолированному модулю.
    - **Inline Scope**: Режим по умолчанию, в котором `Call` обрабатывается напрямую.
    - **Module Scope**: Обозначается через `_module` и делегирует `Call` внешнему `Activity` или `Idea`.

2.  **Метод (Explicit vs. Latent)**
    Метод определяет, генерируется ли результат детерминированным кодом или LLM.
    - **Explicit Method**: Обозначается наличием свойства `_activity`; результат `Call` генерируется детерминированным кодом.
    - **Latent Method**: Поведение по умолчанию при отсутствии `_activity`. Результат `Call` генерируется LLM. Требует наличия необязательного свойства `_output`.

Эти элементы управления можно комбинировать в различные паттерны выполнения, а их контекст контролировать через импорты. Подробное объяснение того, как эти элементы комбинируются и как управляется контекст, см. в **[Протоколе импортов](./008_agent_imports.md)**.

## Idea, Tool и Call: Различия в фокусе

Чтобы понять эту связь, мы должны разобраться в фундаментальном различии в фокусе между этими тремя понятиями.

- **Idea** **ориентирована на результат**. Её основная цель — представить завершённую мысль или результат. `schema` определяет форму `solution` (результата), который был сгенерирован из `context`. Это запись того, что _было_ или _могло бы быть_.

- **Tool** **ориентирован на интерфейс**. Его схема определяет параметры (входные данные) и структуру `_output`. Это абстрактный шаблон для действия — сигнатура функции, ожидающая вызова.

- **Call** **ориентирован на вызов**. Это конкретный, исполняемый экземпляр `Tool`. Он берёт интерфейс `Tool`, ориентированный на параметры, и заполняет его конкретными значениями, превращая в готовый к выполнению запрос о том, что _должно быть сделано_.

## Vessel Idea: один момент принятия решения

Когда агенту нужно принять решение, полный запрос, отправляемый в LLM, структурируется как особый тип `Idea`, который мы называем **Vessel Idea**. Он представляет собой единый, автономный момент принятия решения.

`Vessel Idea` объединяет два ключевых компонента, необходимых LLM для принятия решения:

1.  **Контекст**: включает всю необходимую агенту информацию, такую как запрос пользователя, память и другие данные окружения.
2.  **Схема**: Для `Vessel Idea` основная роль схемы — определить «контейнер» (Vessel), то есть набор возможных `Tool`, которые агент может использовать в данной конкретной ситуации.

LLM обрабатывает всю эту `Idea` — контекст и схему доступных инструментов — и её `solution` является результатом этого решения: массив из нуля или более `Call` для выполнения.

Такая структура позволяет одной целостной `Idea` представлять сложное, многоэтапное действие.

## Паттерны выполнения Call

Когда `Vessel Idea` создаёт несколько `Call`, могут применяться различные стратегии выполнения в зависимости от потребностей приложения:

```typescript
// Выполнение одного Call
const result = await Tool(call);

// Выполнить все Call, дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Call, вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Call, вернуть результат первого завершённого (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны обеспечивают:

- **Детальный контроль**: Обработка `Call` по отдельности с пользовательской логикой между выполнениями
- **Пакетная обработка**: Параллельное выполнение независимых `Call` для максимальной производительности
- **Стратегии быстрого отказа (Fail-Fast)**: Остановка при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «всё или ничего»**: Гарантия, что все `Call` успешно выполнятся вместе (`.all()`), поддерживая согласованность, когда вызовы логически сгруппированы