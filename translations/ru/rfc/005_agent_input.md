# 007: Агент/Ввод

> **Входное сообщение:** Контекстное сообщение, содержащее `schema` и данные `input`. Его наличие превращает `Idea` в `Ideator`, определяя ожидаемые входные данные.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует: [Протокол Idea](./101_concept_idea.md)
> - Включает: [Протокол: Ideators](./103_concept_ideator.md)

Этот документ описывает **Протокол Ввода** — систему для определения структурированных входных данных для `Ideas`. Этот протокол вводит особый тип сообщения, который при включении в контекст `Idea` превращает её из статической единицы знания в исполняемую, подобную функции сущность, известную как **Ideator**.

## Тип сообщения `Input`

Сообщение `Input` — это особый тип контекстного сообщения, предназначенный для формального объявления данных, которые принимает `Idea`. Это механизм, который фиксирует структурированные входные данные, используемые для получения определённого `solution`, завершая «триаду Idea» и предоставляя полную, воспроизводимую запись творческого или вычислительного процесса.

Сообщение `Input` содержит два ключевых свойства:

1.  **`schema`**: Объект JSON Schema, который определяет структуру, типы и ограничения данных, ожидаемых `Idea`.
2.  **`input`**: Конкретный объект данных, который соответствует `schema` и представляет фактические значения, использованные для конкретного выполнения.

Определяя свои входные данные таким структурированным образом, любая `Idea` может стать самоописываемой не только в части своего вывода (`solution` и `schema`), но и в том, что ей требуется для генерации.

### Путь к простоте использования

Значительным преимуществом этого протокола является его способность обеспечивать автоматическую генерацию пользовательского интерфейса. Поскольку `schema` для `input` явно определяет требуемые данные, система может динамически отображать форму с правильными полями, метками и проверкой. Это позволяет мгновенно предоставить любую `Idea` пользователю через функциональный интерфейс, значительно снижая барьер для взаимодействия.

## От Idea к Ideator

Как описано в [Протоколе Idea](./101_concept_idea.md), наличие сообщения `Input` в контексте `Idea` является окончательным сигналом того, что это **Ideator** — `Idea`, которая выполняет работу. Она становится воспроизводимой функцией.

## Взаимодействие с Протоколом Инстансинга

Сообщение `Input` полностью совместимо с [Протоколом Инстансинга](./011_agent_instancing.md), что позволяет использовать сложные стратегии получения данных при одновременной обработке нескольких экземпляров. Оно может работать в двух различных режимах:

1.  **Глобальный ввод**: Если сообщение `Input` предоставлено в контексте агента без свойства `_instance`, его данные `input` рассматриваются как глобальное значение. Они неявно доступны каждому экземпляру, обрабатываемому в запросе. Это полезно для предоставления общей конфигурации, подсказок или параметров, которые применяются ко всем экземплярам одинаково.

2.  **Ввод для конкретного экземпляра**: Если сообщение `Input` включает идентификатор `_instance`, его данные `input` извлекаются непосредственно из состояния этого конкретного экземпляра. Это обеспечивает мощный механизм для переопределения данных для каждого экземпляра или для передачи уникальных данных каждого экземпляра в общий `Ideator`.

Эта возможность двойного режима позволяет создавать гибкие и эффективные рабочие процессы с несколькими экземплярами, где один `Ideator` можно настроить с базовым набором глобальных входных данных, а затем кастомизировать его с помощью конкретных данных от каждого обрабатываемого экземпляра.

## Инверсия: от Ideator к Tool

Хотя `Ideator` является самодостаточной, исполняемой концепцией, для его интеграции в императивный рабочий процесс агента мы должны преобразовать его в **Tool**. Механический процесс превращения `Ideator`, ориентированного на результат, в `Tool`, ориентированный на интерфейс, называется **инверсией**. Мы реструктурируем его компоненты, чтобы приоритет отдавался входным данным.

`Idea` — это триада, определяемая её выводом `schema` и `solution`:
`{ context, schema, solution }`

Чтобы преобразовать её в `Tool`, мы ищем в её `context` сообщение `Input`. Основной шаг инверсии — **повысить** свойства схемы `input` до уровня свойств параметров верхнего уровня для `Tool` (подробнее о структуре схемы `Tool` см. в [Системе Инструментов](./002_agent_tool.md)).

Это создаёт определение `Tool`, которое, по сути, является сигнатурой функции, готовой к регистрации в системе агента и использованию в `Call`.