# 012: Агент/План

> **План:** — это направленный ациклический граф (DAG) из `Tool Calls`. Он определяет последовательность действий, где зависимости определяются инструментами, которые читают и записывают в `State Object`. — [Словарь](./000_glossary.md)

> [!WARNING]
> Этот Нормативный Акт в настоящее время является заготовкой и будет расширен в будущем. Он описывает фундаментальные концепции Планов как более высокоуровневой абстракции, построенной на основе систем Состояния и Вызовов.

> Sidenote:
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [010: Агент/Состояние](./010_agent_state.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **Протокол Плана**, который поднимает возможности агентов от простых, реактивных циклов до сложных, многошаговых рабочих процессов. `План` — это не просто скрипт, а обладающая состоянием, организующая `Идея`, которая направляет `Идею` с данными через граф сервисов.

## 1. План как внешний организатор

Важнейший архитектурный принцип Протокола Плана — это **инверсия контроля**. `План` не является свойством, встроенным в `Идею` с данными, над которой он работает. Вместо этого, `План` — это отдельная, внешняя `Идея`, которая хранит состояние процесса. `Идея` с данными остается легковесной и просто несет в себе ссылку на `План`, который в данный момент ее организует.

Такое разделение дает несколько существенных преимуществ:

- **Компонуемость**: Одна и та же `Идея` с данными может одновременно участвовать в нескольких независимых процессах, поскольку она не обременена необходимостью нести собственную логику выполнения.
- **Централизованное управление состоянием**: `Идея` `Плана` становится единственным источником правды о состоянии выполнения рабочего процесса. Ее `solution` — это текущее состояние графа процесса, которое обновляется на каждом шаге. Это выносит состояние наружу и сохраняет его, делая процесс наблюдаемым и отказоустойчивым.
- **Гибкость**: Поскольку `План` — это просто еще одна `Идея`, он может динамически создаваться, изменяться и компоноваться другими ИИ-центричными процессами, что позволяет создавать адаптируемые и самооптимизирующиеся рабочие процессы.

## 2. Организация и исполнение

`План` определяет направленный ациклический граф (DAG) из `Tool Calls`. Это исполняемый граф действий, предназначенный для запуска внутри **[005: Агент/Цикл](./005_agent_loop.md)**. В то время как одна итерация цикла может выполнить набор параллельных `Вызовов`, `План` позволяет агенту определять и следовать многошаговой последовательности с зависимостями, эффективно организуя серию циклов для достижения более крупной цели.

Когда сервис в конвейере завершает свою задачу над `Идеей` с данными, он использует ссылку на `План` (например, переданную в заголовке или в контексте вызова), чтобы определить следующий пункт назначения. `План` отвечает за маршрутизацию `Идеи` к следующему сервису в графе.

Для длительных или сложных процессов выполнение `Плана` лучше всего доверить отказоустойчивому движку рабочих процессов, такому как Temporal, который может сохранять состояние графа выполнения в распределенных системах и на протяжении длительного времени.

## 3. Безопасность и конфиденциальность

Централизуя логику организации, `План` действует как надежный хранитель информации.

- **Изолированность**: Отдельным сервисам в конвейере не нужно знать весь рабочий процесс. Они получают `Идею`, выполняют свою функцию и возвращают ее организатору. Они не знают, откуда пришли данные и куда они направляются дальше.
- **Управление секретами**: `План` может надежно хранить секреты, API-ключи или другой чувствительный контекст. Затем он может предоставить эту информацию конкретному сервису по мере необходимости, не раскрывая ее остальной части конвейера и не встраивая в саму `Идею` с данными.

Эта модель гарантирует, что система остается гибкой и безопасной, позволяя создавать сложные конвейеры, в которых конфиденциальность и контроль доступа управляются организующим `Планом`.
