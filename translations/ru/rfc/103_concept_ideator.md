# 103: Концепция/Ideator

> Sidenote:
>
> - Требует:
>   - [Протокол Idea](./101_concept_idea.md)
>   - [Протокол Input](./005_agent_input.md)
> - Позволяет:
>   - [Протокол Call](./003_agent_call.md)
>   - [Протокол: Sovereignty](./102_concept_sovereignty.md)

> **Ideator:** `Idea`, которая принимает входные данные, что обозначается контекстным сообщением с `type: "input"`. Он действует как функция, преобразующая входные данные в выходные.
>
> — [Глоссарий](./000_glossary.md)

## 1. Введение

Этот документ описывает протокол для **Ideators** и **Idea Transformers** как исполняемых компонентов, основанных на сервисах. Он основан на базовом [Протоколе Idea](./101_concept_idea.md), который определяет основную структуру данных, и описывает, как `Idea` преобразуется в функциональную, вызываемую сущность.

Для получения подробной информации о различных моделях хостинга и развертывания см. [RFC 11: Протокол: Sovereignty](./102_concept_sovereignty.md).

## 2. От Idea к Ideator

**Ideator** — это не отдельная сущность, а функциональная роль, которую может выполнять любая `Idea`. Его можно рассматривать как функцию, которая выполняет работу, преобразуя входные данные в выходные в **скрытом (латентном) пространстве**. Это означает, что его логика не обязательно определяется явным кодом, а вместо этого руководствуется богатым `context` (контекстом) `Idea` — его схемами, примерами и инструкциями на естественном языке, которые интерпретируются LLM.

Окончательным признаком того, что `Idea` является Ideator, является наличие сообщения `context` с `type: "input"`. Это сообщение определяет схему данных, которые ожидает Ideator. _Исполняемый_ Ideator также может включать сообщение `context` с `type: "code"`, указывающее на явную реализацию.

### 2.1. Idea Transformer: Особый случай

Распространенный и мощный шаблон — это Ideator, входными данными для которого является другая `Idea`. Мы называем этот конкретный тип Ideator **Idea Transformer**. Именно это позволяет создавать композиционные конвейеры, в которых `Idea` объединяются в цепочки и развиваются.

## 3. Реализации и композиция

Архитектурные принципы, изложенные в этом документе, определяют **поведенческий контракт** для любого сервиса Ideator. Этот контракт предназначен не для одной программы, а является стандартом для взаимодействия, что допускает множество реализаций и создает богатую, композиционную экосистему.

### 3.1. Множество реализаций

Контракт сервиса Ideator выполняется путем соблюдения его публичного API (прием одной `Idea` и возврат другой). Это позволяет создавать несколько конкретных реализаций, каждая из которых подходит для разных случаев использования:

- **Управляемые сервисы**: Провайдер может предложить хостинг в виде управляемого облачного сервиса, абстрагируясь от инфраструктуры, как описано в [Протоколе Sovereignty](./102_concept_sovereignty.md).
- **Собственные экземпляры (Self-Hosted)**: Разработчик может запустить собственную реализацию сервиса на своей инфраструктуре, получая полный контроль.
- **Реализации в памяти**: Для локальной разработки и тестирования логика выполнения Ideator может быть запущена как простая функция в памяти, минуя сеть, но по-прежнему соблюдая основной контракт.

### 3.2. Композиция и системы высшего порядка

В этой экосистеме нет понятия «приватного API». Все сервисы созданы для взаимодействия через их публичные, основанные на контрактах, интерфейсы.

Более сложные сервисы, которые можно считать **Системами Высшего Порядка**, создаются путем композиции других, более примитивных `Ideators`. Внутренняя логика сервиса высшего порядка включает вызовы публичных API других `Ideators`.

Например, система **Reactor** — это `Ideator` высшего порядка. Для управления игрой он может:

1.  Принять `Idea` состояния игры через свой публичный API.
2.  Внутренне вызвать публичный сервис `Player` для создания и управления идентификаторами игроков.
3.  Вызвать публичный сервис `Storage` для записи истории игры.
4.  Вернуть новую `Idea` состояния игры через свой публичный API.

Снаружи Reactor — это просто еще один `Ideator`. Его сложность управляется внутри за счет композиции других независимых, публичных сервисов. Это гарантирует, что вся система остается модульной, прозрачной и масштабируемой.