# 103: Концепция/Идеатор

> **Идеатор:** Это `Idea`, принимающая входные данные, что обозначается контекстным сообщением с `type: "input"`. Она действует как функция, преобразуя входные данные в выходные. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
>   - [101: Концепция/Idea](./101_concept_idea.md)
>   - [007: Агент/Ввод](./007_agent_input.md)
> - Открывает возможности для:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [102: Концепция/Суверенитет](./102_concept_sovereignty.md)

## 1. Введение

Этот документ определяет протокол для **Идеаторов** и **Трансформеров Идей** как исполняемых компонентов на основе сервисов. Он основан на фундаментальном документе [101: Концепция/Idea](./101_concept_idea.md), который определяет основную структуру данных, и описывает, как `Idea` превращается в функциональную, вызываемую сущность.

Для получения подробной информации о различных моделях хостинга и развертывания см. [102: Концепция/Суверенитет](./102_concept_sovereignty.md).

## 2. От Идеи к Идеатору

**Идеатор** — это не отдельная сущность, а функциональная роль, которую может выполнять любая `Idea`. Его можно рассматривать как функцию, которая выполняет работу, преобразуя входные данные в выходные в **скрытом пространстве**. Это означает, что его логика не обязательно определяется явным кодом, а направляется богатым `context`-ом `Idea` — ее схемами, примерами и инструкциями на естественном языке, которые интерпретируются LLM.

Окончательным признаком того, что `Idea` является Идеатором, является наличие сообщения в `context` с `type: "input"`. Это сообщение определяет схему данных, которые ожидает Идеатор. _Исполняемый_ Идеатор также может включать сообщение в `context` с `type: "code"`, указывающее на явную реализацию.

### 2.1. Трансформер Идей: Особый случай

Распространенный и мощный паттерн — это Идеатор, входными данными для которого является другая `Idea`. Мы называем этот конкретный тип Идеатора **Трансформером Идей**. Именно это обеспечивает возможность создания композиционных конвейеров, в которых Идеи связываются в цепочки и развиваются.

## 3. Реализации и Композиция

Архитектурные принципы, изложенные в этом документе, определяют **поведенческий контракт** для любого сервиса Идеатора. Этот контракт предназначен не для одной конкретной программы, а является стандартом для взаимодействия, допуская множество реализаций и создавая богатую композиционную экосистему.

### 3.1. Множество реализаций

Контракт сервиса-Идеатора считается выполненным, если он соблюдает свой публичный API (принимает одну `Idea` и возвращает другую). Это позволяет создавать множество конкретных реализаций, каждая из которых подходит для разных сценариев использования:

- **Управляемые сервисы**: Провайдер может предложить хостинг в виде управляемого облачного сервиса, абстрагируясь от инфраструктуры, как описано в [Протоколе Суверенитета](./102_concept_sovereignty.md).
- **Собственные инстансы**: Разработчик может запустить собственную реализацию сервиса на своей инфраструктуре, получая полный контроль.
- **Реализации в памяти**: Для локальной разработки и тестирования логику выполнения Идеатора можно запустить как простую функцию в памяти, полностью минуя сетевое взаимодействие, но при этом соблюдая основной контракт.

### 3.2. Композиция и Системы Высшего Порядка

В этой экосистеме нет понятия «приватного API». Все сервисы созданы для взаимодействия через свои публичные, основанные на контрактах, интерфейсы.

Более сложные сервисы, которые можно рассматривать как **Системы Высшего Порядка**, создаются путем композиции других, более примитивных `Идеаторов`. Внутренняя логика сервиса высшего порядка включает вызовы публичных API других `Идеаторов`.

Например, система **Реактор** — это `Идеатор` высшего порядка. Для управления игрой он может:

1.  Принять `Idea` состояния игры через свой публичный API.
2.  Внутренне вызвать публичный сервис `Player` для создания идентификаторов игроков и управления ими.
3.  Вызвать публичный сервис `Storage` для записи истории игры.
4.  Вернуть новую `Idea` состояния игры через свой публичный API.

Снаружи Реактор — это просто еще один `Идеатор`. Его сложность управляется внутри за счет композиции других независимых публичных сервисов. Это гарантирует, что вся система остается модульной, прозрачной и масштабируемой.