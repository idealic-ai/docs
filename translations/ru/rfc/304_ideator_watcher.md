# 304: Идеатор/Наблюдатель

> **Наблюдатель:** `Идеатор`-«источник» с состоянием, который подписывается на изменения в сервисе `Storage`. Когда происходит изменение (например, сохраняется новая версия `Idea`), он инициирует новую транзакцию, обычно вызывая `Plan` для обработки новых данных.
>
> — [Словарь](./000_glossary.md)

> Sidenote: Требуется знание следующих документов:
> - [301: Идеатор/Хранилище](./301_ideator_storage.md)
> - [012: Агент/План](./012_agent_plan.md)

## 1. Введение

Этот документ определяет **Протокол Наблюдателя** — критически важный компонент для создания асинхронных, событийно-ориентированных рабочих процессов в экосистеме. `Watcher` (также известный как Подписчик) — это постоянный сервис, который отслеживает изменения в провайдере `Storage` и в ответ запускает новые процессы.

Это основной механизм для преодоления разрыва между сервисами с состоянием и без него, а также для обработки длительных задач, которыми невозможно управлять в простом цикле «запрос-ответ».

## 2. Наблюдатель как `Идеатор`-«источник»

В отличие от сервиса `Storage`, который действует как транзакционный «приёмник», `Watcher` является «источником». Его роль — не завершать транзакцию, а **инициировать новую**.

Типичный рабочий процесс выглядит следующим образом:

1.  `Idea` сохраняется в `Storage`, завершая исходную транзакцию.
2.  Сервис `Storage` генерирует событие, уведомляя подписчиков об изменении.
3.  `Watcher`, подписанный на эти события, получает уведомление.
4.  `Watcher` инициирует новую, независимую транзакцию. Обычно это включает вызов [012: Агент/План](./012_agent_plan.md) и передачу новой `Idea` в качестве контекста, запуская новый рабочий процесс.

## 3. Обработка асинхронности и длительных процессов

`Watcher` — это ключ к корректному управлению длительными асинхронными операциями.

Представьте себе `Plan`, который включает шаг, на выполнение которого могут уйти часы или дни (например, ожидание ввода от человека, обработка большого набора данных). Синхронный `Plan` не может просто `await` этот результат.

Вместо этого `Plan` может делегировать длительную задачу внешнему сервису и завершиться. Этот внешний сервис по завершении записывает свой результат обратно в `Storage`. `Watcher`, настроенный на прослушивание этого конкретного результата, может затем запустить _новый_ `Plan` для продолжения рабочего процесса.

Этот паттерн позволяет создавать высокоустойчивые и масштабируемые процессы, не ограниченные памятью или временем жизни какой-либо одной среды выполнения. Он обеспечивает истинную асинхронность, разбивая долгий процесс на серию небольших, запускаемых событиями транзакций.