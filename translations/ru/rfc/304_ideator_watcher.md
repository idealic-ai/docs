# 304: Идеатор/Наблюдатель

> **Наблюдатель (Watcher):** `Идеатор` типа "источник" с отслеживанием состояния, который подписывается на изменения в службе `Storage`. При возникновении изменения (например, сохранении новой версии `Idea`) он инициирует новую транзакцию, обычно вызывая `Plan` для обработки новых данных.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [301: Идеатор/Хранилище](./301_ideator_storage.md)
>   - [012: Агент/План](./012_agent_plan.md)

## 1. Введение

Этот документ определяет **Протокол Наблюдателя (Watcher Protocol)** — ключевой компонент для создания асинхронных, событийно-ориентированных рабочих процессов в экосистеме. `Watcher` (также называемый Подписчиком) — это постоянная служба, которая наблюдает за поставщиком `Storage` на предмет изменений и в ответ запускает новые процессы.

Это основной механизм для преодоления разрыва между службами с отслеживанием состояния и без него, а также для обработки длительных задач, которыми нельзя управлять в простом цикле "запрос-ответ".

## 2. Наблюдатель как Идеатор-источник

В отличие от службы `Storage`, которая действует как транзакционный "приемник", `Watcher` является "источником". Его роль — не завершить транзакцию, а **инициировать новую**.

Типичный рабочий процесс выглядит следующим образом:

1. `Idea` сохраняется в `Storage`, завершая исходную транзакцию.
2. Служба `Storage` генерирует событие, уведомляя подписчиков об изменении.
3. `Watcher`, подписанный на эти события, получает уведомление.
4. `Watcher` инициирует новую, независимую транзакцию. Обычно это включает вызов [012: Агент/План](./012_agent_plan.md) и передачу новой `Idea` в качестве контекста, что запускает новый рабочий процесс.

## 3. Обработка асинхронности и длительных процессов

`Watcher` — это ключ к корректному управлению длительными асинхронными операциями.

Рассмотрим `Plan`, который включает шаг, выполнение которого может занять часы или дни (например, ожидание ввода от человека, обработка большого набора данных). Синхронный `Plan` не может просто `await` этот результат.

Вместо этого `Plan` может делегировать длительную задачу внешней службе, а затем завершиться. Эта внешняя служба по завершении записывает свой результат обратно в `Storage`. `Watcher`, настроенный на прослушивание этого конкретного результата, может затем запустить _новый_ `Plan` для продолжения рабочего процесса.

Этот подход позволяет создавать высокоустойчивые и масштабируемые процессы, не ограниченные памятью или временем жизни какой-либо одной среды выполнения. Он обеспечивает настоящую асинхронность, разбивая длительный процесс на серию более мелких транзакций, запускаемых событиями.
