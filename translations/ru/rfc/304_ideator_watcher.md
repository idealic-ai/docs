# 304: Идеатор/Наблюдатель

> **Наблюдатель:** `Ideator`-«источник» с отслеживанием состояния, который подписывается на изменения в сервисе `Storage`. Когда происходит изменение (например, сохраняется новая версия `Idea`), он инициирует новую транзакцию, обычно вызывая `Plan` для обработки новых данных.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote: Требует ознакомления с [301: Идеатор/Хранилище](./301_ideator_storage.md) и [012: Агент/План](./012_agent_plan.md).

## 1. Введение

Этот документ определяет **Протокол Наблюдателя** — ключевой компонент для создания асинхронных, событийно-ориентированных рабочих процессов в экосистеме. `Watcher` (также называемый Подписчиком) — это постоянный сервис, который наблюдает за провайдером `Storage` на предмет изменений и в ответ запускает новые процессы.

Это основной механизм для преодоления разрыва между сервисами с состоянием и без него, а также для обработки длительных задач, которыми нельзя управлять в простом цикле «запрос-ответ».

## 2. Наблюдатель как Идеатор-«источник»

В отличие от сервиса `Storage`, который действует как транзакционный «приёмник», `Watcher` является «источником». Его роль заключается не в завершении транзакции, а в **инициации новой**.

Типичный рабочий процесс выглядит следующим образом:

1. `Idea` сохраняется в `Storage`, завершая исходную транзакцию.
2. Сервис `Storage` генерирует событие, уведомляя подписчиков об изменении.
3. `Watcher`, подписанный на эти события, получает уведомление.
4. `Watcher` инициирует новую, независимую транзакцию. Обычно это включает вызов [012: Агент/План](./012_agent_plan.md) и передачу новой `Idea` в качестве контекста, запуская новый рабочий процесс.

## 3. Обработка асинхронности и длительных процессов

`Watcher` — это ключ к корректному управлению длительными асинхронными операциями.

Рассмотрим `Plan`, который включает шаг, на выполнение которого могут уйти часы или дни (например, ожидание ввода от человека, обработка большого набора данных). Синхронный `Plan` не может просто `await` этот результат.

Вместо этого `Plan` может делегировать длительную задачу внешнему сервису, а затем завершить свою работу. Этот внешний сервис по завершении записывает свой результат обратно в `Storage`. `Watcher`, настроенный на прослушивание этого конкретного результата, может затем запустить _новый_ `Plan` для продолжения рабочего процесса.

Этот паттерн позволяет создавать высокоустойчивые и масштабируемые процессы, которые не ограничены памятью или временем жизни какой-либо одной среды выполнения. Он обеспечивает истинную асинхронность, разбивая длительный процесс на серию небольших транзакций, запускаемых событиями.