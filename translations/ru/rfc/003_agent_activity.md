# Акт 003: Агент/Действие

> **Действие:** Явная, детерминированная функция кода, которая реализует логику `Tool`. Это механизм для выполнения действий, требующих вызовов внешних API, операций с базой данных или любой задачи, которую невозможно выполнить в скрытом пространстве LLM. — [Глоссарий](./000_glossary.md)

> Sidenote: Требуется: [Акт 002: Агент/Инструмент](./002_agent_tool.md)

Этот документ описывает **Протокол Действий**, который определяет, как `Tools` подкрепляются конкретным исполняемым кодом. Если `Tool` определяет интерфейс возможности, то `Действие` предоставляет её реализацию.

## Архитектура двойного реестра

Система агентов использует два взаимодополняющих реестра, чтобы отделить интерфейс возможности от её реализации:

- **Реестр Инструментов**: Хранит определения схем для `Tools`.
- **Реестр Действий**: Хранит явные функции кода (`Действия`), которые реализуют `Tools`.

Это разделение — ключ к гибкости системы. Оно позволяет определять и использовать `Tools` в режиме скрытого исполнения (когда LLM генерирует результат напрямую), а также заменять различные реализации `Действия` без изменения интерфейса `Tool` (например, для разных сред, таких как разработка и продакшн).

## Регистрация Действия

`Действие` регистрируется с уникальным именем, которое используется для его привязки к `Tool`.

```typescript
// Регистрация реализации Действия.
// Имя 'weatherCheck' должно совпадать с реализуемым Tool.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

## Режимы выполнения: Скрытый и Явный

Система поддерживает два принципиально разных режима выполнения для `Call` (вызова) `Tool`:

- **Скрытое исполнение**: Использует способности LLM к рассуждению. Агент «продумывает» задачу и выдаёт результат напрямую в том же вызове. Это режим по умолчанию, если для `Tool` не найдено соответствующее `Действие`.
  > Sidenote: [104: Концепция / Скрытое](./104_concept_latent.md)
- **Явное исполнение**: Делегирует `Call` детерминированному коду. Для вычисления результата вызывается функция `Действия`. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, воспроизводимой логики.

## Стратегия определения Действия

Система использует стратегию «нулевой конфигурации» для определения режима выполнения при вызове `Tool`. Поле `_activity` в схеме `Tool` сигнализирует о намерении использовать явную реализацию. Это поле определяется автоматически при составлении схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если определение `Tool` само по себе содержит непустую строку `_activity`, это значение используется для поиска `Действия` в реестре.
2.  **Соглашение об одинаковых именах (Рекомендуется)**: Если поле `_activity` в `Tool` отсутствует, система проверяет, зарегистрировано ли `Действие` с **тем же именем**, что и `Tool`. Если найдено, поле `_activity` автоматически устанавливается в имя `Tool`.
3.  **Резервный вариант (Скрытое исполнение)**: Если по вышеуказанным правилам не найдено подходящее `Действие`, поле `_activity` устанавливается в пустую строку, что сигнализирует о необходимости выполнить `Call` в скрытом режиме.

Такой подход, основанный на соглашениях, упрощает разработку:

- **Для «нулевой конфигурации» регистрируйте ваше `Действие` под тем же именем, что и ваш `Tool`.**
- `Tool`, не имеющие соответствующего `Действия`, автоматически и безопасно переключатся на скрытое исполнение.
- Явное поле `_activity` в схеме `Tool` всегда будет иметь приоритет, позволяя одному `Действию` реализовывать несколько интерфейсов `Tool`.

## Почему разделение Действий важно

Без разделения схем `Tool` от реализаций `Действий` определение возможности было бы навсегда связано с её логикой выполнения. Чтобы переключиться с реализации на основе LLM на внешний API, потребовалось бы найти и изменить каждого агента, использующего этот `Tool`.

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы `Tool` стабильными и позволяя их реализациям развиваться. Агенты взаимодействуют с единой схемой `Tool` независимо от того, выполняется ли она в скрытом режиме LLM или явно через `Действие`. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключиться со скрытого на явное исполнение, не трогая код агента.
- **A/B-тестирование стратегий выполнения**: Вы можете сравнивать производительность рассуждений LLM и внешнего API для одной и той же возможности.
- **Постепенное внедрение**: Вы можете развернуть новые реализации `Действий` для части агентов, в то время как другие продолжат использовать старую версию или резервный скрытый режим.

## От определения к действию

Разделяя «что» (`Tool`) и «как» (`Действие`), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом становится оркестрация: как эти `Call` (вызовы) управляются, выполняются и выстраиваются в последовательность.

Следующий документ, [Акт 004: Агент/Вызов](./004_agent_call.md), исследует протокол, который управляет этим выполнением, превращая абстрактные определения в конкретные, отслеживающие состояние действия.