# 002: Агент: Tool

> Sidenote:
>
> - Требуется: [Агент: Request](./001_agent_request.md)

> **Tool**: Схема, определяющая возможность, которую может использовать агент. Она передается LLM как часть запроса и служит структурированным интерфейсом для потенциального действия. LLM активирует инструмент, создавая `Call` с конкретными параметрами. Затем этот `Call` выполняется либо латентно самой LLM, либо явно через зарегистрированную функцию в коде (`Activity`).
>
> — [Глоссарий](./000_glossary.md)

Этот документ описывает Tool — базовый интерфейс на основе схем, который позволяет агентам понимать и использовать структурированные возможности.

## Что такое Tools?

**Tools — это основа** систем действий агентов. Они открывают новый тип возможностей: **выбор действий в контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от ситуации.

Tools предоставляют:

- **Структурированные интерфейсы**: Возможности, определенные схемами, которые агенты могут обнаруживать и понимать.
- **Типобезопасность**: Четкие контракты для входных и выходных данных.
- **Компонуемость**: Строительные блоки, которые объединяются в сложные модели поведения агентов.
- **Интеграция с LLM**: Схемы, которые языковые модели могут анализировать и выбирать.

Когда агент заполняет параметры для Tool, он создает **Call** — это экземпляр Tool со всеми заполненными параметрами, представляющий конкретный запрос на выполнение (подробнее о выполнении Call, Scope и Method см. в [Протоколе Call](./002_agent_calls.md)).

> **Примечание**: Любой запрос к LLM можно представить как Idea (что хорошо подходит для простого генерирования структурированного контента), но Tools предоставляют механизм для более сложных сценариев, требующих динамического выбора действий. Подробнее о том, как Idea можно преобразовать в Tools с помощью входных схем, см. в [RFC по вводу для агентов](./003_agent_input.md).

## Когда использовать систему Tool

Используйте систему Tool, когда агентам необходимо:

- **Динамически выбирать действия** в зависимости от контекста и ситуации.
- **Выбирать между несколькими возможностями** для достижения цели.
- **Выполнять разные реализации** одной и той же возможности (например, разные поисковые системы).
- **Сочетать логику LLM с явным кодом** в процессе принятия решений.

## Архитектура системы Tool

### Основной принцип: Схема как интерфейс

Система Tool построена на фундаментальном принципе: **Tools — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Схема Tool указывает:

- **Что делает инструмент** (описание)
- **Что ему нужно** (входные параметры)
- **Что он производит** (структура `_output`)
- **Как он идентифицируется** (имя `_tool`)
- **Как он вызывается** (поле `_activity` — определяет режим выполнения, см. ниже «Стратегия разрешения Activity»)

### Архитектура двойного реестра

Система Tool использует два дополняющих друг друга реестра:

**Реестр Tool**: Хранит определения схем (интерфейс).
**Реестр Activity**: Хранит функции-реализации (исполнение).

Такое разделение позволяет инструментам существовать без реализаций (для рассуждений LLM) и позволяет заменять реализации во время выполнения (например, для сред разработки и продакшена).

### Мета-поля схемы Tool

Схемы Tool используют мета-поля (с префиксом в виде нижнего подчеркивания) для определения свойств системного уровня:

- **\_tool**: Уникальный идентификатор инструмента (обязательно).
- **\_activity**: Указание режима выполнения (определяется автоматически, если не задано).
- **\_output**: Ожидаемая структура вывода (система делает ее необязательной).
- **\_reasoningForCall**: Объяснение агента, почему был создан этот Call (добавляется системой).

Пользователи определяют эти мета-поля в своих описаниях инструментов, а система Tool дополняет их при композиции схем: определяет `_activity`, если оно не указано, делает `_output` необязательным и добавляет `_reasoningForCall`. Любое поле без префикса в виде нижнего подчеркивания считается параметром инструмента. Мета-поля всегда идут первыми при композиции схемы, обеспечивая единообразную структуру для понимания LLM.

### Границы системы

Система Tool отвечает за:

- Регистрацию Tool (определение и хранение схем)
- Заполнение параметров (извлечение из контекста с помощью LLM)
- Маршрутизацию выполнения (определение латентного или явного режима)
- Управление Activity (регистрация и вызов реализаций)

Протоколы более высокого уровня (такие как [Протокол Call](./002_agent_calls.md)) строят на основе этих примитивов оркестровку рабочих процессов, управление состоянием и политики выполнения.

## Определение и регистрация Tool

Tools определяются через JSON-схемы, которые полностью описывают их интерфейс:

### Базовая схема Tool

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Analyzes text sentiment',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Text to analyze' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

### Tool с регистрацией Activity

```typescript
// Определяем схему инструмента (как в базовом примере)
Tool.register('weatherCheck', {
  /* ... */
});

// Регистрируем реализацию — имя совпадает с инструментом для автоконфигурации
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

## Стратегия разрешения Activity

Система Tool поддерживает два принципиально разных режима выполнения:

> Sidenote:
>
> - [RFC 104: Концепция/Латентность](../rfc/104_concept_latent.md)
>   **Латентное выполнение** использует способности LLM к рассуждению — агент «обдумывает» проблему и выдает результат непосредственно в том же вызове. Это выполнение на основе знаний, идеально подходящее для анализа, планирования или творческих задач, где достаточно знаний, полученных LLM при обучении.

**Явное выполнение** передает задачу детерминированному коду — для вычисления результата вызывается функция Activity. Это выполнение на основе кода, необходимое для вызовов внешних API, операций с базами данных или любых задач, требующих точного и воспроизводимого поведения.

### Нулевая конфигурация сопоставления Activity

Система автоматически определяет режим выполнения при композиции схем:

1.  **Явное поле `_activity`**: Если в определении инструмента есть `_activity`, используется оно.
2.  **Совпадение имен** (рекомендуется): Если `Activity.Names` содержит имя инструмента, `_activity` устанавливается равным имени инструмента (явное выполнение).
3.  **Латентный режим по умолчанию**: В противном случае `_activity` устанавливается в пустую строку (латентное выполнение).

Такой подход на основе соглашений означает:

- **Регистрируйте Activity под тем же именем, что и Tool**, для автоматической конфигурации.
- Отсутствующие Activity автоматически переключаются в латентный режим выполнения.
- Явно указанные поля `_activity` всегда имеют приоритет.

### Композиция схем

Схемы Tool объединяются в массив `calls` для передачи в LLM. Каждая схема дополняется мета-полями и информацией о режиме выполнения (определенной по правилам выше), а затем добавляется с помощью паттерна `anyOf` из JSON Schema:

```typescript
{
  calls: {
    type: 'array',
    items: {
      anyOf: [
        { /* схема инструмента sentimentAnalysis с _activity: '' */ },
        { /* схема инструмента weatherCheck с _activity: 'weatherCheck' */ },
        // ... другие зарегистрированные инструменты
      ]
    }
  }
}
```

Это позволяет LLM выбирать из доступных инструментов и генерировать несколько `Call` в одном запросе.

## Почему важны двойные реестры

Без разделения схем Tool и реализаций Activity изменение режима выполнения потребовало бы переписывания кода агента. Если вы захотите переключиться с рассуждений LLM на внешний API, вам придется изменять каждого агента, использующего эту возможность.

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы инструментов стабильными, в то время как реализации могут меняться. Агенты всегда взаимодействуют с одной и той же схемой Tool, независимо от того, выполняется ли она через LLM или внешний код. Это означает:

- **Изменения в реализации не ломают агентов** — переключайтесь с латентного на явное выполнение, не трогая код агента.
- **A/B-тестирование стратегий выполнения** — сравнивайте рассуждения LLM с внешними API для одной и той же возможности.
- **Постепенное внедрение** — развертывайте новые реализации для части агентов, в то время как остальные используют старую.

## Tools как основа

Tools представляют собой **первый строительный блок** системы действий агента — они определяют, _что можно сделать_, с помощью чистых интерфейсов на основе схем. Следующий уровень, [Протокол Call](./002_agent_calls.md), строится на этой основе, чтобы определить, _как все выполняется_, с помощью элементов управления Scope и Method, обеспечивая сложные рабочие процессы с несколькими инструментами и стратегии выполнения.