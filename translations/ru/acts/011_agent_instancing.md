# 011: Агент/Экземплирование

> [!DEFINITION] :term[Экземплирование]{canonical="Instancing"}
> Протокол для группировки контекстных сообщений путем присвоения им общего уникального идентификатора. Это создает отдельные :term[Экземпляры]{canonical="Instance"} в рамках одного запроса, обеспечивая параллельные, мультиплексированные вычисления.

> Sidenote:
> - Требуется: :term[009: Агент/Состояние]{href="/009_agent_state.md"}
> - Совместимо:
>   - :term[007: Агент/Ввод]{href="/007_agent_input.md"}
>   - :term[013: Агент/Скоупы]{href="/013_agent_scopes.md"}
>   - :term[010: Агент/План]{href="/010_agent_plan.md"}

**Протокол Экземплирования** — это мощный паттерн для масштабирования рабочих процессов агентов, позволяющий выполнять несколько потоков вычислений в рамках одного запроса. Он дает возможность любому агенту одновременно работать с несколькими независимыми контекстами данных без изменения основной логики. Это достигается путем связывания контекстных сообщений, таких как :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}, с уникальными идентификаторами экземпляров. В результате один и тот же многоразовый :term[План]{canonical="Plan"} может выполняться параллельно на множестве экземпляров, но протокол является универсальным и поддерживает любую комбинацию сообщений, что значительно повышает производительность и согласованность.

## Механизм Экземплирования

Экземплирование предоставляет способ обработки нескольких независимых контекстов данных, надстраиваясь поверх сообщений, переносящих данные, таких как :term[Состояние]{canonical="State"}{href="/009_agent_state.md"}. Вместо одного сообщения :term[Состояние]{canonical="State"} запрос может содержать их массив, где каждое сообщение представляет отдельный :term[Экземпляр]{canonical="Instance"} задачи.

Для управления этими параллельными контекстами каждому сообщению :term[Состояние]{canonical="State"} присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы представляют собой короткие уникальные токены (например, `①`, `②`), которые позволяют LLM связывать операции с определенным :term[Экземпляром]{canonical="Instance"}.

Экземплирование — это опциональная функция, включаемая отправителем запроса для каждого сообщения. Добавляя свойство `_instance` к сообщению с данными, такому как :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}, отправитель указывает, что это сообщение следует рассматривать как отдельный, потокобезопасный контекст выполнения. Если свойство `_instance` опущено, сообщение считается глобальным ресурсом, доступным для всех экземпляров.

Этот подход дает значительные преимущества:

- **Эффективность**: Увеличивает пропускную способность системы за счет обработки множества экземпляров в одном запросе к LLM.
- **Согласованность**: Позволяя LLM видеть несколько связанных экземпляров в одном контексте, она может генерировать более согласованные и качественные планы.

## Композиция с контекстными сообщениями

Сила протокола заключается в том, как идентификатор `_instance` определяет область действия для различных типов контекстных сообщений.

- **:term[Состояние]{canonical="State"}:** Сообщение :term[Состояние]{canonical="State"} — это ядро протокола. Каждый :term[Экземпляр]{canonical="Instance"} — это отдельное сообщение :term[Состояние]{canonical="State"}, однозначно идентифицируемое свойством `_instance`. Это обеспечивает изолированное пространство для последовательности операций, гарантируя, что параллельные рабочие процессы не будут мешать друг другу.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="/009_agent_state.md"}

- **:term[Ввод]{canonical="Input"}:** Сообщение :term[Ввод]{canonical="Input"} можно использовать двумя способами. Глобальное сообщение :term[Ввод]{canonical="Input"} (без идентификатора `_instance`) предоставляет конфигурацию для всех экземпляров в пакете. Целевое сообщение :term[Ввод]{canonical="Input"} (с идентификатором `_instance`) предоставляет данные для конкретного сообщения :term[Состояние]{canonical="State"}, переопределяя любые глобальные входные данные.

  > Sidenote:
  > - :term[007: Агент/Ввод]{href="/007_agent_input.md"}

- **:term[Скоупы]{canonical="Scope"}:** Идентификатор `_instance` обеспечивает критически важную изоляцию данных для :term[Скоупов]{canonical="Scope"}. Когда :term[Вызов]{canonical="Call"} нацелен на конкретный экземпляр, его `_scopes` также ограничиваются контекстом этого экземпляра. Это позволяет :term[Делегату]{canonical="Delegate"} видеть только те данные, которые относятся к его конкретной задаче, даже если он является одним из многих в рамках более крупного запроса с несколькими экземплярами.

  > Sidenote:
  > - :term[013: Агент/Скоупы]{href="/013_agent_scopes.md"}

:::details{title="Пример: Масштабная модерация контента"}

Экземплирование превращает агентов, выполняющих одну задачу, в мощные обработчики пакетов. Рассмотрим агента, предназначенного для модерации комментариев пользователей на соответствие правилам сообщества.

Без экземплирования агент будет работать последовательно. Для проверки 100 комментариев потребуется 100 отдельных :term[Запросов]{canonical="Request"}. Это не только медленно, но и "вслепую" по отношению к контексту; агент оценивает каждый комментарий в полной изоляции, что может привести к несогласованным решениям по схожему контенту.

С **Протоколом Экземплирования** рабочий процесс распараллеливается в рамках одного :term[Запроса]{canonical="Request"}.

1.  **Пакетный ввод**: Агент получает `context`, содержащий массив из 100 сообщений :term[Ввод]{canonical="Input"}. Каждому сообщению присваивается уникальный идентификатор `_instance`, и оно содержит отдельный комментарий пользователя.

    ```json
    // Пакет сообщений Input, предоставленный LLM
    [
      {
        "type": "input",
        "_instance": "①",
        "comment": "This is a great post!"
      },
      {
        "type": "input",
        "_instance": "②",
        "comment": "I disagree with this..."
      },
      {
        "type": "input",
        "_instance": "③",
        "comment": "This is spam."
      }
      // ... еще 97 экземпляров комментариев
    ]
    ```

2.  **Параллельное выполнение Плана**: Теперь LLM видит весь пакет. Она может использовать один :term[План]{canonical="Plan"}, определяющий двухэтапный процесс: сначала проанализировать тональность, затем проверить по списку запрещенных ключевых слов. Этот же план применяется ко всем экземплярам.

3.  **Целевой вывод**: :term[Решение]{canonical="Solution"} агента будет содержать плоский список :term[Вызовов]{canonical="Call"}, но каждый `Call` будет направлен на конкретный комментарий с помощью свойства `_instance`.

    ```json
    // Решение, сгенерированное LLM
    {
      "calls": [
        {
          "_tool": "moderateComment",
          "_instance": "①",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "②",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "③",
          "decision": "reject"
        }
        // ... еще 97 вызовов модерации
      ]
    }
    ```

Этот подход дает два основных преимущества:

- **Пропускная способность**: То, что раньше требовало 100 циклов обмена данными с LLM, теперь выполняется за один раз.
- **Согласованность**: Просматривая весь пакет, LLM получает более широкий контекст. Она может выносить более согласованные суждения и даже выявлять закономерности (например, скоординированную спам-атаку), которые были бы незаметны при обработке комментариев по одному.

:::

:::::details{title="Глобальный ввод с экземплированным состоянием"}

Этот пример показывает, как глобальное сообщение `Input` может направить внимание агента на конкретный экземпляр в большом пакете. Это позволяет динамически и целенаправленно управлять параллельными рабочими процессами, превращая простой пакетный обработчик в более сложного координатора, подобного менеджеру, управляющему отдельными сотрудниками.

::::columns
:::column{title="Контекст"}

Этот сценарий использует метафору менеджера, управляющего сотрудниками. Одно глобальное сообщение `input` действует как команда верхнего уровня, в то время как несколько экземплированных сообщений `state` представляют сотрудников с их собственными задачами. Эта схема демонстрирует, как агент, созданный для управления одной сущностью, может легко масштабироваться для координации многих, не изменяя своей основной архитектуры.

```json
[
  // Глобальная инструкция для конкретного сотрудника
  {
    "type": "input",
    "instruction": "Give employee B them a new, high-priority task to 'Finalize the quarterly report'."
  },

  // Текущее состояние всех сотрудников
  {
    "type": "state",
    "_instance": "employee_A",
    "task": "Draft initial proposal",
    "status": "In Progress"
  },
  {
    "type": "state",
    "_instance": "employee_B",
    "task": "Review team submissions",
    "status": "Blocked"
  }
]
```

:::
:::column{title="Целевое решение"}

Несмотря на то, что `Input` является глобальным, LLM правильно интерпретирует инструкцию на естественном языке. Она генерирует `Call`, который точно нацелен на `employee_B` с помощью свойства `_instance`, демонстрируя способность интеллектуально направлять команды. Другой экземпляр 'сотрудник' остается незатронутым.

```json
{
  "calls": [
    {
      "_tool": "updateTask",
      "_instance": "employee_B",
      "newTask": "Finalize the quarterly report",
      "newStatus": "High Priority",
      "output": "†state"
    }
  ]
}
```

:::
::::
:::::

## Композиция с другими протоколами

Экземплирование интегрируется с протоколами более высокого уровня для управления потоком выполнения.

- **:term[Вызовы]{canonical="Call"}:** Свойство `_instance` в :term[Вызове]{canonical="Call"} — это основной механизм, который направляет его выполнение. Оно гарантирует, что все манипуляции с состоянием — будь то запись в `_outputPath` или чтение значения из состояния для использования в качестве входных данных — правильно привязаны к целевому :term[Экземпляру]{canonical="Instance"}.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="/004_agent_call.md"}

- **:term[План]{canonical="Plan"}:** Сообщение :term[План]{canonical="Plan"} не подлежит экземплированию; оно действует как единый глобальный шаблон для рабочего процесса. Его можно комбинировать с несколькими экземплированными сообщениями :term[Состояние]{canonical="State"}, что позволяет выполнять один и тот же план одновременно во многих независимых контекстах данных в рамках одного запроса.

  > Sidenote:
  > - :term[010: Агент/План]{href="/010_agent_plan.md"}

## От Планирования к Процессу

В то время как :term[План]{canonical="Plan"} предоставляет многоразовый шаблон для рабочего процесса, а :term[Экземплирование]{canonical="Instancing"} — механизм для его масштабного выполнения, **:term[Идея Процесса]{href="/203_idea_process.md"}** является артефактом, который фиксирует результат. Это полная, самодостаточная запись стратегического плана и его текущего состояния выполнения по всем экземплярам.
