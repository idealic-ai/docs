# 011: Агент/План

> [!DEFINITION] [План](./000_glossary.md)
> Контекстное сообщение, содержащее граф потока данных из :term[вызовов инструментов]{canonical="Tool Call"}, который представляет стратегию агента. Оно передается между шагами для обеспечения итеративного выполнения и адаптации.

> Sidenote:
> - Требуется:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
>   - :term[009: Агент/Состояние]{href="./009_agent_state.md"}
>   - :term[012: Агент/Экземплирование]{href="./012_agent_instancing.md"}

Сообщение :term[План]{canonical="Plan"} — это основа итеративного выполнения. Когда LLM получает текущий :term[План]{canonical="Plan"} вместе с актуальным объектом :term[Состояния]{canonical="State"}, она может определить свою точную позицию в рабочем процессе. Эта ситуационная осведомленность позволяет агенту быть по-настояшему адаптивным. Он может следовать существующему плану, генерировать новые :term[вызовы инструментов]{canonical="Tool Call"} для его расширения или полностью отбросить его и перепланировать в ответ на неожиданные результаты. Это создает гибкую модель выполнения, которая может варьироваться от жесткой, предопределенной процедуры до динамичной, исследовательской стратегии.

## Как формируется План

Связи в графе создаются не с помощью явных указателей, а через простую и мощную конвенцию потока данных с использованием объекта :term[Состояния]{canonical="State"}.

- **Узлы (:term[Вызовы инструментов]{canonical="Tool Call"}):** Каждый шаг в рабочем процессе — это :term[вызов инструмента]{canonical="Tool Call"}, представляющий действие, которое необходимо выполнить.
- **Ребра (объект :term[Состояния]{canonical="State"}):** Связи между шагами создаются путем записи и чтения из объекта :term[Состояния]{canonical="State"}. Один :term[инструмент]{canonical="Tool"} записывает свой результат по определенному пути в :term[Состоянии]{canonical="State"}, используя мета-свойство `:term[Путь вывода]{canonical="Output Path"}`. Последующий :term[инструмент]{canonical="Tool"} может затем использовать этот результат в качестве входных данных, ссылаясь на тот же путь с помощью **:term[ссылки на переменную]{canonical="Variable Reference"}**.

  > Sidenote:
  > - [008: Агент/Вывод](./008_agent_output.md)

Это устанавливает четкую зависимость: второй :term[вызов инструмента]{canonical="Tool Call"} не может быть выполнен, пока первый не завершится и не заполнит :term[Состояние]{canonical="State"}.

Например, :term[План]{canonical="Plan"} для получения профиля пользователя и его последующего обобщения будет состоять из двух :term[вызовов инструментов]{canonical="Tool Call"}:

:::div{.limited-width}

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

> Sidenote:
> ```mermaid
> graph TD
>     state_var{{"state.user.profile"}}
>
>     Call1["fetchUserProfile"]
>     Call2["summarizeProfile"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```

:::

Здесь вызов `summarizeProfile` зависит от вывода `fetchUserProfile`, создавая двухэтапный план. Эту взаимосвязь можно представить в виде простого графа.

## Содержимое Плана: Граф потока данных

Содержимое сообщения :term[Плана]{canonical="Plan"} — это граф потока данных. Эта структура используется для представления стратегии агента в виде последовательности взаимосвязанных :term[вызовов инструментов]{canonical="Tool Call"}. Представляя рабочий процесс в виде графа, система может четко определить зависимости между шагами, где вывод одного :term[вызова инструмента]{canonical="Tool Call"} становится вводом для другого. Этот формат на основе графа предоставляет четкую, машиночитаемую структуру, которую :term[цикл выполнения]{canonical="Execution Loop"} агента может интерпретировать и выполнять.

> Sidenote:
> :term[План]{canonical="Plan"} не ограничивается линейными последовательностями. Он может представлять сложные рабочие процессы с условной логикой, где путь выполнения зависит от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Получить погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти фильм];
>     C -- state.suggestion --> E[Представить предложение];
>     D -- state.suggestion --> E[Представить предложение];
> ```

Базовая структура графа не ограничивается только определением исполняемых рабочих процессов. Агенту можно дать команду сгенерировать граф :term[вызовов инструментов]{canonical="Tool Call"}, который представляет нечто совершенно иное — визуализацию социальной сети, рабочий процесс GitHub Actions или схему базы данных.

Крайне важно отличать эти выходные данные от :term[Плана]{canonical="Plan"}. Хотя они используют ту же структуру графа, они не являются «планами» в архитектурном смысле, пока не будут переданы в последующий :term[Запрос]{canonical="Request"} в качестве контекстного сообщения :term[Плана]{canonical="Plan"} с намерением быть выполненными. Это различие предотвращает путаницу между генерацией представления существующей системы и созданием исполняемой стратегии.

Хотя содержимое :term[Плана]{canonical="Plan"} может быть мощным инструментом для мозгового штурма, обсуждения и «размышлений вслух», его основное применение в этой системе — определение исполняемых рабочих процессов. Для этой цели мы используем особый тип графа, называемый **направленным ациклическим графом (DAG)**, где каждый узел — это :term[вызов инструмента]{canonical="Tool Call"}.

У DAG есть несколько ключевых свойств, которые делают его идеальным для выполнения:

- **Граф:** «Граф» — это все содержимое сообщения :term[Плана]{canonical="Plan"} — совокупность всех :term[вызовов инструментов]{canonical="Tool Call"} (узлов) и зависимостей данных, которые их связывают (ребер).
- **Направленный:** Связи односторонние, определяются потоком данных. Шаг, создающий данные, должен предшествовать шагу, который их использует.
- **Ациклический:** Рабочий процесс не может иметь циклических зависимостей, что гарантирует наличие у него четкого начала и конца. Это критически важная функция безопасности, предотвращающая генерацию LLM рабочего процесса с бесконечным циклом. Система проверяет, что :term[План]{canonical="Plan"} является ациклическим перед выполнением.

> Sidenote:
> Для реализации итеративной логики, такой как «цикл for», используется шаблон вложенного, делегированного выполнения. Внешний :term[План]{canonical="Plan"} управляет состоянием цикла (например, счетчиком итераций), и на каждой итерации он вызывает подзапрос через :term[Делегата]{canonical="Delegate"}. Этот подзапрос содержит свой собственный, отдельный, ациклический :term[План]{canonical="Plan"}, который выполняет логику для одной итерации. Это гарантирует, что циклы создаются явно и безопасно.

## Разделение планирования и выполнения

Самая мощная особенность этой архитектуры — полное разделение планирования и выполнения. Поскольку :term[План]{canonical="Plan"} является просто декларативной структурой данных, агент может сгенерировать весь граф :term[вызовов инструментов]{canonical="Tool Call"} _до_ запуска любого кода.

LLM выступает в роли планировщика, собирая массив :term[вызовов]{canonical="Call"}, который представляет предполагаемый рабочий процесс. Эта структура данных затем может быть:

- **Проверена:** Система может проверить граф на наличие циклических зависимостей или других структурных ошибок.
- **Симулирована:** Может быть выполнен «пробный запуск» для прогнозирования поведения рабочего процесса.
- **Представлена на утверждение:** :term[План]{canonical="Plan"} может быть показан человеку для проверки, изменения или утверждения перед выполнением, создавая критически важный уровень безопасности и сотрудничества.

Выполнение обрабатывается :term[циклом выполнения]{canonical="Execution Loop"}, который интерпретирует сообщение :term[Плана]{canonical="Plan"} и запускает :term[вызовы инструментов]{canonical="Tool Call"} в правильном порядке на основе их зависимостей, заполняя объект :term[Состояния]{canonical="State"} по мере продвижения.

## План как развивающаяся стратегия

:term[План]{canonical="Plan"} не статичен; это живая стратегия, которая может адаптироваться на каждом шаге цикла выполнения. Ключевое различие заключается в том, что `Plan` — это не любой вывод от LLM. Когда агент впервые генерирует набор :term[вызовов инструментов]{canonical="Tool Call"}, это просто предлагаемая последовательность действий. Он становится настоящим :term[Планом]{canonical="Plan"} только тогда, когда передается в качестве контекстного сообщения в _следующий_ запрос в цикле.

Этот цикл превращает одноразовый вывод в постоянную стратегию:

- **:term[Контекст]{canonical="context"}** для запроса содержит объект :term[Состояния]{canonical="State"} и сообщение :term[Плана]{canonical="Plan"} с предыдущего шага.
- **:term[Решение]{canonical="Solution"}**, сгенерированное LLM, содержит новый набор :term[вызовов инструментов]{canonical="Tool Call"}, который становится **новым :term[Планом]{canonical="Plan"}** для следующего шага.

Этот итеративный процесс позволяет агенту быть одновременно проактивным и реактивным. Он может следовать существующему :term[Плану]{canonical="Plan"}, но также может изменять его в ответ на результаты предыдущего шага. Например, если :term[вызов инструмента]{canonical="Tool Call"} завершается неудачей, агент может сгенерировать новый :term[План]{canonical="Plan"}, включающий шаги по обработке ошибок. Это делает систему устойчивой и адаптируемой.

:::::details{title="Пример: Планирование на один шаг вперед"}

Этот пример демонстрирует, как `Plan` предоставляет структурный «идеальный сценарий», который направляет агента, не позволяя ему отклоняться от стандартной процедуры даже при наличии других вероятных действий.

**Сценарий:** Агенту службы поддержки необходимо обработать возврат средств. Стандартная процедура, инициируемая запросом пользователя, заключается в том, чтобы сначала проверить историю платежей для контекста, а затем произвести возврат.

**1. Первоначальный запрос**

Цикл начинается с запроса клиента. На основе этого `input` LLM формулирует стандартный двухэтапный `Plan` для обработки возврата. Это представляет идеальный, наиболее распространенный рабочий процесс.

::::columns
:::column{title="Контекст и схема для запроса"}

```json
// Agent.Request(конфигурация, схема, контекст)
{
  "schema": {
    "type": "object",
    "properties": {
      "calls": { "type": "array" },
      "output": {
        "type": "object",
        "nullable": true,
        "properties": {
          "confirmationId": { "type": "string" },
          "message": { "type": "string" }
        }
      }
    }
  },
  "context": [
    {
      "type": "input",
      "request": "I'd like a refund for my last order.",
      "customerId": "cust_123",
      "amount": 50.0
    }
  ]
}
```

:::
:::column{title="`solution` от LLM"}

```json
{
  "calls": [
    {
      "_tool": "checkBillingHistory",
      "customerId": "†input.customerId"
    },
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": null
}
```

:::
::::

**2. Следующий запрос в цикле**

:term[Цикл выполнения]{canonical="Execution Loop"} запускает вызов `checkBillingHistory` и заполняет :term[Состояние]{canonical="State"}. История выявляет некоторую сложность (например, предыдущий возврат платежа). На этом этапе неуправляемый агент мог бы с большой вероятностью выбрать другой доступный инструмент, `escalateToSupervisor`.

Однако сообщение `Plan` в контексте предоставляет необходимую структуру. Сопоставляя то, что он _знает_ (сложное :term[Состояние]{canonical="State"}), с тем, что он _должен делать_ (`Plan`), LLM понимает свое точное положение в рабочем процессе и придерживается «идеального сценария».

::::columns
:::column{title="Контекст"}

```json
[
  {
    "type": "state",
    "billingHistory": {
      "orders": 5,
      "lastChargeback": "2025-09-10"
    }
  },
  {
    "type": "plan",
    "plan": [
      {
        "_tool": "checkBillingHistory",
        "customerId": "†input.customerId"
      },
      {
        "_tool": "issueRefund",
        "customerId": "†input.customerId",
        "amount": "†input.amount"
      }
    ]
  }
]
```

:::
:::column{title="`solution` от LLM"}

```json
{
  "calls": [
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": {
    "confirmationId": "refund_xyz789",
    "message": "The refund has been processed successfully."
  }
}
```

:::
::::

`Plan` обеспечивает процедурную последовательность, предотвращая преждевременную эскалацию и удерживая агента на намеченном пути.

:::::

:::::details{title="Пример: Корректировка плана"}

Этот пример демонстрирует, как агент может изменить существующий :term[План]{canonical="Plan"} в ответ на новую информацию, выбрав другой инструмент.

::::columns
:::column{title="Контекст"}

Агенту дается существующий «идеальный сценарий» в виде `Plan` и новый `Input` от пользователя, который вводит новое ограничение.

```ts
[
  { type: 'tool', tool: Tool.bookFlight },
  { type: 'tool', tool: Tool.bookHotel },
  { type: 'tool', tool: Tool.findPetFriendlyHotel },
  {
    type: 'plan',
    plan: [
      {
        _tool: 'bookFlight',
        destination: '†input.destination',
      },
      {
        _tool: 'bookHotel',
        destination: '†input.destination',
      },
    ],
  },
  {
    type: 'input',
    destination: 'Berlin',
    instruction: "Actually, I'll be traveling with my dog.",
  },
];
```

:::
:::column{title="`solution` от LLM"}

LLM распознает, что первоначальный план больше не подходит. Он отбрасывает старый план и генерирует новый, заменяя `bookHotel` более специализированным инструментом.

```json
{
  "calls": [
    {
      "_tool": "bookFlight",
      "destination": "†input.destination"
    },
    {
      "_tool": "findPetFriendlyHotel",
      "destination": "†input.destination"
    }
  ],
  "output": null
}
```

:::
::::

Агент не просто меняет параметр; он коренным образом изменяет свою стратегию, выбирая более подходящий инструмент (`findPetFriendlyHotel`) на основе новых требований. Этот новый набор `Tool Calls` становится `Plan` для следующего шага в :term[цикле выполнения]{canonical="Execution Loop"}.

:::::

:::::details{title="Пример: Обработка сбоев"}

Этот пример демонстрирует, как агент может отклониться от «идеального сценария» :term[Плана]{canonical="Plan"}, столкнувшись с неожиданным сбоем. Процесс показан в два этапа: первоначальный план «идеального сценария» и перепланирование, которое происходит после сбоя инструмента.

**1. Первоначальный план**

Агенту предоставляется набор инструментов и ввод пользователя. Он генерирует оптимистичный, двухэтапный план «идеального сценария», который не учитывает возможность сбоя.

::::columns
:::column{title="Начальный контекст"}

```ts
Agent.Request(config, {
  schema: {
    type: 'object',
    properties: {
      calls: { type: 'array' },
      output: {
        type: 'object',
        nullable: true,
        properties: {
          status: {
            type: 'string',
            enum: ['Success', 'Failed'],
          },
        },
      },
    },
  },
  context: [
    { type: 'tool', tool: 'Tool.processPayment' },
    { type: 'tool', tool: 'Tool.confirmOrder' },
    { type: 'tool', tool: 'Tool.reportFailure' },
    { type: 'input', amount: 50.0 },
  ],
});
```

:::
:::column{title="Начальное решение"}

```json
{
  "calls": [
    {
      "_tool": "processPayment",
      "amount": "†input.amount",
      "_outputPath": "†state.receipt || †state.error"
    },
    {
      "_tool": "confirmOrder",
      "receipt": "†state.receipt"
    }
  ],
  "output": null
}
```

:::
::::

**2. Сбой и перепланирование**

:term[Цикл выполнения]{canonical="Execution Loop"} пытается запустить `processPayment`, но инструмент не срабатывает. Движок заполняет `†state.error`. В следующей итерации LLM видит это новое состояние ошибки вместе с исходным (теперь устаревшим) планом и генерирует новое решение для обработки сбоя.

::::columns
:::column{title="Контекст для следующего запроса"}

```json
[
  {
    "type": "state",
    "error": { "code": "card_declined", "message": "Your card was declined." }
  },
  // Исходный, теперь устаревший план все еще находится в контексте
  {
    "type": "plan",
    "plan": [
      { "_tool": "processPayment", "_outputPath": "†state.receipt || †state.error" },
      { "_tool": "confirmOrder", "receipt": "†state.receipt" }
    ]
  }
]
```

:::
:::column{title="Новое решение (перепланировано)"}

```json
{
  "calls": [
    {
      "_tool": "reportFailure",
      "error": "†state.error"
    }
  ],
  "output": { "status": "Failed" }
}
```

:::
::::

Агент распознал `error` в :term[Состоянии]{canonical="State"}, проигнорировал устаревший «идеальный сценарий» `Plan` и сгенерировал новый, одношаговый план для `reportFailure`. Это демонстрирует способность агента реактивно обрабатывать неожиданные результаты.

:::::

:::::details{title="Пример: Планирование на основе схемы"}

Этот пример демонстрирует, как предоставление `schema` для объекта :term[Состояния]{canonical="State"} действует как чертеж, направляя LLM к созданию структурно правильного :term[Плана]{canonical="Plan"}.

::::columns
:::column{title="Контекст со схемой состояния"}

Вызывающая сторона предоставляет `Input` и сообщение `State`, которое содержит только `schema`. Эта схема определяет предполагаемый поток данных, указывая «переменные», которые должен использовать план.

```json
[
  { "type": "tool", "tool": "Tool.detectLanguage" },
  { "type": "tool", "tool": "Tool.isEnglish" },
  { "type": "tool", "tool": "Tool.translateText" },
  {
    "type": "input",
    "text": "Bonjour le monde"
  },
  {
    "type": "state",
    "schema": {
      "type": "object",
      "properties": {
        "language": { "type": "string" },
        "isEnglish": { "type": "boolean" },
        "translatedText": { "type": "string" }
      }
    }
  }
]
```

:::
:::column{title="`solution` от LLM"}

LLM использует схему `State` в качестве руководства для построения действительного плана, правильно связывая `:term[Путь вывода]{canonical="Output Path"}` одного инструмента с входом следующего.

```json
{
  "calls": [
    {
      "_tool": "detectLanguage",
      "text": "†input.text",
      // LLM знает, что нужно использовать этот путь из схемы.
      "_outputPath": "†state.language"
    },
    {
      "_tool": "isEnglish",
      // Он правильно ссылается на вывод предыдущего шага.
      "language": "†state.language",
      "_outputPath": "†state.isEnglish"
    },
    {
      "_tool": "translateText",
      "text": "†input.text",
      "isEnglish": "†state.isEnglish",
      "_outputPath": "†state.translatedText"
    }
  ],
  "output": null
}
```

:::
::::

Предоставляя `schema`, вызывающая сторона дает LLM четкий чертеж потока данных. LLM не нужно угадывать имена переменных или последовательность; он просто заполняет предварительно определенные слоты, что приводит к более надежному и предсказуемому `Plan`.

:::::

Этот итеративный цикл планирования и выполнения является ядром :term[Процесса]{href="./203_idea_process.md"}. Это самодостаточный снимок рабочего процесса, фиксирующий доступные :term[инструменты]{canonical="Tool"}, актуальное :term[состояние]{canonical="State"} и сам :term[План]{canonical="Plan"}.

## От одного плана к многократно используемым рабочим процессам

Сообщение :term[Плана]{canonical="Plan"} определяет последовательность действий для конкретной задачи. Чтобы сделать эти рабочие процессы по-настоящему мощными, нам нужен способ инкапсулировать их в многократно используемые компоненты, которые можно вызывать из других :term[Планов]{canonical="Plan"}.

Протокол для этого параллельного выполнения описан в :term[012: Агент/Экземплирование]{href="./012_agent_instancing.md"}.
