# 003: Агент/Действие

> [!DEFINITION] :term[Действие]{canonical="Activity"}
> Явная асинхронная функция, реализующая логику для :term[Инструмента]{canonical="Tool"}. Это механизм для выполнения действий, требующих вызовов внешних API, операций с базами данных или любой другой задачи, которая не может быть обработана в скрытом пространстве LLM.

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

Этот документ описывает **Протокол Действий**, который определяет, как :term[Инструменты]{canonical="Tool"} подкрепляются конкретным исполняемым кодом. Если :term[Инструмент]{canonical="Tool"} определяет интерфейс возможности, то :term[Действие]{canonical="Activity"} предоставляет её реализацию.

## Архитектура двойного реестра

Система агентов использует два взаимодополняющих реестра для разделения интерфейса возможности и её реализации:

- **:term[Реестр Инструментов]{canonical="Tool"}**: Хранит определения схем для :term[Инструментов]{canonical="Tool"}.
- **:term[Реестр Действий]{canonical="Activity"}**: Хранит явные `async` функции (:term[Действия]{canonical="Activity"}), которые реализуют :term[Инструменты]{canonical="Tool"}.

Это разделение является ключом к гибкости системы. Оно позволяет определять и использовать :term[Инструменты]{canonical="Tool"} в режиме только скрытого исполнения (где LLM генерирует вывод напрямую) и позволяет заменять различные реализации :term[Действия]{canonical="Activity"} без изменения интерфейса :term[Инструмента]{canonical="Tool"} (например, для разных сред, таких как разработка и продакшен).

## Регистрация Действия

:term[Действие]{canonical="Activity"} регистрируется под уникальным именем, которое используется для его привязки к :term[Инструменту]{canonical="Tool"}.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрация реализации Действия.
// По соглашению, Действие может быть привязано к Инструменту с тем же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Соответствующая схема Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Gets the current weather for a location.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы исполнения: Скрытое и Явное

Система поддерживает два принципиально разных режима исполнения :term[Вызова]{canonical="Call"} :term[Инструмента]{canonical="Tool"}:

- **Скрытое исполнение**: Использует способности LLM к рассуждению. Агент «продумывает» задачу и выдаёт результат напрямую в том же вызове. Это режим по умолчанию, если для :term[Инструмента]{canonical="Tool"} не найдено ни одного :term[Действия]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное исполнение**: Делегирует :term[Вызов]{canonical="Call"} детерминированному коду. Для вычисления результата вызывается функция :term[Действия]{canonical="Activity"}. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, повторяемой логики.

## Стратегия разрешения Действий

Система использует стратегию нулевой конфигурации для определения режима исполнения при вызове :term[Инструмента]{canonical="Tool"}. Поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} сигнализирует о намерении использовать явную реализацию. Это поле разрешается автоматически во время композиции схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если само определение :term[Инструмента]{canonical="Tool"} включает непустую строку `_activity`, это значение используется для поиска :term[Действия]{canonical="Activity"} в реестре.
2.  **Соглашение об одинаковых именах (рекомендуется)**: Если поле `_activity` в :term[Инструменте]{canonical="Tool"} отсутствует, система проверяет, было ли зарегистрировано :term[Действие]{canonical="Activity"} с **тем же именем**, что и :term[Инструмент]{canonical="Tool"}. Если найдено, поле `_activity` автоматически устанавливается на имя :term[Инструмента]{canonical="Tool"}.
3.  **Резервный вариант — скрытое исполнение**: Если по вышеуказанным правилам подходящее :term[Действие]{canonical="Activity"} не найдено, поле `_activity` устанавливается в пустую строку, что означает, что :term[Вызов]{canonical="Call"} должен быть исполнен скрыто.

Этот подход, основанный на соглашениях, упрощает разработку:

- **Для нулевой конфигурации регистрируйте ваше :term[Действие]{canonical="Activity"} под тем же именем, что и ваш :term[Инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"} без соответствующего :term[Действия]{canonical="Activity"} автоматически и безопасно переключатся на скрытое исполнение.
- Явное поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} всегда будет иметь приоритет, позволяя одному :term[Действию]{canonical="Activity"} реализовывать несколько интерфейсов :term[Инструментов]{canonical="Tool"}.

## Почему разделение Действий важно

Без разделения схем :term[Инструментов]{canonical="Tool"} и реализаций :term[Действий]{canonical="Activity"} определение возможности было бы навсегда связано с её логикой исполнения. Чтобы переключиться с реализации на основе LLM на внешний API, пришлось бы находить и изменять каждого агента, использующего этот :term[Инструмент]{canonical="Tool"}.

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы :term[Инструментов]{canonical="Tool"} стабильными и позволяя их базовым реализациям развиваться. Агенты взаимодействуют с последовательной схемой :term[Инструмента]{canonical="Tool"}, независимо от того, исполняется ли она скрыто с помощью LLM или явно с помощью :term[Действия]{canonical="Activity"}. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключаться со скрытого на явное исполнение, не затрагивая код агента.
- **A/B-тестирование стратегий исполнения**: Вы можете сравнивать производительность рассуждений LLM с внешним API для одной и той же возможности.
- **Постепенное внедрение**: Вы можете развертывать новые реализации :term[Действий]{canonical="Activity"} для части агентов, в то время как другие продолжают использовать старую или резервный скрытый вариант.

## От определения к действию

Разделяя «что» (:term[Инструмент]{canonical="Tool"}) и «как» (:term[Действие]{canonical="Activity"}), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом является оркестрация: как эти :term[Вызовы]{canonical="Call"} управляются, исполняются и упорядочиваются.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, исследует протокол, который управляет этим исполнением, превращая абстрактные определения в конкретные, сохраняющие состояние действия.