# 003: Агент/Действие

> [!DEFINITION] [Действие](./000_glossary.md)
> Явная асинхронная функция, реализующая логику для :term[Инструмента]{canonical="Tool"}. Это механизм для выполнения действий, требующих вызовов внешних API, операций с базами данных или любой другой задачи, которую не может выполнить скрытое пространство LLM.

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

**Протокол Действия** определяет, как :term[Инструменты]{canonical="Tool"} подкрепляются конкретным, исполняемым кодом. В то время как :term[Инструмент]{canonical="Tool"} определяет интерфейс возможности, :term[Действие]{canonical="Activity"} предоставляет его реализацию.

## Архитектура двойного реестра

Система агентов использует два взаимодополняющих реестра для разделения интерфейса возможности от ее реализации:

- **:term[Реестр Инструментов]{canonical="Tool"}**: Хранит определения схем для :term[Инструментов]{canonical="Tool"}.
- **:term[Реестр Действий]{canonical="Activity"}**: Хранит явные `async` функции (:term[Действия]{canonical="Activity"}), которые реализуют :term[Инструменты]{canonical="Tool"}.

Это разделение — ключ к гибкости системы. Оно позволяет определять и использовать :term[Инструменты]{canonical="Tool"} в режиме только скрытого исполнения (где LLM генерирует вывод напрямую) и позволяет заменять различные реализации :term[Действия]{canonical="Activity"} без изменения интерфейса :term[Инструмента]{canonical="Tool"} (например, для разных сред, таких как разработка и продакшн).

## Регистрация Действия

:term[Действие]{canonical="Activity"} регистрируется с уникальным именем, которое используется для его привязки к :term[Инструменту]{canonical="Tool"}. Обработчик — это `async` функция, которая получает три аргумента:

- **`call`**: Конкретный объект :term[Вызова]{canonical="Call"}. Он содержит все параметры для инструмента, включая любые мета-свойства (с префиксом `_`), которые направляют выполнение.
- **`tool`**: Определение схемы выполняемого :term[Инструмента]{canonical="Tool"}. Это позволяет действию инспектировать свой собственный интерфейс, например, ожидаемую схему `_output`.
- **`context`**: Массив сообщений, выборочно импортированных из родительской среды. Это не полный контекст родителя, а ограниченное представление, контролируемое протоколом :term[ОбластейВидимости]{canonical="Scope"}, что делает контекстную информацию явной, опциональной функцией.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрация реализации Действия.
// По соглашению, Действие может быть привязано к Инструменту с тем же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async (call, tool, context) => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Соответствующая схема Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Получает текущую погоду для местоположения.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы выполнения: Скрытый и Явный

Система поддерживает два принципиально разных режима выполнения для :term[Вызова]{canonical="Call"} :term[Инструмента]{canonical="Tool"}:

- **Скрытое выполнение**: Использует способности LLM к рассуждению. Агент «продумывает» проблему и генерирует вывод напрямую в том же вызове. Это режим по умолчанию, когда для :term[Инструмента]{canonical="Tool"} не найдено ни одного :term[Действия]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное выполнение**: Делегирует :term[Вызов]{canonical="Call"} детерминированному коду. Для вычисления вывода вызывается функция :term[Действия]{canonical="Activity"}. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, воспроизводимой логики.

## Стратегия разрешения Действия

Система использует стратегию нулевой конфигурации для определения, какой режим выполнения использовать, когда вызывается :term[Инструмент]{canonical="Tool"}. Поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} сигнализирует о намерении использовать явную реализацию. Это поле разрешается автоматически во время композиции схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если определение :term[Инструмента]{canonical="Tool"} само содержит непустую строку `_activity`, это значение используется для поиска :term[Действия]{canonical="Activity"} в реестре.
2.  **Соглашение об одинаковом имени (рекомендуется)**: Если поле `_activity` отсутствует в :term[Инструменте]{canonical="Tool"}, система проверяет, было ли зарегистрировано :term[Действие]{canonical="Activity"} с **тем же именем**, что и :term[Инструмент]{canonical="Tool"}. Если оно найдено, поле `_activity` автоматически устанавливается в имя :term[Инструмента]{canonical="Tool"}.
3.  **Запасной вариант — Скрытое исполнение**: Если по вышеуказанным правилам не найдено подходящее :term[Действие]{canonical="Activity"}, поле `_activity` устанавливается в пустую строку, сигнализируя, что :term[Вызов]{canonical="Call"} должен быть выполнен скрыто.

Этот подход, основанный на соглашениях, упрощает разработку:

- **Для нулевой конфигурации регистрируйте ваше :term[Действие]{canonical="Activity"} под тем же именем, что и ваш :term[Инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"} без соответствующего :term[Действия]{canonical="Activity"} автоматически и безопасно переключатся на скрытое выполнение.
- Явное поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} всегда будет иметь приоритет, позволяя одному :term[Действию]{canonical="Activity"} реализовывать несколько интерфейсов :term[Инструментов]{canonical="Tool"}.

## Взаимодействие с другими системами

:term[Действие]{canonical="Activity"} не выполняется в изоляции. Оно полагается на другие протоколы для получения своих параметров и контекстной информации структурированным и безопасным способом.

- **:term[Вызов]{canonical="Call"}:** Аргумент `call` предоставляет :term[Действию]{canonical="Activity"} полный объект вызова. Это не просто словарь параметров; это богатая структура, которая может включать мета-свойства, такие как `_outputPath` для указания, где хранить результат, или `_instance` для нацеливания на конкретный элемент в пакетной обработке. Это позволяет :term[Действию]{canonical="Activity"} участвовать в сложных, состоятельных рабочих процессах.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
  > - :term[008: Агент/Вывод]{href="./008_agent_output.md"}
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **:term[ОбластиВидимости]{canonical="Scope"}:** Аргумент `context` заполняется через протокол :term[ОбластейВидимости]{canonical="Scope"}. Свойство `_scopes` в :term[Вызове]{canonical="Call"} действует как список разрешений, указывая, какие сообщения из родительской среды (например, :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}) должны быть переданы :term[Действию]{canonical="Activity"}. Это обеспечивает контролируемый и явный механизм для доступа :term[Действия]{canonical="Activity"} к необходимой ему информации, не подвергая его воздействию всего, потенциально зашумленного, родительского контекста.

  > Sidenote:
  > - :term[015: Агент/ОбластиВидимости]{href="./015_agent_scopes.md"}

## Почему важно разделять Действия

Без разделения схем :term[Инструментов]{canonical="Tool"} от реализаций :term[Действий]{canonical="Activity"} определение возможности было бы навсегда привязано к ее логике выполнения. Чтобы переключиться с LLM-реализации на внешний API, пришлось бы найти и изменить каждого агента, использующего этот :term[Инструмент]{canonical="Tool"}.

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы :term[Инструментов]{canonical="Tool"} стабильными, в то время как их базовые реализации могут развиваться. Агенты взаимодействуют с последовательной схемой :term[Инструмента]{canonical="Tool"}, независимо от того, выполняется ли она скрыто LLM или явно :term[Действием]{canonical="Activity"}. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключаться между скрытым и явным выполнением, не трогая код агента.
- **A/B тестирование стратегий выполнения**: Вы можете сравнивать производительность рассуждений LLM с внешним API для одной и той же возможности.
- **Постепенное внедрение**: Вы можете развертывать новые реализации :term[Действий]{canonical="Activity"} для подмножества агентов, в то время как другие продолжают использовать старую или скрытый запасной вариант.

## От определения к действию

Разделяя «что» (:term[Инструмент]{canonical="Tool"}) и «как» (:term[Действие]{canonical="Activity"}), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом является оркестрация: как эти :term[Вызовы]{canonical="Call"} управляются, выполняются и упорядочиваются.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, исследует протокол, который управляет этим выполнением, превращая абстрактные определения в конкретные, состоятельные действия.
