# 003: Агент/Действие

> [!DEFINITION] :term[Действие]
> Явная асинхронная функция, реализующая логику для :term[Инструмента]. Это механизм для выполнения действий, требующих вызовов внешних API, операций с базами данных или любой другой задачи, которая не может быть обработана в скрытом пространстве LLM.

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

Этот документ описывает **Протокол Действий**, который определяет, как :term[Инструменты] подкрепляются конкретным исполняемым кодом. Если :term[Инструмент] определяет интерфейс возможности, то :term[Действие] предоставляет её реализацию.

## Архитектура двойного реестра

Система агентов использует два взаимодополняющих реестра для разделения интерфейса возможности и её реализации:

- **:term[Реестр Инструментов]**: Хранит определения схем для :term[Инструментов].
- **:term[Реестр Действий]**: Хранит явные `async` функции (:term[Действия]), которые реализуют :term[Инструменты].

Это разделение является ключом к гибкости системы. Оно позволяет определять и использовать :term[Инструменты] в режиме только скрытого исполнения (где LLM генерирует вывод напрямую) и позволяет заменять различные реализации :term[Действия] без изменения интерфейса :term[Инструмента] (например, для разных сред, таких как разработка и продакшен).

## Регистрация Действия

:term[Действие] регистрируется под уникальным именем, которое используется для его привязки к :term[Инструменту].

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрация реализации Действия.
// По соглашению, Действие может быть привязано к Инструменту с тем же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Соответствующая схема Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Gets the current weather for a location.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы исполнения: Скрытое и Явное

Система поддерживает два принципиально разных режима исполнения :term[Вызова] :term[Инструмента]:

- **Скрытое исполнение**: Использует способности LLM к рассуждению. Агент «продумывает» задачу и выдаёт результат напрямую в том же вызове. Это режим по умолчанию, если для :term[Инструмента] не найдено ни одного :term[Действия].
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное исполнение**: Делегирует :term[Вызов] детерминированному коду. Для вычисления результата вызывается функция :term[Действия]. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, повторяемой логики.

## Стратегия разрешения Действий

Система использует стратегию нулевой конфигурации для определения режима исполнения при вызове :term[Инструмента]. Поле `_activity` в схеме :term[Инструмента] сигнализирует о намерении использовать явную реализацию. Это поле разрешается автоматически во время композиции схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если само определение :term[Инструмента] включает непустую строку `_activity`, это значение используется для поиска :term[Действия] в реестре.
2.  **Соглашение об одинаковых именах (рекомендуется)**: Если поле `_activity` в :term[Инструменте] отсутствует, система проверяет, было ли зарегистрировано :term[Действие] с **тем же именем**, что и :term[Инструмент]. Если найдено, поле `_activity` автоматически устанавливается на имя :term[Инструмента].
3.  **Резервный вариант — скрытое исполнение**: Если по вышеуказанным правилам подходящее :term[Действие] не найдено, поле `_activity` устанавливается в пустую строку, что означает, что :term[Вызов] должен быть исполнен скрыто.

Этот подход, основанный на соглашениях, упрощает разработку:

- **Для нулевой конфигурации регистрируйте ваше :term[Действие] под тем же именем, что и ваш :term[Инструмент].**
- :term[Инструменты] без соответствующего :term[Действия] автоматически и безопасно переключатся на скрытое исполнение.
- Явное поле `_activity` в схеме :term[Инструмента] всегда будет иметь приоритет, позволяя одному :term[Действию] реализовывать несколько интерфейсов :term[Инструментов].

## Почему разделение Действий важно

Без разделения схем :term[Инструментов] и реализаций :term[Действий] определение возможности было бы навсегда связано с её логикой исполнения. Чтобы переключиться с реализации на основе LLM на внешний API, пришлось бы находить и изменять каждого агента, использующего этот :term[Инструмент].

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы :term[Инструментов] стабильными и позволяя их базовым реализациям развиваться. Агенты взаимодействуют с последовательной схемой :term[Инструмента], независимо от того, исполняется ли она скрыто с помощью LLM или явно с помощью :term[Действия]. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключаться со скрытого на явное исполнение, не затрагивая код агента.
- **A/B-тестирование стратегий исполнения**: Вы можете сравнивать производительность рассуждений LLM с внешним API для одной и той же возможности.
- **Постепенное внедрение**: Вы можете развертывать новые реализации :term[Действий] для части агентов, в то время как другие продолжают использовать старую или резервный скрытый вариант.

## От определения к действию

Разделяя «что» (:term[Инструмент]) и «как» (:term[Действие]), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом является оркестрация: как эти :term[Вызовы] управляются, исполняются и упорядочиваются.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, исследует протокол, который управляет этим исполнением, превращая абстрактные определения в конкретные, сохраняющие состояние действия.