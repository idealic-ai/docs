# 003: Агент/Действие

> [!DEFINITION] [Действие](./000_glossary.md)
> Явная асинхронная функция, которая реализует логику для :term[Инструмента]{canonical="Tool"}. Это механизм для выполнения действий, требующих вызовов внешних API, операций с базами данных или любой задачи, которая не может быть обработана в скрытом пространстве LLM.

> Sidenote:
> - Требуется: :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}

**Протокол Действий** определяет, как :term[Инструменты]{canonical="Tool"} подкрепляются конкретным, исполняемым кодом. В то время как :term[Инструмент]{canonical="Tool"} определяет интерфейс возможности, :term[Действие]{canonical="Activity"} предоставляет его реализацию.

## Архитектура с двумя реестрами

Система агентов использует два взаимодополняющих реестра для разделения интерфейса возможности и её реализации:

- **:term[Реестр Инструментов]{canonical="Tool"}**: Хранит определения схем для :term[Инструментов]{canonical="Tool"}.
- **:term[Реестр Действий]{canonical="Activity"}**: Хранит явные кодовые функции `async` (:term[Действия]{canonical="Activity"}), которые реализуют :term[Инструменты]{canonical="Tool"}.

Это разделение — ключ к гибкости системы. Оно позволяет определять и использовать :term[Инструменты]{canonical="Tool"} в режиме только скрытого исполнения (где LLM генерирует вывод напрямую), а также заменять различные реализации :term[Действия]{canonical="Activity"} без изменения интерфейса :term[Инструмента]{canonical="Tool"} (например, для разных сред, таких как разработка и продакшн).

## Регистрация Действия

:term[Действие]{canonical="Activity"} регистрируется с уникальным именем, которое используется для его привязки к :term[Инструменту]{canonical="Tool"}. Обработчик — это асинхронная (`async`) функция, которая получает три аргумента:

- **`call`**: Конкретный объект :term[Вызова]{canonical="Call"}. Он содержит все параметры для инструмента, включая любые мета-свойства (с префиксом `_`), которые управляют выполнением.
- **`tool`**: Определение схемы выполняемого :term[Инструмента]{canonical="Tool"}. Это позволяет действию инспектировать свой собственный интерфейс, например, ожидаемую схему `_output`.
- **`context`**: Массив сообщений, выборочно импортированных из родительской среды. Это не полный контекст родителя, а ограниченное представление, контролируемое протоколом :term[Скоупов]{canonical="Scope"}, что делает контекстную информацию явной, опциональной функцией.

Возвращаемое значение `Activity` является гибким. Если оно возвращает объект `Message` (например, `Data Message`), :term[Цикл выполнения]{canonical="Execution Loop"} добавит его напрямую в контекст. Это даёт `Activity` полный контроль над своим выводом, позволяя конструировать точное сообщение, необходимое для рабочего процесса. Если возвращается любое другое значение (например, сырой объект или строка), цикл автоматически обернёт его в `Data Message`, используя `_outputPath` из исходного вызова для определения, куда записать результат.

::::columns
:::column{title="Реализация Действия"}

```typescript
// Регистрируем реализацию Действия.
// По соглашению, Действие может быть привязано к Инструменту с тем же именем.
// Типы автоматически выводятся из Инструмента.
Activity.register('weatherCheck', async (call, tool, context) => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

:::
:::column{title="Соответствующая схема Инструмента"}

```typescript
Tool.register('weatherCheck', {
  type: 'object',
  description: 'Получает текущую погоду для указанного места.',
  properties: {
    _tool: { type: 'string', const: 'weatherCheck' },
    location: { type: 'string' },
    _output: {
      type: 'object',
      properties: {
        temperature: { type: 'number' },
        conditions: { type: 'string' },
      },
      required: ['temperature', 'conditions'],
    },
  },
  required: ['location'],
});
```

:::
::::

## Режимы выполнения: Скрытый и Явный

Система поддерживает два принципиально разных режима выполнения для :term[Вызова]{canonical="Call"} :term[Инструмента]{canonical="Tool"}:

- **Скрытое исполнение**: Использует способности LLM к рассуждению. Агент «продумывает» задачу и выдаёт результат напрямую в том же вызове. Это режим по умолчанию, если для :term[Инструмента]{canonical="Tool"} не найдено соответствующее :term[Действие]{canonical="Activity"}.
  > Sidenote:
  > - :term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}
- **Явное исполнение**: Делегирует :term[Вызов]{canonical="Call"} детерминированному коду. Для вычисления результата вызывается функция :term[Действия]{canonical="Activity"}. Это необходимо для взаимодействия с внешним миром (например, API, базы данных) или для задач, требующих точной, воспроизводимой логики.

## Стратегия разрешения Действий

Система использует стратегию "нулевой конфигурации" для определения режима выполнения при вызове :term[Инструмента]{canonical="Tool"}. Поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} сигнализирует о намерении использовать явную реализацию. Это поле разрешается автоматически во время композиции схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если определение :term[Инструмента]{canonical="Tool"} само по себе содержит непустую строку `_activity`, это значение используется для поиска :term[Действия]{canonical="Activity"} в реестре.
2.  **Соглашение об одинаковых именах (рекомендуется)**: Если поле `_activity` отсутствует в :term[Инструменте]{canonical="Tool"}, система проверяет, было ли зарегистрировано :term[Действие]{canonical="Activity"} с **тем же именем**, что и :term[Инструмент]{canonical="Tool"}. Если найдено, поле `_activity` автоматически устанавливается в имя :term[Инструмента]{canonical="Tool"}.
3.  **Резервное скрытое исполнение**: Если по вышеуказанным правилам подходящее :term[Действие]{canonical="Activity"} не найдено, поле `_activity` устанавливается в пустую строку, сигнализируя, что :term[Вызов]{canonical="Call"} должен быть выполнен в скрытом режиме.

Этот подход, основанный на соглашениях, упрощает разработку:

- **Для "нулевой конфигурации" регистрируйте ваше :term[Действие]{canonical="Activity"} под тем же именем, что и ваш :term[Инструмент]{canonical="Tool"}.**
- :term[Инструменты]{canonical="Tool"} без соответствующего :term[Действия]{canonical="Activity"} автоматически и безопасно по умолчанию переключатся на скрытое исполнение.
- Явное поле `_activity` в схеме :term[Инструмента]{canonical="Tool"} всегда будет иметь приоритет, позволяя одному :term[Действию]{canonical="Activity"} реализовывать несколько интерфейсов :term[Инструментов]{canonical="Tool"}.

## Взаимодействие с другими системами

:term[Действие]{canonical="Activity"} не выполняется изолированно. Оно полагается на другие протоколы для получения своих параметров и контекстной информации структурированным и безопасным способом.

- **:term[Вызов]{canonical="Call"}:** Аргумент `call` предоставляет :term[Действию]{canonical="Activity"} полный объект вызова. Это не просто словарь параметров; это богатая структура, которая может включать мета-свойства, такие как `_outputPath` для указания, куда следует сохранить результат, или `_instance` для нацеливания на конкретный элемент в пакетной обработке. Это позволяет :term[Действию]{canonical="Activity"} участвовать в сложных, состоятельных рабочих процессах.

  > Sidenote:
  > - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
  > - :term[008: Агент/Вывод]{href="./008_agent_output.md"}
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **:term[Скоупы]{canonical="Scope"}:** Аргумент `context` заполняется через протокол :term[Скоупов]{canonical="Scope"}. Свойство `_scopes` в :term[Вызове]{canonical="Call"} действует как "белый список", указывая, какие сообщения из родительской среды (например, :term[Состояние]{canonical="State"} или :term[Ввод]{canonical="Input"}) должны быть переданы :term[Действию]{canonical="Activity"}. Это обеспечивает контролируемый и явный механизм для доступа :term[Действия]{canonical="Activity"} к необходимой информации, не подвергая его воздействию всего, потенциально зашумленного, родительского контекста.

  > Sidenote:
  > - :term[015: Агент/Скоупы]{href="./015_agent_scopes.md"}

- **Разрешение ветвящихся путей:** Способность `Activity` возвращать полный объект `Message` является ключом к проактивной обработке ошибок и другой сложной логике ветвления. `_outputPath` в `call` теперь служит контрактом или руководством. Когда `Activity` получает вызов с выражением ветвления, таким как `_outputPath: '†state.success || †state.error'`, его внутренняя логика может определить результат, а затем создать и вернуть правильное `Data Message`, чтобы записать результат по выбранному пути (например, сообщение, содержащее `{ data: { success: { ... } } }`). Это дает детерминированному коду полный контроль над управлением потоком плана.

## Почему важны отдельные Действия

Без разделения схем :term[Инструментов]{canonical="Tool"} и реализаций :term[Действий]{canonical="Activity"} определение возможности было бы навсегда связано с логикой её выполнения. Чтобы переключиться с реализации на основе LLM на внешний API, пришлось бы находить и изменять каждого агента, использующего этот :term[Инструмент]{canonical="Tool"}.

Архитектура с двумя реестрами решает эту проблему, сохраняя интерфейсы :term[Инструментов]{canonical="Tool"} стабильными и позволяя их базовым реализациям развиваться. Агенты взаимодействуют с последовательной схемой :term[Инструмента]{canonical="Tool"}, независимо от того, выполняется ли она в скрытом режиме LLM или явно с помощью :term[Действия]{canonical="Activity"}. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключиться со скрытого на явное исполнение, не затрагивая код агента.
- **A/B-тестирование стратегий выполнения**: Вы можете сравнивать производительность рассуждений LLM с внешним API для одной и той же возможности.
- **Постепенное развёртывание**: Вы можете развернуть новые реализации :term[Действий]{canonical="Activity"} для подмножества агентов, в то время как другие продолжат использовать старую или резервное скрытое исполнение.

## От определения к действию

Разделяя «что» (:term[Инструмент]{canonical="Tool"}) и «как» (:term[Действие]{canonical="Activity"}), система приобретает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом становится оркестрация: как этими :term[Вызовами]{canonical="Call"} управляют, как их выполняют и упорядочивают.

Следующий документ, :term[004: Агент/Вызов]{href="./004_agent_call.md"}, рассматривает протокол, который управляет этим выполнением, превращая абстрактные определения в конкретные, состоятельные действия.
