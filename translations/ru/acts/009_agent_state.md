# 009: Агент/Состояние

> [!DEFINITION] [Сообщение о Состоянии](./000_glossary.md)
> Постоянное сообщение `Data`, представляющее собой живую, развивающуюся память рабочего процесса. Оно действует как набор локальных переменных, позволяя выполнять многошаговые операции с сохранением состояния.

> Sidenote:
>
> - Требуется:
>   - [004: Агент/Вызов](./004_agent/call.md)
>   - [006: Агент/Данные](./006_agent/data.md)
> - Позволяет:
>   - [010: Агент/План](./010_agent/plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent/instancing.md)
>   - [012: Агент/Делегат](./012_agent/delegate.md)
>   - [013: Агент/Scopes](./013_agent/scopes.md)

Этот документ описывает **сообщение о Состоянии (State)**, специализированное сообщение `Data`, которое обеспечивает постоянную память для цикла выполнения агента. В то время как [Переменные](./008_agent_variables.md) предоставляют «провода» для соединения инструментов, объект `State` служит «черновиком», где результаты этих соединений сохраняются и поддерживаются на протяжении нескольких шагов.

Объект `State` выступает источником истины о текущем статусе запроса и является ключом к отказоустойчивости и возобновлению работы. Поскольку он захватывает полный контекст рабочего процесса в определенный момент времени, это позволяет приостанавливать и возобновлять процесс. Когда начинается новая итерация, `State` из предыдущего шага предоставляет LLM ясное понимание того, на чем остановился процесс, обеспечивая бесшовное продолжение работы в последующих операциях.

## Направление рабочего процесса с помощью Schema

Предоставление `schema` для объекта `State` — это необязательный, но мощный шаг. Схема документирует предполагаемый поток данных, определяя набор ожидаемых свойств. Это неявно определяет взаимодействия между `Tools` и намекает на общий процесс. Это создает сильную обратную связь для LLM: зная, какие свойства должен содержать `State`, он получает указание генерировать `Tool Calls` с соответствующими значениями `_outputPath`. Это улучшает результаты, гарантируя, что действия агента структурно корректны и соответствуют желаемому рабочему процессу.

> Sidenote: [008: Агент/Переменные](./008_agent_variables.md)

## Многошаговые инструменты

Основная функция сообщения `State` — позволить разным `Tools` обмениваться информацией в рамках одного непрерывного процесса. Оно обеспечивает операции с состоянием, предоставляя общий черновик, где `Tools` могут хранить свои результаты.

Это достигается с помощью простого механизма чтения/записи: один `Tool` может записать свой вывод в объект `State`, а другой `Tool` затем может прочитать эти данные в качестве своего ввода на последующем шаге. Это позволяет создавать цепочки инструментов, где вывод одной возможности напрямую влияет на ввод следующей, и все это без потери контекста между выполнениями.

## Планирование и Выполнение

Сочетание записи в состояние через `_outputPath` и чтения из него с помощью **Ссылок на Переменные** является основным механизмом, который позволяет отделить планирование от выполнения. Это позволяет агенту построить полный граф потока данных — цепочку `Tool Calls`, связанных ссылками, — *до* того, как будет запущен какой-либо инструмент.

Этот граф ссылок можно проверять, повторно использовать и даже симулировать, что делает его полностью совместимым со скрытым исполнением LLM. Гибкость этой системы заключается в возможности контролировать как входы, так и выходы на уровне схемы. Разработчик рабочего процесса может оставить **Ссылки на Переменные** (входы) и **`_outputPath`** (выходы) динамическими для решения LLM, или же предписать их для обеспечения жесткого и надежного потока данных.

> [!HEADSUP] Внимание
> Создание `Tool Calls`, связанных друг с другом через `State`, — это и есть акт планирования. Эта система предоставляет техническую основу для этого процесса: постоянный `State` действует как черновик, **Ссылки на Переменные** и `_outputPath` — как провода, а **Цикл** агента — как итеративный движок. Вместе эти компоненты позволяют агенту построить полный граф потока данных, что и является сутью **Плана**.
> 
> > Sidenote:
> > 
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [010: Агент/План](./010_agent_plan.md)

## Композиция

- **Call:** Система `Call` тесно связана со `State` через мета-свойство `_outputPath`. Это свойство превращает `Tool Call`, который в ином случае мог бы быть stateless (без состояния), чистой функцией, в операцию, изменяющую состояние. Указывая `_outputPath`, `Call` указывает движку записать свой результат в объект `State`, что делает его основным механизмом для записи агентом результатов своих действий. Это взаимодействие позволяет последовательности `Calls` строиться друг на друге, создавая цепочку причин и следствий, которая записывается в `State`.

  > Sidenote: [004: Агент/Вызов](./004_agent_call.md)

- **Data:** Сообщение `State` по сути является специализированным применением системы сообщений `Data`, используя сообщение `Data` с `kind: "state"`. Оно использует основные возможности сообщений `Data` для создания постоянной памяти для агента. Свойство `schema` используется для определения ожидаемой структуры этой памяти, предоставляя черновик, который направляет действия LLM. Кроме того, критически важны возможности слияния системы `Data`, позволяющие обновлять `State` инкрементально через серию патчей, при этом система преобразует их в единое, согласованное представление.

  > Sidenote: [006: Агент/Данные](./006_agent_data.md)

- **Scopes:** Система `Scopes` является основным механизмом для предоставления объекта `State` инструменту `Tool`, работающему в изолированном контексте, таком как **Делегат**. Когда `Call` делегируется, свойство `_scopes` может указывать, что `state` должен быть включен в «чистую комнату» делегата. Это позволяет инкапсулированным инструментам читать из состояния основного рабочего процесса и взаимодействовать с ним контролируемым и явным образом.

  > Sidenote: [013: Агент/Scopes](./013_agent_scopes.md)

- **Instancing:** Сообщение `State` полностью совместимо с системой `Instancing`. Когда запрос обрабатывает несколько `Instances`, каждый из них поддерживает свой собственный изолированный объект `State`, идентифицируемый уникальным ключом `_instance`. **Ссылки на Переменные** (например, `†state.currentUser.id`) автоматически и прозрачно направляются к правильному объекту `State`, соответствующему `Instance`, на который нацелен `Tool Call`. Это позволяет выполнять один общий `Plan` для многих различных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote: [011: Агент/Инстансинг](./011_agent_instancing.md)

- **Plan:** Хотя `State` позволяет создавать простые последовательности инструментов, его полная мощь раскрывается при использовании в качестве основы системы `Plan`. В `Plan` рабочий процесс представлен как направленный ациклический граф (DAG), где `Tool Calls` являются узлами. Объект `State` предоставляет связи — рёбра — между этими узлами. Он позволяет одному узлу записывать в переменную, а другим — читать из нее, обеспечивая сложные шаблоны, такие как логические ветвления (if-else) или параллельные разветвления.

  > Sidenote: [010: Агент/План](./010_agent_plan.md)

## От единого состояния к оркестрованным рабочим процессам

Сообщение `State` предоставляет механизм для управления памятью одного целостного рабочего процесса. С постоянным черновиком и переменными для соединения инструментов мы теперь можем проектировать и выполнять сложные, многошаговые рабочие процессы.

Следующий документ, **[010: Агент/План](./010_agent_plan.md)**, описывает систему для оркестрации этих рабочих процессов в виде графа `Tool Calls`.