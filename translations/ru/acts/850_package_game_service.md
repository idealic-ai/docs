# 850: Пакет/Игровой Сервис

> [!DEFINITION] [:term[Игровой Сервис]{canonical="Game Service"}](./000_glossary.md)
> Автономный, независящий от транспорта бэкенд-сервис, предназначенный для управления жизненным циклом пошаговых игр. Он действует как авторитетный сервер для :term[состояния игры]{canonical="game state"}, обрабатывая действия игроков, развивая логику через подключаемые :term[движки]{canonical="engine"} и сохраняя результаты.

> Sidenote:
> - Работает на:
>   - :term[851: Пакет/Покерный Движок]{href="./851_package_poker_engine.md"}
> - Совместим с:
>   - :term[852: Пакет/Покерный Интерфейс]{href="./852_package_poker_ui.md"}

:term[Игровой Сервис]{canonical="Game Service"} (`@idealic/game-service`) — это модульный Node.js бэкенд, созданный для валидации и хостинга пошаговых игр. Изначально он был ориентирован на покер, но его архитектура является универсальной и служит безопасной песочницей для разработки и тестирования игровой логики в отрыве от проприетарной платформы клиента.

## Основная архитектура

Сервис построен на модели **API без сохранения состояния (Stateless API)**. Он взаимодействует с внешним миром через единую конечную точку, которая получает клиентскую версию :term[состояния игры]{canonical="game state"}. Сервер объединяет её со своим авторитетным :term[состоянием]{canonical="state"}, проверяет и обрабатывает действия, а затем возвращает обновление.

### Подключаемые игровые :term[движки]{canonical="engine"}

Сервис строго отделён от игровой логики. Он функционирует как контейнер-хост для **подключаемых :term[движков]{canonical="engine"}**.

- **Паттерн Реестра:** Сервис использует реестр для загрузки различных игровых движков.
- **Единый интерфейс:** :term[Движки]{canonical="Engine"} должны предоставлять стандартный интерфейс (`State.advance()`, `State.join()` и т.д.).
- **Разделение ответственности:**
  - **Игровой :term[движок]{canonical="engine"} (например, покер):** Отвечает за правила, валидацию и переходы состояний.
  - **:term[Игровой Сервис]{canonical="Game Service"} (этот :term[пакет]{canonical="Package"}):** Управляет «метаигровой» логикой, такой как сетевое взаимодействие, сохранение данных, управление сессиями и таймаутами.

### «:term[Состояние]{canonical="State"}» как источник истины

Сервис полагается на концепцию **:term[объекта состояния]{canonical="State Object"}** от базового :term[движка]{canonical="engine"}. Это не просто снимок, а полная, сериализуемая запись истории (подобно шахматной нотации).

- **Обмен данными без сохранения состояния:** Клиенты и серверы обмениваются полным :term[объектом состояния]{canonical="State Object"}.
- **Детерминизм:** :term[Состояние]{canonical="State"} включает в себя случайное начальное число (random seed), что позволяет идеально восстановить историю игры для проверки и разрешения споров.
- **Перспектива игрока:** :term[Состояние]{canonical="State"} поддерживает «маскировку», при которой сервер генерирует персонализированное представление для каждого игрока (скрывая карманные карты противников) перед отправкой данных.

## Слой абстракции ввода-вывода (I/O)

Сервис не зависит от транспорта. Все внешние взаимодействия абстрагированы в выделенный слой ввода-вывода (`service.io.ts`), что позволяет интегрировать сервис в любую среду (Express, WebSockets, Serverless) путем замены заглушек.

- **Сохранение :term[состояния]{canonical="state"}:** `saveGame` и `loadGame` отвечают за хранение авторитетного :term[состояния]{canonical="state"}.
- **Управление сессиями:** `fetchPlayerStacks` и `savePlayerStacks` интегрируются с внешними системами кошельков.
- **Обмен данными в реальном времени:** `broadcastToPlayers` отвечает за отправку обновлений :term[состояния]{canonical="state"} клиентам (например, через WebSockets).
- **Фоновые процессы:** `fetchTimedOutGames` позволяет опрашивать сервис для контроля времени хода игроков.

## Концепция сервиса столов

Сервис реализует модель **сервиса столов**, где столы — это не статические записи в базе данных, а динамически определяемые **активные :term[состояния игры]{canonical="Game State"}**.

- **Динамическое выделение:** Столы создаются по требованию. Если игрок ищет игру (например, «Техасский Холдем, $1/$2») и за столами нет свободных мест, создается новое :term[состояние игры]{canonical="Game State"}.
- **Жизненный цикл:**
  1.  **Поиск:** Клиент запрашивает стол с определёнными параметрами. Система находит существующую игру или создаёт новую.
  2.  **Наблюдение:** Игрок получает :term[состояние игры]{canonical="Game State"}, чтобы наблюдать за ходом действия.
  3.  **Присоединение:** Игрок отправляет действие `join`, чтобы занять место.
  4.  **Игра:** Игровой цикл продолжается.
  5.  **Завершение:** Игроки удаляются по таймауту или из-за банкротства (недостаточно средств для следующей раздачи).

## Как это работает

Операционный цикл сервиса выглядит так:

1.  **Инициация:** Внешнее событие (действие игрока) поступает в сервис.
2.  **Загрузка:** Авторитетное :term[состояние]{canonical="state"} загружается из хранилища.
3.  **Слияние:** Входящее клиентское :term[состояние]{canonical="state"} объединяется с :term[состоянием]{canonical="state"} сервера.
4.  **Продвижение:** Сервис вызывает `advance()`, который циклически выполняет логику игрового :term[движка]{canonical="engine"} до тех пор, пока не потребуется ввод от игрока.
5.  **Завершение:** Если раунд заканчивается, сервис завершает раздачу, распределяет банки и начинает следующий раунд.
6.  **Сохранение и рассылка:** Обновлённое :term[состояние]{canonical="state"} сохраняется и отправляется всем игрокам.
