# 008: Агент/Переменные

> [!DEFINITION] [Ссылка на переменную](./000_glossary.md)
> Строка со специальным синтаксисом (`†<kind>.<path>`), используемая в параметрах :term[Вызова инструмента]{canonical="Call"} для динамической ссылки на значение из контекста агента.

:term[Переменные] основаны на системе [Данных](./006_agent_data.md), чтобы обеспечить динамические потоки данных. Они делают структурированную информацию интерактивной с помощью двух основных функций:

- **Чтение:** Ссылка на значение, существующее в контексте агента (например, сообщение :term[Ввода] или :term[Состояния]), без необходимости прямого копирования данных в параметры :term[Вызова инструмента]{canonical="Call"}.
- **Запись:** Сохранение результата в объекте :term[Данных] (чаще всего в :term[Состоянии]), чтобы его значение было доступно на последующих шагах цикла агента.

## Чтение из контекста

Параметр в :term[Вызове инструмента]{canonical="Call"} может содержать **ссылку на переменную** — специальную строку, которая указывает на значение в другом месте контекста, — вместо самого значения. Это предотвращает неэффективный и подверженный ошибкам процесс, когда LLM копирует большие объекты данных из своего контекста в параметры :term[Вызова инструмента]{canonical="Call"}. Использование ссылки быстрее, дешевле и надёжнее, поскольку исключает риск изменения данных LLM при их воспроизведении.

Ссылка представляет собой простой строковый синтаксис с префиксом в виде кинжала (`†`). Синтаксис: `†<kind>.<path>`, где `<kind>` — это тип сообщения :term[Данных] (например, `state`, `input`), а `<path>` — это путь к желаемому значению в точечной нотации.

> Sidenote:
> - Википедия: [Кинжал (знак)](<https://en.wikipedia.org/wiki/Dagger_(mark)>)

::::columns
:::column{title="Параметры инструмента с использованием переменных"}

```json
{
  "_tool": "greetUser",
  "userName": "†input.userName"
}
```

:::
:::column{title="Эквивалентный код на Typescript"}

```typescript
greetUser({
  userName: input.userName,
});
```

:::
::::

## Запись в контекст

Чтобы сохранить результат работы инструмента, :term[Вызов] может включать мета-свойство `_outputPath`. Эта строка — **путь вывода** — указывает движку исполнения, куда поместить результат, делая его доступным для последующих шагов или будущих итераций цикла. Обычно используется путь, указывающий на объект :term[Состояния] (например, `†state.user.summary`).

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

`_outputPath` можно определить двумя способами, что позволяет гибко контролировать поведение инструмента.

::::columns{.examples}
:::column{title="Динамический путь (определяется LLM)"}

В этом режиме LLM может самостоятельно решать, куда сохранять результат во время выполнения, что делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки пользователя.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный путь (жёстко заданный)"}

Этот подход обеспечивает строгое, предсказуемое поведение, гарантируя, что инструмент всегда будет записывать свой вывод в определённое, жёстко заданное место.

```json
// Схема инструмента закрепляет за _outputPath конкретное значение
{
  "_outputPath": {
    "type": "string",
    "const": "†state.user.summary"
  }
}
```

:::
::::

## Декларативная связь

Сила :term[переменных] заключается в их способности определять операции над данными, которые ещё не доступны. Например, :term[Вызов инструмента]{canonical="Call"} можно определить для работы со значением из сообщения :term[Ввода], даже если этот конкретный ввод ещё не был предоставлен. Это позволяет создавать многоразовые, параметризованные рабочие процессы.

Эта концепция расширяется до связывания :term[Вызовов инструментов]{canonical="Call"} в цепочки. :term[Вызов инструмента]{canonical="Call"} может быть создан со :term[ссылкой на переменную], которая указывает на `_outputPath` *предыдущего* вызова в той же последовательности. Это создаёт многошаговый поток данных, где вывод одного инструмента становится вводом для следующего.

Такое декларативное связывание становится особенно мощным, когда `пути вывода` используются для определения возможных исходов.

::::columns
:::column{title="Альтернативные пути (ветвление)"}
Использование `||` в `_outputPath` позволяет инструменту объявлять возможные исходы. Внутренняя логика инструмента затем определяет, по какому пути записывать результат.

```json
// Если `verifyUser` выполняется успешно, результат записывается в `state.user.verified`;
// в противном случае — в `state.user.failed`.
{
  "_tool": "verifyUser",
  "userId": "perfect-stranger",
  "_outputPath": "†state.user.verified || †state.user.failed"
}
```

:::
:::column{title="Параллельные пути (разветвление)"}
Использование `&&` в `_outputPath` указывает движку выполнить разветвление, записывая один и тот же вывод по нескольким путям одновременно.

```json
// Одновременная запись в объекты `user` и `audit` в состоянии.
{
  "_tool": "generateSummary",
  "text": "Long body of text here...",
  "_outputPath": "†state.user.summary && †state.audit.summary"
}
```

:::
::::

Эта способность определять полную последовательность операций — включая сложное ветвление и разветвление — над данными, которых ещё не существует, и есть то, что делает возможным декларативное планирование. Она позволяет LLM генерировать полный граф потока данных (:term[План]), который можно просмотреть, утвердить и повторно использовать до выполнения любого кода. Эта мощная возможность планирования возникает благодаря тому, как :term[переменные] сочетаются с другими ключевыми концепциями:

> Sidenote:
> - [010: Агент/План](./010_agent_plan.md)

## Композиция

- **:term[Данные]:** Переменные — это механизм, который делает сообщения :term[Данных] интерактивными. :term[Ссылки на переменные] читают из сообщений :term[Данных] (таких как :term[Ввод] или :term[Состояние]), а `пути вывода` записывают обратно в них, создавая динамический цикл, в котором данные можно получать и изменять.

  > Sidenote:
  > - [006: Агент/Данные](./006_agent_data.md)

- **:term[Ввод]:** :term[Ссылки на переменные] могут указывать на сообщения :term[Ввода], что позволяет параметризовать рабочий процесс. Это необходимо для создания воспроизводимых планов, в которых общая структура определена, а конкретные данные для работы предоставляются во время выполнения.

  > Sidenote:
  > - [007: Агент/Ввод](./007_agent_input.md)

- **:term[Состояние]:** Объект :term[Состояния] является основной черновой областью для переменных в многошаговых рабочих процессах. Это наиболее частая цель для `путей вывода`, поскольку он сохраняется между шагами цикла выполнения агента, позволяя одному шагу оставлять результат, который может прочитать следующий.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md)

- **:term[План]:** Переменные — это фундаментальная технология, лежащая в основе системы :term[Планов]. Сообщение :term[Плана] содержит граф :term[Вызовов инструментов]{canonical="Call"}, где связи (рёбра) формируются :term[ссылками на переменные], указывающими на `пути вывода`. Это позволяет агенту определять полный, исполняемый рабочий процесс как единую декларативную структуру данных.

  > Sidenote:
  > - [010: Агент/План](./010_agent_plan.md)

## От эфемерных связей к постоянной памяти

:term[Переменные] предоставляют механизм для связывания данных с инструментами в рамках одного атомарного запроса. Однако для создания сложных агентов, выполняющих задачи в несколько шагов, требуется более постоянная форма памяти — «черновик», где результаты могут храниться и быть доступны в нескольких независимых запросах в цикле выполнения.

Следующий документ, [009: Агент/Состояние](./009_agent_state.md), описывает протокол для управления этим постоянным состоянием.
