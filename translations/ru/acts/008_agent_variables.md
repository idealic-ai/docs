# 008: Агент/Переменные

> [!DEFINITION] [Ссылка на переменную](./000_glossary.md)
> Строка со специальным синтаксисом (`†<kind>.<path>`), используемая в параметрах `Tool Call` для динамической ссылки на значение из контекста агента.

**Переменные** развивают систему [Данных](./006_agent_data.md) для создания динамических потоков данных. Они делают структурированную информацию интерактивной с помощью двух основных функций:

- **Чтение:** Ссылка на значение, существующее в контексте агента (например, сообщение `Input` или `State`), без необходимости прямого копирования данных в параметры `Tool Call`.
- **Запись:** Сохранение результата в объект `Data` (чаще всего `State`), чтобы его значение было доступно на последующих шагах цикла агента.

## Чтение из контекста

Параметр в `Tool Call` может содержать **ссылку на переменную** — специальную строку, указывающую на значение в другом месте контекста, — вместо самого значения. Это позволяет избежать неэффективного и подверженного ошибкам процесса, когда LLM копирует большие объемы данных из своего контекста в параметры `Tool Call`. Использование ссылки быстрее, дешевле и надежнее, так как исключает риск изменения данных LLM при их воспроизведении.

Ссылка представляет собой простой строковый синтаксис с префиксом в виде кинжала (`†`). Синтаксис выглядит так: `†<kind>.<path>`, где `<kind>` — это тип сообщения `Data` (например, `state`, `input`), а `<path>` — это путь к нужному значению в точечной нотации.

> Sidenote: Википедия: [Кинжал (знак)](<https://en.wikipedia.org/wiki/Dagger_(mark)>)

::::columns
:::column{title="Параметры инструмента, использующие переменные"}

```json
{
  "_tool": "greetUser",
  "userName": "†input.userName"
}
```

:::
:::column{title="Эквивалентный код на Typescript"}

```typescript
greetUser({
  userName: input.userName,
});
```

:::
::::

## Запись в контекст

Чтобы сохранить результат работы инструмента, `Call` может включать мета-свойство `_outputPath`. Эта строка — **выходной путь** — указывает движку исполнения, куда поместить результат, делая его доступным для последующих шагов или будущих итераций цикла. Обычно используется путь, указывающий на объект `State` (например, `†state.user.summary`).

> Sidenote: [004: Агент/Вызов](./004_agent_call.md)

Путь `_outputPath` можно определить двумя способами:

- **Динамический (определяется LLM):** Схема `Tool` для `_outputPath` может быть гибкой (например, `{ "type": "string" }`), предоставляя LLM свободу для генерации пути.
- **Предписанный (жестко закодированный):** В качестве альтернативы схема может использовать ограничивающие ключевые слова JSON Schema, такие как `const` или `enum`, чтобы закрепить поведение инструмента за определенным путем или небольшим набором опций.

## Декларативное соединение

Сила `Переменных` заключается в их способности определять операции над данными, которые еще недоступны. Например, можно определить `Tool Call` для работы со значением из сообщения `Input`, даже если это конкретное входное сообщение еще не было предоставлено. Это позволяет создавать многоразовые, параметризованные рабочие процессы.

Эта концепция распространяется и на связывание `Tool Call` в цепочки. `Tool Call` можно создать со **ссылкой на переменную**, которая указывает на `_outputPath` _предыдущего_ вызова в той же последовательности. Это создает многошаговый поток данных, где выходные данные одного инструмента становятся входными для следующего.

Это декларативное соединение становится особенно мощным, когда `Выходные Пути` используются для определения потенциальных исходов.

- **Альтернативные пути (ветвление):** Использование `||` для разделения путей в `_outputPath` (например, `"†state.success || †state.failure"`) позволяет `Tool Call` объявить возможные исходы до его выполнения. Когда инструмент выполняется, его внутренняя логика определяет, по какому пути записать результат, эффективно инкапсулируя решение об исходе внутри инструмента, выполняющего работу.
- **Одновременные пути (разветвление):** Использование `&&` (например, `"†state.user.profile.summary && †state.audit.log.summary"`) указывает движку выполнить разветвление, записывая один и тот же результат по нескольким путям одновременно.

Эта способность определять полную последовательность операций, включая сложное ветвление и разветвление, над еще не существующими данными, и есть то, что делает возможным декларативное планирование. Это позволяет LLM генерировать полный граф потоков данных (`План`), который можно просмотреть, утвердить и повторно использовать до выполнения любого кода. Эта мощная возможность планирования возникает благодаря тому, как `Переменные` сочетаются с другими основными концепциями:

> Sidenote: [010: Агент/План](./010_agent_plan.md)

## Композиция

- **Данные:** Переменные — это механизм, который делает сообщения `Data` интерактивными. `Ссылки на переменные` считывают данные из сообщений `Data` (таких как `Input` или `State`), а `Выходные Пути` записывают данные обратно, создавая динамический цикл, в котором данные можно получать и изменять.

  > Sidenote: [006: Агент/Данные](./006_agent_data.md)

- **Ввод:** `Ссылки на переменные` могут указывать на сообщения `Input`, что позволяет параметризовать рабочий процесс. Это необходимо для создания воспроизводимых планов, где общая структура определена, а конкретные данные для работы предоставляются во время выполнения.

  > Sidenote: [007: Агент/Ввод](./007_agent_input.md)

- **Состояние:** Объект `State` является основной «черновой» областью для переменных в многошаговых рабочих процессах. Это наиболее частая цель для `Выходных Путей`, поскольку он сохраняется между шагами цикла выполнения агента, позволяя одному шагу оставить результат, который сможет прочитать следующий.

  > Sidenote: [009: Агент/Состояние](./009_agent_state.md)

- **План:** Переменные — это фундаментальная технология, лежащая в основе системы `Планов`. `План` представляет собой граф `Tool Calls`, где соединения (ребра) формируются `Ссылками на переменные`, указывающими на `Выходные Пути`. Это позволяет агенту определять полный, исполняемый рабочий процесс в виде единой, декларативной структуры данных.

  > Sidenote: [010: Агент/План](./010_agent_plan.md)

## От временных соединений к постоянной памяти

Переменные предоставляют механизм для связывания данных с инструментами в рамках одного атомарного запроса. Однако для создания сложных агентов, выполняющих задачи в несколько этапов, требуется более постоянная форма памяти — «черновик», где результаты могут храниться и быть доступными в течение нескольких независимых запросов в цикле выполнения.

Следующий документ, **[009: Агент/Состояние](./009_agent_state.md)**, описывает протокол для этого постоянного управления состоянием.