# 008: Агент/Вывод

> [!DEFINITION] [Путь Вывода](./000_glossary.md)
> Мета-свойство `_outputPath` в :term[Вызове]{canonical="Call"}, которое указывает, где сохранять результат инструмента. Это строка, которая сообщает механизму выполнения, куда поместить результат, делая его доступным для последующих шагов.

> Sidenote:
> - Требуется:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

Система агентов имеет две формы вывода: промежуточные результаты :term[Вызовов Инструментов]{canonical="Tool Call"}, записываемые в контекст, и :term[Итоговый Вывод]{canonical="Final Output"} всего итеративного процесса.

## Запись в контекст с помощью :term[Пути Вывода]{canonical="Output Path"}

В то время как любое :term[Сообщение с Данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком для рабочего процесса, мета-свойство :term[Путь Вывода]{canonical="Output Path"} в :term[Вызове]{canonical="Call"} является основным механизмом для записи в него. Когда выполняется :term[Вызов Инструмента]{canonical="Tool Call"} с этим свойством, система добавляет его результат в контекст как новое сообщение.

> Sidenote:
> В то время как целью может быть любое :term[Сообщение с Данными]{canonical="Data Message"}, наиболее частым случаем является запись в :term[Сообщение о Состоянии]{canonical="State Message" href="./009_agent_state.md"} для сохранения информации на протяжении нескольких шагов процесса.

Это новое сообщение является стандартным :term[Сообщением с Данными]{canonical="Data Message"}, но оно включает два дополнительных элемента метаданных, скрытых от LLM:

- **`_call`**: Исходный :term[Вызов Инструмента]{canonical="Tool Call"}, который сгенерировал этот вывод.
- **`_date`**: ISO-отметка времени, когда был записан вывод.

Это обеспечивает полный, проверяемый след того, как изменялся контекст, что бесценно для отладки и отслеживания логики агента.

### Определение Пути Вывода

:term[Путь Вывода]{canonical="Output Path"} можно определить двумя способами, что позволяет гибко контролировать поведение инструмента.

::::columns{.examples}
:::column{title="Динамический Путь (определяется LLM)"}

В этом режиме LLM может свободно решать, где сохранить результат во время выполнения, что делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный Путь (жестко заданный)"}

Этот подход обеспечивает строгое, предсказуемое поведение, гарантируя, что инструмент всегда будет записывать свой вывод в определенное, жестко заданное место.

```json
// Схема инструмента фиксирует _outputPath на конкретном значении
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Разрешение по принципу "Последняя запись побеждает"

Важно отметить, что эти выходные сообщения **добавляются**, а не объединяются. Такое проектное решение упрощает систему и соответствует естественному ходу процесса, где новая информация заменяет старую.

Когда необходимо разрешить :term[Ссылку на Переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, движок ищет по сообщениям контекста в **обратном хронологическом порядке**. Он проверяет каждое сообщение от нового к старому, и первое, которое содержит запрошенный путь (`user.name`), предоставляет значение. Эта стратегия «последняя запись побеждает» гарантирует, что всегда используется самое последнее значение, без сложной логики слияния.

:::::details{title="Пример: Добавление и разрешение"}

**1. Исходное состояние**

Контекст начинается с исходного сообщения `data`.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "inactive",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Движок добавляет новое сообщение с выводом, которое содержит метаданные о вызове, его сгенерировавшем.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  },
  // Добавленное сообщение с выводом из вызова
  {
    "type": "data",
    "data": { "user": { "status": "inactive" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "inactive",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Разрешение переменных**

- Для разрешения `†data.user.status` движок сначала проверяет последнее сообщение. Он находит `user.status` и возвращает `"inactive"`.
- Для разрешения `†data.user.name` движок проверяет последнее сообщение, не находит `user.name`, затем проверяет предыдущее сообщение. Он находит его там и возвращает `"Alex"`

:::::

Сила сочетания :term[Ссылок на Переменные]{canonical="Variable Reference"} с :term[Путями Вывода]{canonical="Output Path"} заключается в их способности определять операции над данными, которые еще нe доступны. Например, :term[Вызов Инструмента]{canonical="Call"} может быть определен для работы со значением из :term[Входного]{canonical="Input"} сообщения, даже если этот конкретный ввод еще не предоставлен. Это позволяет создавать многоразовые, параметризованные рабочие процессы.

Эта концепция распространяется и на связывание :term[Вызовов Инструментов]{canonical="Call"} в цепочку. :term[Вызов Инструмента]{canonical="Call"} может быть создан с :term[Ссылкой на Переменную]{canonical="Variable Reference"}, которая указывает на :term[Путь Вывода]{canonical="Output Path"} *предыдущего* вызова в той же последовательности. Это создает многоэтапный поток данных, где вывод одного инструмента становится вводом для следующего.

## Взаимодействие с другими системами

- **:term[Сообщение с Данными]{canonical="Data Message"}:** `_outputPath` — это основной механизм для создания и обновления :term[Сообщений с Данными]{canonical="Data Message"} в рамках рабочего процесса. Он преобразует :term[Вызов Инструмента]{canonical="Tool Call"} без состояния в операцию с состоянием, сохраняя ее результат в контексте и делая его доступным для последующих шагов.

  > Sidenote:
  > - :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщение о Состоянии]{canonical="State Message"}:** Хотя целью может быть любое :term[Сообщение с Данными]{canonical="Data Message"}, наиболее частым случаем является запись в :term[Сообщение о Состоянии]{canonical="State Message"}. Это делает объект :term[Состояния]{canonical="State"} «черновиком» для рабочего процесса, позволяя различным инструментам обмениваться информацией и основываться на результатах друг друга в течение нескольких тактов :term[Цикла Выполнения]{canonical="Execution Loop"}.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылка на Переменную]{canonical="Variable Reference"}:** :term[Путь Вывода]{canonical="Output Path"} является прямым аналогом :term[Ссылке на Переменную]{canonical="Variable Reference"}. :term[Путь Вывода]{canonical="Output Path"} записывает данные в контекст, а :term[Ссылка на Переменную]{canonical="Variable Reference"} их считывает. Вместе они образуют полную, декларативную схему потока данных, соединяя вывод одного инструмента с вводом другого.

  > Sidenote:
  > - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** Выражения вводят логику непосредственно в проводку потока данных. Используя `||` и `&&` в :term[Пути Вывода]{canonical="Output Path"}, :term[Вызов Инструмента]{canonical="Tool Call"} может объявлять условные результаты или разветвлять свой результат на несколько направлений. Это уводит систему от жестких, закодированных конвейеров данных к гибкой структуре, которая адаптируется к условиям времени выполнения.

  > Sidenote:
  > - :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[Плана]{canonical="Plan"}, :term[Пути Вывода]{canonical="Output Path"} действуют как «провода», которые соединяют различные :term[Вызовы Инструментов]{canonical="Tool Call"} («узлы») в полный граф потока данных. Это позволяет агенту определять и выполнять целую многошаговую стратегию как единый, декларативный объект.

  > Sidenote:
  > - :term[012: Агент/План]{href="./012_agent_plan.md"}

- **:term[Экземплирование]{canonical="Instancing"}:** Когда :term[Вызов Инструмента]{canonical="Tool Call"} включает свойство `_instance`, любой указанный им `_outputPath` автоматически привязывается к контексту данных этого конкретного экземпляра. Это обеспечивает изоляцию данных при параллельной обработке, гарантируя, что вывод инструмента, работающего с одним экземпляром, не будет мешать состоянию другого.

  > Sidenote:
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

## От эфемерных выводов к постоянному состоянию

Механизм :term[Пути Вывода]{canonical="Output Path"} предоставляет надежный способ управления потоком данных между отдельными :term[Вызовами Инструментов]{canonical="Tool Call"} и может быть нацелен на любое :term[Сообщение с Данными]{canonical="Data Message"}. Однако для создания сложных многошаговых агентов, способных рассуждать и адаптироваться со временем, требуется специализированная форма памяти — тип сообщения, специально разработанный для сохранения информации между несколькими независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает протокол для этой постоянной памяти.
