# 008: Агент/Вывод

> [!DEFINITION] [Выходной Путь](./000_glossary.md)
> Мета-свойство `_outputPath` у :term[Вызова]{canonical="Call"}, которое указывает, куда сохранить результат работы инструмента. Это строка, которая сообщает движку исполнения, куда поместить результат, делая его доступным для последующих шагов.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md", canonical="004: Agent/Call"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md", canonical="007: Agent/Variables"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md", canonical="010: Agent/Loop"}

Система агентов имеет две формы вывода: промежуточные результаты :term[Вызовов Инструментов]{canonical="Tool Call"}, записываемые в контекст, и :term[Финальный Вывод]{canonical="Final Output"} всего итеративного процесса.

## Запись в контекст с помощью :term[Выходного Пути]{canonical="Output Path"}

Хотя любое :term[Сообщение с Данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком для рабочего процесса, мета-свойство :term[Выходной Путь]{canonical="Output Path"} у :term[Вызова]{canonical="Call"} является основным механизмом для записи в него. Когда :term[Вызов Инструмента]{canonical="Tool Call"} с этим свойством выполняется, система добавляет его результат в контекст как новое сообщение.

> Sidenote:
> Хотя целью может быть любое :term[Сообщение с Данными]{canonical="Data Message"}, самый распространенный случай — это запись в :term[Сообщение о Состоянии]{canonical="State Message" href="./009_agent_state.md"} для сохранения информации на протяжении нескольких шагов процесса.

Это новое сообщение является стандартным :term[Сообщением с Данными]{canonical="Data Message"}, но оно включает два дополнительных элемента метаданных, которые скрыты от LLM:

- **`_call`**: Исходный :term[Вызов Инструмента]{canonical="Tool Call"}, который сгенерировал этот вывод.
- **`_date`**: ISO-отметка времени, когда был записан вывод.

Это обеспечивает полный, проверяемый след того, как изменялся контекст, что неоценимо для отладки и отслеживания логики агента.

### Определение Выходного Пути

:term[Выходной Путь]{canonical="Output Path"} можно определить двумя способами, что позволяет варьировать степень контроля над поведением инструмента.

::::columns{.examples}
:::column{title="Динамический Путь (определяется LLM)"}

В этом режиме LLM может свободно решать, куда сохранять результат во время выполнения, что делает инструмент очень гибким.

```json
// Схема инструмента позволяет использовать любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки о пользователе.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный Путь (жестко закодирован)"}

Этот подход обеспечивает строгое, предсказуемое поведение, гарантируя, что инструмент всегда будет записывать свой вывод в определенное, жестко закодированное место.

```json
// Схема инструмента фиксирует _outputPath на конкретном значении
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Разрешение по принципу «последняя запись побеждает»

Важно отметить, что эти выходные сообщения **добавляются**, а не объединяются. Это проектное решение упрощает систему и соответствует естественному ходу процесса, где новая информация заменяет старую.

Когда необходимо разрешить :term[Ссылку на Переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, движок ищет в сообщениях контекста в **обратном хронологическом порядке**. Он проверяет каждое сообщение от нового к старому, и первое, которое содержит запрошенный путь (`user.name`), предоставляет значение. Эта стратегия «последняя запись побеждает» гарантирует, что всегда используется самое свежее значение, без сложной логики объединения.

:::::details{title="Пример: Добавление и Разрешение"}

**1. Начальное Состояние**

Контекст начинается с исходного сообщения `data`.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  }
]
```

**2. Выполнение Вызова Инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "inactive",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Движок добавляет новое сообщение, содержащее вывод, которое включает метаданные о вызове, его сгенерировавшем.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  },
  // Добавленное выходное сообщение от вызова
  {
    "type": "data",
    "data": { "user": { "status": "inactive" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "inactive",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Разрешение Переменных**

- Чтобы разрешить `†data.user.status`, движок сначала проверяет последнее сообщение. Он находит `user.status` и возвращает `"inactive"`.
- Чтобы разрешить `†data.user.name`, движок проверяет последнее сообщение, не находит `user.name`, затем проверяет предыдущее. Он находит его там и возвращает `"Alex"`.

:::::

### Декларативный Поток Данных

Сила сочетания :term[Ссылок на Переменные]{canonical="Variable Reference"} с :term[Выходными Путями]{canonical="Output Path"} заключается в их способности определять операции над данными, которые еще недоступны. Например, :term[Вызов Инструмента]{canonical="Call"} может быть определен для работы со значением из сообщения :term[Ввода]{canonical="Input"}, даже если этот конкретный ввод еще не был предоставлен. Это позволяет создавать многоразовые, параметризованные рабочие процессы.

Эта концепция распространяется и на объединение :term[Вызовов Инструментов]{canonical="Call"} в цепочки. :term[Вызов Инструмента]{canonical="Call"} может быть создан с :term[Ссылкой на Переменную]{canonical="Variable Reference"}, указывающей на :term[Выходной Путь]{canonical="Output Path"} _предыдущего_ вызова в той же последовательности. Это создает многошаговый поток данных, где вывод одного инструмента становится вводом для следующего.

Такая декларативная «проводка» становится особенно мощной, когда :term[Выходные Пути]{canonical="Output Path"} используются для определения потенциальных исходов.

::::columns
:::column{title="Альтернативные Пути (Ветвление)"}
Использование `||` в :term[Выходном Пути]{canonical="Output Path"} позволяет инструменту объявлять возможные исходы. Внутренняя логика инструмента затем определяет, по какому пути записать результат.

```json
// Если `verifyUser` завершается успешно, результат записывается в `data.user.verified`;
// в противном случае — в `data.user.failed`.
{
  "_tool": "verifyUser",
  "userId": "perfect-stranger",
  "_outputPath": "†data.user.verified || †data.user.failed"
}
```

:::
:::column{title="Параллельные Пути (Разветвление)"}
Использование `&&` в :term[Выходном Пути]{canonical="Output Path"} указывает движку выполнить разветвление, записывая один и тот же вывод по нескольким путям одновременно.

```json
// Одновременная запись в объекты `user` и `audit` в состоянии.
{
  "_tool": "generateSummary",
  "text": "Long body of text here...",
  "_outputPath": "†data.user.summary && †data.audit.summary"
}
```

:::
::::

## От временных выводов к постоянному состоянию

Механизм :term[Выходного Пути]{canonical="Output Path"} предоставляет надежный способ управления потоком данных между отдельными :term[Вызовами Инструментов]{canonical="Tool Call"} и может нацеливаться на любое :term[Сообщение с Данными]{canonical="Data Message"}. Однако для создания сложных, многошаговых агентов, способных рассуждать и адаптироваться со временем, требуется специализированная форма памяти — тип сообщения, специально разработанный для сохранения информации между несколькими независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md", canonical="009: Agent/State"}, описывает протокол для этой постоянной памяти.
