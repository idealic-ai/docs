# 008: Агент/Вывод

> [!DEFINITION] [Путь Вывода](./000_glossary.md)
> Мета-свойство `_outputPath` в :term[Вызове]{canonical="Call"}, которое указывает, где сохранять результат работы инструмента. Это строка, которая сообщает движку исполнения, куда поместить результат, делая его доступным для последующих шагов.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>   - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}
> - Открывает возможности для:
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

Система агентов поддерживает две формы вывода: промежуточные результаты :term[Вызовов Инструментов]{canonical="Tool Call"}, записываемые в контекст, и :term[Финальный Вывод]{canonical="Final Output"} всего итеративного процесса.

## Запись в контекст с помощью :term[Пути Вывода]{canonical="Output Path"}

Хотя любое :term[Сообщение с Данными]{canonical="Data Message" href="./005_agent_data.md"} может служить черновиком для рабочего процесса, мета-свойство :term[Путь Вывода]{canonical="Output Path"} в :term[Вызове]{canonical="Call"} является основным механизмом для записи в него. Когда выполняется :term[Вызов Инструмента]{canonical="Tool Call"} с этим свойством, система добавляет его результат в контекст как новое сообщение.

> Sidenote:
> Хотя целью может быть любое :term[Сообщение с Данными]{canonical="Data Message"}, чаще всего запись происходит в :term[Сообщение о Состоянии]{canonical="State Message" href="./009_agent_state.md"} для сохранения информации между несколькими шагами процесса.

Это новое сообщение является стандартным :term[Сообщением с Данными]{canonical="Data Message"}, но оно включает в себя два дополнительных элемента метаданных, которые скрыты от LLM:

- **`_call`**: Исходный :term[Вызов Инструмента]{canonical="Tool Call"}, который сгенерировал этот вывод.
- **`_date`**: Временная метка в формате ISO, указывающая, когда был записан вывод.
- **`_outputMethod`**: Метод, указанный в исходном вызове, который определяет, как эти данные должны быть объединены с другими данными.

Это обеспечивает полный, отслеживаемый след изменений контекста, что бесценно для отладки и прослеживания логики агента.

### Определение Пути Вывода

:term[Путь Вывода]{canonical="Output Path"} можно определить двумя способами, что позволяет гибко управлять поведением инструмента.

::::columns{.examples}
:::column{title="Динамический путь (определяется LLM)"}

В этом режиме LLM может свободно решать, где сохранить результат во время выполнения, что делает инструмент очень гибким.

```json
// Схема инструмента разрешает любую строку для _outputPath
{
  "_outputPath": {
    "type": "string",
    "description": "Путь для сохранения сводки по пользователю.",
    "pattern": "^†"
  }
}
```

:::
:::column{title="Предписанный путь (жестко заданный)"}

Этот подход обеспечивает строгое, предсказуемое поведение, гарантируя, что инструмент всегда будет записывать свой вывод в определенное, жестко заданное место.

```json
// Схема инструмента закрепляет _outputPath за конкретным значением
{
  "_outputPath": {
    "type": "string",
    "const": "†data.user.summary"
  }
}
```

:::
::::

### Динамическое разрешение переменных

Важно отметить, что эти выходные сообщения **добавляются**, а не объединяются во время записи. Такая архитектура позволяет динамически конструировать конечное состояние любой переменной во время чтения на основе `_outputMethod`, хранящегося в каждом сообщении.

Когда необходимо разрешить :term[Ссылку на Переменную]{canonical="Variable Reference" href="./007_agent_variables.md"}, например `†data.user.name`, движок ищет по сообщениям контекста в **обратном хронологическом порядке** (от новых к старым).

- Если обработчик находит сообщение для целевого пути с `_outputMethod` равным **`set`** (или без метода, так как `set` является значением по умолчанию), он немедленно останавливается. Значение этого сообщения является конечным, и все более старые сообщения для этого пути игнорируются. Это поведение называется «побеждает последняя запись».
- Если обработчик находит сообщения с методами, такими как **`merge`**, **`push`** или **`concat`**, он продолжает поиск назад, собирая все такие сообщения, пока не достигнет сообщения с `set` или начала контекста. Затем он восстанавливает конечное значение, применяя эти собранные операции в хронологическом порядке (от старых к новым).

Такое динамическое разрешение гарантирует, что состояние всегда будет согласованным и точно отражать историю операций, что позволяет осуществлять сложные и надежные манипуляции с состоянием.

:::::details{title="Пример: Добавление и разрешение"}

**1. Начальное состояние**

Контекст начинается с исходного сообщения `data`.

```json
[
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  }
]
```

**2. Выполнение вызова инструмента**

Вызывается инструмент для обновления статуса пользователя.

```json
// Выполняемый вызов
{
  "_tool": "updateUserStatus",
  "newStatus": "inactive",
  "_outputPath": "†data.user.status"
}
```

**3. Контекст после выполнения**

Движок добавляет новое сообщение с выводом, которое включает метаданные о вызове, его сгенерировавшем.

```json
[
  // Исходное сообщение с данными
  {
    "type": "data",
    "data": { "user": { "name": "Alex", "status": "active" } }
  },
  // Добавленное сообщение вывода из вызова
  {
    "type": "data",
    "data": { "user": { "status": "inactive" } },
    "_call": {
      "_tool": "updateUserStatus",
      "newStatus": "inactive",
      "_outputPath": "†data.user.status"
    },
    "_date": "2025-10-26T12:00:00Z"
  }
]
```

**4. Разрешение переменной**

- Для разрешения `†data.user.status` движок сначала проверяет последнее сообщение. Он находит `user.status` и возвращает `"inactive"`.
- Для разрешения `†data.user.name` движок проверяет последнее сообщение, не находит `user.name`, затем проверяет предыдущее сообщение. Он находит его там и возвращает `"Alex"`

:::::

Сила объединения :term[Ссылок на Переменные]{canonical="Variable Reference"} с :term[Путями Вывода]{canonical="Output Path"} заключается в их способности определять операции над данными, которые еще недоступны. Например, :term[Вызов Инструмента]{canonical="Call"} может быть определен для работы со значением из :term[Входного]{canonical="Input"} сообщения, даже если этот конкретный ввод еще не был предоставлен. Это позволяет создавать многоразовые, параметризованные рабочие процессы.

Эта концепция распространяется и на связывание :term[Вызовов Инструментов]{canonical="Call"} в цепочки. :term[Вызов Инструмента]{canonical="Call"} может быть создан с :term[Ссылкой на Переменную]{canonical="Variable Reference"}, которая указывает на :term[Путь Вывода]{canonical="Output Path"} _предыдущего_ вызова в той же последовательности. Это создает многоэтапный поток данных, где вывод одного инструмента становится вводом для следующего.

## Вызовы без Пути Вывода

Не каждый :term[Вызов Инструмента]{canonical="Call"} должен сохранять свой результат. Отсутствие свойства `_outputPath` является осознанным выбором, который сигнализирует о разном поведении для скрытых и явных вызовов.

### Эфемерные рассуждения для скрытых вызовов

Для скрытого вызова отсутствие `_outputPath` позволяет ему функционировать как эфемерный шаг рассуждения — «мысль», которая информирует последующие действия в том же ходу, но не сохраняется в постоянное :term[Состояние]{canonical="State"}. Это мощный метод структурирования процесса рассуждений LLM.

Например, агент может быть спроектирован так, чтобы сначала использовать скрытый инструмент `think` для анализа проблемы и наброска стратегии. Эта «мысль» не сохраняется, но ее генерация немедленно обогащает собственный внутренний контекст LLM. На следующем шаге того же `solution` LLM может генерировать конкретные, явные :term[Вызовы Инструментов]{canonical="Call"}, которые будут более эффективными и согласованными благодаря предыдущему, несохраненному шагу рассуждения.

### «Выполнил и забыл» для явных вызовов

Для явного вызова :term[Действия]{canonical="Activity"} отсутствие `_outputPath` сигнализирует об операции «выполнил и забыл». :term[Цикл Исполнения]{canonical="Execution Loop"} вызовет :term[Действие]{canonical="Activity"}, но не будет ждать результата и не сохранит его в контексте.

Это полезно для побочных эффектов, когда возвращаемое значение не требуется для продолжения текущего рабочего процесса. Типичные примеры:

- Запись события во внешний сервис аналитики.
- Отправка уведомления пользователю или другой системе.
- Запуск длительного фонового процесса без необходимости блокировать текущий план.

## Взаимодействие с другими системами

- **:term[Сообщение с Данными]{canonical="Data Message"}:** `_outputPath` является основным механизмом создания и обновления :term[Сообщений с Данными]{canonical="Data Message"} в рамках рабочего процесса. Он преобразует :term[Вызов Инструмента]{canonical="Tool Call"} без состояния в операцию с состоянием, сохраняя его результат в контексте и делая его доступным для последующих шагов.

  > Sidenote:
  > - :term[005: Агент/Данные]{href="./005_agent_data.md"}

- **:term[Сообщение о Состоянии]{canonical="State Message"}:** Хотя целью может быть любое :term[Сообщение с Данными]{canonical="Data Message"}, наиболее частым случаем является запись в :term[Сообщение о Состоянии]{canonical="State Message"}. Это делает объект :term[Состояния]{canonical="State"} «черновиком» для рабочего процесса, позволяя различным инструментам обмениваться информацией и основываться на результатах друг друга на протяжении нескольких тактов :term[Цикла Исполнения]{canonical="Execution Loop"}.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Ссылка на Переменную]{canonical="Variable Reference"}:** :term[Путь Вывода]{canonical="Output Path"} является прямым аналогом :term[Ссылки на Переменную]{canonical="Variable Reference"}. :term[Путь Вывода]{canonical="Output Path"} записывает данные в контекст, а :term[Ссылка на Переменную]{canonical="Variable Reference"} их читает. Вместе они образуют полную декларативную схему потока данных, соединяя вывод одного инструмента с вводом другого.

  > Sidenote:
  > - :term[007: Агент/Переменные]{href="./007_agent_variables.md"}

- **:term[Выражения]{canonical="Expression"}:** Выражения вводят логику непосредственно в схему потока данных. Используя `||` и `&&` в :term[Пути Вывода]{canonical="Output Path"}, :term[Вызов Инструмента]{canonical="Tool Call"} может объявлять условные результаты или распределять свой результат по нескольким назначениям. Это позволяет отойти от жестких, закодированных конвейеров данных к гибкой структуре, которая адаптируется к условиям времени выполнения.

  > Sidenote:
  > - :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}

- **:term[План]{canonical="Plan"}:** В контексте :term[Плана]{canonical="Plan"} :term[Пути Вывода]{canonical="Output Path"} действуют как «провода», которые соединяют различные :term[Вызовы Инструментов]{canonical="Tool Call"} («узлы») в полный граф потока данных. Это позволяет агенту определять и выполнять целую многошаговую стратегию как единый декларативный объект.

  > Sidenote:
  > - :term[012: Агент/План]{href="./012_agent_plan.md"}

- **:term[Экземплирование]{canonical="Instancing"}:** Когда :term[Вызов Инструмента]{canonical="Tool Call"} включает свойство `_instance`, любой указанный `_outputPath` автоматически ограничивается контекстом данных этого конкретного экземпляра. Это обеспечивает изоляцию данных при параллельной обработке, гарантируя, что вывод инструмента, работающего с одним экземпляром, не будет мешать состоянию другого.

  > Sidenote:
  > - :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

## От эфемерных выводов к постоянному состоянию

Механизм :term[Пути Вывода]{canonical="Output Path"} предоставляет надежный способ управления потоком данных между отдельными :term[Вызовами Инструментов]{canonical="Tool Call"} и может быть нацелен на любое :term[Сообщение с Данными]{canonical="Data Message"}. Однако для создания сложных, многоэтапных агентов, способных рассуждать и адаптироваться со временем, требуется специализированная форма памяти — тип сообщения, специально разработанный для сохранения информации между несколькими независимыми запросами.

Следующий документ, :term[009: Агент/Состояние]{href="./009_agent_state.md"}, описывает протокол для этой постоянной памяти.
