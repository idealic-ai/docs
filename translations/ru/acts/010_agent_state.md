# 010: Агент/Состояние

> **Сообщение о состоянии:** Персистентное сообщение `Data`, которое представляет живую, развивающуюся память рабочего процесса. Оно действует как набор локальных переменных, позволяя выполнять многошаговые операции с сохранением состояния. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [006: Агент/Данные](./006_agent_data.md)
> - Позволяет:
>   - [012: Агент/План](./012_agent_plan.md)
> - Дополняется:
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **сообщение о состоянии (State message)**, которое предоставляет механизм для управления персистентным состоянием в цикле выполнения агента. Сообщение `State` — это специализированное применение системы **Data**, разработанное для создания многошаговых рабочих процессов с сохранением состояния. Оно функционирует как контейнер для «локальных переменных» процесса, позволяя сохранять контекст между последовательными выполнениями `Tool`.

Объект `State` служит источником истины о текущем статусе запроса и является ключом к отказоустойчивости и возобновлению работы. Поскольку он захватывает полный контекст рабочего процесса в определенный момент времени, это позволяет приостанавливать и возобновлять процесс. Когда начинается новая итерация, `State` из предыдущего такта дает LLM четкое понимание того, на чем остановился процесс, обеспечивая бесшовное продолжение работы.

## Многошаговые инструменты

Основная функция сообщения `State` — позволить разным `Tools` обмениваться информацией в рамках единого непрерывного процесса. Оно делает возможными операции с состоянием, предоставляя общее пространство, где `Tools` могут сохранять свои результаты.

Это достигается с помощью простого механизма чтения/записи: один `Tool` может записать свой результат в объект `State`, а другой `Tool` — прочитать эти данные в качестве входных на следующем шаге. Это позволяет создавать цепочки инструментов, где выходные данные одного инструмента напрямую служат входными для следующего, и все это без потери контекста между выполнениями.

## Входные данные

Основной механизм для чтения из `State` — это **ссылки на переменные (Variable References)**. Эта система позволяет любому параметру в `Tool Call` быть специальной строкой, которая ссылается на переменную из контекста, а не на само значение. Ссылка представляет собой строку с определенным синтаксисом. Такой подход очень эффективен, так как он позволяет избежать дублирования больших объектов данных, экономя место и средства.

Ссылка имеет простой синтаксис: строка с префиксом в виде кинжала (`†`). Синтаксис выглядит так: `†<kind>.<path>`, где `<kind>` — это тип сообщения `Data` (например, `state`, `input`), а `<path>` — это путь к нужному значению в точечной нотации.

Например, `Tool Call` для получения профиля пользователя может быть определен как структура данных (например, в JSON) следующим образом:

```json
{
  "_tool": "fetchUserProfile",
  "userId": "†state.currentUser.id"
}
```

Во время выполнения система разрешает ссылку `†state.currentUser.id`, что делает вызов эквивалентным следующему коду на TypeScript:

```typescript
fetcUserProfile({
  userId: state.currentUser.id,
});
```

## Выходные данные

Основной механизм для записи в `State` — это мета-свойство `_outputPath` в `Call`. Эта строка указывает ядру выполнения, куда поместить результат работы инструмента.

> Sidenote: [004: Агент/Вызов](./004_agent_call.md)

`schema` сообщения `State` может использоваться для определения набора ожидаемых свойств. Это создает мощную обратную связь для LLM: когда `schema` требует определенных свойств, LLM направляется на вызов тех `Tools`, чей `_outputPath` соответствует этим свойствам, обеспечивая структурную корректность последовательности `Tool`.

### Синтаксис пути

Строка `_outputPath` может принимать несколько форм:

- **Обычный путь:** Простая строка, указывающая на одно местоположение. Необязательный префикс `†state.` — это соглашение, чтобы уточнить, что путь ведет к объекту `State`.
  ```json
  "†state.user.summary"
  ```
- **Альтернативные пути (ветвление):** Использование `||` для разделения путей указывает на набор возможных исходов. Результат будет записан в одно из указанных мест, причем выбор часто определяется ядром выполнения или на последующем этапе рассуждения.
  ```json
  "†state.summary.text || †state.summary.json"
  ```
- **Одновременные пути (разветвление):** Использование `&&` указывает ядру выполнения на разветвление, записывая один и тот же результат по всем указанным путям одновременно.
  ```json
  "†state.user.profile.summary && †state.audit.log.summary"
  ```

### Способы спецификации

Метод определения значения `_outputPath` задается его схемой, что похоже на то, как система **Imports** обрабатывает контекст:

- **Динамический (определяется LLM):** Схема `Tool` для `_outputPath` может быть гибкой (например, `{ "type": "string" }`), что дает LLM свободу генерировать любой из вышеупомянутых синтаксисов путей. Это позволяет агенту динамически соединять инструменты и создавать новые потоки данных на лету.

  _Схема Tool:_

  ```json
  {
    "_outputPath": {
      "type": "string"
    }
  }
  ```

- **Предписанный (жестко закодированный):** В качестве альтернативы, схема может использовать ограничивающие ключевые слова JSON Schema, такие как `const`, `enum` или `oneOf`, чтобы зафиксировать поведение инструмента. Значение `const` задает один конкретный путь, а `enum` может заставить LLM выбирать из ограниченного набора предопределенных вариантов. Это крайне важно для создания стабильных рабочих процессов и надежных шаблонов обработки ошибок, где возможные исходы известны заранее.

  _Схема Tool (предписывающая выбор между путями успеха/неудачи):_

  ```json
  {
    "_outputPath": {
      "enum": ["†state.success", "†state.failure"]
    }
  }
  ```

Это дает инструмент для управления предсказуемостью рабочего процесса, позволяя разработчику переходить от гибкой, исследовательской фазы к зафиксированной, детерминированной, чтобы обеспечить надежные результаты.

## Планирование и Выполнение

Сочетание записи в состояние через `_outputPath` и чтения из него с помощью **ссылок на переменные** является ключевым механизмом, который позволяет отделить планирование от выполнения. Это дает агенту возможность построить полный граф потока данных — цепочку `Tool Calls`, связанных ссылками — _до_ запуска любого инструмента.

Этот граф ссылок можно проверять, повторно использовать и даже симулировать, что делает его полностью совместимым со скрытым исполнением LLM. Гибкость этой системы заключается в возможности контролировать как входные, так и выходные данные на уровне схемы. Разработчик рабочего процесса может оставить **ссылки на переменные** (входы) и **`_outputPath`** (выходы) динамическими для определения LLM, или же предписать их, чтобы обеспечить жесткий и надежный поток данных.

> [!HEADSUP] Heads up
> Создание `Tool Calls`, связанных друг с другом через `State`, и есть акт планирования. Эта система предоставляет техническую основу для этого процесса: персистентное `State` выступает в роли холста, **ссылки на переменные** и `_outputPath` — в роли проводов, а **цикл** агента — в роли итеративного движка. Вместе эти компоненты позволяют агенту построить полный граф потока данных, что и является сутью **Плана**.
>
> > Sidenote:
> >
> > - [005: Агент/Цикл](./005_agent_loop.md)
> > - [012: Агент/План](./012_agent_plan.md)

## Композиция

- **Call:** Система `Call` тесно связана с `State` через мета-свойство `_outputPath`. Это свойство превращает `Tool Call`, который в ином случае мог бы быть чистой функцией без состояния, в операцию, изменяющую состояние. Указывая `_outputPath`, `Call` направляет движок записать свой результат в объект `State`, что делает его основным механизмом для записи агентом итогов своих действий. Это взаимодействие позволяет последовательности `Calls` опираться друг на друга, создавая цепочку причин и следствий, которая фиксируется в `State`.

  > Sidenote: [004: Агент/Вызов](./004_agent_call.md)

- **Data:** Сообщение `State` по своей сути является специализированным применением системы сообщений `Data`, используя сообщение `Data` с `kind: "state"`. Оно использует ключевые особенности сообщений `Data` для создания персистентной памяти для агента. Свойство `schema` используется для определения ожидаемой структуры этой памяти, предоставляя черновик, который направляет действия LLM. Кроме того, критически важны возможности слияния системы `Data`, позволяющие обновлять `State` инкрементально через серию патчей, которые система объединяет в единое, согласованное представление.

  > Sidenote: [006: Агент/Данные](./006_agent_data.md)

- **Imports:** Система `Imports` является основным механизмом для предоставления объекта `State` инструменту `Tool`, работающему в изолированном контексте, например, в **модуле**. Когда `Call` делегируется, свойство `_imports` может указать, что `state` должен быть включен в «чистую» среду модуля. Это позволяет инкапсулированным инструментам читать и взаимодействовать с состоянием основного рабочего процесса контролируемым и явным образом.

  > Sidenote: [008: Агент/Импорты](./008_agent_imports.md)

- **Plan:** Хотя `State` позволяет создавать простые последовательности инструментов, его полная мощь раскрывается при использовании в качестве основы системы `Plan`. В `Plan` рабочий процесс представлен как направленный ациклический граф (DAG), где узлами являются `Tool Calls`. Объект `State` обеспечивает связи — ребра — между этими узлами. Он позволяет одному узлу записывать в переменную, а другим читать из нее, что делает возможными сложные шаблоны, такие как логические ветвления (if-else) или параллельные разветвления.

  > Sidenote: [012: Агент/План](./012_agent_plan.md)

- **Instancing:** Сообщение `State` полностью совместимо с системой `Instancing`. Когда запрос обрабатывает несколько `Instances`, каждый из них поддерживает свой собственный изолированный объект `State`, идентифицируемый уникальным ключом `_instance`. **Ссылки на переменные** (например, `†state.currentUser.id`) автоматически и прозрачно направляются к правильному объекту `State`, соответствующему `Instance`, на который нацелен `Tool Call`. Это позволяет выполнять один общий `Plan` для множества различных состояний параллельно с гарантированной изоляцией данных.

  > Sidenote: [011: Агент/Инстансинг](./011_agent_instancing.md)

## От единого состояния к параллельному выполнению

Сообщение `State` предоставляет механизм для управления памятью одного целостного рабочего процесса. Однако для создания по-настоящему масштабируемых систем агенты должны уметь применять один и тот же рабочий процесс ко многим различным данным одновременно. Это требует способа управления множеством независимых состояний параллельно в рамках одного запроса, при этом операции, такие как **ссылки на переменные** и `_outputPath`, должны корректно направляться к соответствующему состоянию.

Следующий документ, **[011: Агент/Инстансинг](./011_agent_instancing.md)**, описывает систему, которая делает возможным такое параллельное выполнение.
