# 010: Агент/План

> [!DEFINITION] :term[План]{canonical="Plan"}
> Контекстное сообщение, содержащее граф потока данных из :term[Вызовов Инструментов]{canonical="Tool Call"}, который представляет стратегию агента. Оно передается между шагами для обеспечения итеративного выполнения и адаптации.

> Sidenote:
>
> - Требуется:
>   - :term[004: Агент/Вызов]{href="/004_agent_call.md"}
>   - :term[005: Агент/Цикл]{href="/005_agent_loop.md"}
>   - :term[008: Агент/Переменные]{href="/008_agent_variables.md"}
>   - :term[009: Агент/Состояние]{href="/009_agent_state.md"}
>   - :term[011: Агент/Экземплирование]{href="/011_agent_instancing.md"}

Сообщение :term[План]{canonical="Plan"} — это основа итеративного выполнения. Когда LLM получает текущий :term[План]{canonical="Plan"} вместе с активным объектом :term[Состояние]{canonical="State"}, она может определить свою точную позицию в рабочем процессе. Эта ситуационная осведомленность позволяет агенту быть по-настоящему адаптивным. Он может следовать существующему плану, генерировать новые :term[Вызовы Инструментов]{canonical="Tool Call"} для его расширения или полностью отбросить его и перепланировать в ответ на неожиданные результаты. Это создает гибкую модель выполнения, которая может варьироваться от жесткой, предопределенной процедуры до гибкой, исследовательской стратегии.

## Как формируется План

Связи в графе создаются не с помощью явных указателей, а через простую и мощную конвенцию потока данных с использованием объекта :term[Состояние]{canonical="State"}.

- **Узлы (:term[Вызовы Инструментов]{canonical="Tool Call"}):** Каждый шаг в рабочем процессе — это :term[Вызов Инструмента]{canonical="Tool Call"}, представляющий собой действие, которое необходимо выполнить.
- **Ребра (объект :term[Состояние]{canonical="State"}):** Связи между шагами создаются путем записи в объект :term[Состояние]{canonical="State"} и чтения из него. Один :term[Инструмент]{canonical="Tool"} записывает свой результат по определенному пути в :term[Состояние]{canonical="State"}, используя мета-свойство `_outputPath`. Следующий :term[Инструмент]{canonical="Tool"} может затем использовать этот результат в качестве входных данных, ссылаясь на тот же путь с помощью **:term[Ссылки на Переменную]{canonical="Variable Reference"}**.

Это устанавливает четкую зависимость: второй :term[Вызов Инструмента]{canonical="Tool Call"} не может быть выполнен, пока первый не завершится и не заполнит :term[Состояние]{canonical="State"}.

Например, :term[План]{canonical="Plan"} для получения профиля пользователя и его последующего суммирования будет состоять из двух :term[Вызовов Инструментов]{canonical="Tool Call"}:

:::div{.limited-width}

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

> Sidenote:
>
> ```mermaid
> graph TD
>     state_var{{"state.user.profile"}}
>
>     Call1["fetchUserProfile"]
>     Call2["summarizeProfile"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- считывается --> Call2
> ```

:::

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, создавая двухэтапный план. Эту зависимость можно представить в виде простого графа.

## Содержимое Плана: Граф потока данных

Содержимое сообщения :term[План]{canonical="Plan"} — это граф потока данных. Эта структура используется для представления стратегии агента в виде последовательности взаимосвязанных :term[Вызовов Инструментов]{canonical="Tool Call"}. Представляя рабочий процесс в виде графа, система может четко определить зависимости между шагами, где результат одного :term[Вызова Инструмента]{canonical="Tool Call"} становится входными данными для другого. Этот формат на основе графа обеспечивает ясную, машиночитаемую структуру, которую :term[Цикл Выполнения]{canonical="Execution Loop"} агента может интерпретировать и выполнять.

> Sidenote:
> :term[План]{canonical="Plan"} не ограничивается линейными последовательностями. Он может представлять сложные рабочие процессы с условной логикой, где путь выполнения зависит от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Получить погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти фильм];
>     C -- state.suggestion --> E[Предложить вариант];
>     D -- state.suggestion --> E[Предложить вариант];
> ```

Базовая структура графа не ограничивается только определением исполняемых рабочих процессов. Агент может получить запрос на создание графа из :term[Вызовов Инструментов]{canonical="Tool Call"}, который представляет что-то совершенно иное — визуализацию социальной сети, рабочий процесс GitHub Actions или схему базы данных.

Крайне важно отличать эти результаты от :term[Плана]{canonical="Plan"}. Хотя они используют ту же структуру графа, они не являются «планами» в архитектурном смысле, если только они не передаются в последующий :term[Запрос]{canonical="Request"} как контекстное сообщение :term[План]{canonical="Plan"} с намерением быть выполненными. Это различие предотвращает путаницу между созданием представления существующей системы и созданием исполняемой стратегии.

Хотя содержимое :term[Плана]{canonical="Plan"} может быть мощным инструментом для мозгового штурма, обсуждения и «размышлений вслух», его основное применение в этой системе — определение исполняемых рабочих процессов. Для этой цели мы используем особый тип графа, называемый **направленным ациклическим графом (DAG)**, где каждый узел — это :term[Вызов Инструмента]{canonical="Tool Call"}.

A DAG имеет несколько ключевых свойств, которые делают его идеальным для выполнения:

- **Граф:** «Граф» — это всё содержимое сообщения :term[План]{canonical="Plan"} — совокупность всех :term[Вызовов Инструментов]{canonical="Tool Call"} (узлов) и зависимостей по данным, которые их связывают (ребра).
- **Направленный:** Связи односторонние, они определяются потоком данных. Шаг, который создает данные, должен предшествовать шагу, который их использует.
- **Ациклический:** Рабочий процесс не может иметь циклических зависимостей, что обеспечивает ему четкое начало и конец. Это критически важная функция безопасности, предотвращающая создание LLM рабочего процесса с бесконечным циклом. Система проверяет :term[План]{canonical="Plan"} на ацикличность перед выполнением.

> Sidenote:
> Для реализации итеративной логики, такой как цикл «for», используется шаблон вложенного, делегированного выполнения. Внешний :term[План]{canonical="Plan"} управляет состоянием цикла (например, счетчиком итераций), и на каждой итерации он вызывает подзапрос через :term[Делегат]{canonical="Delegate"}. Этот подзапрос содержит свой собственный отдельный, ациклический :term[План]{canonical="Plan"}, который выполняет логику для одной итерации. Это гарантирует, что циклы создаются явно и безопасно.

## Разделение планирования и выполнения

Самая мощная особенность этой архитектуры — полное разделение планирования и выполнения. Поскольку :term[План]{canonical="Plan"} — это просто декларативная структура данных, агент может сгенерировать весь граф :term[Вызовов Инструментов]{canonical="Tool Call"} _до_ запуска какого-либо кода.

LLM выступает в роли планировщика, собирая массив :term[Вызовов]{canonical="Call"}, который представляет предполагаемый рабочий процесс. Эту структуру данных затем можно:

- **Проверить:** Система может проверить граф на наличие циклических зависимостей или других структурных ошибок.
- **Сымитировать:** Можно выполнить «пробный запуск», чтобы предвидеть поведение рабочего процесса.
- **Представить на утверждение:** :term[План]{canonical="Plan"} можно показать человеку для проверки, изменения или утверждения перед выполнением, создавая критически важный уровень безопасности и взаимодействия.

Выполнение обрабатывается :term[Циклом Выполнения]{canonical="Execution Loop"}, который интерпретирует сообщение :term[План]{canonical="Plan"} и запускает :term[Вызовы Инструментов]{canonical="Tool Call"} в правильном порядке на основе их зависимостей, заполняя объект :term[Состояние]{canonical="State"} по мере выполнения.

## План как развивающаяся стратегия

:term[План]{canonical="Plan"} не статичен; это живая стратегия, которую можно адаптировать на каждом шаге цикла выполнения. Ключевое различие заключается в том, что `Plan` — это не просто какой-либо вывод от LLM. Когда агент впервые генерирует набор :term[Вызовов Инструментов]{canonical="Tool Call"}, это просто предлагаемая последовательность действий. Она становится настоящим :term[Планом]{canonical="Plan"} только тогда, когда передается как контекстное сообщение в _следующий_ запрос в цикле.

Этот цикл превращает разовый результат в непрерывную стратегию:

- **:term[контекст]{canonical="context"}** для запроса содержит объект :term[Состояние]{canonical="State"} и сообщение :term[План]{canonical="Plan"} с предыдущего шага.
- **:term[решение]{canonical="Solution"}**, сгенерированное LLM, содержит новый набор :term[Вызовов Инструментов]{canonical="Tool Call"}, который становится **новым :term[Планом]{canonical="Plan"}** для следующего шага.

Этот итеративный процесс позволяет агенту быть как проактивным, так и реактивным. Он может следовать существующему :term[Плану]{canonical="Plan"}, но также может изменять его в ответ на результаты предыдущего шага. Например, если :term[Вызов Инструмента]{canonical="Tool Call"} не удался, агент может сгенерировать новый :term[План]{canonical="Plan"}, который включает шаги по обработке ошибок. Это делает систему устойчивой и адаптируемой.

:::::details{title="Пример: Планирование на шаг вперед"}

Этот пример демонстрирует, как `Plan` обеспечивает структурный «оптимальный путь», который направляет агента, не позволяя ему отклоняться от стандартной процедуры даже при наличии других вероятных действий.

**Сценарий:** Агенту поддержки клиентов необходимо обработать возврат средств. Стандартная процедура, инициированная запросом пользователя, — сначала проверить историю платежей для получения контекста, а затем оформить возврат.

**1. Исходный запрос**

Цикл начинается с запроса клиента. На основе этого `input`, LLM формирует стандартный двухэтапный `Plan` для обработки возврата. Это представляет собой идеальный, наиболее распространенный рабочий процесс.

::::columns
:::column{title="Контекст и схема для запроса"}

```json
// Agent.Request(config, schema, context)
{
  "schema": {
    "type": "object",
    "properties": {
      "calls": { "type": "array" },
      "output": {
        "type": "object",
        "nullable": true,
        "properties": {
          "confirmationId": { "type": "string" },
          "message": { "type": "string" }
        }
      }
    }
  },
  "context": [
    {
      "type": "input",
      "request": "I'd like a refund for my last order.",
      "customerId": "cust_123",
      "amount": 50.0
    }
  ]
}
```

:::
:::column{title="`solution` от LLM"}

```json
{
  "calls": [
    {
      "_tool": "checkBillingHistory",
      "customerId": "†input.customerId"
    },
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": null
}
```

:::
::::

**2. Следующий запрос в цикле**

:term[Цикл Выполнения]{canonical="Execution Loop"} выполняет вызов `checkBillingHistory` и заполняет :term[Состояние]{canonical="State"}. История выявляет некоторую сложность (например, предыдущий чарджбэк). В этот момент неуправляемый агент мог бы с полным основанием выбрать другой доступный инструмент, `escalateToSupervisor`.

Однако сообщение `Plan` в контексте обеспечивает необходимую структуру. Сопоставляя то, что он _знает_ (сложное `State`), с тем, что он _должен делать_ (`Plan`), LLM понимает свое точное положение в рабочем процессе и придерживается «оптимального пути».

::::columns
:::column{title="Контекст"}

```json
[
  {
    "type": "state",
    "billingHistory": {
      "orders": 5,
      "lastChargeback": "2025-09-10"
    }
  },
  {
    "type": "plan",
    "plan": [
      {
        "_tool": "checkBillingHistory",
        "customerId": "†input.customerId"
      },
      {
        "_tool": "issueRefund",
        "customerId": "†input.customerId",
        "amount": "†input.amount"
      }
    ]
  }
]
```

:::
:::column{title="`solution` от LLM"}

```json
{
  "calls": [
    {
      "_tool": "issueRefund",
      "customerId": "†input.customerId",
      "amount": "†input.amount"
    }
  ],
  "output": {
    "confirmationId": "refund_xyz789",
    "message": "The refund has been processed successfully."
  }
}
```

:::
::::

`Plan` обеспечивает процедурную последовательность, предотвращая преждевременную эскалацию и удерживая агента на намеченном пути.

:::::

:::::details{title="Пример: Корректировка плана"}

Этот пример демонстрирует, как агент может изменить существующий :term[План]{canonical="Plan"} в ответ на новую информацию, выбрав другой инструмент.

::::columns
:::column{title="Контекст"}

Агенту предоставляется существующий «оптимальный» `Plan` и новый `Input` от пользователя, который вводит новое ограничение.

```ts
[
  { type: 'tool', tool: Tool.bookFlight },
  { type: 'tool', tool: Tool.bookHotel },
  { type: 'tool', tool: Tool.findPetFriendlyHotel },
  {
    type: 'plan',
    plan: [
      {
        _tool: 'bookFlight',
        destination: '†input.destination',
      },
      {
        _tool: 'bookHotel',
        destination: '†input.destination',
      },
    ],
  },
  {
    type: 'input',
    destination: 'Berlin',
    instruction: "Actually, I'll be traveling with my dog.",
  },
];
```

:::
:::column{title="`solution` от LLM"}

LLM распознает, что первоначальный план больше не подходит. Он отбрасывает старый план и генерирует новый, заменяя `bookHotel` более специализированным инструментом.

```json
{
  "calls": [
    {
      "_tool": "bookFlight",
      "destination": "†input.destination"
    },
    {
      "_tool": "findPetFriendlyHotel",
      "destination": "†input.destination"
    }
  ],
  "output": null
}
```

:::
::::

Агент не просто меняет параметр; он коренным образом изменяет свою стратегию, выбирая более подходящий инструмент (`findPetFriendlyHotel`) на основе новых требований. Этот новый набор `Tool Calls` становится `Plan` для следующего шага в :term[Цикле Выполнения]{canonical="Execution Loop"}.

:::::

:::::details{title="Пример: Обработка сбоев"}

Этот пример демонстрирует, как агент может отклониться от «оптимального» :term[Плана]{canonical="Plan"} при столкновении с неожиданным сбоем. Процесс показан в два этапа: первоначальный «оптимальный» план и перепланирование, которое происходит после сбоя инструмента.

**1. Первоначальный план**

Агенту предоставляется набор инструментов и вводные данные от пользователя. Он генерирует оптимистичный, двухэтапный «оптимальный» план, который не учитывает возможность сбоя.

::::columns
:::column{title="Исходный контекст"}

```ts
Agent.Request(config, {
  schema: {
    type: 'object',
    properties: {
      calls: { type: 'array' },
      output: {
        type: 'object',
        nullable: true,
        properties: {
          status: {
            type: 'string',
            enum: ['Success', 'Failed'],
          },
        },
      },
    },
  },
  context: [
    { type: 'tool', tool: 'Tool.processPayment' },
    { type: 'tool', tool: 'Tool.confirmOrder' },
    { type: 'tool', tool: 'Tool.reportFailure' },
    { type: 'input', amount: 50.0 },
  ],
});
```

:::
:::column{title="Исходное решение"}

```json
{
  "calls": [
    {
      "_tool": "processPayment",
      "amount": "†input.amount",
      "_outputPath": "†state.receipt || †state.error"
    },
    {
      "_tool": "confirmOrder",
      "receipt": "†state.receipt"
    }
  ],
  "output": null
}
```

:::
::::

**2. Сбой и перепланирование**

:term[Цикл Выполнения]{canonical="Execution Loop"} пытается выполнить `processPayment`, но инструмент дает сбой. Движок заполняет `†state.error`. На следующей итерации LLM видит это новое состояние ошибки вместе с исходным (теперь устаревшим) планом и генерирует новое решение для обработки сбоя.

::::columns
:::column{title="Контекст для следующего запроса"}

```json
[
  {
    "type": "state",
    "error": { "code": "card_declined", "message": "Your card was declined." }
  },
  // Исходный, теперь уже устаревший, план все еще находится в контексте
  {
    "type": "plan",
    "plan": [
      { "_tool": "processPayment", "_outputPath": "†state.receipt || †state.error" },
      { "_tool": "confirmOrder", "receipt": "†state.receipt" }
    ]
  }
]
```

:::
:::column{title="Новое решение (перепланированное)"}

```json
{
  "calls": [
    {
      "_tool": "reportFailure",
      "error": "†state.error"
    }
  ],
  "output": { "status": "Failed" }
}
```

:::
::::

Агент распознал `error` в `State`, проигнорировал устаревший «оптимальный» `Plan` и сгенерировал новый, одношаговый план для `reportFailure`. Это демонстрирует способность агента реактивно обрабатывать неожиданные результаты.

:::::

:::::details{title="Пример: Планирование на основе схемы"}

Этот пример демонстрирует, как предоставление `schema` для объекта :term[Состояние]{canonical="State"} действует как чертеж, направляя LLM к созданию структурно корректного :term[Плана]{canonical="Plan"}.

::::columns
:::column{title="Контекст со схемой State"}

Вызывающая сторона предоставляет `Input` и сообщение `State`, которое содержит только `schema`. Эта схема определяет предполагаемый поток данных, указывая «переменные», которые должен использовать план.

```json
[
  { "type": "tool", "tool": "Tool.detectLanguage" },
  { "type": "tool", "tool": "Tool.isEnglish" },
  { "type": "tool", "tool": "Tool.translateText" },
  {
    "type": "input",
    "text": "Bonjour le monde"
  },
  {
    "type": "state",
    "schema": {
      "type": "object",
      "properties": {
        "language": { "type": "string" },
        "isEnglish": { "type": "boolean" },
        "translatedText": { "type": "string" }
      }
    }
  }
]
```

:::
:::column{title="`solution` от LLM"}

LLM использует схему `State` в качестве руководства для построения действительного плана, правильно связывая `_outputPath` одного инструмента с входом следующего.

```json
{
  "calls": [
    {
      "_tool": "detectLanguage",
      "text": "†input.text",
      // LLM знает, что нужно использовать этот путь из схемы.
      "_outputPath": "†state.language"
    },
    {
      "_tool": "isEnglish",
      // Он правильно ссылается на вывод предыдущего шага.
      "language": "†state.language",
      "_outputPath": "†state.isEnglish"
    },
    {
      "_tool": "translateText",
      "text": "†input.text",
      "isEnglish": "†state.isEnglish",
      "_outputPath": "†state.translatedText"
    }
  ],
  "output": null
}
```

:::
::::

Предоставляя `schema`, вызывающая сторона дает LLM четкий чертеж потока данных. LLM не нужно угадывать имена переменных или последовательность; он просто заполняет предопределенные слоты, что приводит к более надежному и предсказуемому `Plan`.

:::::

Этот итеративный цикл планирования и выполнения является ядром :term[Процесса]{href="./203_idea_process.md"}. Это самодостаточный снимок рабочего процесса, фиксирующий доступные :term[Инструменты]{canonical="Tool"}, текущее :term[Состояние]{canonical="State"} и сам :term[План]{canonical="Plan"}.

## От одного плана к многоразовым рабочим процессам

Сообщение :term[План]{canonical="Plan"} определяет последовательность действий для конкретной задачи. Чтобы сделать эти рабочие процессы по-настоящему мощными, нам нужен способ инкапсулировать их в многоразовые компоненты, которые можно вызывать из других :term[Планов]{canonical="Plan"}.

Протокол для этого параллельного выполнения описан в :term[011: Агент/Экземплирование]{href="/011_agent_instancing.md"}.
