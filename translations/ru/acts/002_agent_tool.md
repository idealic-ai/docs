# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Схема, определяющая возможность, которую может использовать агент. Она передается в LLM как часть запроса и служит структурированным интерфейсом для потенциального действия. LLM активирует инструмент, генерируя :term[Вызов]{canonical="Call"} с конкретными параметрами, который затем выполняется либо скрыто самой LLM, либо явно зарегистрированной функцией кода (:term[Действие]{canonical="Activity"}).

> Sidenote:
> - Требуется: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это интерфейс на основе схемы, который определяет структурированную возможность, доступную агенту. Он служит основополагающим элементом для всех действий агента, предоставляя LLM способ понимать и выбирать из списка возможных поведений.

## Что такое Инструменты?

**Инструменты — это краеугольный камень** систем действий агентов. Они открывают новый тип возможностей: **выбор действия в контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от текущей ситуации.

Инструменты предоставляют:

- **Структурированные интерфейсы**: Возможности, определенные схемой, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Четкие контракты для входов и выходов
- **Компонуемость**: Строительные блоки, которые объединяются в сложное поведение агента
- **Интеграция с LLM**: Схемы, о которых языковые модели могут рассуждать и которые они могут выбирать

Когда агент заполняет конкретные параметры для :term[Инструмента]{canonical="Tool"}, он создает :term[Вызов]{canonical="Call"} — экземпляр :term[Инструмента]{canonical="Tool"} со всеми заполненными обязательными параметрами, представляющий собой конкретный запрос на выполнение.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему :term[Инструментов]{canonical="Tool"}, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации
- **Выбирали между несколькими возможностями** для достижения цели
- **Выполняли различные реализации** одной и той же возможности (например, разные поисковые системы)
- **Смешивали рассуждения LLM с явной логикой** в процессе принятия решений

## Схема как интерфейс

Система :term[Инструментов]{canonical="Tool"} основана на фундаментальном принципе: **:term[Инструменты]{canonical="Tool"} — это чистые схемы**, которые определяют интерфейсы, не предписывая конкретных реализаций. Это разделение интерфейса и реализации является ключом к гибкости и компонуемости системы.

Схема `Tool` — это стандартный объект JSON Schema. Любое поле без префикса в виде подчеркивания считается параметром инструмента. Система использует специальные мета-поля (с префиксом `_`) для определения свойств системного уровня, которые управляют идентификацией и выполнением инструмента.

Схема :term[Инструмента]{canonical="Tool"} определяет его полный интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с детерминированной функцией кода для явного выполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Делегирует выполнение инструмента изолированному внешнему делегату. См. :term[013: Агент/Делегат]{href="./013_agent_delegate.md"}
> - **`_outputPath`**: Делает инструмент состоятельным, записывая его вывод в постоянный объект данных. См. :term[008: Агент/Вывод]{href="./008_agent_output.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. См. :term[012: Агент/Экземплирование]{href="./012_agent_instancing.md"}

- **`title`**: Человекочитаемое имя для схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`properties`**: Любые поля без подчеркивания определяют входные данные, необходимые инструменту.
- **`_tool`**: Предоставляет уникальное имя для идентификации инструмента.
- **`_output`**: Определяет ожидаемую структуру результата работы инструмента.
- **`_reasoningForCall`**: Поле, добавляемое системой, чтобы агент мог объяснить, почему он выбрал этот инструмент.

Протоколы более высокого уровня строят оркестрацию рабочих процессов, управление состоянием и политики выполнения поверх этих примитивов.

## Определение Инструмента

:term[Инструменты]{canonical="Tool"} определяются как JSON-схемы. В примере ниже показан :term[Инструмент]{canonical="Tool"} для анализа тональности. Этот :term[Инструмент]{canonical="Tool"} предназначен для скрытого выполнения, так как он полагается на встроенное понимание языка LLM и не требует внешней функции.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода LLM"}

```json
// Запрос: "Какая тональность у 'Это лучшее!'"
{
  "_tool": "sentimentAnalysis",
  "text": "This is the best!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Компоновка схем для LLM

Агент не просто работает с инструментами; ему часто нужно создать конечный, структурированный вывод после завершения задачи. Для этого среда выполнения агента компонует схемы всех доступных :term[Инструментов]{canonical="Tool"} с определенной пользователем _схемой вывода_. Это создает единую, унифицированную схему, которая предоставляется LLM в :term[Запросе]{canonical="Request"}.

Эта композиция даёт LLM выбор, как отвечать. В зависимости от запроса, она может:

- **Сгенерировать только `meta` и `calls`:** Если задача требует промежуточных шагов, LLM вызовет один или несколько инструментов, обновит версию :term[Идеи]{canonical="Idea"} в объекте `meta` и оставит поле `output` равным `null`.
- **Сгенерировать только `meta` и `output`:** Если на запрос можно ответить напрямую без использования инструментов, LLM предоставит конечный результат в поле `output`, обновит `meta` и оставит `calls` пустым.
- **Сгенерировать всё:** В некоторых случаях LLM может выполнить действие и выдать конечный результат за один шаг, соответствующим образом обновив `meta`.

Этот механизм позволяет единому, гибкому интерфейсу обрабатывать как простые, одношаговые ответы, так и сложные задачи с использованием нескольких инструментов. Разработчик предоставляет схемы :term[Инструментов]{canonical="Tool"} и схему вывода отдельно, а система объединяет их в структуру, которую LLM может использовать для выбора наилучшего курса действий.

Пример ниже иллюстрирует, как компонуются схема :term[Инструмента]{canonical="Tool"} и схема вывода.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация для запроса (например, модель, температура)
  {
    // Схема вывода
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то запрос' },
  ]
);
```

:::
:::column{title="Скомпонованная схема (для LLM)"}

```json
{
  "type": "object",
  "properties": {
    "meta": {
      "type": "object",
      "description": "Метаданные об идее, включая версию и идентификатор. Ожидается, что LLM обновит их, например, увеличив версию.",
      "properties": {
        "path": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["meta", "calls", "output"]
}
```

:::
::::

## Расширение Инструментов с помощью Мета-свойств

Помимо определения основных параметров инструмента, его схема может быть расширена при вызове. Это другая форма композиции, где новые поведения накладываются на один инструмент.

Когда агент решает использовать инструмент, он создает :term[Вызов]{canonical="Call"} — конкретный экземпляр этого инструмента. :term[Вызов]{canonical="Call"} включает параметры для инструмента, но его также можно дополнить специальными мета-свойствами (с префиксом `_`), которые предоставляют дополнительные инструкции для движка выполнения. Эти свойства управляют аспектами выполнения инструмента, выходящими за рамки его основного определения.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет использовать простую, базовую схему инструмента мощными и гибкими способами. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последняя часть головоломки — это понимание различных способов, которыми :term[Вызов]{canonical="Call"} может быть фактически выполнен.

## Скрытое и Явное выполнение

Как только :term[Вызов]{canonical="Call"} сгенерирован, система должна его выполнить. Схема `Tool`, будучи просто интерфейсом, сама по себе не содержит логики выполнения. Вместо этого ее выполнение может происходить одним из двух способов. По умолчанию используется **скрытое выполнение**, при котором LLM использует свои собственные внутренние рассуждения для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром — например, вызова API или доступа к базе данных — `Tool` должен быть связан с детерминированной функцией кода. Эта явная реализация называется **:term[Действием]{canonical="Activity"}**.

Разделение интерфейса :term[Инструмента]{canonical="Tool"} от реализации :term[Действия]{canonical="Activity"} является ключевым принципом дизайна. Это позволяет определять и рассуждать о возможностях агента абстрактно, в то время как базовая логика выполнения может быть заменена или обновлена независимо. Следующий документ, :term[003: Агент/Действие]{href="./003_agent_activity.md"}, описывает, как :term[Действия]{canonical="Activity"} предоставляют конкретную логику для :term[Инструментов]{canonical="Tool"}s.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
