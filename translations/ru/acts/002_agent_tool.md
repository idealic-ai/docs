# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Схема, определяющая возможность, которую может использовать агент. Она предоставляется LLM как часть запроса, выступая в роли структурированного интерфейса для потенциального действия. LLM активирует инструмент, создавая :term[Вызов]{canonical="Call"} с определенными параметрами, который затем выполняется либо скрыто самой LLM, либо явно зарегистрированной функцией (:term[Действие]{canonical="Activity"}).

> Sidenote:
> - Требуется: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это интерфейс на основе схемы, который определяет структурированную возможность, доступную агенту. Он служит фундаментальным строительным блоком для всех действий агента, позволяя LLM понимать и выбирать из набора возможных поведений.

## Что такое Инструменты?

**Инструменты — это основа** систем действий агентов. Они открывают новый тип возможностей: **выбор действия в контексте**, позволяя агентам выбирать и выполнять соответствующие действия в зависимости от ситуации.

Инструменты обеспечивают:

- **Структурированные интерфейсы**: Возможности, определенные в схеме, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Четкие контракты для входов и выходов
- **Компонуемость**: Строительные блоки, которые объединяются в сложные поведения агента
- **Интеграция с LLM**: Схемы, которые языковые модели могут анализировать и выбирать

Когда агент заполняет конкретные параметры для Инструмента, он создает **:term[Вызов]{canonical="Call"}** — экземпляр Инструмента со всеми заполненными параметрами, представляющий собой конкретный запрос на выполнение.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации
- **Выбирали между несколькими возможностями** для достижения цели
- **Выполняли различные реализации** одной и той же возможности (например, разные поисковые системы)
- **Сочетали логику LLM с явной логикой** в процессе принятия решений

## Схема как интерфейс

Система Инструментов построена на фундаментальном принципе: **Инструменты — это чистые схемы**, которые определяют интерфейсы, не предписывая конкретные реализации. Это разделение интерфейса и реализации является ключом к гибкости и компонуемости системы.

Схема `Tool` — это стандартный объект JSON Schema. Любое поле без префикса в виде подчеркивания считается параметром инструмента. Система использует специальные мета-поля (с префиксом `_`) для определения системных свойств, которые управляют идентификацией и выполнением инструмента

Схема Инструмента определяет его полный интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с детерминированной функцией для явного выполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Делегирует выполнение инструмента изолированному внешнему делегату. См. :term[012: Агент/Делегат]{href="./012_agent_delegate.md"}
> - **`_outputPath`**: Делает инструмент состоянием, записывая его вывод в постоянный объект состояния. См. :term[009: Агент/Состояние]{href="./009_agent_state.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. См. :term[011: Агент/Экземплирование]{href="./011_agent_instancing.md"}

- **`title`**: Человекочитаемое имя схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`properties`**: Любые поля без префикса подчеркивания определяют входы, которые требуются инструменту.
- **`_tool`**: Предоставляет уникальное имя для идентификации инструмента.
- **`_output`**: Определяет ожидаемую структуру результата работы инструмента.
- **`_reasoningForCall`**: Поле, добавляемое системой, чтобы агент объяснил, почему он выбрал этот инструмент.

Протоколы более высокого уровня строят оркестрацию рабочих процессов, управление состоянием и политики выполнения поверх этих примитивов.

## Определение Инструмента

Инструменты определяются как JSON-схемы. В примере ниже показан `Tool` для анализа тональности. Этот `Tool` предназначен для скрытого выполнения, так как он полагается на встроенное понимание языка LLM и не требует внешней функции.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода LLM"}

```json
// Запрос: "Какова тональность 'Это лучше всего!'"
{
  "_tool": "sentimentAnalysis",
  "text": "This is the best!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Компоновка схем для LLM

Агент не просто работает с инструментами; ему часто нужно получить окончательный структурированный результат после завершения задачи. Для этого среда выполнения агента компонует схемы всех доступных :term[Инструментов]{canonical="Tool"} с определенной пользователем _схемой вывода_. Это создает единую, унифицированную схему, которая предоставляется LLM в :term[Запросе]{canonical="Request"}.

Такая компоновка дает LLM выбор в том, как отвечать. В зависимости от запроса, она может:

- **Генерировать только `calls`:** Если задача требует промежуточных шагов, LLM вызовет один или несколько инструментов и оставит поле `output` равным `null`.
- **Генерировать только `output`:** Если на запрос можно ответить напрямую без инструментов, LLM предоставит конечный результат в поле `output` и оставит `calls` пустым.
- **Генерировать и то, и другое:** В некоторых случаях LLM может выполнить действие и выдать конечный результат за один шаг.

Этот механизм позволяет единому, гибкому интерфейсу обрабатывать как простые, одношаговые ответы, так и сложные задачи с использованием нескольких инструментов. Разработчик предоставляет схемы `Tool` и схему вывода отдельно, а система объединяет их в структуру, которую LLM может использовать для принятия решения о наилучшем курсе действий.

Пример ниже иллюстрирует, как компонуются схема `Tool` и схема вывода.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация для запроса (например, модель, температура)
  {
    // Схема вывода
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то запрос' },
  ]
);
```

:::
:::column{title="Скомпонованная схема (для LLM)"}

```json
{
  "type": "object",
  "properties": {
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["calls", "output"]
}
```

:::
::::

## Расширение Инструментов с помощью мета-свойств

Кроме определения основных параметров инструмента, его схема может быть расширена при вызове. Это другая форма компоновки, при которой новые поведения накладываются на один инструмент.

Когда агент решает использовать инструмент, он создает :term[Вызов]{canonical="Call"} — конкретный экземпляр этого инструмента. :term[Вызов]{canonical="Call"} включает параметры для инструмента, но он также может быть дополнен специальными мета-свойствами (с префиксом `_`), которые предоставляют дополнительные инструкции для механизма выполнения. Эти свойства управляют аспектами выполнения инструмента, которые выходят за рамки его основного определения.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет использовать простую, базовую схему инструмента мощными и гибкими способами. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последняя часть головоломки — это понимание различных способов, которыми :term[Вызов]{canonical="Call"} может быть фактически выполнен.

## Скрытое и явное выполнение

Как только :term[Вызов]{canonical="Call"} сгенерирован, системе необходимо его выполнить. Схема `Tool`, будучи просто интерфейсом, сама по себе не содержит логики выполнения. Вместо этого ее выполнение может происходить одним из двух способов. По умолчанию используется **скрытое выполнение**, при котором LLM использует свои собственные внутренние рассуждения для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром, — таких как вызов API или доступ к базе данных, — `Tool` должен быть связан с детерминированной функцией. Эта явная реализация называется **:term[Действие]{canonical="Activity"}**.

Разделение интерфейса :term[Инструмента]{canonical="Tool"} от реализации :term[Действия]{canonical="Activity"} является ключевым принципом дизайна. Это позволяет определять и рассуждать о возможностях агента абстрактно, в то время как базовая логика выполнения может быть заменена или обновлена независимо. Следующий документ, :term[003: Агент/Действие]{href="./003_agent_activity.md"}, описывает, как :term[Действия]{canonical="Activity"} предоставляют конкретную логику для :term[Инструментов]{canonical="Tool"}.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
