# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Схема, определяющая возможность, которую может использовать агент. Она предоставляется LLM как часть запроса, выступая в роли структурированного интерфейса для потенциального действия. LLM активирует инструмент, создавая `Call` с определёнными параметрами, который затем выполняется либо скрыто самой LLM, либо явно зарегистрированной функцией кода (Действие).

> Sidenote:
> - Требуется: [001: Агент/Запрос](./001_agent_request.md)
> - Дополняется: [003: Агент/Действие](./003_agent_activity.md)

`Tool` (Инструмент) — это интерфейс на основе схемы, который определяет структурированную возможность, доступную агенту. Он служит фундаментальным строительным блоком для всех действий агента, позволяя LLM понимать и выбирать из меню возможных поведений.

## Что такое Инструменты?

**Инструменты — это основа** систем действий агентов. Они открывают новый тип возможностей: **выбор действия в контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от текущей ситуации.

Инструменты предоставляют:

- **Структурированные интерфейсы**: Возможности, определённые схемой, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Чёткие контракты для входных и выходных данных
- **Компонуемость**: Строительные блоки, которые объединяются в сложные модели поведения агента
- **Интеграция с LLM**: Схемы, которые языковые модели могут анализировать и выбирать

Когда агент заполняет определённые параметры для Инструмента, он создаёт **Вызов (`Call`)** — экземпляр Инструмента со всеми заполненными обязательными параметрами, представляющий собой конкретный запрос на выполнение.

> Sidenote:
> [004: Агент/Вызов](./004_agent_call.md)
>

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации
- **Выбирали между несколькими возможностями** для достижения цели
- **Выполняли различные реализации** одной и той же возможности (например, разные поисковые системы)
- **Сочетали рассуждения LLM с явной логикой** в процессе принятия решений

## Архитектура системы Инструментов

### Основной принцип: Схема как интерфейс

Система Инструментов построена на фундаментальном принципе: **Инструменты — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Это разделение интерфейса и реализации является ключом к гибкости и компонуемости системы.

Схема `Tool` — это стандартный объект JSON Schema. Любое поле без префикса в виде нижнего подчеркивания считается параметром инструмента. Система использует специальные мета-поля (с префиксом `_`) для определения свойств системного уровня, которые управляют идентификацией и выполнением инструмента.

Схема Инструмента определяет его полный интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с детерминированной функцией кода для явного выполнения. ([003: Агент/Действие](./003_agent_activity.md))
> - **`_delegate`**: Делегирует выполнение инструмента изолированному внешнему делегату. ([012: Агент/Делегат](./012_agent_delegate.md))
> - **`_outputPath`**: Делает инструмент сохраняющим состояние, записывая его вывод в постоянный объект состояния. ([009: Агент/Состояние](./009_agent_state.md))
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. ([011: Агент/Экземплирование](./011_agent_instancing.md))

- **`title`**: Человекочитаемое имя для схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`parameters`**: Любые поля без нижнего подчеркивания определяют входные данные, необходимые инструменту.
- **`_tool`**: Предоставляет уникальное имя для идентификации инструмента.
- **`_output`**: Определяет ожидаемую структуру результата работы инструмента.
- **`_reasoningForCall`**: Поле, добавляемое системой, чтобы агент объяснил, почему он выбрал этот инструмент.

Протоколы более высокого уровня строят оркестрацию рабочих процессов, управление состоянием и политики выполнения поверх этих примитивов.

## Определение Инструмента

Инструменты определяются как JSON-схемы. Пример ниже показывает `Tool` для анализа тональности. Этот `Tool` предназначен для скрытого выполнения, так как он полагается на встроенное понимание языка LLM и не требует внешней функции.

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

## Составление схем для LLM

Агент не просто работает с инструментами; ему часто требуется создать конечный, структурированный вывод по завершении задачи. Для этого среда выполнения агента составляет схемы всех доступных `Tool`s с определённой пользователем _схемой вывода_. Это создаёт единую, унифицированную схему, которая предоставляется LLM в `Request`.

Такая композиция даёт LLM выбор, как реагировать. В зависимости от промпта, она может:

- **Генерировать только `calls`:** Если задача требует промежуточных шагов, LLM вызовет один или несколько инструментов и оставит поле `output` равным `null`.
- **Генерировать только `output`:** Если на промпт можно ответить напрямую без инструментов, LLM предоставит конечный результат в поле `output` и оставит `calls` пустым.
- **Генерировать и то, и другое:** В некоторых случаях LLM может выполнить действие и выдать конечный результат за один шаг.

Этот механизм позволяет единому, гибкому интерфейсу обрабатывать как простые, одноразовые ответы, так и сложные задачи с использованием нескольких инструментов. Разработчик предоставляет схемы `Tool` и схему вывода отдельно, а система объединяет их в структуру, которую LLM может использовать для выбора наилучшего плана действий.

Пример ниже иллюстрирует, как составляется схема `Tool` и схема вывода.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация для запроса (например, модель, температура)
  {
    // Схема вывода
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то промпт' },
  ]
);
```

:::
:::column{title="Составная схема (для LLM)"}

```json
{
  "type": "object",
  "properties": {
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    }
  },
  "required": ["calls", "output"]
}
```

:::
::::

## Расширение Инструментов с помощью мета-свойств

Помимо определения основных параметров инструмента, его схема может быть расширена при вызове. Это другая форма композиции, где новые модели поведения накладываются на один инструмент.

Когда агент решает использовать инструмент, он создаёт `Call` — конкретный экземпляр этого инструмента. `Call` включает параметры для инструмента, но также может быть дополнен специальными мета-свойствами (с префиксом `_`), которые предоставляют дополнительные инструкции для исполнительной системы. Эти свойства управляют аспектами выполнения инструмента, которые выходят за рамки его базового определения.

> Sidenote:
> - [004: Агент/Вызов](./004_agent_call.md)

Этот механизм позволяет использовать простую, базовую схему инструмента мощными и гибкими способами. `Call` становится насыщенной инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последний элемент этой головоломки — понять различные способы, которыми `Call` может быть фактически выполнен.

## Скрытое и явное выполнение

После создания `Call` система должна его выполнить. Схема `Tool`, будучи всего лишь интерфейсом, сама по себе не содержит логики выполнения. Вместо этого её выполнение может происходить одним из двух способов. По умолчанию используется **скрытое выполнение**, при котором LLM использует свои внутренние рассуждения для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром, — например, вызова API или доступа к базе данных, — `Tool` должен быть связан с детерминированной функцией кода. Эта явная реализация называется **Действием (`Activity`)**.

Разделение интерфейса `Tool` от реализации `Activity` — это ключевой принцип проектирования. Это позволяет определять и анализировать возможности агента абстрактно, в то время как базовая логика выполнения может быть заменена или обновлена независимо. Следующий документ, **[003: Агент/Действие](./003_agent_activity.md)**, описывает, как `Activities` предоставляют конкретную логику для `Tools`.

> Sidenote:
> - [003: Агент/Действие](./003_agent_activity.md).
