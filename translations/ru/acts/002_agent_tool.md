# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Схема, определяющая возможность, которую может использовать агент. Она представляется LLM как часть запроса, выступая в роли структурированного интерфейса для потенциального действия. LLM активирует инструмент, генерируя :term[Вызов]{canonical="Call"} с определёнными параметрами, который затем выполняется либо скрыто самой LLM, либо явно зарегистрированной функцией (:term[Активностью]{canonical="Activity"}).

> Sidenote:
> - Требуется: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это интерфейс на основе схемы, который определяет структурированную возможность, доступную агенту. Он служит фундаментальным строительным блоком для всех действий агента, предоставляя LLM способ понимать и выбирать из меню возможных поведений.

## Что такое Инструменты?

**Инструменты — это краеугольный камень** систем действий агентов. Они открывают новый тип возможностей: **выбор действия в контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от текущей ситуации.

Инструменты предоставляют:

- **Структурированные интерфейсы**: Возможности, определённые схемой, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Чёткие контракты для входов и выходов
- **Компонуемость**: Строительные блоки, которые объединяются в сложные модели поведения агентов
- **Интеграция с LLM**: Схемы, которые языковые модели могут анализировать и выбирать

Когда агент заполняет определённые параметры для :term[Инструмента]{canonical="Tool"}, он создаёт :term[Вызов]{canonical="Call"} — экземпляр :term[Инструмента]{canonical="Tool"} со всеми заполненными обязательными параметрами, представляющий собой конкретный запрос на выполнение.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации
- **Выбирали между несколькими возможностями** для достижения цели
- **Выполняли разные реализации** одной и той же возможности (например, разные поисковые системы)
- **Сочетали рассуждения LLM с явной логикой** в процессе принятия решений

## Схема как интерфейс

Система Инструментов построена на фундаментальном принципе: **Инструменты — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Это разделение интерфейса и реализации является ключом к гибкости и компонуемости системы.

Схема `Tool` — это стандартный объект JSON Schema. Любое поле без префикса в виде подчёркивания считается параметром инструмента. Система использует специальные мета-поля (с префиксом `_`) для определения свойств системного уровня, которые управляют идентификацией и выполнением инструмента.

Схема Инструмента определяет его полный интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с детерминированной функцией для явного выполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Делегирует выполнение инструмента изолированному внешнему :term[делегату]{canonical="Delegate"}. См. :term[014: Агент/Делегат]{href="./014_agent_delegate.md"}
> - **`_outputPath`**: Делает инструмент запоминающим состояние, записывая его вывод в постоянный объект :term[данных]{canonical="Data"}. См. :term[008: Агент/Вывод]{href="./008_agent_output.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный :term[экземпляр]{canonical="Instance"} в запросе с несколькими :term[экземплярами]{canonical="Instance"}. См. :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **`title`**: Человекочитаемое имя для схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`properties`**: Любые поля без подчёркивания определяют входные данные, необходимые инструменту.
- **`_tool`**: Предоставляет уникальное имя для идентификации инструмента.
- **`_output`**: Определяет ожидаемую структуру результата работы инструмента.
- **`_reasoningForCall`**: Поле, добавляемое системой, чтобы агент мог объяснить, почему он выбрал этот инструмент.

Протоколы более высокого уровня строят оркестрацию рабочих процессов, управление состоянием и политики выполнения на основе этих примитивов.

## Определение Инструмента

Инструменты определяются как JSON-схемы. В примере ниже показан `Tool` для анализа тональности. Этот `Tool` предназначен для скрытого выполнения, так как он полагается на встроенное в LLM понимание языка и не требует внешней функции.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода LLM"}

```json
// Запрос: "Какая тональность у фразы 'Это лучше всех!'"
{
  "_tool": "sentimentAnalysis",
  "text": "This is the best!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Компоновка схем для LLM

Агент не просто работает с инструментами; ему часто нужно выдать конечный, структурированный результат по завершении задачи. Для этого среда выполнения агента компонует схемы всех доступных :term[Инструментов]{canonical="Tool"} с определённой пользователем _схемой вывода_. Это создаёт единую, унифицированную схему, которая предоставляется LLM в :term[Запросе]{canonical="Request"}.

Такая компоновка даёт LLM выбор, как реагировать. В зависимости от запроса, она может:

- **Сгенерировать только `meta` и `calls`:** Если задача требует промежуточных шагов, LLM вызовет один или несколько инструментов, обновит версию :term[Идеи]{canonical="Idea"} в объекте `meta` и оставит поле `output` равным `null`.
- **Сгенерировать только `meta` и `output`:** Если на запрос можно ответить напрямую без использования инструментов, LLM предоставит конечный результат в поле `output`, обновит `meta` и оставит `calls` пустым.
- **Сгенерировать всё:** В некоторых случаях LLM может выполнить действие и выдать конечный результат за один шаг, соответствующим образом обновив `meta`.

Чтобы уменьшить неоднозначность и предотвратить распространённые галлюцинации LLM, система интеллектуально изменяет схему инструмента в зависимости от режима его выполнения.

- Если :term[Инструмент]{canonical="Tool"} является **скрытым** (без соответствующей :term[Активности]{canonical="Activity"}), его схема `_output` включается как есть, поскольку LLM отвечает за генерацию результата.
- Если :term[Инструмент]{canonical="Tool"} является **явным** (поддерживается :term[Активностью]{canonical="Activity"}), его свойство `_output` **динамически удаляется** из схемы перед отправкой в LLM. Это обеспечивает чёткий и однозначный контракт: единственная задача LLM — предоставить правильные входные данные для инструмента. Информация о возвращаемом значении инструмента должна быть включена в его `description`, чтобы направлять планирование LLM, не давая ему поля для неверного заполнения.

Этот механизм позволяет единому гибкому интерфейсу обрабатывать как простые, одномоментные ответы, так и сложные задачи с несколькими инструментами. Разработчик предоставляет схемы :term[Инструментов]{canonical="Tool"} и схему вывода отдельно, а система объединяет их в структуру, которую LLM может использовать для выбора наилучшего плана действий.

Пример ниже иллюстрирует, как компонуются схема :term[Инструмента]{canonical="Tool"} и схема вывода.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация для запроса (например, модель, температура)
  {
    // Схема вывода
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то запрос' },
  ]
);
```

:::
:::column{title="Скомпонованная схема (для LLM)"}

```json
{
  "type": "object",
  "properties": {
    "meta": {
      "type": "object",
      "description": "Метаданные об идее, включая версию и идентификатор. Ожидается, что LLM обновит их, например, увеличив версию.",
      "properties": {
        "path": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["meta", "calls", "output"]
}
```

:::
::::

## Расширение Инструментов с помощью мета-свойств

Помимо определения базовых параметров инструмента, его схема может быть расширена при вызове. Это другая форма компоновки, при которой новые поведения накладываются на один инструмент.

Когда агент решает использовать инструмент, он создаёт :term[Вызов]{canonical="Call"} — конкретный экземпляр этого инструмента. :term[Вызов]{canonical="Call"} включает параметры для инструмента, но он также может быть дополнен специальными мета-свойствами (с префиксом `_`), которые дают дополнительные инструкции для движка выполнения. Эти свойства управляют аспектами выполнения инструмента, выходящими за рамки его базового определения.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет использовать простую, базовую схему инструмента мощными и гибкими способами. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последняя часть головоломки — это понимание различных способов, которыми :term[Вызов]{canonical="Call"} может быть фактически выполнен.

## Скрытое и явное выполнение

Как только :term[Вызов]{canonical="Call"} сгенерирован, система должна его выполнить. Схема `Tool`, будучи просто интерфейсом, сама по себе не содержит логики выполнения. Вместо этого её выполнение может происходить одним из двух способов. По умолчанию используется **скрытое выполнение**, когда LLM использует собственное внутреннее мышление для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром — например, вызова API или доступа к базе данных — `Tool` должен быть связан с детерминированной функцией. Эта явная реализация называется **:term[Активностью]{canonical="Activity"}**.

Разделение интерфейса :term[Инструмента]{canonical="Tool"} и реализации :term[Активности]{canonical="Activity"} является ключевым принципом проектирования. Это позволяет определять и анализировать возможности агента абстрактно, в то время как базовая логика выполнения может быть заменена или обновлена независимо. Следующий документ, :term[003: Агент/Действие]{href="./003_agent_activity.md"}, описывает, как :term[Активности]{canonical="Activity"} предоставляют конкретную логику для :term[Инструментов]{canonical="Tool"}.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
