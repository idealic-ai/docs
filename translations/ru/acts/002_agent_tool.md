# 002: Агент/Инструмент

> [!DEFINITION] [Инструмент](./000_glossary.md)
> Схема, определяющая возможность, которую может использовать агент. Она предоставляется LLM как часть запроса, выступая в роли структурированного интерфейса для потенциального действия. LLM активирует инструмент, генерируя :term[Вызов]{canonical="Call"} с определенными параметрами, который затем выполняется либо скрыто самой LLM, либо явно зарегистрированной функцией кода (:term[Действием]{canonical="Activity"}).

> Sidenote:
> - Требует: :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется: :term[003: Агент/Действие]{href="./003_agent_activity.md"}

:term[Инструмент]{canonical="Tool"} — это управляемый схемой интерфейс, который определяет структурированную возможность, которую может использовать агент. Он служит фундаментальным строительным блоком для всех действий агента, предоставляя LLM способ понимать и выбирать из меню возможных поведений.

## Что такое Инструменты?

**Инструменты — это основа** систем действий агента. Они предоставляют новый тип возможности: **выбор действия в контексте**, позволяя агентам выбирать и выполнять соответствующие действия в зависимости от ситуации.

Инструменты предоставляют:

- **Структурированные интерфейсы**: Определенные схемой возможности, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Четкие контракты для входов и выходов
- **Компонуемость**: Строительные блоки, которые объединяются в сложное поведение агента
- **Интеграция с LLM**: Схемы, о которых языковые модели могут рассуждать и которые они могут выбирать

Когда агент заполняет определенные параметры для :term[Инструмента]{canonical="Tool"}, он создает :term[Вызов]{canonical="Call"} — экземпляр :term[Инструмента]{canonical="Tool"} со всеми заполненными обязательными параметрами, представляющий собой конкретный запрос на выполнение.

> Sidenote:
> :term[004: Агент/Вызов]{href="./004_agent_call.md"}
>

## Когда использовать систему Инструментов

Используйте систему :term[Инструментов]{canonical="Tool"}, когда вам нужно, чтобы агенты:

- **Динамически выбирали действия** в зависимости от контекста и ситуации
- **Выбирали между несколькими возможностями** для достижения цели
- **Выполняли разные реализации** одной и той же возможности (например, разные поисковые системы)
- **Смешивали рассуждения LLM с явной логикой** в процессе принятия решений

## Схема как интерфейс

Система :term[Инструментов]{canonical="Tool"} построена на фундаментальном принципе: **:term[Инструменты]{canonical="Tool"} — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Это разделение интерфейса и реализации является ключом к гибкости и компонуемости системы.

Схема :term[Инструмента]{canonical="Tool"} — это стандартный объект JSON Schema. Любое поле без префикса в виде нижнего подчеркивания считается параметром инструмента. Система использует специальные мета-поля (с префиксом `_`) для определения системных свойств, которые управляют идентификацией и выполнением инструмента.

Схема :term[Инструмента]{canonical="Tool"} определяет его полный интерфейс:

> Sidenote:
> Расширения:
>
> - **`_activity`**: Связывает инструмент с детерминированной функцией кода для явного выполнения. См. :term[003: Агент/Действие]{href="./003_agent_activity.md"}
> - **`_delegate`**: Делегирует выполнение инструмента изолированному внешнему делегату. См. :term[014: Агент/Делегат]{href="./014_agent_delegate.md"}
> - **`_outputPath`**: Делает инструмент отслеживающим состояние, записывая его вывод в постоянный объект данных. См. :term[008: Агент/Вывод]{href="./008_agent_output.md"}
> - **`_instance`**: Направляет выполнение инструмента на конкретный экземпляр в запросе с несколькими экземплярами. См. :term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}

- **`title`**: Человекочитаемое имя для схемы (необязательно).
- **`description`**: Объясняет, что делает инструмент.
- **`properties`**: Любые поля без нижнего подчеркивания определяют входные данные, необходимые инструменту.
- **`_tool`**: Предоставляет уникальное имя для идентификации инструмента.
- **`_output`**: Определяет ожидаемую структуру результата работы инструмента.
- **`_reasoningForCall`**: Поле, добавляемое системой, чтобы агент мог объяснить, почему он выбрал этот инструмент.

Протоколы более высокого уровня строят оркестрацию рабочих процессов, управление состоянием и политики выполнения поверх этих примитивов.

## Определение Инструмента

:term[Инструменты]{canonical="Tool"} определяются как JSON-схемы. В примере ниже показан :term[Инструмент]{canonical="Tool"} для анализа тональности. Этот :term[Инструмент]{canonical="Tool"} предназначен для скрытого выполнения, поскольку он полагается на встроенное в LLM понимание языка и не требует внешней функции.

::::columns
:::column{title="Определение Инструмента"}

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

:::
:::column{title="Пример вывода LLM"}

```json
// Запрос: "Какая тональность у 'Это просто лучшее!'"
{
  "_tool": "sentimentAnalysis",
  "text": "This is the best!",
  "_output": {
    "sentiment": "positive",
    "confidence": 0.99
  }
}
```

:::
::::

## Переопределение Инструмента

:term[Инструменты]{canonical="Tool"} идентифицируются по их уникальному имени `_tool`. Если запрос содержит несколько определений для одного и того же инструмента (например, в истории сообщений), **приоритет имеет последнее определение**.

Это поведение «побеждает последний» обеспечивает мощные паттерны композиции:

- **По умолчанию и переопределение**: Агенты могут быть инициализированы стандартным набором инструментов, который затем можно настроить для конкретных задач, просто добавив новое определение.
- **Контекстуальная адаптация**: Описание или параметры инструмента могут быть уточнены в ходе разговора, чтобы лучше соответствовать изменяющемуся контексту.

При возникновении конфликта более раннее определение игнорируется и исключается из окончательной схемы, представляемой LLM.

## Компоновка схем для LLM

Агент не просто работает с инструментами; ему часто нужно произвести окончательный, структурированный вывод после завершения задачи. Для этого среда выполнения агента компонует схемы всех доступных :term[Инструментов]{canonical="Tool"} с определенной пользователем _схемой вывода_. Это создает единую, унифицированную схему, которая предоставляется LLM в :term[Запросе]{canonical="Request"}.

Эта композиция дает LLM выбор в том, как отвечать. В зависимости от запроса, он может:

- **Сгенерировать только `meta` и `calls`:** Если задача требует промежуточных шагов, LLM вызовет один или несколько инструментов, обновит версию :term[Идеи]{canonical="Idea"} в объекте `meta` и оставит поле `output` равным `null`.
- **Сгенерировать только `meta` и `output`:** Если на запрос можно ответить напрямую без использования инструментов, LLM предоставит конечный результат в поле `output`, обновит `meta` и оставит `calls` пустым.
- **Сгенерировать все:** В некоторых случаях LLM может выполнить действие и произвести конечный результат за один шаг, соответствующим образом обновив `meta`.

Чтобы уменьшить неоднозначность и предотвратить распространенные галлюцинации LLM, система интеллектуально изменяет схему инструмента в зависимости от режима его выполнения.

- Если :term[Инструмент]{canonical="Tool"} является **скрытым** (нет соответствующего :term[Действия]{canonical="Activity"}), его схема `_output` включается как есть, поскольку LLM отвечает за генерацию результата.
- Если :term[Инструмент]{canonical="Tool"} является **явным** (подкреплен :term[Действием]{canonical="Activity"}), его свойство `_output` **динамически удаляется** из схемы перед отправкой в LLM. Это обеспечивает четкий и недвусмысленный контракт: единственная задача LLM — предоставить правильные входные данные для инструмента. Информация о возвращаемом значении инструмента должна быть включена в его `description`, чтобы направлять планирование LLM, не давая ему поля для неверного заполнения.

Этот механизм позволяет единому, гибкому интерфейсу обрабатывать как простые, одношаговые ответы, так и сложные, многоинструментальные задачи. Разработчик предоставляет схемы :term[Инструментов]{canonical="Tool"} и схему вывода отдельно, а система объединяет их в структуру, которую LLM может использовать для принятия решения о наилучшем курсе действий.

Пример ниже иллюстрирует, как компонуются схема :term[Инструмента]{canonical="Tool"} и схема вывода.

::::columns
:::column{title="Конфигурация Агента"}

```typescript
Agent.Request(
  config, // Конфигурация для запроса (например, модель, температура)
  {
    // Схема вывода
    type: 'object',
    properties: {
      summary: { type: 'string' },
    },
    required: ['summary'],
  },
  [
    // Контекст
    {
      type: 'tool',
      tool: {
        greetUser: {
          type: 'object',
          properties: {
            userName: { type: 'string' },
          },
          required: ['userName'],
        },
      },
    },
    { type: 'text', text: 'здесь какой-то запрос' },
  ]
);
```

:::
:::column{title="Скомпонованная схема (для LLM)"}

```json
{
  "type": "object",
  "properties": {
    "meta": {
      "type": "object",
      "description": "Метаданные об идее, включая версию и идентификацию. Ожидается, что LLM обновит это, например, увеличив версию.",
      "properties": {
        "path": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "output": {
      "type": ["object", "null"],
      "properties": {
        "summary": { "type": "string" }
      },
      "required": ["summary"],
      "additionalProperties": false
    },
    "calls": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "_tool": { "const": "greetUser" },
          "userName": { "type": "string" }
        },
        "required": ["_tool", "userName"]
      }
    }
  },
  "required": ["meta", "calls", "output"]
}
```

:::
::::

## Улучшение Инструментов с помощью Мета-свойств

Помимо определения базовых параметров инструмента, его схема может быть улучшена при вызове. Это другая форма композиции, где новые поведения накладываются на один инструмент.

Когда агент решает использовать инструмент, он создает :term[Вызов]{canonical="Call"} — конкретный экземпляр этого инструмента. :term[Вызов]{canonical="Call"} включает параметры для инструмента, но он также может быть дополнен специальными мета-свойствами (с префиксом `_`), которые предоставляют дополнительные инструкции для механизма выполнения. Эти свойства контролируют аспекты выполнения инструмента, которые выходят за рамки его базового определения.

> Sidenote:
> - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Этот механизм позволяет гибко использовать простую, основную схему инструмента. :term[Вызов]{canonical="Call"} становится богатой инструкцией, которая указывает, _что_ делать (инструмент и его параметры) и _как_ это делать (мета-свойства). Последняя часть головоломки — это понимание различных способов, которыми :term[Вызов]{canonical="Call"} может быть фактически выполнен.

## Скрытое и явное выполнение

После того как :term[Вызов]{canonical="Call"} сгенерирован, система должна его выполнить. Схема :term[Инструмента]{canonical="Tool"}, будучи просто интерфейсом, сама по себе не содержит логики выполнения. Вместо этого ее выполнение может происходить одним из двух способов. По умолчанию используется **скрытое выполнение**, когда LLM использует собственное внутреннее рассуждение для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром — например, вызова API или доступа к базе данных — :term[Инструмент]{canonical="Tool"} должен быть связан с детерминированной функцией кода. Эта явная реализация называется **:term[Действием]{canonical="Activity"}**.

Разделение интерфейса :term[Инструмента]{canonical="Tool"} и реализации :term[Действия]{canonical="Activity"} является основным принципом проектирования. Это позволяет определять и рассуждать о возможностях агента абстрактно, в то время как базовая логика выполнения может быть заменена или обновлена независимо. :term[003: Агент/Действие]{href="./003_agent_activity.md"} описывает, как :term[Действия]{canonical="Activity"} предоставляют конкретную логику для :term[Инструментов]{canonical="Tool"}.

> Sidenote:
> - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.
