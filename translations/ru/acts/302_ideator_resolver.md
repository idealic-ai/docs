# 302: Ideator/Решатель

## 1. Введение

Этот документ определяет **System: Resolver**, мощный `Idea Transformer`, который обеспечивает композицию и динамическое связывание `Idea`. Являясь важным дополнением к [System: Storage](./301_ideator_storage.md), цель Решателя — взять высокоуровневую `Idea`, содержащую ссылки на другие `Idea`, и преобразовать её в полную, самодостаточную и исполняемую `Idea` со всеми разрешёнными ссылками.

Этот механизм позволяет `Idea` становиться модульными и многократно используемыми строительными блоками, предотвращая дублирование данных и позволяя создавать сложные системы из более простых, версионированных компонентов.

## 2. Основная концепция: Разрешение как Idea Transformer

Сервис Resolver функционирует как `Idea Transformer` без сохранения состояния, который обогащает `Idea`, извлекая и встраивая её зависимости.

- **Входные данные**: `Idea`, чьи `schema` или `context` содержат одну или несколько ссылок на другие `Idea`.
- **Процесс**: Решатель анализирует входную `Idea` для выявления этих ссылок. Для каждой ссылки он запрашивает настроенный набор сервисов `Storage` для получения соответствующего содержимого `Idea`. Затем он разумно вставляет содержимое полученных `Idea` в исходную.
- **Выходные данные**: Новая, «наполненная» `Idea`, в которой все ссылки заменены их разрешённым содержимым, что делает её полной, самодостаточной единицей, готовой к выполнению или дальнейшей обработке.

## 3. Ключевые характеристики

### 3.1. Синтаксис ссылок

Хотя конкретная реализация может варьироваться, ссылки должны быть выражены в ясном, однозначном URI-подобном формате. Этот формат должен позволять указывать уникальное имя `Idea`, а также необязательную версию или ветку.

_Пример: Схема, составляющая несколько `Idea` с использованием `allOf`._

```json
{
  "type": "object",
  "allOf": [
    { "$ref": "idea://my-org/article-template?version=1.2.0" },
    { "$ref": "idea://my-org/system-prompts/chain-of-thought?branch=latest" }
  ]
}
```

### 3.2. Глубокое (рекурсивное) разрешение

Процесс разрешения является рекурсивным. Если разрешённая `Idea` сама содержит дальнейшие ссылки, Решатель будет продолжать извлекать и встраивать их до тех пор, пока весь граф зависимостей не будет разрешён, что приведёт к финальной `