# 014: Агент/Области видимости

> [!DEFINITION] [Область видимости](./000_glossary.md)
> Механизм, который делает контролируемое подмножество контекста из родительской среды доступным для выполнения. Свойство `_scopes` действует как список разрешений, определяя сфокусированное и безопасное представление данных, к которым может получить доступ :term[Вызов]{canonical="Call"}.

> Sidenote:
> - Требуется:
>   - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Паттерн **:term[Ограниченного контекста]{canonical="scope"}** — это фундаментальный механизм для управления контекстом, доступным :term[Вызову]{canonical="Call"}. В сложной агентной системе :term[Вызов]{canonical="Call"} редко выполняется в вакууме; ему часто требуется доступ к информации из родительской среды, такой как ввод пользователя, текущее :term[состояние]{canonical="state"} или результаты предыдущих шагов. Ограниченный контекст предоставляет безопасный и явный способ контролировать этот поток информации.

Ограничивая контекст, области видимости повышают безопасность, предотвращают случайную утечку данных и фокусируют LLM, что приводит к более предсказуемым и экономичным выполнениям. Этот контролируемый контекст также является ключом к модульности, позволяя таким компонентам, как :term[Идеи]{canonical="Idea"} и :term[Действия]{canonical="Activity"}, быть по-настоящему автономными и многократно используемыми. В этом документе объясняется, как работает этот паттерн и как он сочетается с другими возможностями агента.

## Предоставление и запрос контекста

Схема свойства `_scopes` определяет, статически ли контекст **предоставляется** или динамически **запрашивается** во время выполнения.

> Sidenote:
> ```mermaid
> graph TD
>     subgraph Родительский контекст
>         direction LR
>         input("входные данные")
>         state("состояние")
>     end
>
>     subgraph Вызов инструмента
>         direction LR
>         filter{{"_scopes: ['input']"}}
>     end
>
>     input --> filter
>     state -.-> filter
>
>     subgraph Предоставленный контекст
>         Execute(Выполнить инструмент)
>     end
>
>     filter --> HITL{{Одобрение человеком}}
>     HITL --> Execute
>
>     classDef unused stroke-dasharray: 5, 5, stroke:#aaa, color:#aaa
>     class state unused
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

- **Статические области видимости (Предоставление контекста)**: Схема `_scopes` может быть значением `const`, что означает, что контекст **предоставляется**. Разработчик жестко задает точный контекст, который разрешено видеть инструменту.

  ```json
  {
    "_scopes": {
      "const": ["input"]
    }
  }
  ```

- **Динамические области видимости (Запрос контекста)**: Схема `_scopes` может быть более гибкой, позволяя контексту быть **запрошенным**. LLM решает, какие из доступных областей видимости ей нужны для генерации :term[Вызова]{canonical="Call"}.

  ```json
  {
    "_scopes": {
      "type": "array",
      "items": {
        "enum": ["state", "input"]
      }
    }
  }
  ```

  Этот динамический паттерн особенно эффективен в сочетании с системой утверждения с участием человека, обеспечивая критически важный уровень прозрачности и контроля.

## Роль областей видимости в композиции вызовов

Свойство `_scopes` является основным механизмом контроля контекста, доступного :term[Вызову]{canonical="Call"}. Оно действует как список разрешений, фильтруя родительскую среду для предоставления сфокусированного, ограниченного поля зрения для выполнения. Этот контролируемый контекст является основополагающим для обработки :term[Вызова]{canonical="Call"}, и его роль адаптируется для поддержки композиционной модели выполнения, где могут сочетаться различные возможности, такие как явная логика, :term[экземплирование]{canonical="instancing"} и модульность.

- **Скрытое выполнение**: При скрытом выполнении по умолчанию `_scopes` служат «подсказкой» для фокусировки внимания LLM на релевантных частях родительского контекста. Это скорее рекомендация, а не строгий фильтр, но она крайне важна для повышения надежности и экономической эффективности рассуждений LLM за счет уменьшения шума от нерелевантных данных. См. пример [Устранение неоднозначности с помощью областей видимости](#example-disambiguation-with-scopes).

  > Sidenote:
  > - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}.

- **Явное выполнение (`_activity`)**: Когда :term[Вызов]{canonical="Call"} подкреплен детерминированным :term[Действием]{canonical="Activity"}, роль областей видимости становится более прямой. Ограниченный контекст передается целиком в функцию :term[Действия]{canonical="Activity"} в качестве дополнительного параметра. Это дает :term[Действию]{canonical="Activity"} полный доступ к необходимым контекстным данным, даже если эти данные не были напрямую использованы LLM для генерации основных параметров :term[Вызова]{canonical="Call"}. См. пример [Предоставление контекста действию](#example-providing-context-to-an-activity).

  > Sidenote:
  > - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.

- **:term[Экземплирование]{canonical="Instancing"} (`_instance`)**: В запросе с несколькими :term[экземплярами]{canonical="instance"}, где агент обрабатывает пакет схожих объектов данных, области видимости начинают учитывать :term[экземпляры]{canonical="instance"}. Протокол гарантирует, что :term[Вызов]{canonical="Call"}, нацеленный на конкретный :term[экземпляр]{canonical="instance"}, получает контекст только для _этого_ :term[экземпляра]{canonical="instance"}. Это критически важно для поддержания целостности данных и предотвращения «утечки» контекста между параллельными выполнениями.

  > Sidenote:
  > - :term[012: Агент/Экземплирование]{href="./012_agent_instancing.md"}

- **Изоляция через делегирование (`_delegate`)**: Когда :term[Вызов]{canonical="Call"} делегируется внешнему :term[Делегату]{canonical="Delegate"}, области видимости выступают в роли стражей контекста. Они определяют, что из родительской среды _добавляется_ к собственному внутреннему контексту :term[делегата]{canonical="delegate"}, создавая окончательный контекст для изолированного подзапроса. Ничего из родительского контекста недоступно, если оно явно не указано в области видимости, что обеспечивает настоящую инкапсуляцию. См. примеры [Ограничение контекста делегата](#example-scoping-a-delegates-context) и [Экземплирование с ограниченными делегатами](#example-instancing-with-scoped-delegates).

  > Sidenote:
  > - :term[013: Агент/Делегат]{href="./013_agent_delegate.md"}

Свойство `_scopes` — это мост, который позволяет :term[Вызову]{canonical="Call"} получать контекст. Эта глава показала, как этот единый механизм адаптируется к различным режимам выполнения — от мягкого направления скрытого вызова до строгого определения всего контекста для делегированного. Именно эта гибкость делает его краеугольным камнем в построении сложных, безопасных и модульных агентных систем.

## Примеры

:::::details{title="Пример: Устранение неоднозначности с помощью областей видимости"}

::::columns
:::column{title="Неоднозначный контекст"}

В этом примере контекст неоднозначен. Он содержит двух разных пользователей: `currentUser` в состоянии и `mentionedUser` во входных данных. Агенту нужно отправить сообщение, но неясно, кому.

```json
[
  {
    "type": "state",
    "currentUser": { "id": "user_A", "name": "Alice" }
  },
  {
    "type": "input",
    "mentionedUser": { "id": "user_B", "name": "Bob" },
    "instruction": "Send a welcome message to the user mentioned above."
  }
]
```

:::
:::column{title="`Вызов` с областью видимости"}

Добавляя `_scopes: ["input"]`, вызывающий дает важную подсказку. Это указывает LLM сосредоточиться на входном сообщении, эффективно разрешая неоднозначность и гарантируя, что сообщение будет отправлено правильному получателю, Бобу.

```json
{
  "_tool": "sendMessage",
  "_scopes": ["input"],
  "recipientId": "user_B",
  "message": "Welcome, Bob!"
}
```

:::
::::
:::::

:::::details{title="Пример: Предоставление контекста действию"}

Здесь :term[Действию]{canonical="Activity"} требуется доступ к контекстной информации, которая не является прямым параметром инструмента. Инструмент `logEvent` принимает только `eventName`, но для правильной работы базовому действию также необходимо знать `userId`.

::::columns
:::column{title="`Вызов` с областью видимости"}

:term[Вызов]{canonical="Call"} прост и предоставляет только `eventName`. Однако свойство `_scopes: ["state"]` указывает движку выполнения передать объект состояния действию.

```json
{
  "_tool": "logEvent",
  "_scopes": ["state"],
  "eventName": "user_login"
}
```

:::
:::column{title="Реализация действия (TypeScript)"}

:term[Действие]{canonical="Activity"} регистрируется с функцией, которая деструктурирует свои параметры непосредственно из вызова и ограниченного контекста. Это обеспечивает чистый, прямой доступ как к `eventName`, так и к `userId`.

```typescript
// Параметры деструктурируются для прямого доступа к 'eventName'
// из вызова и 'state' из ограниченного контекста.
Activity.register('logEvent', async ({ eventName }, { state }) => {
  const userId = state.userId;
  await analytics.track(eventName, { userId });
});
```

:::
::::
:::::

:::::details{title="Пример: Ограничение контекста делегата"}

При делегировании `_scopes` определяют, что из родительского контекста _добавляется_ к собственному внутреннему контексту делегата. Здесь высокоуровневый Оркестратор делегирует задачу, передавая весь объект состояния специализированному делегату-Суммаризатору.

::::columns
:::column{title="Родительский `Вызов` с областью видимости"}

Агент-Оркестратор имеет собственный контекст. Он делает :term[Вызов]{canonical="Call"}, который ограничивает состояние для включения в контекст делегата.

```json
// Контекст и вызов Оркестратора
[
  {
    "type": "state",
    "articleText": "A long and complex article..."
  },
  {
    "_tool": "summarizeArticle",
    "_delegate": "SummarizerAgent",
    "_scopes": ["state"]
  }
]
```

:::
:::column{title="Контекст подзапроса делегата"}

Среда выполнения Суммаризатора состоит из его собственного внутреннего контекста плюс данных, ограниченных из родительского контекста. Это обеспечивает модульность, предоставляя при этом необходимую информацию.

```json
// Контекст, созданный для подзапроса Суммаризатора
[
  // Внутренний контекст Суммаризатора
  {
    "type": "system",
    "message": "You are an expert summarizer."
  },
  // Ограниченный контекст из родителя добавляется
  {
    "type": "state",
    "articleText": "A long and complex article..."
  }
]
```

:::
::::
:::::

:::::details{title="Пример: Экземплирование с ограниченными делегатами"}

Этот пример показывает, как `_scopes` и `_instance` сочетаются, позволяя одному агенту организовывать несколько изолированных вызовов делегатов параллельно.

::::columns
:::column{title="Родительский контекст и решение"}

У родительского агента есть два разных :term[экземпляра]{canonical="instance"} :term[Состояния]{canonical="State"}. Он генерирует решение с двумя :term[Вызовами]{canonical="Call"} к `translatorDelegate`. Каждый вызов нацелен на свой :term[экземпляр]{canonical="instance"} и правильно ограничивает только :term[состояние]{canonical="state"} для этого :term[экземпляра]{canonical="instance"}.

```json
// РОДИТЕЛЬСКИЙ КОНТЕКСТ
[
  { "type": "state", "_instance": "①", "text": "Hello" },
  { "type": "state", "_instance": "②", "text": "Bonjour" }
]

// РЕШЕНИЕ LLM
{
  "calls": [
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "①",
      "_scopes": ["state"]
    },
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "②",
      "_scopes": ["state"]
    }
  ]
}
```

:::
:::column{title="Контексты подзапросов делегатов"}

Движок выполнения создает два независимых подзапроса. Свойства `_instance` и `_scopes` работают вместе, чтобы каждый делегат получил только свое собственное, правильно ограниченное :term[состояние]{canonical="state"}.

```json
// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ①
[
  { "type": "system", "message": "You are a translator." },
  { "type": "state", "text": "Hello" }
]

// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ②
[
  { "type": "system", "message": "You are a translator." },
  { "type": "state", "text": "Bonjour" }
]
```

:::
::::
:::::
