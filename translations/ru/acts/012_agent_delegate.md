# 012: Агент/Делегат

> [!DEFINITION] [Делегат](./000_glossary.md)
> Протокол для изоляции контекста выполнения. Он вызывается через свойство `_delegate` в `Call` и исполняет `Activity` или новый `Request` в изолированной среде («clean room»), а свойство `_scopes` предоставляет контролируемый доступ к родительскому контексту.

> Sidenote:
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [013: Агент/Области видимости](./013_agent_scopes.md)

Хотя в предыдущих документах было описано, как определяются и исполняются отдельные `Tools`, **протокол делегирования** решает критическую задачу масштабирования и композиции этих возможностей. Он предоставляет мощный механизм для исполнения `Tools` в изолированных средах («clean rooms»), что предотвращает смешение контекста и обеспечивает настоящую переиспользуемость. Делегируя `Call` внешнему делегату — будь то определение другого `Request` или `Activity` в подзапросе — система может создавать сложные агентские поведения из самодостаточных, независимо разработанных компонентов.

## Проблема: Монолитные инструменты и смешение контекста

По мере роста возможностей агента, определение всех `Tools` в едином монолитном контексте становится непрактичным.

1.  **Большие схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать за один запрос. Объединение множества сложных `Tools` может превысить эти лимиты, мешая LLM правильно обработать доступные варианты.
2.  **Смешение контекста**: Когда все `Tools` работают в одном контексте, LLM может попасть под влияние нерелевантной информации, что приводит к неверному выбору `Tool` или заполнению его параметров.
3.  **Отсутствие переиспользуемости**: `Tool`, определенный для одного агента, нелегко перенести к другому, не захватив с собой весь его контекст.

Протокол делегирования решает эти проблемы, вводя **область видимости делегата (Delegate Scope)** — способ делегировать `Call` во внешнюю, изолированную среду исполнения.

## Свойство `_delegate`

Область видимости делегата обозначается свойством `_delegate` в схеме (`schema`) `Tool`. Это свойство указывает системе рассматривать `Call` не как встроенную операцию, а как запрос к внешнему делегату.

Свойство `_delegate` является строкой (`string`) и может использоваться двумя способами:

- **Ссылка на сохраненный `Request`**: Строка может быть путем или URL к JSON-файлу, который определяет самодостаточный `Request` — JSON-объект, содержащий свойства `context` и `schema`. Это позволяет `Tool` делегировать свое исполнение совершенно отдельному набору инструкций.

  > Sidenote:
  > Сохраненный, переиспользуемый [001: Агент/Запрос](./001_agent_request.md) является наиболее распространенной формой `Идеи`. Протокол делегирования — это основной механизм для композиции этих `Идей` в более сложные системы. Подробнее см. в [101: Концепция/Идея](./101_concept_idea.md).

- **Создание анонимного делегата**: Строковый литерал `'anonymous'` указывает на анонимного делегата. Это используется для создания изолированной среды исполнения для вызова `Tool Call` (скрытого или явного) без необходимости в промежуточном JSON-файле. Он автоматически создает новую, пустую область контекста для `Call`.

## Исполнение в изолированной среде

Делегат предоставляет «чистую комнату» (clean room) для исполнения. Вместо того чтобы работать в перегруженном контексте родительского агента, `Call` обрабатывается в новом, изолированном подзапросе. Контекст для этого подзапроса создается тщательно, а не наследуется.

Именно здесь [Протокол областей видимости](./013_agent_scopes.md) становится критически важным. Свойство `_scopes` в схеме `Tool` действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в изолированную среду делегата. Это дает родительскому агенту точный контроль над тем, что может видеть делегат, предотвращая смешение контекста и обеспечивая настоящую инкапсуляцию.

> Sidenote:
> - [013: Агент/Области видимости](./013_agent_scopes.md)

## Обработка больших схем

Протокол делегирования также предлагает решение для управления `Tools` с очень большими или сложными схемами вывода. Вместо включения огромной схемы `_output` в основной запрос, что потенциально может вытеснить другие инструменты, `Tool` можно определить только с его входными параметрами (`input`) и указателем `_delegate`.

LLM может спланировать `Call`, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе делегата. Это позволяет агенту рассуждать о последовательности сложных операций, не «видя» всю подробную схему для каждого шага в одном окне контекста. LLM доверяет, что делегат произведет правильный вывод, который она получит и использует на последующих шагах.

## Стратегии разрешения делегатов

`Tool` становится `Delegate`, просто включая свойство `_delegate` в свою схему. Это сигнализирует о том, что `Call` должен быть делегирован. Ключевой вопрос в том, _когда_ это делегирование разрешается. Система поддерживает две стратегии, позволяя найти компромисс между строгой безопасностью и динамической гибкостью.

### 1. Разрешение во время исполнения (по умолчанию)

Подход по умолчанию и самый гибкий — разрешать делегата во **время исполнения**, после того как агент уже сгенерировал `Call`.

Этот метод открывает мощную парадигму, невозможную в традиционном коде: **LLM действует как интеллектуальный «склеивающий» слой.** Агент может сгенерировать `Call` с параметрами, которые не идеально соответствуют ожидаемой схеме `input` делегата. Во время исполнения система собирает контекст делегата и предоставленные вызывающей стороной входные данные, и на LLM в подзапросе ложится задача преодолеть этот разрыв.

Это значительное преимущество, поскольку оно позволяет делегатам обновляться и развиваться независимо. Даже если делегат изменит структуру своих входных данных, вызывающие его агенты не сломаются немедленно. LLM попытается адаптировать старый формат `Call` к новой схеме `input`, обеспечивая уровень устойчивости и слабой связности, уникальный для этой архитектуры.

Процесс выглядит следующим образом:

1.  Агент генерирует `Call` к модульному `Tool`.
2.  Исполнитель видит свойство `_delegate` и инициирует протокол.
3.  **Сборка контекста**: Исполнитель получает файл определения делегата (если он не анонимный) и собирает базовый контекст. Затем он использует `_scopes`, чтобы добавить контекст вызывающей стороны.
4.  **Сопоставление ввода**: `params` из `Call` упаковываются во `Входное сообщение` и добавляются в контекст. Именно здесь проявляется «склеивающая» способность LLM, поскольку она будет использовать эти входные данные для выполнения логики делегата, даже если схемы не совпадают идеально.
5.  **Исполнение**: Создается новый изолированный `Request` с объединенным контекстом. Результат возвращается как вывод исходного `Call`.

### 2. Предварительное разрешение (опционально)

Для сценариев, требующих более строгих гарантий, делегат может быть разрешен **предварительно**, до того как начальный `Request` будет отправлен агенту.

В этом режиме система предварительно загружает определение `Request` делегата и объединяет его схему `input` со схемой параметров `Tool`. Это позволяет LLM агента видеть точные требования делегата с самого начала, гарантируя, что сгенерированный `Call` будет идеально сформирован и типобезопасен. Важно отметить, что это предварительное слияние может также включать схему `_output` делегата, обеспечивая строгий контракт для ожидаемого результата.

Этот подход обеспечивает безопасность традиционных контрактов API, где и входы, и выходы известны и проверены. Он жертвует гибкостью разрешения во время исполнения и лучше всего подходит для критически важных, четко определенных интеграций, где слабая связность не является желаемой особенностью.

## Композиция и переиспользуемость: Композитор и Звукорежиссер

Делегаты обеспечивают мощную композицию, позволяя определениям `Request` действовать как автономные сервисы, которые могут быть оркестрованы другими агентами. Это создает ясную, динамическую иерархию: высокоуровневые агенты могут сосредоточиться на оркестрации, делегируя специализированные задачи низкоуровневым, переиспользуемым делегатам.

Рассмотрим рабочий процесс с двумя специализированными делегатами: **`Композитор`** и **`Звукорежиссер`**.

- **`Звукорежиссер`** — это низкоуровневый эксперт. Это самодостаточное определение `Request`, сфокусированное на физике звука и знающее, как управлять синтезаторами для создания конкретных аудиоданных.

- **`Композитор`** — это специалист среднего уровня. Его основная задача — создать песню. Он использует свои собственные встроенные инструменты для генерации мелодии и музыкальной структуры. Чтобы реализовать свое видение, он затем делает вызовы (`Calls`) к делегату `Звукорежиссер` для синтеза реальных звуков.

Эта двухуровневая иерархия является распространенным шаблоном. Однако истинная мощь делегатов заключается в их динамической, управляемой задачами композиции.

Теперь давайте введем высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую запись. В зависимости от конкретной задачи, `Продюсер` может оркестровать своих делегатов по-разному:

> Sidenote:
> Такая схема обеспечивает гибкую оркестрацию. Высокоуровневый `Продюсер` может делегировать задачу `Композитору`, который, в свою очередь, использует `Звукорежиссера`. Однако `Продюсер` также может обойти `Композитора` и взаимодействовать с `Звукорежиссером` напрямую для выполнения конкретных задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> SoundDesigner(Звукорежиссер)
>     Композитор --> SoundDesigner(Звукорежиссер)
> ```

- **Иерархическая оркестрация**: Для создания песни `Продюсер` может сделать один `Call` к делегату `Композитор`. `Продюсер` дает высокоуровневое указание («Мне нужна грустная баллада»), а `Композитор` выполняет весь свой внутренний рабочий процесс, включая свои собственные вложенные вызовы (`Calls`) к `Звукорежиссеру`. В этом случае `Продюсеру` не нужно знать о существовании `Звукорежиссера`.

- **Параллельная оркестрация**: Если `Продюсеру` также нужны конкретные звуковые эффекты для записи (например, фоли-шумы или эмбиент), он может делать вызовы (`Calls`) напрямую к делегату `Звукорежиссер` для этих задач, параллельно со своим вызовом к `Композитору`.

Это демонстрирует ключевой принцип: композиция не является фиксированной внутри самих инструментов. `Продюсер` может по своему усмотрению рассматривать `Композитора` как черный ящик или взаимодействовать с его составными частями (`Звукорежиссер`) напрямую, в зависимости от потребностей момента. Эта гибкость позволяет комбинировать один и тот же набор экспертных делегатов в различных аранжировках, создавая глубоко композитную и эмерджентную систему.

## От делегатов к памяти

Делегаты обеспечивают мощную инкапсуляцию для дискретных возможностей, но сложные, многошаговые рабочие процессы требуют памяти. Агенту нужен способ поддерживать постоянное состояние между вызовами (`Calls`), чтобы отслеживать прогресс, учиться на предыдущих результатах и выполнять долгосрочные планы. Это мост от изолированных действий к последовательному, состоятельному исполнению.

Следующий документ, [009: Агент/Состояние](./009_agent_state.md), описывает протокол для управления этим постоянным состоянием.
