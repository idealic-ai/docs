# 801: Пакет/Агент

> [!DEFINITION] [Агент](./000_glossary.md)
> Эталонная реализация протоколов **:term[Актов Становления]{canonical="Acts of Emergence"}**. Она предоставляет среду исполнения для выполнения управляемых схемами, :term[ИИ-центричных]{canonical="AI-Native"} рабочих процессов, от атомарных :term[Запросов]{canonical="Request"} до сложных, сохраняющих состояние :term[Агентов]{canonical="Agent"}.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Agent/Request"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Agent/Loop"}

Библиотека `@augceo/agent` — это каноническая реализация агентной архитектуры, определённой в :term[Актах]{canonical="Acts"}. В отличие от фреймворков, которые отдают приоритет инженерии промптов, эта библиотека ставит во главу угла **соблюдение протокола**. Она реализует строгий конечный автомат, где каждое взаимодействие строго типизировано, управляется схемой и является уникальным.

## Акты (RFC)

Эта библиотека создана непосредственно на основе спецификаций, определённых в **:term[Актах]{canonical="Acts"}**. Каждая функция соответствует определённому документу протокола.

Эта модульная архитектура спроектирована для **компонуемости и расширяемости**. Вместо монолитного фреймворка, каждый :term[Акт]{canonical="Act"} определяет отдельную возможность. Вы можете подключать только те функции, которые вам нужны — будь то простое использование :term[Инструментов]{canonical="Tool"} или сложная многоагентная система с сохранением состояния и делегированием.

### Основные Примитивы

- **:term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Agent/Request"}**: Атомарная единица вычислений.
  - Преобразует :term[Контекст]{canonical="Context"} + :term[Схему]{canonical="Schema"} в структурированное :term[Решение]{canonical="Solution"}.
  - Поддерживает **мультиплексирование** (создание нескольких решений одновременно).
  - Служит основой для всех поведений агентов более высокого уровня.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md" canonical="Agent/Tool"}**: Определение возможности в виде схемы.
  - Определяет **интерфейс** для действий отдельно от их реализации.
  - Позволяет LLM выбирать поведение на основе структурированных метаданных.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md" canonical="Agent/Activity"}**: Явная, детерминированная реализация :term[Инструмента]{canonical="Tool"} в виде кода.
  - Связывает абстрактные схемы :term[Инструментов]{canonical="Tool"} с реальным кодом.
  - Поддерживает паттерн **Двойного Реестра** (отделение интерфейса от реализации).
- **:term[004: Агент/Вызов]{href="./004_agent_call.md" canonical="Agent/Call"}**: Конкретный экземпляр использования :term[Инструмента]{canonical="Tool"}.
  - Представляет собой параметризованный запрос на выполнение.
  - Служит стандартизированным транспортом между намерением LLM и действием системы.

### Данные и Состояние

- **:term[005: Агент/Данные]{href="./005_agent_data.md" canonical="Agent/Data"}**: Протокол для структурированной информации в контексте.
  - Предоставляет единую оболочку для всех постоянных сообщений контекста.
  - Обеспечивает структурированное слияние информации.
- **:term[006: Агент/Ввод]{href="./006_agent_input.md" canonical="Agent/Input"}**: Превращает общий :term[Запрос]{canonical="Request"} в повторно используемую функцию.
  - Определяет строгие **входные параметры** для :term[Запроса]{canonical="Request"}.
  - Обеспечивает автоматическую генерацию UI и типобезопасный вызов.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md" canonical="Agent/State"}**: Постоянная память, которая сохраняется между шагами.
  - Выступает в роли **общей рабочей области** для цикла выполнения.
  - Обеспечивает возобновление и рабочие процессы с сохранением состояния.
- **:term[016: Агент/Мета]{href="./016_agent_meta.md" canonical="Agent/Meta"}**: Управляет идентификацией и происхождением.
  - Отслеживает **версионирование, ветвление и происхождение**.
  - Позволяет агентам автономно развиваться и обновлять свои версии.

### Связывание и Поток

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md" canonical="Agent/Variables"}**: Динамические ссылки.
  - Использует синтаксис `†kind.path` для связывания выходов со входами.
  - Позволяет :term[Инструментам]{canonical="Tool"} **читать** из контекста, не копируя данные.
- **:term[008: Агент/Вывод]{href="./008_agent_output.md" canonical="Agent/Output"}**: Механизм записи результата.
  - Использует `_outputPath` для указания, куда следует сохранить результат :term[Инструмента]{canonical="Tool"}.
  - Обеспечивает **цепочки** операций через состояние.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md" canonical="Agent/Expressions"}**: Логика в потоке данных.
  - Поддерживает **ветвление** (`||`) для резервной или условной логики.
  - Поддерживает **разветвление** (`&&`) для параллельного распределения данных.

### Оркестрация

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Agent/Loop"}**: Движок исполнения.
  - Повторяет :term[Запросы]{canonical="Request"} до достижения цели.
  - Управляет циклом обратной связи: генерация вызовов, их выполнение и обновление контекста.
- **:term[012: Агент/План]{href="./012_agent_plan.md" canonical="Agent/Plan"}**: Декларативная стратегия.
  - Представляет рабочий процесс в виде **графа потока данных** из :term[Вызовов Инструментов]{canonical="Tool Call"}.
  - Разделяет **планирование** (рассуждение) и **исполнение** (действие).
- **:term[013: Агент/Экземплирование]{href="./013_agent_instancing.md" canonical="Agent/Instancing"}**: Масштабирование параллельного выполнения.
  - Группирует сообщения по ID `_instance` для запуска параллельных контекстов.
  - Масштабирует один :term[План]{canonical="Plan"} на неограниченное количество элементов данных.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md" canonical="Agent/Delegate"}**: Модульная композиция.
  - Изолирует выполнение в **изолированных подзапросах**.
  - Позволяет вкладывать агентов в агентов (:term[Агенты]{canonical="Agent"} как :term[Инструменты]{canonical="Tool"}).
- **:term[015: Агент/Области]{href="./015_agent_scopes.md" canonical="Agent/Scopes"}**: Контроль контекста.
  - Использует `_scopes` для строгого определения данных, которые видит :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает утечку контекста и повышает безопасность.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md" canonical="Agent/Advisor"}**: Структурированное обсуждение.
  - Внедряет определённые персоны для рассуждения **перед** действием.
  - Обеспечивает взвешенное голосование и стратегическое руководство для основного агента.

## Концепции

В то время как :term[Акты]{canonical="Acts"}, описанные выше, определяют _механизмы_, следующие концепции определяют _философию_ архитектуры:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md" canonical="Concept/Latent"}**: По умолчанию — "Без кода".
  - Если у :term[Инструмента]{canonical="Tool"} нет зарегистрированного :term[Действия]{canonical="Activity"}, :term[Агент]{canonical="Agent"} по умолчанию использует **скрытое исполнение**.
  - Он использует внутренние рассуждения LLM («скрытое пространство») для имитации вывода инструмента.
  - Это позволяет вам прототипировать сложные рабочие процессы, используя только схемы, и добавлять код только при необходимости.

- **Единство Планирования и Исполнения**:
  - В этой архитектуре **планирование — это исполнение**.
  - :term[Агент]{canonical="Agent"} не создаёт статический план, чтобы затем его выполнить.
  - На каждом шаге он генерирует _новый_ :term[План]{canonical="Plan"} (следующий шаг), эффективно перепланируя свои действия на основе последнего :term[Состояния]{canonical="State"}.

- **Человек в цикле (HITL)**:
  - :term[Агент]{canonical="Agent"} предоставляет колбэк `confirm()`.
  - Это позволяет хост-системе перехватывать, проверять и одобрять каждый **:term[Вызов Инструмента]{canonical="Tool Call"}** перед его выполнением.
  - Если человек отклоняет или изменяет вызов, обратная связь возвращается агенту для корректировки его плана.

- **Восстановление после ошибок**:
  - Ошибки не являются фатальными. Если :term[Инструмент]{canonical="Tool"} вызывает исключение, оно фиксируется как **Сообщение об ошибке** в контексте.
  - :term[Агент]{canonical="Agent"} «видит» сбой на следующем шаге и использует свои рассуждения для самокоррекции (например, повторяет попытку с другими параметрами или выбирает альтернативную стратегию).

## Агент vs. Запрос

Библиотека различает низкоуровневый **:term[Запрос]{canonical="Request"}** и высокоуровневого **:term[Агента]{canonical="Agent"}**.

### Запрос (Низкий уровень)

:term[Запрос]{canonical="Request"} — это единая, атомарная транзакция с LLM. Он предполагает соотношение 1:1 между входным контекстом/схемой и выходным решением.

- **Управление:** Он не цикличен. Выполняет ровно один шаг генерации.
- **Мультиплексирование:** Поддерживает создание нескольких кандидатов в решения из одного и того же контекста (через параметр `n`).
- **Стриминг и Колбэки:** Предоставляет механизм `callbackPath`. Это позволяет системе перехватывать и обрабатывать определённые части структуры (например, `calls`) по мере их потоковой передачи, обеспечивая выполнение инструментов в реальном времени, пока LLM всё ещё генерирует оставшуюся часть ответа.

### Агент (Высокий уровень)

:term[Агент]{canonical="Agent"} — это **Цикл Исполнения**, который организует последовательность :term[Запросов]{canonical="Request"}.

- **Цикличность:** Он многократно вызывает :term[Запросы]{canonical="Request"}, выполняя полученные :term[Вызовы Инструментов]{canonical="Tool Call"} и возвращая результат обратно в контекст.
- **Завершение:** Он продолжает циклически работать до тех пор, пока система не решит записать окончательный `output`.
- **Сходимость:** По соглашению, желаемая схема результата пользователя оборачивается в свойство `output`, которое может быть null. Цикл считает свою работу завершённой только тогда, когда это свойство заполнено.

### Единая структура вывода

Чтобы избежать двойственности между двумя режимами, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} нормализуют свой вывод. Пользовательская схема всегда оборачивается в свойство `output`.

- **Запрос:** Возвращает `Data<T>[]` (массив решений, обычно кортеж из 1 элемента).
- **Агент:** Возвращает `Data<T>` (конечное сошедшееся состояние).

## Видение Типобезопасности

Эта библиотека использует **:term[Схимию]{canonical="Schemistry"}**, чтобы обеспечить сквозную типобезопасность без генерации кода. Цель состоит в том, чтобы типы TypeScript идеально отражали трансформации, применяемые конвейером агента во время выполнения.

### Проблема

В агентной системе итоговая схема, отправляемая в LLM, редко является просто тем, что определил пользователь. Это **композиция** из:

1. Схемы пользователя (цель).
2. Системных функций (:term[Вызовы Инструментов]{canonical="Tool Call"}, :term[Советники]{canonical="Advisor"}, Мета-свойства).

Эти функции включаются **Обработчиками Сообщений**. Например, добавление сообщения :term[Советника]{canonical="Advisor"} в контекст запускает обработчик, который добавляет массив `advisors` в итоговую схему вывода.

### Решение: Конвейер Редукции Типов

Мы представляем себе конвейер системы типов, который отражает логику времени выполнения. Подобно тому, как обработчики сообщений преобразуют JSON-схему во время выполнения, они также должны **редуцировать и преобразовывать выведенный тип TypeScript**.

Процесс работает следующим образом:

1. **Вывод типа:** Схема пользователя преобразуется в тип `T` через `FromSchema<S>`.
2. **Редукция:** Каждый активный Обработчик Сообщений оборачивает или изменяет `T`.
   - _Обработчик Advisor:_ Добавляет `{ advisors: Advisor[] }`
   - _Обработчик Tool:_ Добавляет `{ calls: Call[] }`
   - _Обработчик Meta:_ Добавляет `{ meta: Meta }`
3. **Реконструкция:** Конечный тип является строгим пересечением намерения пользователя и возможностей системы.

### Расширяемость

Эта архитектура спроектирована как открытая.

- **Пользовательские Обработчики:** Пользователи могут регистрировать собственные обработчики сообщений. Эти обработчики могут изменять схему (во время выполнения) и участвовать в редукции типов (во время компиляции).
- **Реестр Инструментов:** :term[Инструменты]{canonical="Tool"} регистрируются глобально через `Tool.register`. Это определяет _интерфейс_ возможности.
- **Реестр Действий:** Реализации регистрируются через `Activity.register`. Это определяет _логику выполнения_ (код) для инструмента.
- **Реестр Советников:** (Планируется) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, что позволит подключать определённые персоны и модели рассуждений к любому агенту.
- **Реестр Схем:** Схемы можно регистрировать через :term[Схимию]{canonical="Schemistry"} и ссылаться на них с помощью `$ref` (например, `"$ref": "MySchema"`), что позволяет повторно использовать типы в системе.
- **Пресеты:** Повторно используемые конфигурации, объединяющие сообщения, трансформеры и настройки. Пресеты можно регистрировать через `Preset.register` и вызывать декларативно в потоке сообщений, используя `{ type: 'preset', preset: 'Name' }`. Это позволяет создавать мощные композиции поведений агентов (например, «Совет» советников или определённую игровую персону) без сложного кода настройки.

Рассматривая схему как единственный источник истины и позволяя системе типов следовать за ней, мы гарантируем, что если код компилируется, он соответствует протоколу.

## Видение Наблюдаемости и Стандартизации

Мы стремимся к строгой стандартизации операционных аспектов выполнения агентов, обеспечивая согласованность между различными поставщиками LLM.

### Нормализация Токенов

Разные провайдеры по-разному сообщают об использовании. Мы планируем нормализовать эту статистику в единый интерфейс, который отслеживает:

- **Входные Токены**: Использование окна контекста.
- **Выходные Токены**: Сгенерированный контент.
- **Токены Мышления**: Бюджеты для рассуждений в режиме "цепочки мыслей".

### Доступ к Процессу Мышления

По мере того как модели всё чаще предоставляют доступ к своим внутренним рассуждениям (CoT), мы рассматриваем это как первоклассный элемент протокола:

- **Доступ**: Предоставление необработанного потока процесса мышления на уровень приложения.
- **Бюджетирование**: Стандартизация параметров «бюджета на мышление» между провайдерами, что позволяет агентам запрашивать определённую глубину рассуждений независимо от базовой модели.

## Архитектура с учётом Кэша

Мы вводим явную поддержку **Кэширования Контекста**, чтобы значительно снизить задержку и стоимость для долго работающих агентов.

### Метрики Токенов

Мы будем отслеживать специфичные метрики использования кэша для количественной оценки экономии:

- **Токены, прочитанные из кэша**: Токены, полученные из кэша.
- **Токены, записанные в кэш**: Новые токены, добавленные в кэш.

### Оптимизация только для добавления

Для максимального использования **Префиксного Кэширования** библиотека вводит специальные режимы работы, которые избегают инвалидации кэша:

- **Добавление вместо перезаписи**: Предпочтение добавления новых дельт :term[Данных]{canonical="Data"} или :term[Сообщений]{canonical="Message"} вместо замены всего контекста.
- **Логика слияния**: Использование естественного поведения слияния :term[Данных]{canonical="Data"} и :term[Советников]{canonical="Advisor"} для аддитивного обновления состояния.
- **Режим вывода**: Структурирование выводов для линейного расширения истории диалога.

### Управление Контекстом

Чтобы сбалансировать попадания в кэш и ограничения окна контекста, мы предоставим настраиваемое **Сжатие Контекста**:

- **Ленивое сжатие**: Оптимизированная процедура, которая сворачивает лог только для добавления в снимок только при необходимости, сохраняя префикс кэша как можно дольше.
- **Конфигурация**: Переключатель «Оптимизировано для кэша» для управления этим поведением в зависимости от конкретных требований к задержке/стоимости рабочей нагрузки.
