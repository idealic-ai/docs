# 801: Пакет/Агент

> [!DEFINITION] [:term[Агент]{canonical="Agent"}](./000_glossary.md)
> Эталонная реализация протоколов **:term[Актов Становления]{canonical="Acts of Emergence"}**. Она предоставляет среду выполнения для запуска :term[ИИ-центричных]{canonical="AI-Native"} рабочих процессов, управляемых схемами, от атомарных :term[Запросов]{canonical="Request"} до сложных :term[Агентов]{canonical="Agent"} с сохранением состояния.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md"}

Библиотека `@augceo/agent` — это каноническая реализация агентной архитектуры, определённой в :term[Актах]{canonical="Acts"}. В отличие от фреймворков, которые ставят во главу угла инженерию промптов, эта библиотека уделяет основное внимание **соблюдению протокола**. Она реализует строгую машину состояний, где каждое взаимодействие строго типизировано, управляется схемой и является отдельным.

## Акты (RFC)

Эта библиотека создана непосредственно на основе спецификаций, определённых в **:term[Актах]{canonical="Acts"}**. Каждая функция соответствует определённому документу протокола.

Эта модульная архитектура спроектирована для **компонуемости и расширяемости**. Вместо монолитного фреймворка каждый :term[Акт]{canonical="Act"} определяет отдельную возможность. Вы можете подключать только те функции, которые вам нужны — будь то простое использование :term[Инструментов]{canonical="Tool"} или сложная многоагентная система с сохранением состояния и делегированием.

### Основные Примитивы

- **:term[001: Агент/Запрос]{href="./001_agent_request.md"}**: Атомарная единица вычислений.
  - Преобразует `Context` + `Schema` в структурированное `Solution`.
  - Поддерживает **мультиплексирование** (одновременное создание нескольких решений).
  - Является основой для всех поведений агентов более высокого уровня.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md"}**: Определение возможности в виде схемы.
  - Определяет **интерфейс** для действий отдельно от их реализации.
  - Позволяет LLM выбирать поведения на основе структурированных метаданных.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md"}**: Явная, детерминированная реализация :term[Инструмента]{canonical="Tool"} в коде.
  - Связывает абстрактные схемы :term[Инструментов]{canonical="Tool"} с реальным кодом.
  - Поддерживает паттерн **Двойного Реестра** (разделение интерфейса и реализации).
- **:term[004: Агент/Вызов]{href="./004_agent_call.md"}**: Конкретный экземпляр использования :term[Инструмента]{canonical="Tool"}.
  - Представляет собой параметризованный запрос на выполнение.
  - Служит стандартизированным транспортом между намерением LLM и действием системы.

### Данные и Состояние

- **:term[005: Агент/Данные]{href="./005_agent_data.md"}**: Протокол для структурированной информации в контексте.
  - Предоставляет единую оболочку для всех постоянных сообщений контекста.
  - Позволяет структурированно объединять информацию.
- **:term[006: Агент/Ввод]{href="./006_agent_input.md"}**: Превращает общий :term[Запрос]{canonical="Request"} в повторно используемую функцию.
  - Определяет строгие **входные параметры** для :term[Запроса]{canonical="Request"}.
  - Позволяет автоматически генерировать пользовательский интерфейс и выполнять типобезопасные вызовы.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md"}**: Постоянная память, сохраняющаяся между несколькими шагами.
  - Служит **общим черновиком** для цикла выполнения.
  - Позволяет возобновлять работу и создавать рабочие процессы с сохранением состояния.
- **:term[016: Агент/Мета]{href="./016_agent_meta.md"}**: Управляет идентификацией и происхождением.
  - Отслеживает **версионирование, ветвление и источник**.
  - Позволяет агентам автономно развиваться и обновлять свои версии.

### Связывание и Поток

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md"}**: Динамические ссылки.
  - Использует синтаксис `†kind.path` для связывания выходов с входами.
  - Позволяет :term[Инструментам]{canonical="Tool"} **читать** из контекста без копирования данных.
- **:term[008: Агент/Вывод]{href="./008_agent_output.md"}**: Механизм записи результата.
  - Использует `_outputPath`, чтобы указать, где должен храниться результат :term[Инструмента]{canonical="Tool"}.
  - Позволяет **связывать** операции в цепочки через состояние.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md"}**: Логика в потоке данных.
  - Поддерживает **ветвление** (`||`) для резервной или условной логики.
  - Поддерживает **разветвление** (`&&`) для параллельного распределения данных.

### Орхестрация

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md"}**: Движок выполнения.
  - Повторяет :term[Запросы]{canonical="Request"} до тех пор, пока не будет достигнута цель.
  - Управляет циклом обратной связи: создание вызовов, их выполнение и обновление контекста.
- **:term[012: Агент/План]{href="./012_agent_plan.md"}**: Декларативная стратегия.
  - Представляет рабочий процесс в виде **графа потока данных** из :term[Вызовов Инструментов]{canonical="Tool Call"}.
  - Разделяет **планирование** (рассуждение) и **исполнение** (действие).
- **:term[013: Агент/Экземплирование]{href="./013_agent_instancing.md"}**: Масштабирование параллельного выполнения.
  - Группирует сообщения по ID `_instance` для запуска параллельных контекстов.
  - Масштабирует один :term[План]{canonical="Plan"} на неограниченное количество элементов данных.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md"}**: Модульная композиция.
  - Изолирует выполнение в **изолированных подзапросах**.
  - Позволяет вкладывать агентов в агентов (:term[Агенты]{canonical="Agent"} как :term[Инструменты]{canonical="Tool"}).
- **:term[015: Агент/Области]{href="./015_agent_scopes.md"}**: Управление контекстом.
  - Использует `_scopes` для строгого определения данных, которые могут видеть :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает утечку контекста и повышает безопасность.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md"}**: Структурированное обсуждение.
  - Внедряет определённые персоны для рассуждения **перед** действием.
  - Обеспечивает взвешенное голосование и стратегическое руководство для основного агента.

## Концепции

В то время как :term[Акты]{canonical="Acts"}, описанные выше, определяют _механизмы_, следующие концепции определяют _философию_ архитектуры:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md"}**: Поведение по умолчанию "Без Кода".
  - Если для :term[Инструмента]{canonical="Tool"} не зарегистрировано ни одного :term[Действия]{canonical="Activity"}, :term[Агент]{canonical="Agent"} по умолчанию использует **Скрытое Исполнение**.
  - Он использует внутренние рассуждения LLM ("скрытое пространство"), чтобы симулировать результат инструмента.
  - Это позволяет прототипировать сложные рабочие процессы, используя только схемы, и добавлять код лишь при необходимости.

- **Единство Планирования и Исполнения**:
  - В этой архитектуре **планирование — это исполнение**.
  - :term[Агент]{canonical="Agent"} не создаёт статический план для последующего выполнения.
  - На каждом шаге он генерирует _новый_ :term[План]{canonical="Plan"} (следующий шаг), эффективно перепланируя свои действия на основе последнего :term[Состояния]{canonical="State"}.

- **Человек-в-цикле (HITL)**:
  - `Agent` предоставляет колбэк `confirm()`.
  - Это позволяет хост-системе перехватывать, проверять и одобрять каждый **:term[Вызов Инструмента]{canonical="Tool Call"}** перед его выполнением.
  - Если вызов отклонён или изменён человеком, обратная связь возвращается агенту для корректировки его плана.

- **Восстановление после ошибок**:
  - Ошибки не являются фатальными. Если :term[Инструмент]{canonical="Tool"} вызывает исключение, оно фиксируется как **Сообщение об ошибке** в контексте.
  - :term[Агент]{canonical="Agent"} "видит" сбой на следующем шаге и использует свои рассуждения для самокоррекции (например, повторяет попытку с другими параметрами или выбирает альтернативную стратегию).

## :term[Агент]{canonical="Agent"} vs. :term[Запрос]{canonical="Request"}

Библиотека различает низкоуровневый **:term[Запрос]{canonical="Request"}** и высокоуровневого **:term[Агента]{canonical="Agent"}**.

### :term[Запрос]{canonical="Request"} (Низкоуровневый)

`Request` — это одна атомарная транзакция с LLM. Он предполагает соотношение 1:1 между входным контекстом/схемой и выходным решением.

- **Управление:** Он не зацикливается. Он выполняет ровно один шаг генерации.
- **Мультиплексирование:** Он поддерживает создание нескольких возможных решений из одного и того же контекста (с помощью параметра `n`).
- **Стриминг и Колбэки:** Он предоставляет механизм `callbackPath`. Это позволяет системе перехватывать и обрабатывать определённые части структуры (например, `calls`) по мере их поступления, обеспечивая выполнение инструментов в реальном времени, пока LLM ещё генерирует остальную часть ответа.

### :term[Агент]{canonical="Agent"} (Высокоуровневый)

`Agent` — это **Цикл Выполнения**, который управляет последовательностью :term[Запросов]{canonical="Request"}.

- **Зацикливание:** Он многократно вызывает :term[Запросы]{canonical="Request"}, выполняя полученные :term[Вызовы Инструментов]{canonical="Tool Call"} и возвращая результат обратно в контекст.
- **Завершение:** Он продолжает цикл до тех пор, пока система не решит записать конечный `output`.
- **Сходимость:** По соглашению, желаемая схема результата пользователя оборачивается в свойство `output`, которое может быть null. Цикл считает свою работу завершённой только тогда, когда это свойство заполнено.

### Единая Структура Вывода

Чтобы избежать двойственности между двумя режимами, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} нормализуют свой вывод. Пользовательская схема всегда оборачивается в свойство `output`.

- **:term[Запрос]{canonical="Request"}:** Возвращает `Data<T>[]` (массив решений, обычно кортеж из одного элемента).
- **:term[Агент]{canonical="Agent"}:** Возвращает `Data<T>` (конечное сошедшееся состояние).

## Видение Типобезопасности

Эта библиотека использует **:term[Схимию]{canonical="Schemistry"}**, чтобы обеспечить сквозную типобезопасность без генерации кода. Цель состоит в том, чтобы типы TypeScript идеально отражали преобразования, применяемые конвейером агента во время выполнения.

### Проблема

В агентной системе окончательная схема, отправляемая в LLM, редко совпадает с той, что определил пользователь. Это **композиция** из:

1. Схемы пользователя (цель).
2. Системных функций (:term[Вызовы Инструментов]{canonical="Tool Call"}, :term[Советники]{canonical="Advisor"}, Мета-свойства).

Эти функции переключаются **Обработчиками Сообщений**. Например, добавление сообщения `Advisor` в контекст активирует обработчик, который внедряет массив `advisors` в конечную схему вывода.

### Решение: Конвейер Редукции Типов

Мы представляем себе конвейер системы типов, который отражает логику времени выполнения. Подобно тому, как обработчики сообщений преобразуют JSON-схему во время выполнения, они также должны **редуцировать и преобразовывать выведенный тип TypeScript**.

Процесс работает следующим образом:

1. **Вывод типа:** Схема пользователя преобразуется в тип `T` с помощью `FromSchema<S>`.
2. **Редукция:** Каждый активный Обработчик Сообщений оборачивает или изменяет `T`.
   - _Обработчик :term[Советника]{canonical="Advisor"}:_ Добавляет `{ advisors: Advisor[] }`
   - _Обработчик :term[Инструмента]{canonical="Tool"}:_ Добавляет `{ calls: Call[] }`
   - _Обработчик :term[Мета]{canonical="Meta"}:_ Добавляет `{ meta: Meta }`
3. **Реконструкция:** Конечный тип представляет собой строгое пересечение намерения пользователя и возможностей системы.

### Расширяемость

Эта архитектура спроектирована быть открытой.

- **Пользовательские Обработчики:** Пользователи могут регистрировать свои собственные обработчики сообщений. Эти обработчики могут изменять схему (во время выполнения) и участвовать в редукции типов (во время компиляции).
- **Реестр :term[Инструментов]{canonical="Tool"}:** :term[Инструменты]{canonical="Tool"} регистрируются глобально через `Tool.register`. Это определяет _интерфейс_ возможности.
- **Реестр :term[Действий]{canonical="Activity"}:** Реализации регистрируются через `Activity.register`. Это определяет _логику выполнения_ (код) для инструмента.
- **Реестр :term[Советников]{canonical="Advisor"}:** (Планируется) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, что позволит подключать определённые персоны и модели рассуждений к любому агенту.
- **Реестр Схем:** Схемы можно регистрировать через :term[Схимию]{canonical="Schemistry"} и ссылаться на них с помощью `$ref` (например, `"$ref": "MySchema"`), что позволяет повторно использовать типы по всей системе.

Рассматривая схему как единственный источник истины и позволяя системе типов следовать за ней, мы гарантируем, что если код компилируется, он соответствует протоколу.

## Видение Наблюдаемости и Стандартизации

Мы стремимся к строгой стандартизации операционных аспектов выполнения агентов, обеспечивая согласованность между различными провайдерами LLM.

### Нормализация Токенов

Разные провайдеры по-разному сообщают об использовании. Мы планируем нормализовать эту статистику в единый интерфейс, который отслеживает:

- **Входные Токены**: Использование окна контекста.
- **Выходные Токены**: Сгенерированный контент.
- **Токены Мышления**: Бюджеты на рассуждения в режиме "цепочки мыслей".

### Доступ к Мыслительному Процессу

Поскольку модели всё чаще предоставляют доступ к своим внутренним рассуждениям (CoT), мы рассматриваем это как первоклассного участника протокола:

- **Доступ**: Предоставление потока необработанного мыслительного процесса на уровень приложения.
- **Бюджетирование**: Стандартизация параметров "бюджета мышления" у разных провайдеров, что позволяет агентам запрашивать определённую глубину рассуждений независимо от базовой модели.

## Архитектура с Учётом Кэша

Мы вводим явную поддержку **Кэширования Контекста** для значительного сокращения задержек и затрат при работе долгоживущих агентов.

### Метрики Токенов

Мы будем отслеживать определённые метрики использования кэша для количественной оценки экономии:

- **Токены, Прочитанные из Кэша**: Токены, полученные из кэша.
- **Токены, Записанные в Кэш**: Новые токены, добавленные в кэш.

### Оптимизация Только для Добавления

Для максимального использования **Кэширования Префиксов** библиотека вводит специальные режимы работы, которые позволяют избежать инвалидации кэша:

- **Добавление Вместо Перезаписи**: Предпочтение добавления новых дельт `Data` или `Message` вместо полной замены контекста.
- **Логика Слияния**: Использование естественного поведения слияния `Data` и `Advisors` для аддитивного обновления состояния.
- **Режим Вывода**: Структурирование выводов для линейного расширения истории диалога.

### Управление Контекстом

Чтобы сбалансировать попадания в кэш с ограничениями окна контекста, мы предоставим настраиваемое **Сжатие Контекста**:

- **Ленивое Сжатие**: Оптимизированная процедура, которая сворачивает лог "только для добавления" в снимок только при необходимости, сохраняя префикс кэша как можно дольше.
- **Конфигурация**: Переключатель "Оптимизировано для Кэша" для управления этими режимами в зависимости от конкретных требований к задержке/стоимости рабочей нагрузки.
