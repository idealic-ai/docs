# 801: Пакет/Агент

> [!DEFINITION] [:term[Агент]{canonical="Agent"}](./000_glossary.md)
> Эталонная реализация протоколов **Акты Становления**. Она предоставляет среду выполнения для запуска :term[ИИ-центричных]{canonical="AI-Native"} рабочих процессов, управляемых схемами, от атомарных :term[Запросов]{canonical="Request"} до сложных :term[Агентов]{canonical="Agent"} с сохранением состояния.

> Sidenote:
> - Реализует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Agent/Request"}
>   - :term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Agent/Loop"}

Библиотека `@augceo/agent` — это каноническая реализация агентной архитектуры, определённой в :term[Актах]{canonical="Acts"}. В отличие от фреймворков, которые отдают приоритет инжинирингу промптов, эта библиотека ставит во главу угла **соблюдение протокола**. Она реализует строгую машину состояний, где каждое взаимодействие строго типизировано, управляется схемой и является обособленным.

## Акты (RFC)

Эта библиотека создана непосредственно на основе спецификаций, определённых в **:term[Актах]{canonical="Acts"}**. Каждая функция соответствует определённому документу протокола.

Эта модульная архитектура разработана для **компонуемости и расширяемости**. Вместо монолитного фреймворка каждый :term[Акт]{canonical="Act"} определяет отдельную возможность. Вы можете подключать только те функции, которые вам нужны — будь то простое использование :term[Инструмента]{canonical="Tool"} или сложная многоагентная система с сохранением состояния и делегированием.

### Основные Примитивы

- **:term[001: Агент/Запрос]{href="./001_agent_request.md" canonical="Agent/Request"}**: Атомарная единица вычислений.
  - Преобразует `Context` + `Schema` в структурированное `Solution`.
  - Поддерживает **мультиплексирование** (создание нескольких решений одновременно).
  - Является основой для всех поведений агентов более высокого уровня.
- **:term[002: Агент/Инструмент]{href="./002_agent_tool.md" canonical="Agent/Tool"}**: Определение возможности в виде схемы.
  - Определяет **интерфейс** для действий отдельно от их реализации.
  - Позволяет LLM выбирать поведение на основе структурированных метаданных.
- **:term[003: Агент/Действие]{href="./003_agent_activity.md" canonical="Agent/Activity"}**: Явная, детерминированная реализация :term[Инструмента]{canonical="Tool"} в коде.
  - Связывает абстрактные схемы :term[Инструментов]{canonical="Tool"} с реальным кодом.
  - Поддерживает паттерн **Двойного Реестра** (разделение интерфейса и реализации).
- **:term[004: Агент/Вызов]{href="./004_agent_call.md" canonical="Agent/Call"}**: Конкретный экземпляр использования :term[Инструмента]{canonical="Tool"}.
  - Представляет параметризованный запрос на выполнение.
  - Служит стандартизированным средством передачи между намерением LLM и действием системы.

### Данные и Состояние

- **:term[005: Агент/Данные]{href="./005_agent_data.md" canonical="Agent/Data"}**: Протокол для структурированной информации в контексте.
  - Предоставляет единую оболочку для всех постоянных сообщений контекста.
  - Позволяет структурированно объединять информацию.
- **:term[006: Агент/Ввод]{href="./006_agent_input.md" canonical="Agent/Input"}**: Превращает общий :term[Запрос]{canonical="Request"} в многоразовую функцию.
  - Определяет строгие **входные параметры** для :term[Запроса]{canonical="Request"}.
  - Обеспечивает автоматическую генерацию UI и типобезопасный вызов.
- **:term[009: Агент/Состояние]{href="./009_agent_state.md" canonical="Agent/State"}**: Постоянная память, сохраняющаяся между несколькими шагами.
  - Действует как **общий черновик** для цикла выполнения.
  - Позволяет возобновлять работу и создавать рабочие процессы с сохранением состояния.
- **:term[016: Агент/Мета]{href="./016_agent_meta.md" canonical="Agent/Meta"}**: Управляет идентификацией и происхождением.
  - Отслеживает **версионирование, ветвление и происхождение**.
  - Позволяет агентам автономно развиваться и обновлять свои собственные версии.

### Связывание и Поток

- **:term[007: Агент/Переменные]{href="./007_agent_variables.md" canonical="Agent/Variables"}**: Динамические ссылки.
  - Использует синтаксис `†kind.path` для связывания выходов со входами.
  - Позволяет :term[Инструментам]{canonical="Tool"} **читать** из контекста без копирования данных.
- **:term[008: Агент/Вывод]{href="./008_agent_output.md" canonical="Agent/Output"}**: Механизм записи результата.
  - Использует `_outputPath`, чтобы указать, где должен храниться результат :term[Инструмента]{canonical="Tool"}.
  - Обеспечивает **цепочки** операций через состояние.
- **:term[011: Агент/Выражения]{href="./011_agent_expressions.md" canonical="Agent/Expressions"}**: Логика внутри потока данных.
  - Поддерживает **ветвление** (`||`) для резервной или условной логики.
  - Поддерживает **разветвление** (`&&`) для параллельного распределения данных.

### Орхестрация

- **:term[010: Агент/Цикл]{href="./010_agent_loop.md" canonical="Agent/Loop"}**: Движок выполнения.
  - Повторяет :term[Запросы]{canonical="Request"} до тех пор, пока не будет достигнута цель.
  - Управляет циклом обратной связи: генерация вызовов, их выполнение и обновление контекста.
- **:term[012: Агент/План]{href="./012_agent_plan.md" canonical="Agent/Plan"}**: Декларативная стратегия.
  - Представляет рабочий процесс в виде **графа потока данных** из :term[Вызовов Инструментов]{canonical="Tool Call"}.
  - Разделяет **планирование** (рассуждение) и **исполнение** (действие).
- **:term[013: Агент/Экземплирование]{href="./013_agent_instancing.md" canonical="Agent/Instancing"}**: Масштабирование параллельного выполнения.
  - Группирует сообщения по ID `_instance` для запуска параллельных контекстов.
  - Масштабирует один :term[План]{canonical="Plan"} на неограниченное количество элементов данных.
- **:term[014: Агент/Делегат]{href="./014_agent_delegate.md" canonical="Agent/Delegate"}**: Модульная композиция.
  - Изолирует выполнение в **изолированных подзапросах** (песочнице).
  - Позволяет вкладывать агентов в агентов (:term[Агенты]{canonical="Agent"} как :term[Инструменты]{canonical="Tool"}).
- **:term[015: Агент/Области]{href="./015_agent_scopes.md" canonical="Agent/Scopes"}**: Управление контекстом.
  - Использует `_scopes` для строгого определения данных, которые может видеть :term[Делегат]{canonical="Delegate"} или :term[Действие]{canonical="Activity"}.
  - Предотвращает утечку контекста и повышает безопасность.
- **:term[017: Агент/Советник]{href="./017_agent_advisor.md" canonical="Agent/Advisor"}**: Структурированное обсуждение.
  - Внедряет определённые персоны для рассуждения **перед** действием.
  - Обеспечивает взвешенное голосование и стратегическое руководство для основного агента.

## Концепции

В то время как вышеупомянутые :term[Акты]{canonical="Acts"} определяют _механизмы_, следующие концепции определяют _философию_ архитектуры:

- **:term[104: Концепция/Скрытое]{href="./104_concept_latent.md" canonical="Concept/Latent"}**: "No-Code" по умолчанию.
  - Если для :term[Инструмента]{canonical="Tool"} не зарегистрировано ни одного :term[Действия]{canonical="Activity"}, :term[Агент]{canonical="Agent"} по умолчанию использует **Скрытое Исполнение**.
  - Он использует внутренние рассуждения LLM («скрытое пространство») для симуляции вывода инструмента.
  - Это позволяет прототипировать сложные рабочие процессы, используя только схемы, и добавлять код только при необходимости.

- **Единство Планирования и Исполнения**:
  - В этой архитектуре **планирование — это исполнение**.
  - :term[Агент]{canonical="Agent"} не создаёт статический план, чтобы затем его выполнить.
  - На каждом шаге он генерирует _новый_ :term[План]{canonical="Plan"} (следующий шаг), эффективно перепланируя свои действия на основе последнего :term[Состояния]{canonical="State"}.

- **Человек в цикле (HITL)**:
  - :term[Агент]{canonical="Agent"} предоставляет колбэк `confirm()`.
  - Это позволяет хост-системе перехватывать, проверять и одобрять каждый **:term[Вызов Инструмента]{canonical="Tool Call"}** перед его выполнением.
  - Если вызов отклонён или изменён человеком, обратная связь возвращается агенту для корректировки его плана.

- **Восстановление после ошибок**:
  - Ошибки не являются фатальными. Если :term[Инструмент]{canonical="Tool"} выбрасывает исключение, оно фиксируется как **Сообщение об ошибке** в контексте.
  - :term[Агент]{canonical="Agent"} «видит» сбой на следующем шаге и использует свои рассуждения для самокоррекции (например, повторяет попытку с другими параметрами или выбирает альтернативную стратегию).

## Агент и Запрос

Библиотека различает низкоуровневый **:term[Запрос]{canonical="Request"}** и высокоуровневого **:term[Агента]{canonical="Agent"}**.

### Запрос (низкоуровневый)

:term[Запрос]{canonical="Request"} — это единая, атомарная транзакция с LLM. Он предполагает отношение 1:1 между входным контекстом/схемой и выходным решением.

- **Управление:** Он не выполняет циклов. Он выполняет ровно один шаг генерации.
- **Мультиплексирование:** Он поддерживает создание нескольких решений-кандидатов из одного контекста (через параметр `n`).
- **Потоковая передача и колбэки:** Он предоставляет механизм `callbackPath`. Это позволяет системе перехватывать и обрабатывать определённые части структуры (например, `calls`) по мере их потоковой передачи, что обеспечивает выполнение инструментов в реальном времени, пока LLM ещё генерирует остальную часть ответа.

### Агент (высокоуровневый)

:term[Агент]{canonical="Agent"} — это **Цикл Выполнения**, который управляет последовательностью :term[Запросов]{canonical="Request"}.

- **Цикличность:** Он многократно вызывает :term[Запросы]{canonical="Request"}, выполняя полученные :term[Вызовы Инструментов]{canonical="Tool Call"} и возвращая результат обратно в контекст.
- **Завершение:** Он продолжает циклически работать до тех пор, пока система не примет решение записать финальный `output`.
- **Сходимость:** По соглашению, желаемая схема результата пользователя оборачивается в свойство `output`, которое может быть null. Цикл считает свою работу завершённой только тогда, когда это свойство заполнено.

### Единая Структура Вывода

Чтобы избежать двойственности между двумя режимами, и :term[Агент]{canonical="Agent"}, и :term[Запрос]{canonical="Request"} нормализуют свой вывод. Пользовательская схема всегда оборачивается в свойство `output`.

- **:term[Запрос]{canonical="Request"}:** Возвращает `Data<T>[]` (массив решений, обычно кортеж из 1 элемента).
- **:term[Агент]{canonical="Agent"}:** Возвращает `Data<T>` (финальное сошедшееся состояние).

## Концепция Типобезопасности

Эта библиотека использует **:term[Схимию]{canonical="Schemistry"}**, чтобы обеспечить сквозную типобезопасность без генерации кода. Цель состоит в том, чтобы типы TypeScript идеально отражали преобразования, применяемые конвейером агента во время выполнения.

### Проблема

В агентной системе окончательная схема, отправляемая в LLM, редко совпадает с той, которую определил пользователь. Это **композиция** из:

1. Пользовательской Схемы (цель).
2. Системных Функций (:term[Вызовы Инструментов]{canonical="Tool Call"}, :term[Советники]{canonical="Advisor"}, :term[Мета-свойства]{canonical="Meta"}).

Эти функции переключаются **Обработчиками Сообщений**. Например, добавление сообщения :term[Советника]{canonical="Advisor"} в контекст запускает обработчик, который внедряет массив `advisors` в итоговую схему вывода.

### Решение: Конвейер Сокращения Типов

Мы представляем конвейер системы типов, который отражает логику времени выполнения. Точно так же, как обработчики сообщений преобразуют JSON-схему во время выполнения, они также должны **сокращать и преобразовывать выведенный тип TypeScript**.

Процесс работает следующим образом:

1. **Вывод типа:** Пользовательская схема преобразуется в тип `T` с помощью `FromSchema<S>`.
2. **Сокращение:** Каждый активный Обработчик Сообщений оборачивает или изменяет `T`.
   - _Обработчик :term[Советника]{canonical="Advisor"}:_ Добавляет `{ advisors: Advisor[] }`
   - _Обработчик :term[Инструмента]{canonical="Tool"}:_ Добавляет `{ calls: Call[] }`
   - _Обработчик :term[Мета]{canonical="Meta"}:_ Добавляет `{ meta: Meta }`
3. **Реконструкция:** Окончательный тип представляет собой строгое пересечение намерения пользователя и возможностей системы.

### Расширяемость

Эта архитектура спроектирована как открытая.

- **Пользовательские Обработчики:** Пользователи могут регистрировать свои собственные обработчики сообщений. Эти обработчики могут изменять схему (во время выполнения) и участвовать в сокращении типов (во время компиляции).
- **Реестр :term[Инструментов]{canonical="Tool"}:** :term[Инструменты]{canonical="Tool"} регистрируются глобально через `Tool.register`. Это определяет _интерфейс_ возможности.
- **Реестр :term[Действий]{canonical="Activity"}:** Реализации регистрируются через `Activity.register`. Это определяет _логику выполнения_ (код) для инструмента.
- **Реестр :term[Советников]{canonical="Advisor"}:** (Планируется) :term[Советники]{canonical="Advisor"} будут регистрироваться глобально, что позволит подключать определённые персоны и модели рассуждений к любому агенту.
- **Реестр Схем:** Схемы можно регистрировать через :term[Схимию]{canonical="Schemistry"} и ссылаться на них с помощью `$ref` (например, `"$ref": "MySchema"`), что обеспечивает возможность повторного использования типов по всей системе.

Рассматривая схему как единственный источник истины и позволяя системе типов вытекать из неё, мы гарантируем, что если код компилируется, он соответствует протоколу.
