# 012: Агент/Экземплирование

> [!DEFINITION] [Экземплирование](./000_glossary.md)
> Протокол для группировки контекстных сообщений путем присвоения им общего уникального идентификатора. Это создает отдельные :term[Экземпляры]{canonical="Instance"} в рамках одного запроса, обеспечивая параллельные, мультиплексированные вычисления.

> Sidenote:
> - Требуется: :term[009: Агент/Состояние]{href="./009_agent_state.md"}
> - Совместимо:
>   - :term[006: Агент/Ввод]{href="./006_agent_input.md"}
>   - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}
>   - :term[011: Агент/План]{href="./012_agent_plan.md"}

**Протокол Экземплирования** — это мощный паттерн для масштабирования агентных рабочих процессов, позволяющий выполнять несколько потоков вычислений в рамках одного запроса. Он дает возможность любому агенту одновременно работать с несколькими независимыми контекстами данных, не требуя изменений в его основной логике. Это достигается путем связывания контекстных сообщений, таких как :term[Состояние]{canonical="State"} или :term[Входные данные]{canonical="Input"}, с уникальными идентификаторами экземпляров. В результате один и тот же многоразовый :term[План]{canonical="Plan"} может выполняться параллельно на множестве экземпляров, но протокол является универсальным и поддерживает любую комбинацию сообщений, что значительно повышает пропускную способность и согласованность.

## Механизм Экземплирования

:term[Экземплирование]{canonical="Instancing"} предоставляет способ обработки нескольких независимых контекстов данных путем наслоения на сообщения, переносящие данные, такие как :term[Состояние]{href="./009_agent_state.md"}. Вместо одного сообщения :term[Состояния]{canonical="State"} запрос может включать их массив, где каждое сообщение представляет отдельный :term[Экземпляр]{canonical="Instance"} задачи.

Для управления этими параллельными контекстами каждому сообщению :term[Состояния]{canonical="State"} присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы представляют собой короткие уникальные токены (например, `①`, `②`), которые позволяют LLM связывать операции с определенным :term[Экземпляром]{canonical="Instance"}.

:term[Экземплирование]{canonical="Instancing"} — это опциональная функция, включаемая вызывающей стороной для каждого сообщения. Добавляя свойство `_instance` к сообщению с данными, такому как :term[Состояние]{canonical="State"} или :term[Входные данные]{canonical="Input"}, вызывающая сторона указывает, что это сообщение следует рассматривать как отдельный, потокобезопасный контекст выполнения. Если свойство `_instance` опущено, сообщение рассматривается как глобальный ресурс, доступный для всех экземпляров.

Этот подход дает значительные преимущества:

- **Эффективность**: Увеличивает пропускную способность системы за счет обработки множества экземпляров в одном запросе к LLM.
- **Согласованность**: Позволяя LLM видеть несколько связанных экземпляров в одном контексте, он может генерировать более согласованные и качественные планы.

## Композиция с Контекстными Сообщениями

Сила протокола заключается в том, как идентификатор `_instance` определяет область действия для различных типов контекстных сообщений.

- **:term[Состояние]{canonical="State"}:** Сообщение :term[Состояния]{canonical="State"} является ядром протокола. Каждый :term[Экземпляр]{canonical="Instance"} — это отдельное сообщение :term[Состояния]{canonical="State"}, однозначно идентифицируемое свойством `_instance`. Это обеспечивает изолированную среду для последовательности операций, гарантируя, что параллельные рабочие процессы не будут мешать друг другу.

  > Sidenote:
  > - :term[009: Агент/Состояние]{href="./009_agent_state.md"}

- **:term[Входные данные]{canonical="Input"}:** Сообщение :term[Входных данных]{canonical="Input"} можно использовать двумя способами. Глобальное сообщение :term[Входных данных]{canonical="Input"} (без идентификатора `_instance`) предоставляет конфигурацию для всех экземпляров в пакете. Целевое сообщение :term[Входных данных]{canonical="Input"} (с идентификатором `_instance`) предоставляет данные для конкретного сообщения :term[Состояния]{canonical="State"}, переопределяя любые глобальные входные данные.

  > Sidenote:
  > - :term[006: Агент/Ввод]{href="./006_agent_input.md"}

- **:term[Области видимости]{canonical="Scope"}:** Идентификатор `_instance` обеспечивает критически важную изоляцию данных для :term[Областей видимости]{canonical="Scope"}. Когда :term[Вызов]{canonical="Call"} нацелен на конкретный экземпляр, его `_scopes` также ограничиваются контекстом этого экземпляра. Именно это позволяет :term[Делегату]{canonical="Delegate"} видеть только те данные, которые относятся к его конкретной единице работы, даже если он является одним из многих в рамках более крупного запроса с несколькими экземплярами.

  > Sidenote:
  > - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}

:::details{title="Пример: Масштабная модерация контента"}

:term[Экземплирование]{canonical="Instancing"} превращает однозадачных агентов в мощные обработчики пакетов. Рассмотрим агента, предназначенного для модерации комментариев пользователей на соответствие правилам сообщества.

Без экземплирования агент будет работать последовательно. Для проверки 100 комментариев потребуется 100 отдельных :term[Запросов]{canonical="Request"}. Это не только медленно, но и "вслепую" по отношению к контексту; агент оценивает каждый комментарий в полной изоляции, что может привести к несогласованным решениям по схожему контенту.

С **Протоколом Экземплирования** рабочий процесс распараллеливается в рамках одного :term[Запроса]{canonical="Request"}.

1.  **Пакетный ввод**: Агент получает `context`, содержащий массив из 100 сообщений :term[Входных данных]{canonical="Input"}. Каждому сообщению присваивается уникальный идентификатор `_instance` и оно содержит отдельный комментарий пользователя.

    ```json
    // Пакет сообщений Входных данных, предоставленный LLM
    [
      {
        "type": "input",
        "_instance": "①",
        "comment": "This is a great post!"
      },
      {
        "type": "input",
        "_instance": "②",
        "comment": "I disagree with this..."
      },
      {
        "type": "input",
        "_instance": "③",
        "comment": "This is spam."
      }
      // ... еще 97 экземпляров комментариев
    ]
    ```

2.  **Параллельное выполнение плана**: Теперь LLM видит весь пакет. Он может использовать один :term[План]{canonical="Plan"}, определяющий двухэтапный процесс: сначала анализ тональности, затем проверка по списку запрещенных ключевых слов. Этот же план применяется ко всем экземплярам.

3.  **Целевой вывод**: :term[Решение]{canonical="Solution"} агента будет содержать плоский список :term[Вызовов]{canonical="Call"}, но каждый `Call` будет направлен на конкретный комментарий через свойство `_instance`.

    ```json
    // Решение, сгенерированное LLM
    {
      "calls": [
        {
          "_tool": "moderateComment",
          "_instance": "①",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "②",
          "decision": "approve"
        },
        {
          "_tool": "moderateComment",
          "_instance": "③",
          "decision": "reject"
        }
        // ... еще 97 вызовов модерации
      ]
    }
    ```

Этот подход дает два основных преимущества:

- **Пропускная способность**: То, что раньше требовало 100 обращений к LLM, теперь выполняется за одно.
- **Согласованность**: Просматривая весь пакет, LLM получает более широкий контекст. Он может выносить более последовательные суждения и даже выявлять закономерности (например, скоординированную спам-атаку), которые были бы незаметны при обработке комментариев по одному.

:::

:::::details{title="Глобальные Входные Данные с Экземплированным Состоянием"}

Этот пример показывает, как глобальное сообщение `Input` может направить фокус агента на конкретный экземпляр в большом пакете. Это позволяет динамически и целенаправленно управлять параллельными рабочими процессами, превращая простой пакетный обработчик в более сложного оркестратора, подобного менеджеру, управляющему отдельными сотрудниками.

::::columns
:::column{title="Контекст"}

В этом сценарии используется метафора менеджера, управляющего сотрудниками. Одно глобальное сообщение `input` действует как команда высокого уровня, в то время как несколько экземплированных сообщений `state` представляют сотрудников с их собственными задачами. Эта схема демонстрирует, как агент, разработанный для управления одной сущностью, может легко масштабироваться для оркестрации многих, без каких-либо изменений в его основной конструкции.

```json
[
  // Глобальная инструкция для конкретного сотрудника
  {
    "type": "input",
    "instruction": "Give employee B them a new, high-priority task to 'Finalize the quarterly report'."
  },

  // Текущее состояние всех сотрудников
  {
    "type": "state",
    "_instance": "employee_A",
    "task": "Draft initial proposal",
    "status": "In Progress"
  },
  {
    "type": "state",
    "_instance": "employee_B",
    "task": "Review team submissions",
    "status": "Blocked"
  }
]
```

:::
:::column{title="Целевое Решение"}

Несмотря на то, что `Input` является глобальным, LLM правильно интерпретирует инструкцию на естественном языке. Он генерирует `Call`, который точно нацелен на `employee_B` с помощью свойства `_instance`, демонстрируя свою способность интеллектуально маршрутизировать команды. Другой экземпляр 'сотрудника' остается полностью незатронутым.

```json
{
  "calls": [
    {
      "_tool": "updateTask",
      "_instance": "employee_B",
      "newTask": "Finalize the quarterly report",
      "newStatus": "High Priority",
      "output": "†state"
    }
  ]
}
```

:::
::::
:::::

## Взаимодействие с другими системами

:term[Экземплирование]{canonical="Instancing"} интегрируется с протоколами более высокого уровня для управления потоком выполнения.

- **:term[Вызовы]{canonical="Call"}:** Свойство `_instance` в :term[Вызове]{canonical="Call"} является основным механизмом, который направляет его выполнение. Оно гарантирует, что все манипуляции с состоянием — будь то запись в `:term[Выходной путь]{canonical="Output Path"}` или чтение значения из состояния для использования в качестве входных данных — правильно ограничены предполагаемым :term[Экземпляром]{canonical="Instance"}.

  > Sidenote:
  > - [008: Агент/Вывод](./008_agent_output.md)

- **:term[План]{canonical="Plan"}:** Сообщение :term[Плана]{canonical="Plan"} не подлежит экземплированию; оно действует как единый глобальный шаблон для рабочего процесса. Его можно комбинировать с несколькими экземплированными сообщениями :term[Состояния]{canonical="State"}, что позволяет выполнять один и тот же план одновременно во многих независимых контекстах данных в рамках одного запроса.

  > Sidenote:
  > - :term[011: Агент/План]{href="./012_agent_plan.md"}

## От Планирования к Процессу

В то время как :term[План]{canonical="Plan"} предоставляет многоразовый шаблон для рабочего процесса, а :term[Экземплирование]{canonical="Instancing"} — механизм для его масштабного выполнения, **:term[Идея Процесса]{href="./203_idea_process.md"}** является артефактом, который фиксирует результат. Это полная, самодостаточная запись стратегического плана и его текущего состояния выполнения по всем экземплярам.
