# 011: Агент/Инстансинг

> **Инстансинг:** Процесс обработки нескольких независимых `Instances` (каждый со своим `State Object` и уникальным идентификатором) в рамках одного запроса к агенту.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется: [Агент/Состояние](./010_agent_state.md)
> - Совместимо:
> - [Агент/Ввод](./007_agent_input.md)
> - [Агент/Импорт](./008_agent_imports.md)
> - [Агент/План](./013_agent_plan.md)

Этот документ описывает протокол для обработки нескольких независимых инстансов в рамках одного запроса к агенту, используя архитектуру, управляемую состоянием.

## 1. Фундаментальное требование: Система состояний

Основным предварительным условием для этого протокола инстансинга является **Система состояний**, которая явно разделяет планирование действий и их исполнение.

**Объект состояния** — это мост между этими фазами. Это изменяемый, JSON-подобный объект, который выполняет две критически важные функции:

1. **Цель для исполнения**: Это холст, на котором работают инструменты. Каждый `Tool Call` включает свойство `_outputPath`, которое указывает путь внутри объекта `State`, куда должен быть записан результат работы инструмента во время исполнения.
2. **Источник для зависимостей**: `Tool Call` может ссылаться на значение из `State` в качестве одного из своих входных данных. Это позволяет создавать графы зависимостей.

## 2. Механизм инстансинга

Истинная мощь этой архитектуры раскрывается в её нативной поддержке операций с несколькими инстансами, что стало возможным благодаря Системе состояний.

### 2.1. Идентификаторы состояний

Для обработки нескольких инстансов в одном запросе система принимает массив контекстных сообщений. Каждому сообщению, представляющему отдельный инстанс, присваивается **уникальный идентификатор** через специальное свойство `_instance`. Эти идентификаторы — короткие, уникальные токены (например, числа в кружках, такие как `①`, `②`), которые легко видны LLM, но не несут семантического значения, кроме как служить ссылкой.

### 2.2. Целевые операции

Этот `_instance` затем используется для направления всех операций в контекст конкретного инстанса. Кроме того, все мета-параметры для `Tool Call` имеют префикс в виде нижнего подчеркивания (`_`), а его `params` встраиваются непосредственно в объект вызова.

- **Связывание `Tool Call`**: Каждый `Tool Call` в сгенерированном плане содержит `_instance` контекста, с которым он должен работать.
- **Неявное ограничение области видимости**: `_instance` в `Tool Call` неявно ограничивает все операции, основанные на путях (`_outputPath` и ссылки на входные данные), в рамках этого вызова. Это означает, что когда инструмент читает из объекта состояния или записывает в него, путь является относительным к `_instance` контекста, к которому он принадлежит.

Этот механизм позволяет определениям самих инструментов оставаться простыми и не зависеть от контекста инстансинга. `_outputPath` и ссылки на входные данные в схеме инструмента не требуют обновления; идентификатор четко разделяет операционные контексты.

### 2.3. Пример

Один запрос может содержать два объекта состояния для анализа тональности. Схема состояния может быть предоставлена для ограничения доступных свойств и направления LLM.

```json
{
  "context": [
    {
      "_instance": "①",
      "type": "state",
      "state": { "text": "This is wonderful!" },
      "schema": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "sentiment": { "type": "string" }
        },
        "required": ["text"]
      }
    },
    { "_instance": "②", "type": "state", "state": { "text": "This is terrible." } }
  ]
}
```

LLM обрабатывает оба в одном контексте и генерирует единый план:

```json
{
  "calls": [
    {
      "_tool": "analyzeSentiment",
      "_instance": "①",
      "text": "†state.text",
      "_outputPath": "sentiment"
    },
    {
      "_tool": "analyzeSentiment",
      "_instance": "②",
      "text": "†state.text",
      "_outputPath": "sentiment"
    }
  ]
}
```

Затем хост-среда выполняет этот план, записывая результаты в соответствующие объекты состояния.

## 3. Дополняющая система: Граф планирования

Хотя это и не является строгим требованием для инстансинга, **Система планирования** работает в симбиозе с этой архитектурой, чтобы создавать легко предсказуемые и многоразовые рабочие процессы.

**План** — это шаблон процесса, определенный как направленный ациклический граф (DAG) из `Tool Calls`. Этот граф создается путем анализа зависимостей между инструментами, которые читают из `State Object` и записывают в него.

Важно отметить, что этот план можно сгенерировать и усовершенствовать _до_ исполнения. После завершения план можно передать агенту как `Context Message`. При обработке нескольких инстансов агент может следовать этому заранее определенному плану для каждого `State Object`, достигая очень последовательных и предсказуемых результатов при многократных вызовах. `State Object` для каждого инстанса служит снимком его текущей позиции в этом графе исполнения.

## 4. Преимущества этого подхода

Эта модель инстансинга, управляемая состоянием, предоставляет значительные преимущества:

- **Эффективность**: Она увеличивает пропускную способность системы, обрабатывая множество инстансов за один запрос к LLM, что значительно повышает скорость и снижает затраты.
- **Последовательность и качество**: Позволяя LLM видеть несколько связанных инстансов в одном контексте, она может генерировать более последовательные и качественные планы, используя общие закономерности для всех инстансов.
- **Предсказуемость**: В сочетании с заранее определенным **Планом** система может достигать детерминированных результатов. Детерминированный цикл исполнения гарантирует, что после выполнения плана его результат будет надежным и повторяемым для каждого инстанса.
