# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Это конкретный экземпляр `Tool`, готовый к выполнению, с заданными значениями для его `params`. Он представляет собой ориентированный на исполнение запрос о том, *что должно быть сделано*.

Требует:
- [002: Агент/Инструмент](./002_agent_tool.md)
Открывает возможности для:
- [103: Концепция/Идеатор](./103_concept_ideator.md)
- [013: Агент/Скоупы](./013_agent_scopes.md)
- [011: Агент/Инстансинг](./011_agent_instancing.md)
- [202: Идея/Носитель](./202_idea_vessel.md)
- [203: Идея/Процесс](./203_idea_process.md)
Расширяется:
- [012: Агент/Делегат](./012_agent_delegate.md)

[002: Агент/Инструмент](./002_agent_tool.md) закладывает основу интерфейса на базе схем, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **004: Агент/Вызов**, который, в свою очередь, определяет, как происходит исполнение.

**Вызов** — это конкретный экземпляр Инструмента с заданными параметрами, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это будет исполнено_.

> [!HEADSUP] Обратите внимание
> [001: Агент/Запрос](./001_agent_request.md), результатом которого становится набор `Calls`, является [202: Идея/Носитель](./202_idea_vessel.md). `Носитель` — это единый, реактивный момент принятия решения, когда агент выбирает из доступных `Tools` для формирования ответа.

## Композиция и Контекст

Сам по себе `Call` — это простая структура данных. Его сила — в композиции с другими протоколами, которые управляют средой его исполнения. Эти протоколы активируются через специальные мета-свойства (с префиксом `_`) в схеме `Tool`, что позволяет одному объекту `Call` запускать самые разные варианты поведения при исполнении.

Наделяя эти мета-свойства чётким семантическим значением, мы позволяем LLM активно участвовать в композиции. Модель может анализировать различные комбинации этих свойств, чтобы создавать сложные и новые цепочки исполнения, переходя от простого выбора инструментов к динамической оркестрации рабочих процессов.

> [!TIP]
> В следующем разделе объясняются связи с другими частями системы, которые мы подробно рассмотрим позже. Нет необходимости забегать вперед — мы обо всём расскажем в своё время. Вы всегда сможете вернуться к этому разделу.

- **Явное исполнение (`_activity`)**: Самое базовое расширение — это привязка `Call` к детерминированной функции кода. Свойство `_activity` указывает, что `Call` должен быть исполнен **Действием**, а не через скрытое рассуждение LLM. [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное исполнение (`_delegate`)**: `Call` может быть делегирован внешнему **Делегату**. Свойство `_delegate` обычно содержит ссылку на сохраненный [001: Агент/Запрос](./001_agent_request.md) (часто в виде пути к JSON-файлу), позволяя вызывать этот запрос как инструмент многоразового использования. Это обеспечивает изолированную «чистую комнату» для исполнения, предотвращая смешивание контекстов и обеспечивая настоящую инкапсуляцию. [012: Агент/Делегат](./012_agent_delegate.md).

- **Передача контекста (`_scopes`)**: Протокол **Скоупов** контролирует, какой контекст доступен для `Call`. Его основное назначение — сфокусировать внимание LLM во время скрытого исполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает смешивание контекстов и приводит к более надежным результатам. При использовании с `_delegate` его роль становится еще более мощной: он строго определяет _весь_ контекст для изолированного исполнения делегата. [013: Агент/Скоупы](./013_agent_scopes.md).

- **Исполнение с состоянием (`_outputPath`)**: `Call` можно сделать исполняемым с состоянием, указав ему, куда записывать результат. Свойство `_outputPath` указывает путь внутри постоянного **Объекта состояния**, куда следует сохранить результат `Call`. Это позволяет создавать многошаговые рабочие процессы, где результат одного `Call` может использоваться как входные данные для другого. [009: Агент/Состояние](./009_agent_state.md).

- **Инстансированное исполнение (`_instance`)**: `Call` может быть нацелен на конкретный **Инстанс** в рамках запроса с несколькими инстансами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого `Call` (такие как чтение входных данных и запись результатов в `Объект состояния`) на определенном контексте. Это обеспечивает эффективную параллельную обработку нескольких состояний с использованием одного и того же набора инструментов. [011: Агент/Инстансинг](./011_agent_instancing.md).

## Паттерны исполнения Вызовов

Когда агент генерирует несколько Вызовов, можно применять различные стратегии исполнения в зависимости от потребностей приложения:

```typescript
// Исполнение одного Вызова
const result = await Tool(call);

// Исполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все Вызовы, вернуть первый завершившийся (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Тонкая настройка управления**: Обрабатывать Вызовы по отдельности с пользовательской логикой между исполнениями
- **Пакетная обработка**: Исполнять независимые Вызовы параллельно для максимальной производительности
- **Стратегии быстрого отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «всё или ничего»**: Гарантировать, что все Вызовы выполнятся успешно вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы

## Оркестрация Вызовов в цикле

Хотя эти паттерны управляют исполнением одного пакета `Calls`, агентам часто необходимо выполнять многошаговые задачи, где результат одного `Call` влияет на следующий. Это решается протоколом более высокого уровня, который организует последовательность `Requests` и `Calls`.

Следующий документ, [005: Агент/Цикл](./005_agent_loop.md), подробно описывает этот цикл исполнения.