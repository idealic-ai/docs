# 004: Агент/Вызов

> **Вызов:** Конкретный, исполняемый экземпляр `Tool` с определёнными значениями для его `params`. Это запрос, ориентированный на вызов и определяющий, _что должно быть сделано_. — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
> - [002: Агент/Инструмент](./002_agent_tool.md)
> - Открывает возможности для:
> - [103: Концепция/Идеатор](./103_concept_ideator.md)
> - [008: Агент/Импорты](./008_agent_imports.md)
> - [011: Агент/Инстансинг](./011_agent_instancing.md)
> - [202: Идея/Носитель](./202_idea_vessel.md)
> - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
> - [009: Агент/Модуль](./009_agent_module.md)

[002: Агент/Инструмент](./002_agent_tool.md) устанавливает базовый, основанный на схемах интерфейс, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **004: Агент/Вызов**, который основан на Инструментах и определяет, как происходит исполнение.

**Вызов** — это конкретный экземпляр Инструмента с заданными значениями параметров, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это будет исполнено_.

> [!HEADSUP] Heads up
> [001: Агент/Запрос](./001_agent_request.md), результатом которого является набор `Calls`, представляет собой [202: Идея/Носитель](./202_idea_vessel.md). `Носитель` символизирует единичный, реактивный момент принятия решения, когда агент выбирает из доступных `Инструментов` для формирования ответа.

## Композиция и Контекст

Сам по себе `Call` — это простая структура данных. Его сила заключается в композиции с другими протоколами, которые управляют его средой исполнения. Эти протоколы активируются специальными мета-свойствами (с префиксом `_`) в схеме `Инструмента`, позволяя одному объекту `Call` запускать разнообразные сценарии исполнения.

Придавая этим мета-свойствам ясное семантическое значение, мы делаем LLM активным участником композиции. Модель может анализировать различные комбинации этих свойств для создания сложных и новых цепочек исполнения, переходя от простого выбора инструментов к динамической оркестровке рабочих процессов.

- **Явное исполнение (`_activity`)**: Самое базовое расширение — это связывание `Вызова` с детерминированной функцией в коде. Свойство `_activity` указывает, что `Вызов` должен быть исполнен **Действием**, а не скрытым мышлением LLM.

  > Sidenote: - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное исполнение (`_module`)**: `Вызов` может быть делегирован внешнему **Модулю**. Свойство `_module` обычно содержит ссылку на сохранённый [001: Агент/Запрос](./001_agent_request.md) (часто в виде пути к JSON-файлу), что позволяет вызывать этот запрос как многоразовый инструмент. Это обеспечивает изолированную "чистую комнату" для исполнения, предотвращая смешивание контекстов и обеспечивая настоящую инкапсуляцию.

  > Sidenote: - [009: Агент/Модуль](./009_agent_module.md).

- **Перенос контекста (`_imports`)**: Протокол **Импортов** контролирует, какой контекст доступен `Вызову`. Его основная задача — сфокусировать внимание LLM во время скрытого исполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает смешивание контекстов и приводит к более надёжным результатам. При использовании с `_module` его роль становится ещё более значимой: он строго определяет _весь_ контекст для изолированного исполнения модуля.

  > Sidenote: - [008: Агент/Импорты](./008_agent_imports.md).

- **Исполнение с сохранением состояния (`_outputPath`)**: `Вызов` можно сделать состоянием (stateful), указав, куда записывать его результат. Свойство `_outputPath` определяет путь внутри постоянного **Объекта Состояния**, где будет сохранён результат `Вызова`. Это позволяет создавать многошаговые рабочие процессы, в которых результат одного `Вызова` может использоваться как входные данные для другого.

  > Sidenote: - [010: Агент/Состояние](./010_agent_state.md).

- **Инстанцированное исполнение (`_instance`)**: `Вызов` может быть нацелен на конкретный **Экземпляр** в рамках запроса с несколькими экземплярами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого `Вызова` (например, чтение входных данных и запись результатов в `Объект Состояния`) на определённом контексте. Это обеспечивает эффективную параллельную обработку нескольких состояний с использованием одного и того же набора инструментов.
  > Sidenote: - [011: Агент/Инстансинг](./011_agent_instancing.md).

## Паттерны Исполнения Вызовов

Когда агент генерирует несколько Вызовов, можно применять различные стратегии исполнения в зависимости от потребностей приложения:

```typescript
// Исполнение одного Вызова
const result = await Tool(call);

// Исполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все Вызовы, вернуть первый завершённый результат (успех или неудача)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Тонкое Управление**: Обрабатывать Вызовы индивидуально с пользовательской логикой между исполнениями
- **Пакетная Обработка**: Исполнять независимые Вызовы параллельно для максимальной производительности
- **Стратегии Быстрого Отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции "Всё или Ничего"**: Гарантировать, что все Вызовы завершатся успешно вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы

## Оркестрация Вызовов в Цикле

Хотя эти паттерны управляют исполнением одной пачки `Вызовов`, агентам часто необходимо выполнять многошаговые задачи, где результат одного `Вызова` влияет на следующий. Это решается с помощью протокола более высокого уровня, который организует последовательность `Запросов` и `Вызовов`.

Следующий документ, [005: Агент/Цикл](./005_agent_loop.md), подробно описывает этот цикл исполнения.
