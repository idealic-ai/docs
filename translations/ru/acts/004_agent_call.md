# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Конкретный, исполняемый экземпляр :term[инструмента]{canonical="Tool"}, с определёнными значениями для его `params`. Это запрос, сфокусированный на вызове, который описывает, что _должно быть сделано_.

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Включает:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [013: Агент/Области видимости](./013_agent_scopes.md)
>   - [011: Агент/Экземплирование](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [012: Агент/Делегат](./012_agent_delegate.md)

Протокол :term[инструментов]{canonical="Tool"} создаёт базовый интерфейс на основе схем, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **:term[вызова]{canonical="Call"}**, который основан на :term[инструментах]{canonical="Tool"} и определяет, как происходит исполнение.

:term[Вызов]{canonical="Call"} — это конкретный экземпляр :term[инструмента]{canonical="Tool"} с определёнными значениями параметров, готовый к исполнению. Если :term[инструменты]{canonical="Tool"} определяют, _что можно сделать_, то :term[вызовы]{canonical="Call"} определяют, _как это будет исполнено_.

> [!HEADSUP] На заметку
> :term[Запрос]{canonical="Request", href="./001_agent_request.md"}, который приводит к набору :term[вызовов]{canonical="Call"}, является :term[носителем]{canonical="Vessel", href="./202_idea_vessel.md"}. :term[Носитель]{canonical="Vessel"} представляет собой единый реактивный момент принятия решения, когда агент выбирает из доступных :term[инструментов]{canonical="Tool"}, чтобы сформировать ответ.
>
> > Sidenote:
> >
> > - [001: Агент/Запрос](./001_agent_request.md)
> > - [202: Идея/Носитель](./202_idea_vessel.md)

## Композиция и контекст

Сам по себе :term[вызов]{canonical="Call"} — это простая структура данных. Его сила заключается в композиции с другими протоколами, которые управляют его средой исполнения. Эти протоколы активируются специальными мета-свойствами (с префиксом `_`) в схеме :term[инструмента]{canonical="Tool"}, что позволяет одному объекту :term[вызова]{canonical="Call"} запускать различные сценарии исполнения.

Придавая этим мета-свойствам ясное семантическое значение, мы позволяем LLM активно участвовать в композиции. Модель может анализировать различные комбинации этих свойств для создания сложных и новых цепочек исполнения, переходя от простого выбора инструментов к динамической оркестрации рабочих процессов.

> [!TIP]
> Следующий раздел объясняет связи с другими частями системы, которые будут подробно описаны позже. Не нужно забегать вперёд, мы рассмотрим всё в логической последовательности. Вы сможете вернуться к этому разделу позже.

- **Явное исполнение (`_activity`)**: Самое фундаментальное расширение — это связывание :term[вызова]{canonical="Call"} с детерминированной функцией кода. Свойство `_activity` указывает на то, что :term[вызов]{canonical="Call"} должен быть исполнен :term[действием]{canonical="Activity"}, а не скрытыми рассуждениями LLM.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное исполнение (`_delegate`)**: :term[Вызов]{canonical="Call"} может быть делегирован внешнему :term[делегату]{canonical="Delegate"}. Свойство `_delegate` обычно содержит ссылку на сохранённый :term[запрос]{canonical="Request"} (часто в виде пути к JSON-файлу), что позволяет вызывать этот запрос как многоразовый инструмент. Это обеспечивает изолированную «чистую комнату» для исполнения, предотвращая утечку контекста и обеспечивая настоящую инкапсуляцию.

  > Sidenote:
  > - [012: Агент/Делегат](./012_agent_delegate.md).

- **Перенос контекста (`_scopes`)**: Протокол :term[областей видимости]{canonical="Scopes"} контролирует, какой контекст доступен :term[вызову]{canonical="Call"}. Его основное применение — сфокусировать внимание LLM во время скрытого исполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает утечку контекста и ведёт к более надёжным результатам. При использовании с `_delegate` его роль становится ещё более мощной: он строго определяет _весь_ контекст для изолированного исполнения делегата.

  > Sidenote:
  > - [013: Агент/Области видимости](./013_agent_scopes.md).

- **Исполнение с сохранением состояния (`_outputPath`)**: :term[Вызов]{canonical="Call"} можно сделать сохраняющим состояние, указав ему, куда записывать результат. Свойство `_outputPath` определяет путь в постоянном :term[состоянии]{canonical="State"}, где должен храниться результат :term[вызова]{canonical="Call"}. Это позволяет создавать многоэтапные рабочие процессы, в которых результат одного :term[вызова]{canonical="Call"} может использоваться как входные данные для другого.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md).

- **Исполнение экземпляров (`_instance`)**: :term[Вызов]{canonical="Call"} может быть нацелен на конкретный :term[экземпляр]{canonical="Instance"} в рамках запроса с несколькими экземплярами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого :term[вызова]{canonical="Call"} (например, чтение входных данных из :term[состояния]{canonical="State"} и запись результатов в него) на определённом контексте. Это обеспечивает эффективную параллельную обработку нескольких состояний с одним и тем же набором инструментов.
  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md).

## Паттерны исполнения вызовов

Когда агент генерирует несколько :term[вызовов]{canonical="Call"}, можно применять различные стратегии исполнения в зависимости от потребностей приложения:

```typescript
// Исполнение одного вызова
const result = await Tool(call);

// Исполнить все вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все вызовы, вернуть первый завершённый (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Тонкая настройка**: Обрабатывать :term[вызовы]{canonical="Call"} по отдельности с пользовательской логикой между исполнениями
- **Пакетная обработка**: Исполнять независимые :term[вызовы]{canonical="Call"} параллельно для максимальной производительности
- **Стратегии быстрого отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «всё или ничего»**: Гарантировать, что все :term[вызовы]{canonical="Call"} выполнятся успешно вместе (`.all()`), поддерживая согласованность, когда :term[вызовы]{canonical="Call"} логически сгруппированы

## Оркестрация вызовов в цикле

Хотя эти паттерны управляют исполнением одной партии :term[вызовов]{canonical="Call"}, агентам часто необходимо выполнять многоэтапные задачи, где результат одного :term[вызова]{canonical="Call"} влияет на следующий. Это решается с помощью протокола более высокого уровня, который организует последовательность из `Requests` и :term[вызовов]{canonical="Call"}.

Следующий документ, :term[005: Агент/Цикл]{href="./005_agent_loop.md"}, подробно описывает этот цикл исполнения.
