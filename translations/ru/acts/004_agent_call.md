# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Конкретный, исполняемый экземпляр :term[Tool] с заданными значениями для его `params`. Это запрос, ориентированный на вызов, который определяет, _что должно быть сделано_.

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Включает:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [013: Агент/Скоупы](./013_agent_scopes.md)
>   - [011: Агент/Экземплирование](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [012: Агент/Делегат](./012_agent_delegate.md)

Протокол :term[Tool] создаёт фундаментальный интерфейс на основе схем, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **:term[Call]**, который строится на основе :term[Tools] для определения того, как происходит выполнение.

:term[Call] — это конкретный экземпляр :term[Tool] с заданными значениями параметров, готовый к выполнению. Если :term[Tools] определяют, _что можно сделать_, то :term[Calls] определяют, _как это будет выполнено_.

> [!HEADSUP] На заметку
> :term[Request]{href="./001_agent_request.md"}, результатом которого является набор :term[Calls], — это :term[Vessel]{href="./202_idea_vessel.md"}. :term[Vessel] представляет собой единый реактивный момент принятия решения, когда агент выбирает из доступных :term[Tools] для формирования ответа.
>
> > Sidenote:
> >
> > - [001: Агент/Запрос](./001_agent_request.md)
> > - [202: Идея/Носитель](./202_idea_vessel.md)

## Композиция и Контекст

Сам по себе :term[Call] — это простая структура данных. Его сила заключается в композиции с другими протоколами, которые управляют его средой выполнения. Эти протоколы активируются специальными мета-свойствами (с префиксом `_`) в схеме :term[Tool], позволяя одному объекту :term[Call] запускать различные варианты поведения при выполнении.

Наделяя эти мета-свойства ясным семантическим значением, мы позволяем LLM стать активным участником композиции. Модель может рассуждать о различных комбинациях этих свойств для построения сложных и новых цепочек выполнения, переходя от простого выбора инструментов к динамической организации рабочих процессов.

> [!TIP]
> Следующий раздел объясняет связи с другими частями системы, которые будут рассмотрены позже. Не нужно забегать вперёд, мы всё рассмотрим в логической последовательности. Вы сможете вернуться к этому разделу позже.

- **Явное выполнение (`_activity`)**: Самое фундаментальное расширение — это связывание :term[Call] с детерминированной функцией в коде. Свойство `_activity` указывает, что :term[Call] должен быть выполнен :term[Activity], а не через скрытые рассуждения LLM.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное выполнение (`_delegate`)**: :term[Call] может быть делегирован внешнему :term[Delegate]. Свойство `_delegate` обычно содержит ссылку на сохранённый :term[Request] (часто в виде пути к JSON-файлу), что позволяет вызывать этот запрос как многоразовый инструмент. Это создаёт изолированную «чистую комнату» для выполнения, предотвращая утечку контекста и обеспечивая настоящую инкапсуляцию.

  > Sidenote:
  > - [012: Агент/Делегат](./012_agent_delegate.md).

- **Передача контекста (`_scopes`)**: Протокол :term[Scopes] контролирует, какой контекст доступен :term[Call]. Его основное применение — сфокусировать внимание LLM во время скрытого выполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает утечку контекста и ведёт к более надёжным результатам. При использовании с `_delegate` его роль становится ещё более мощной: он строго определяет _весь_ контекст для изолированного выполнения делегата.

  > Sidenote:
  > - [013: Агент/Скоупы](./013_agent_scopes.md).

- **Выполнение с сохранением состояния (`_outputPath`)**: :term[Call] можно сделать сохраняющим состояние, указав ему, куда записывать результат. Свойство `_outputPath` указывает путь в постоянном :term[State], где должен храниться результат :term[Call]. Это позволяет создавать многошаговые рабочие процессы, где результат одного :term[Call] может быть использован как входные данные для другого.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md).

- **Экземплированное выполнение (`_instance`)**: :term[Call] может быть нацелен на конкретный :term[Instance] в рамках запроса с несколькими экземплярами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого :term[Call] (например, чтение входных данных и запись результатов в :term[State]) на определённом контексте. Это обеспечивает эффективную параллельную обработку нескольких состояний с использованием одного и того же набора инструментов.
  > Sidenote:
  > - [011: Агент/Экземплирование](./011_agent_instancing.md).

## Паттерны выполнения Вызовов

Когда агент генерирует несколько :term[Calls], могут применяться различные стратегии выполнения в зависимости от потребностей приложения:

```typescript
// Выполнение одного Вызова
const result = await Tool(call);

// Выполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Выполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Выполнить все Вызовы, вернуть первый завершённый результат (успех или неудача)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Точный контроль**: Обрабатывать :term[Calls] по отдельности с пользовательской логикой между выполнениями
- **Пакетная обработка**: Выполнять независимые :term[Calls] параллельно для максимальной производительности
- **Стратегии быстрого отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «всё или ничего»**: Гарантировать, что все :term[Calls] успешно завершатся вместе (`.all()`), сохраняя согласованность, когда :term[Calls] логически сгруппированы

## Оркестрация Вызовов в цикле

Хотя эти паттерны управляют выполнением одного пакета :term[Call], агентам часто требуется выполнять многошаговые задачи, где результат одного :term[Call] служит основой для следующего. Это обрабатывается протоколом более высокого уровня, который организует `Requests` и :term[Call]{canonical="Call"} в последовательность.

Следующий документ, :term[005: Агент/Цикл]{href="./005_agent_loop.md"}, подробно описывает этот цикл выполнения
