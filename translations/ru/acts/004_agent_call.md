# 004: Агент/Вызов

> [!DEFINITION] [Вызов](./000_glossary.md)
> Конкретный, исполняемый экземпляр `Tool` с определёнными значениями для его `params`. Это сфокусированный на вызове запрос о том, что _должно быть сделано_.

> Sidenote:
> - Требует:
>   - [002: Агент/Инструмент](./002_agent_tool.md)
> - Позволяет использовать:
>   - [103: Концепция/Идеатор](./103_concept_ideator.md)
>   - [013: Агент/Области](./013_agent_scopes.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)
>   - [202: Идея/Носитель](./202_idea_vessel.md)
>   - [203: Идея/Процесс](./203_idea_process.md)
> - Расширяется:
>   - [012: Агент/Делегат](./012_agent_delegate.md)

В документе [002: Агент/Инструмент](./002_agent_tool.md) устанавливается базовый интерфейс на основе схемы, который позволяет агентам понимать структурированные возможности. Этот документ описывает протокол **004: Агент/Вызов**, который, опираясь на Инструменты, определяет, как происходит исполнение.

**Вызов** — это конкретный экземпляр Инструмента с определёнными значениями параметров, готовый к исполнению. Если Инструменты определяют, _что можно сделать_, то Вызовы определяют, _как это будет исполнено_.

> [!HEADSUP] Внимание
> [001: Агент/Запрос](./001_agent_request.md), результатом которого является набор `Calls`, представляет собой [202: Идея/Носитель](./202_idea_vessel.md). `Vessel` представляет собой единый, реактивный момент принятия решения, когда агент выбирает из доступных `Tools` для формирования ответа.

## Композиция и Контекст

Сам по себе `Call` — это простая структура данных. Его сила заключается в композиции с другими протоколами, которые управляют его средой исполнения. Эти протоколы активируются специальными мета-свойствами (с префиксом `_`) в схеме `Tool`, что позволяет одному объекту `Call` запускать разнообразные варианты поведения при исполнении.

Наделяя эти мета-свойства ясным семантическим значением, мы позволяем LLM стать активным участником композиции. Модель может анализировать различные комбинации этих свойств для создания сложных и новых цепочек исполнения, переходя от простого выбора инструментов к динамической оркестрации рабочих процессов.

> [!TIP]
> Следующий раздел объясняет связи с другими частями системы, которые будут подробно описаны позже. Не нужно забегать вперёд, так как мы рассмотрим всё в логической последовательности. Вы сможете вернуться к этому разделу позже.

- **Явное Исполнение (`_activity`)**: Самое фундаментальное расширение — это связывание `Call` с детерминированной функцией кода. Свойство `_activity` сигнализирует, что `Call` должен быть исполнен **Действием**, а не через скрытое исполнение LLM.

  > Sidenote:
  > - [003: Агент/Действие](./003_agent_activity.md).

- **Делегированное Исполнение (`_delegate`)**: `Call` можно делегировать внешнему **Делегату**. Свойство `_delegate` обычно содержит ссылку на сохранённый [001: Агент/Запрос](./001_agent_request.md) (часто в виде пути к JSON-файлу), что позволяет вызывать этот запрос как многоразовый инструмент. Это обеспечивает изолированную «чистую среду» для исполнения, предотвращая смешивание контекстов и обеспечивая настоящую инкапсуляцию.

  > Sidenote:
  > - [012: Агент/Делегат](./012_agent_delegate.md).

- **Перенос Контекста (`_scopes`)**: Протокол **Scopes** контролирует, какой контекст доступен для `Call`. Его основное применение — фокусировать внимание LLM во время скрытого исполнения, указывая, какие части родительского контекста следует учитывать. Это предотвращает смешивание контекстов и ведёт к более надёжным результатам. При использовании с `_delegate` его роль становится ещё более значимой: он строго определяет _весь_ контекст для изолированного исполнения делегата.

  > Sidenote:
  > - [013: Агент/Области](./013_agent_scopes.md).

- **Исполнение с Сохранением Состояния (`_outputPath`)**: `Call` можно сделать сохраняющим состояние, указав ему, куда записывать результат. Свойство `_outputPath` определяет путь внутри постоянного **Объекта Состояния**, где должен храниться результат `Call`. Это позволяет создавать многоэтапные рабочие процессы, в которых результат одного `Call` может использоваться как входные данные для другого.

  > Sidenote:
  > - [009: Агент/Состояние](./009_agent_state.md).

- **Инстансированное Исполнение (`_instance`)**: `Call` может быть нацелен на конкретный **Экземпляр** в запросе с несколькими экземплярами. Свойство `_instance` действует как уникальный идентификатор, фокусируя все операции этого `Call` (например, чтение входных данных и запись результатов в **Объект Состояния**) на определённом контексте. Это обеспечивает эффективную параллельную обработку нескольких состояний с использованием одного и того же набора инструментов.
  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md).

## Паттерны Исполнения Вызовов

Когда агент генерирует несколько Вызовов, в зависимости от потребностей приложения могут применяться различные стратегии исполнения:

```typescript
// Исполнение одного Вызова
const result = await Tool(call);

// Исполнить все Вызовы, дождаться всех результатов
const results = await Tool.all(calls);

// Исполнить все Вызовы, вернуть первый успешный результат
const result = await Tool.any(calls);

// Исполнить все Вызовы, вернуть результат первого завершившегося (успешно или с ошибкой)
const result = await Tool.race(calls);
```

Эти паттерны позволяют:

- **Тонкая Настройка Управления**: Обрабатывать Вызовы по отдельности с пользовательской логикой между исполнениями
- **Пакетная Обработка**: Исполнять независимые Вызовы параллельно для максимальной производительности
- **Стратегии Быстрого Отказа**: Останавливаться при первом успехе (`.any()`) или первом завершении (`.race()`)
- **Операции «Всё или Ничего»**: Гарантировать, что все Вызовы завершатся успешно вместе (`.all()`), поддерживая согласованность, когда Вызовы логически сгруппированы

## Оркестрация Вызовов в Цикле

Хотя эти паттерны управляют исполнением одной порции `Calls`, агентам часто требуется выполнять многоэтапные задачи, где результат одного `Call` влияет на следующий. Это решается протоколом более высокого уровня, который организует последовательность `Requests` и `Calls`.

Следующий документ, [005: Агент/Цикл](./005_agent_loop.md), подробно описывает этот цикл исполнения.
