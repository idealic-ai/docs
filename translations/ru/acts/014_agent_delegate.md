# 013: Агент/Делегат

> [!DEFINITION] [Делегат](./000_glossary.md)
> Протокол для изоляции контекста выполнения. Вызываемый свойством `_delegate` :term[Вызова]{canonical="Call"}, он выполняет :term[Активность]{canonical="Activity"} или новый :term[Запрос]{canonical="Request"} в изолированном окружении, где свойство `_scopes` предоставляет контролируемый доступ к родительскому контексту.

> Sidenote:
> - Требуется:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
> - Дополняется:
>   - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}

Паттерн **Делегирование** решает критическую задачу масштабирования и композиции возможностей агентов. Он предоставляет мощный механизм для выполнения :term[Инструментов]{canonical="Tool"} в изолированных контекстах (песочницах), предотвращая смешение контекстов и обеспечивая настоящую переиспользуемость. Делегируя :term[Вызов]{canonical="Call"} внешнему делегату — будь то определение другого :term[Запроса]{canonical="Request"} или :term[Активность]{canonical="Activity"} в подзапросе — система может создавать сложные агентские поведения из самодостаточных, независимо разработанных компонентов.

## Проблема: Монолитные Инструменты и Смешение Контекстов

По мере роста возможностей агентов, определение всех :term[Инструментов]{canonical="Tool"} в едином монолитном контексте становится непрактичным.

1.  **Большие схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать в одном запросе. Объединение множества сложных :term[Инструментов]{canonical="Tool"} может превысить эти ограничения, мешая LLM правильно обрабатывать доступные варианты.
2.  **Смешение контекстов**: Когда все :term[Инструменты]{canonical="Tool"} работают в одном контексте, LLM может подвергаться влиянию нерелевантной информации, что приводит к неверному выбору :term[Инструмента]{canonical="Tool"} или заполнению его параметров.
3.  **Отсутствие переиспользуемости**: :term[Инструмент]{canonical="Tool"}, определенный для одного агента, нелегко перенести на другой без переноса всего его контекста.

Делегирование решает эти проблемы, вводя **Делегированную Изоляцию** — способ делегировать :term[Вызов]{canonical="Call"} во внешнюю, изолированную среду выполнения.

## Вызов Делегата

Делегированное выполнение обозначается свойством `_delegate` в схеме :term[Инструмента]{canonical="Tool"}. Это свойство указывает системе рассматривать :term[Вызов]{canonical="Call"} не как встроенную операцию, а как запрос к внешнему делегату.

Свойство `_delegate` является `string` и может использоваться двумя способами:

- **Ссылка на сохраненный :term[Запрос]{canonical="Request"}**: Строка может быть путем или URL к JSON-файлу, который определяет самодостаточный :term[Запрос]{canonical="Request"} — JSON-объект, содержащий свойства `context` и `schema`. Это позволяет :term[Инструменту]{canonical="Tool"} делегировать свое выполнение совершенно отдельному набору инструкций.

  > Sidenote:
  > Сохраненный, переиспользуемый :term[Запрос]{href="./001_agent_request.md"} — это наиболее распространенная форма :term[Идеи]{canonical="Idea"}. Паттерн Делегирования является основным механизмом для композиции этих :term[Идей]{canonical="Idea"} в более сложные системы. См. :term[101: Концепция/Идея]{href="./101_concept_idea.md"} для подробностей.

- **Создание анонимного делегата**: Строковый литерал `'anonymous'` обозначает анонимного делегата. Это используется для создания свежей, изолированной среды выполнения для :term[Вызова Инструмента]{canonical="Tool Call"} (скрытого или явного) без необходимости в промежуточном JSON-файле. Это автоматически создает новый, пустой контекст для :term[Вызова]{canonical="Call"}.

## Выполнение в Изолированной Среде

Делегат предоставляет «чистую комнату» для выполнения. Вместо выполнения в оживленном контексте родительского агента, :term[Вызов]{canonical="Call"} обрабатывается в новой, самодостаточной сессии. Контекст для этого подзапроса тщательно создается, а не наследуется.

Здесь :term[контекст с ограниченной областью видимости]{canonical="scope" href="./015_agent_scopes.md"} становится критически важным. Свойство `_scopes` в схеме :term[Инструмента]{canonical="Tool"} действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в выделенное рабочее пространство делегата. Это дает родительскому агенту точный контроль над тем, что может видеть делегат, предотвращая смешение контекстов и обеспечивая настоящую инкапсуляцию.

> Sidenote:
> - :term[014: Агент/Области видимости]{href="./015_agent_scopes.md"}

## Обработка Больших Схем

Делегирование также предоставляет решение для управления :term[Инструментами]{canonical="Tool"} с очень большими или сложными схемами вывода. Вместо включения массивной схемы `_output` в основной запрос, что потенциально может вытеснить другие инструменты, :term[Инструмент]{canonical="Tool"} можно определить только с его `input` параметрами и указателем `_delegate`.

LLM может спланировать :term[Вызов]{canonical="Call"}, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе делегата. Это позволяет агенту рассуждать о последовательности сложных операций, не имея необходимости «видеть» всю подробную схему для каждого шага в одном окне контекста. LLM доверяет, что делегат произведет правильный вывод, который он получит и использует на последующих шагах.

## Стратегии Разрешения Делегатов

:term[Инструмент]{canonical="Tool"} становится :term[Делегатом]{canonical="Delegate"} просто путем включения свойства `_delegate` в его схему. Это сигнализирует о том, что :term[Вызов]{canonical="Call"} должен быть делегирован. Ключевой вопрос — _когда_ это делегирование разрешается. Система поддерживает две стратегии, позволяя найти компромисс между строгой безопасностью и динамической гибкостью.

### 1. Разрешение во время выполнения (по умолчанию)

Подход по умолчанию и самый гибкий — разрешать делегата во **время выполнения**, после того как агент уже сгенерировал :term[Вызов]{canonical="Call"}.

Этот метод открывает мощную парадигму, невозможную в традиционном коде: **LLM действует как интеллектуальный «клей».** Агент может сгенерировать :term[Вызов]{canonical="Call"} с параметрами, которые не идеально соответствуют ожидаемой `input` схеме делегата. Во время выполнения система собирает контекст делегата и предоставленные вызывающей стороной входные данные, и LLM в подзапросе получает задачу устранить этот разрыв.

Это существенное преимущество, поскольку оно позволяет делегатам обновляться и развиваться независимо. Даже если делегат меняет структуру своих входных данных, вызывающие агенты не сломаются сразу. LLM попытается адаптировать старый формат :term[Вызова]{canonical="Call"} к новой `input` схеме, обеспечивая уровень устойчивости и слабой связанности, уникальный для этой архитектуры.

Процесс выглядит следующим образом:

1.  Агент генерирует :term[Вызов]{canonical="Call"} к модульному :term[Инструменту]{canonical="Tool"}.
2.  Исполнитель видит свойство `_delegate` и инициирует процесс делегирования.
3.  **Сборка контекста**: Исполнитель получает файл определения делегата (если он не анонимный) и собирает базовый контекст. Затем он использует `_scopes` для добавления контекста вызывающей стороны.
4.  **Сопоставление входных данных**: `params` из :term[Вызова]{canonical="Call"} упаковываются в :term[Сообщение Ввода]{canonical="Input Message"} и добавляются в контекст. Именно здесь проявляется способность LLM выступать в роли «клея», так как он будет использовать эти входные данные для выполнения логики делегата, даже если схемы не совпадают идеально.
5.  **Выполнение**: Создается новый, изолированный :term[Запрос]{canonical="Request"} с объединенным контекстом. Результат возвращается как вывод исходного :term[Вызова]{canonical="Call"}.

### 2. Предварительное разрешение (опционально)

Для сценариев, требующих более строгих гарантий, делегат может быть разрешен **заранее**, до отправки первоначального :term[Запроса]{canonical="Request"} агенту.

В этом режиме система предварительно загружает определение :term[Запроса]{canonical="Request"} делегата и объединяет его `input` схему со схемой параметров :term[Инструмента]{canonical="Tool"}. Это позволяет LLM агента видеть точные требования делегата с самого начала, гарантируя, что сгенерированный :term[Вызов]{canonical="Call"} будет идеально сформирован и типобезопасен. Важно отметить, что это предварительное слияние может также включать `_output` схему делегата, обеспечивая строгий контракт для ожидаемого результата.

Этот подход обеспечивает безопасность традиционных API-контрактов, где как входные, так и выходные данные известны и проверены. Он жертвует гибкостью разрешения во время выполнения и лучше всего подходит для критически важных, четко определенных интеграций, где слабая связанность не является желательной особенностью.

:::::details{title="Пример: Гибкое сопоставление входных данных во время выполнения"}

Этот пример демонстрирует концепцию «LLM как клей», где делегат может быть успешно выполнен, даже если :term[Вызов]{canonical="Call"} вызывающего агента не полностью соответствует входной схеме делегата. Это поведение по умолчанию, с разрешением во время выполнения.

::::columns
:::column{title="Точка зрения вызывающей стороны"}

Агенту-оркестратору нужно отправить сообщение. Он знает об :term[Инструменте]{canonical="Tool"} `sendMessage`, который делегирует задачу внешнему агенту, идентифицированному по URL. На основе своего собственного контекста он генерирует :term[Вызов]{canonical="Call"} с параметрами `userId` и `text`, не зная внутренних требований делегата.

```json
// ВЫЗОВ, СГЕНЕРИРОВАННЫЙ ОРКЕСТРАТОРОМ
{
  "_tool": "sendMessage",
  "_delegate": "http://example.com/agents/speaker_EN",
  "userId": "u_123",
  "text": "Hello, world!"
}
```

:::
:::column{title="Точка зрения делегата и итоговый контекст"}

Делегат `speaker_EN` — это отдельное определение :term[Запроса]{canonical="Request"}. Во время выполнения система упаковывает параметры вызывающей стороны в свойство `input` :term[Сообщения Ввода]{canonical="Input Message"}. Важно, что она также включает собственную `schema` делегата, которая не совпадает с предоставленным `input`. LLM делегата теперь отвечает за преодоление этого семантического разрыва, интеллектуально сопоставляя `userId` с `recipientId` и `text` с `messageBody`. Это преобразование не является программным; это семантическое сопоставление, происходящее в скрытом пространстве (latent space) LLM.

```json
// ИТОГОВЫЙ КОНТЕКСТ ДЛЯ ПОДЗАПРОСА
[
  {
    "type": "system",
    "message": "Вы — эксперт по отправке сообщений на английском языке."
  },
  {
    "type": "input",
    // Это необработанные входные данные, предоставленные вызывающим агентом.
    "input": {
      "userId": "u_123",
      "text": "Hello, world!"
    },
    // Это ожидаемый формат входных данных для делегата
    "schema": {
      "type": "object",
      "properties": {
        "recipientId": { "type": "string" },
        "messageBody": { "type": "string" }
      }
    }
  }
]
```

:::
::::
:::::

:::details{title="Пример: Создатели музыки"}

Делегаты обеспечивают мощную композицию, позволяя определениям :term[Запросов]{canonical="Request"} действовать как автономные сервисы, которые могут быть оркестрованы другими агентами. Это создает ясную, динамическую иерархию: высокоуровневые агенты могут сосредоточиться на оркестрации, делегируя специализированные задачи низкоуровневым, переиспользуемым делегатам.

Рассмотрим рабочий процесс с двумя специализированными делегатами: **`Композитором`** и **`Звукорежиссером`**.

- **`Звукорежиссер`** — это низкоуровневый эксперт. Это самодостаточное определение :term[Запроса]{canonical="Request"}, сосредоточенное на физике звука и знающее, как управлять синтезаторами для создания конкретных аудиоданных.

- **`Композитор`** — специалист среднего уровня. Его основная задача — создать песню. Он использует свои собственные встроенные инструменты для генерации мелодии и музыкальной структуры. Чтобы реализовать свое видение, он затем делает :term[Вызовы]{canonical="Call"} к делегату `Звукорежиссер` для синтеза реальных звуков.

Эта двухуровневая иерархия является распространенным паттерном. Однако истинная мощь делегатов заключается в их динамической, управляемой задачами композиции.

Теперь давайте представим высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую запись. В зависимости от конкретной задачи, `Продюсер` может по-разному оркестровать своих делегатов:

> Sidenote:
> Такая схема обеспечивает гибкую оркестрацию. Высокоуровневый `Продюсер` может делегировать задачу `Композитору`, который, в свою очередь, использует `Звукорежиссера`. Однако `Продюсер` также может обойти `Композитора` и взаимодействовать со `Звукорежиссером` напрямую для выполнения конкретных задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> SoundDesigner(Звукорежиссер)
>     Композитор --> SoundDesigner(Звукорежиссер)
> ```

- **Иерархическая оркестрация**: для создания песни `Продюсер` может сделать один :term[Вызов]{canonical="Call"} к делегату `Композитор`. `Продюсер` дает общее направление («Мне нужна грустная баллада»), а `Композитор` выполняет весь свой внутренний рабочий процесс, включая собственные вложенные :term[Вызовы]{canonical="Call"} к `Звукорежиссеру`. В этом случае `Продюсеру` не нужно знать о существовании `Звукорежиссера`.

- **Параллельная оркестрация**: если `Продюсеру` также нужны определенные звуковые эффекты для записи (например, шумы или эмбиент), он может делать :term[Вызовы]{canonical="Call"} напрямую к делегату `Звукорежиссер` для этих задач, параллельно со своим :term[Вызовом]{canonical="Call"} к `Композитору`.

Это демонстрирует ключевой принцип: композиция не зафиксирована внутри самих инструментов. `Продюсер` может рассматривать `Композитора` как черный ящик или взаимодействовать с его составными частями (`Звукорежиссером`) напрямую, в зависимости от текущих потребностей. Эта гибкость позволяет комбинировать один и тот же набор экспертных делегатов в различных аранжировках, создавая глубоко компонуемую и эмерджентную систему.

:::

## От Делегирования к Областям Видимости (Scopes)

Делегированное выполнение предоставляет изолированную среду, но чтобы быть полезным, делегату нужен способ получать информацию от своего родителя. Свойство `_scopes` предоставляет этот механизм, действуя как контролируемый мост между контекстами. Особенности работы этого моста определяются паттерном :term[контекста с ограниченной областью видимости]{canonical="scope" href="./015_agent_scopes.md"}.
