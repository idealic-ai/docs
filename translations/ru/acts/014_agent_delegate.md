# 013: Агент/Делегат

> [!DEFINITION] [Делегат](./000_glossary.md)
> Протокол для изоляции контекста выполнения. Вызываемый свойством `_delegate` :term[Вызова]{canonical="Call"}, он выполняет :term[Активность]{canonical="Activity"} или новый :term[Запрос]{canonical="Request"} в изолированной среде, где свойство `_scopes` обеспечивает контролируемый доступ к родительскому контексту.

> Sidenote:
> - Требует:
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}
> - Дополняется:
>   - :term[015: Агент/Области]{href="./015_agent_scopes.md"}

Паттерн **Делегирования** решает критическую задачу масштабирования и композиции возможностей агентов. Он предоставляет мощный механизм для выполнения :term[Инструментов]{canonical="Tool"} в изолированных средах («песочницах»), предотвращая смешение контекстов и обеспечивая настоящую переиспользуемость. Делегируя :term[Вызов]{canonical="Call"} внешнему делегату — будь то определение другого :term[Запроса]{canonical="Request"} или :term[Активность]{canonical="Activity"} в подзапросе — система может создавать сложное агентное поведение из автономных, независимо разработанных компонентов.

## Реализация как Активность

Концептуально, делегирование — это не новый или отдельный протокол, а мощное применение существующей системы :term[Активностей]{canonical="Activity"}. Выполнение делегата обрабатывается специальной, универсальной «всеобъемлющей» :term[Активностью]{canonical="Activity"}, которая регистрируется системой для обработки любого :term[Вызова]{canonical="Call"}, содержащего свойство `_delegate`.

Эта `Активность Делегирования` получает три стандартных аргумента:

- **`call`**: Полный объект вызова, включая параметры, предназначенные для подзапроса.
- **`tool`**: Схема инструмента, из которой активность считывает свойство `_delegate`, чтобы знать, _что_ вызывать.
- **`context`**: Массив сообщений, ограниченных из родительского контекста, которые будут перенаправлены в подзапрос.

Логика активности проста: она использует эти три аргумента для сборки и выполнения нового, изолированного :term[Запроса]{canonical="Request"}. Эта элегантная реализация демонстрирует мощь основных протоколов: благодаря надежности сигнатуры `Activity`, даже сложные паттерны, такие как делегирование, могут быть построены поверх нее как стандартная реализация, не требуя нового набора правил.

## Проблема: Монолитные инструменты и смешение контекстов

По мере роста возможностей агентов, определение всех :term[Инструментов]{canonical="Tool"} в едином, монолитном контексте становится непрактичным.

1.  **Большие схемы**: У LLM есть практические ограничения на сложность схем, которые они могут обработать в одном запросе. Объединение множества сложных :term[Инструментов]{canonical="Tool"} может превысить эти лимиты, мешая LLM правильно обработать доступные опции.
2.  **Смешение контекстов**: Когда все :term[Инструменты]{canonical="Tool"} работают в одном контексте, LLM может подвергаться влиянию нерелевантной информации, что приводит к неправильному выбору :term[Инструмента]{canonical="Tool"} или заполнению параметров.
3.  **Отсутствие переиспользуемости**: :term[Инструмент]{canonical="Tool"}, определенный для одного агента, нелегко перенести к другому, не захватив с собой весь его контекст.

Делегирование решает эти проблемы, вводя **Делегированную Изоляцию** — способ делегировать :term[Вызов]{canonical="Call"} внешней, изолированной среде выполнения.

## Вызов Делегата

Делегированное выполнение обозначается свойством `_delegate` в схеме :term[Инструмента]{canonical="Tool"}. Это свойство указывает системе рассматривать :term[Вызов]{canonical="Call"} не как встроенную операцию, а как запрос к внешнему делегату.

Свойство `_delegate` — это `string` и может использоваться двумя способами:

- **Ссылка на сохраненный :term[Запрос]{canonical="Request"}**: Строка может быть путем или URL-адресом к JSON-файлу, который определяет автономный :term[Запрос]{canonical="Request"} — JSON-объект, содержащий свойства `context` и `schema`. Это позволяет :term[Инструменту]{canonical="Tool"} делегировать свое выполнение совершенно отдельному набору инструкций.

  > Sidenote:
  > Сохраненный, переиспользуемый :term[Запрос]{href="./001_agent_request.md"} — это наиболее распространенная форма :term[Идеи]{canonical="Idea"}. Паттерн Делегирования — это основной механизм для композиции этих :term[Идей]{canonical="Idea"} в более сложные системы. Подробнее см. в :term[101: Концепция/Идея]{href="./101_concept_idea.md"}.

- **Создание анонимного делегата**: Строковый литерал `'anonymous'` обозначает анонимного делегата. Это используется для создания свежей, изолированной среды выполнения для :term[Вызова Инструмента]{canonical="Tool Call"} (скрытого или явного) без необходимости в промежуточном JSON-файле. Он автоматически создает новый, пустой контекст для :term[Вызова]{canonical="Call"}.

## Выполнение в изолированной среде

Делегат предоставляет «чистую комнату» для выполнения. Вместо выполнения в оживленном контексте родительского агента, :term[Вызов]{canonical="Call"} обрабатывается в новой, автономной сессии. Контекст для этого подзапроса тщательно конструируется, а не наследуется.

Здесь :term[Ограниченный контекст]{canonical="scope" href="./015_agent_scopes.md"} становится критически важным. Свойство `_scopes` в схеме :term[Инструмента]{canonical="Tool"} действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в выделенное рабочее пространство делегата. Это дает родительскому агенту точный контроль над тем, что может видеть делегат, предотвращая смешение контекстов и обеспечивая настоящую инкапсуляцию.

> Sidenote:
> - :term[015: Агент/Области]{href="./015_agent_scopes.md"}

## Обработка больших схем

Делегирование также предлагает решение для управления :term[Инструментами]{canonical="Tool"} с очень большими или сложными схемами вывода. Вместо включения массивной схемы `_output` в основной запрос — что потенциально может вытеснить другие инструменты — :term[Инструмент]{canonical="Tool"} может быть определен только с его параметрами `input` и указателем `_delegate`.

LLM может планировать :term[Вызов]{canonical="Call"}, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе делегата. Это позволяет агенту рассуждать о последовательности сложных операций, не видя всей подробной схемы для каждого шага в одном окне контекста. LLM доверяет, что делегат произведет правильный вывод, который он получит и использует на последующих шагах.

## Стратегии разрешения делегатов

:term[Инструмент]{canonical="Tool"} становится :term[Делегатом]{canonical="Delegate"}, просто включив свойство `_delegate` в свою схему. Это сигнализирует о том, что :term[Вызов]{canonical="Call"} должен быть делегирован. Ключевой вопрос — _когда_ это делегирование разрешается. Система поддерживает две стратегии, позволяющие найти компромисс между строгой безопасностью и динамической гибкостью.

### 1. Разрешение во время выполнения (по умолчанию)

Подход по умолчанию и самый гибкий — разрешать делегата во **время выполнения**, после того как агент уже сгенерировал :term[Вызов]{canonical="Call"}.

Этот метод открывает мощную парадигму, невозможную в традиционном коде: **LLM действует как интеллектуальный «клей»**. Агент может сгенерировать :term[Вызов]{canonical="Call"} с параметрами, которые не идеально соответствуют ожидаемой `input` схеме делегата. Во время выполнения система собирает контекст делегата и предоставленные вызывающей стороной входные данные, и задачей LLM в подзапросе становится преодоление этого разрыва.

Это значительное преимущество, так как позволяет делегатам обновляться и развиваться независимо. Даже если делегат изменит свою структуру входных данных, вызывающие агенты не сломаются сразу. LLM попытается адаптировать старый формат :term[Вызова]{canonical="Call"} к новой `input` схеме, обеспечивая уровень устойчивости и слабой связанности, уникальный для этой архитектуры.

Процесс выглядит следующим образом:

1.  Агент генерирует :term[Вызов]{canonical="Call"} к модульному :term[Инструменту]{canonical="Tool"}.
2.  Исполнитель видит свойство `_delegate` и инициирует процесс делегирования.
3.  **Сборка контекста**: Исполнитель получает файл определения делегата (если он не анонимный) и собирает базовый контекст. Затем он использует `_scopes` для добавления контекста вызывающей стороны.
4.  **Сопоставление ввода**: `params` из :term[Вызова]{canonical="Call"} упаковываются в :term[Входное Сообщение]{canonical="Input Message"} и добавляются в контекст. Именно здесь вступает в игру «клеящая» способность LLM, так как она будет использовать эти входные данные для выполнения логики делегата, даже если схемы не совпадают идеально.
5.  **Выполнение**: Создается новый, изолированный :term[Запрос]{canonical="Request"} с объединенным контекстом. Результат возвращается как вывод исходного :term[Вызова]{canonical="Call"}.

### 2. Заранее разрешение (опционально)

Для сценариев, требующих более строгих гарантий, делегат может быть разрешен **заранее**, до отправки первоначального :term[Запроса]{canonical="Request"} агенту.

В этом режиме система предварительно загружает определение :term[Запроса]{canonical="Request"} делегата и объединяет его `input` схему со схемой параметров :term[Инструмента]{canonical="Tool"}. Это позволяет LLM агента видеть точные требования делегата с самого начала, гарантируя, что сгенерированный :term[Вызов]{canonical="Call"} будет идеально сформирован и типобезопасен. Важно отметить, что это предварительное слияние может также включать `_output` схему делегата, обеспечивая строгий контракт для ожидаемого результата.

Этот подход обеспечивает безопасность традиционных API-контрактов, где и входы, и выходы известны и проверены. Он жертвует гибкостью разрешения во время выполнения и лучше всего подходит для критически важных, четко определенных интеграций, где слабая связанность не является желательной особенностью.

:::::details{title="Пример: Гибкое сопоставление ввода во время выполнения"}

Этот пример демонстрирует концепцию «LLM как клей», где делегат может быть успешно выполнен, даже если :term[Вызов]{canonical="Call"} вызывающего агента не идеально соответствует входной схеме делегата. Это поведение по умолчанию, с разрешением во время выполнения.

::::columns
:::column{title="Точка зрения вызывающей стороны"}

Агенту-оркестратору нужно отправить сообщение. Он знает об :term[Инструменте]{canonical="Tool"} `sendMessage`, который делегирует задачу внешнему агенту, идентифицированному по URL. На основе своего контекста он генерирует :term[Вызов]{canonical="Call"} с параметрами `userId` и `text`, не зная внутренних требований делегата.

```json
// ВЫЗОВ, СГЕНЕРИРОВАННЫЙ ОРКЕСТРАТОРОМ
{
  "_tool": "sendMessage",
  "_delegate": "http://example.com/agents/speaker_EN",
  "userId": "u_123",
  "text": "Hello, world!"
}
```

:::
:::column{title="Точка зрения делегата и итоговый контекст"}

Делегат `speaker_EN` — это отдельное определение :term[Запроса]{canonical="Request"}. Во время выполнения система упаковывает параметры вызывающей стороны в свойство `input` :term[Входного Сообщения]{canonical="Input Message"}. Важно, что она также включает собственную `schema` делегата, которая не соответствует предоставленному `input`. LLM делегата теперь отвечает за преодоление этого семантического разрыва, интеллектуально сопоставляя `userId` с `recipientId` и `text` с `messageBody`. Это преобразование не программное; это семантическое сопоставление, происходящее в скрытом пространстве LLM.

```json
// ИТОГОВЫЙ КОНТЕКСТ ДЛЯ ПОДЗАПРОСА
[
  {
    "type": "system",
    "message": "Вы — эксперт по обмену сообщениями на английском языке."
  },
  {
    "type": "input",
    // Это необработанные входные данные, предоставленные вызывающим агентом.
    "input": {
      "userId": "u_123",
      "text": "Hello, world!"
    },
    // Это ожидаемый формат входных данных для делегата
    "schema": {
      "type": "object",
      "properties": {
        "recipientId": { "type": "string" },
        "messageBody": { "type": "string" }
      }
    }
  }
]
```

:::
::::
:::::

:::details{title="Пример: Создатели музыки"}

Делегаты обеспечивают мощную композицию, позволяя определениям :term[Запросов]{canonical="Request"} действовать как автономные сервисы, которые могут быть оркестрированы другими агентами. Это создает ясную, динамичную иерархию: высокоуровневые агенты могут сосредоточиться на оркестрации, делегируя специализированные задачи низкоуровневым, переиспользуемым делегатам.

Рассмотрим рабочий процесс с двумя специализированными делегатами: **`Композитором`** и **`Звукорежиссером`**.

- **`Звукорежиссер`** — это низкоуровневый эксперт. Это автономное определение :term[Запроса]{canonical="Request"}, сосредоточенное на физике звука и знающее, как управлять синтезаторами для создания конкретных аудиоданных.

- **`Композитор`** — это специалист среднего уровня. Его основная задача — создать песню. Он использует свои собственные встроенные инструменты для генерации мелодии и музыкальной структуры. Чтобы воплотить свое видение, он делает :term[Вызовы]{canonical="Call"} к делегату `Звукорежиссер` для синтеза реальных звуков.

Эта двухуровневая иерархия — распространенный паттерн. Однако истинная мощь делегатов заключается в их динамичной, управляемой задачами композиции.

Теперь давайте представим высокоуровневого агента-**`Продюсера`**. Цель `Продюсера` — создать готовую запись. В зависимости от конкретной задачи `Продюсер` может оркестрировать своих делегатов по-разному:

> Sidenote:
> Такая схема обеспечивает гибкую оркестрацию. Высокоуровневый `Продюсер` может делегировать задачу `Композитору`, который, в свою очередь, использует `Звукорежиссера`. Однако `Продюсер` также может обойти `Композитора` и взаимодействовать со `Звукорежиссером` напрямую для выполнения конкретных задач.
>
> ```mermaid
> graph TD
>     Продюсер --> Композитор
>     Продюсер --> SoundDesigner(Звукорежиссер)
>     Композитор --> SoundDesigner(Звукорежиссер)
> ```

- **Иерархическая оркестрация**: Для создания песни `Продюсер` может сделать один :term[Вызов]{canonical="Call"} к делегату `Композитор`. `Продюсер` дает общие указания («Мне нужна грустная баллада»), а `Композитор` выполняет весь свой внутренний рабочий процесс, включая собственные вложенные :term[Вызовы]{canonical="Call"} к `Звукорежиссеру`. В этом случае `Продюсеру` не нужно знать о существовании `Звукорежиссера`.

- **Параллельная оркестрация**: Если `Продюсеру` также нужны специальные звуковые эффекты для записи (например, фоли или эмбиент), он может делать :term[Вызовы]{canonical="Call"} напрямую к делегату `Звукорежиссер` для этих задач, параллельно с :term[Вызовом]{canonical="Call"} к `Композитору`.

Это демонстрирует ключевой принцип: композиция не зафиксирована внутри самих инструментов. `Продюсер` может рассматривать `Композитора` как черный ящик или взаимодействовать с его составными частями (`Звукорежиссером`) напрямую, в зависимости от текущих потребностей. Эта гибкость позволяет комбинировать один и тот же набор экспертных делегатов в различных аранжировках, создавая глубоко композитную и эмерджентную систему.

:::

## От делегирования к областям видимости

Делегированное выполнение предоставляет изолированную среду, но чтобы она была полезной, делегату нужен способ получать информацию от своего родителя. Свойство `_scopes` обеспечивает этот механизм, действуя как контролируемый мост между контекстами. Особенности работы этого моста определяются паттерном :term[Ограниченного контекста]{canonical="scope" href="./015_agent_scopes.md"}.
