# 012: Агент/План

> **План:** Структурированное представление рабочего процесса, видения или системы, выраженное в виде графа. Это универсальный инструмент для создания любой сети — от исполняемой последовательности `Tool Calls` до концептуальной карты для мозгового штурма. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [005: Агент/Цикл](./005_agent_loop.md)
>   - [010: Агент/Состояние](./010_agent_state.md)
>   - [011: Агент/Инстансинг](./011_agent_instancing.md)

Этот документ описывает **Протокол Плана**, который расширяет возможности агентов от простых, реактивных циклов до сложных, многошаговых рабочих процессов. `Plan` — это структура данных, обычно массив `Tool Calls`, описывающая последовательность действий. Это не строгий сценарий, а динамический граф, где зависимости формируются неявно через `Calls`, которые читают и записывают данные в общий объект `State`.

Такой подход превращает объект `State` в холст для планирования, позволяя агенту создавать и выполнять сложные потоки данных для достижения цели.

## Что такое План?

`Plan` — это универсальный и мощный инструмент для мышления в графах. Он предоставляет структурированный формат для представления любой системы взаимосвязанных идей, от высокоуровневого видения до детального технического чертежа. Эта графовая структура является очень эффективным способом сжатия сложного контекста в формат, который LLM понимают гораздо легче, чем длинные тексты.

> Sidenote:
> `Plan` не ограничивается линейными последовательностями. Он может представлять сложные рабочие процессы с условной логикой, где путь выполнения зависит от результата предыдущего шага:
>
> ```mermaid
> graph TD
>     A[Получить погоду] --> B{Солнечно?};
>     B -- state.sunny --> C[Найти парк];
>     B -- state.notSunny --> D[Найти фильм];
>     C -- state.suggestion --> E[Представить предложение];
>     D -- state.suggestion --> E[Представить предложение];
> ```

Протокол `Plan` не ограничивается только выполнением задач. Его можно использовать для создания любого графа в ответ на запрос пользователя. Например, `Tool` может взять таблицу контактов и создать `Plan`, который визуализирует сеть друзей. Другой `Tool` может сгенерировать `Plan`, представляющий собой полный рабочий процесс GitHub Actions или черновик для новой схемы базы данных.

Хотя `Plan` может быть мощным инструментом для мозгового штурма, обсуждений и «размышлений вслух», его основное применение в этой системе — определение исполняемых рабочих процессов. Для этой цели мы используем особый тип графа, называемый **Направленным Ациклическим Графом (НАГ)**, где каждый узел — это `Tool Call`.

У НАГ есть несколько ключевых свойств, которые делают его идеальным для исполнения:

- **Граф:** «Граф» — это весь `Plan`, то есть совокупность всех `Tool Calls` (узлов) и зависимостей по данным, которые их соединяют (ребра).
- **Направленный:** Связи односторонние и определяются потоком данных. Шаг, создающий данные, должен идти _перед_ шагом, который их использует.
- **Ациклический:** Рабочий процесс не может иметь циклических зависимостей, что обеспечивает ему четкое начало и конец.

## Как формируется План

Связи в графе создаются не с помощью явных указателей, а через простую и мощную конвенцию потока данных с использованием объекта `State`.

- **Узлы (`Tool Calls`):** Каждый шаг в рабочем процессе — это `Tool Call`, представляющий собой действие, которое нужно выполнить.
- **Рёбра (Объект `State`):** Связи между шагами создаются путем записи и чтения из объекта `State`. Один `Tool` записывает свой результат по определенному пути в `State`, используя мета-свойство `_outputPath`. Следующий `Tool` может затем использовать этот результат как входные данные, ссылаясь на тот же путь с помощью **Ссылки на Переменную**.

Это устанавливает четкую зависимость: второй `Tool Call` не может быть выполнен, пока первый не завершится и не заполнит `State`.

Например, `Plan` для получения профиля пользователя и его последующего суммирования будет состоять из двух `Tool Calls`:

```json
[
  {
    "_tool": "fetchUserProfile",
    "userName": "Alice",
    "_outputPath": "†state.userProfileData"
  },
  {
    "_tool": "summarizeProfile",
    "profile": "†state.userProfileData",
    "_outputPath": "†state.profileSummary"
  }
]
```

Здесь вызов `summarizeProfile` зависит от результата `fetchUserProfile`, создавая двухэтапный план. Эту взаимосвязь можно представить в виде простого графа:

> Sidenote:
> ```mermaid
> graph TD
>     state_var("state.user.profile")
>
>     Call1["fetchUserProfile"]
>     Call2["summarizeProfile"]
>
>     Call1 -- записывает в --> state_var
>     state_var -- читается --> Call2
> ```
>
> - [010: Агент/Состояние](./010_agent_state.md)

## Разделение планирования и исполнения

Самая мощная особенность этой архитектуры — полное разделение планирования и исполнения. Поскольку `Plan` — это просто декларативная структура данных, агент может сгенерировать весь граф `Tool Calls` _до_ запуска какого-либо кода.

LLM выступает в роли планировщика, составляя массив `Calls`, который представляет собой предполагаемый рабочий процесс. Эту структуру данных затем можно:

- **Проверить:** Система может проверить граф на наличие циклических зависимостей или других структурных ошибок.
- **Симулировать:** Можно выполнить «пробный запуск», чтобы предсказать поведение рабочего процесса.
- **Представить на утверждение:** `Plan` можно показать человеку для проверки, изменения или одобрения перед выполнением, что создает важный уровень безопасности и сотрудничества.

За исполнение отвечает **[Цикл Агента](./005_agent_loop.md)**, который интерпретирует `Plan` и выполняет `Tool Calls` в правильном порядке на основе их зависимостей, заполняя объект `State` по ходу дела.

## План как развивающаяся стратегия

`Plan` не статичен; это живая стратегия, которую можно адаптировать на каждом шаге цикла исполнения. В типичном рабочем процессе сам `Plan` является сообщением в `context`, предоставляемом LLM.

- **`context`** содержит объект `State` и `Plan` с предыдущего шага.
- **`solution`**, сгенерированное LLM, — это **новый `Plan`** для текущего шага.

Этот итеративный процесс позволяет агенту быть одновременно проактивным и реактивным. Он может следовать существующему `Plan`, но также может изменять его в ответ на результаты предыдущего шага. Например, если `Tool Call` завершается с ошибкой, агент может сгенерировать новый `Plan`, включающий шаги по обработке ошибок. Это делает систему устойчивой и адаптируемой.

> [!HEADSUP] Внимание
> Этот итеративный цикл планирования и исполнения является ядром [203: Идея/Процесс](./203_idea_process.md). Это самодостаточный снимок рабочего процесса, который включает доступные `Tools`, текущее `State` и сам `Plan`.

## Композиция

Протокол Плана — это высокоуровневый слой оркестрации, который объединяет несколько других основных протоколов.

- **Вызов:** `Tool Calls` являются фундаментальными строительными блоками — узлами — любого `Plan`. Свойство `_outputPath` в `Call` позволяет ему участвовать в `Plan`, изменяя общее `State`.

  > Sidenote:
  > - [004: Агент/Вызов](./004_agent_call.md)

- **Состояние:** Объект `State` — это основной холст, на котором рисуется `Plan`. Он предоставляет «провода», которые соединяют независимые `Tool Calls` в единый рабочий процесс.

  > Sidenote:
  > - [010: Агент/Состояние](./010_agent_state.md)

- **Цикл:** Исполняющий `Loop` — это движок, который оживляет `Plan`. Он обрабатывает `Calls` в `Plan`, управляет потоком данных через `State` и обеспечивает итеративное перепланирование, которое делает систему динамичной.

  > Sidenote:
  > - [005: Агент/Цикл](./005_agent_loop.md)

- **Инстансинг:** Протокол `Plan` полностью совместим с `Instancing`. Один `Plan` может служить шаблоном для пакетной операции, применяемой к массиву объектов `State`. Система `Instancing` гарантирует, что каждое параллельное выполнение имеет свое собственное изолированное `State`, что позволяет выполнять сложный рабочий процесс последовательно и безопасно для множества элементов одновременно.

  > Sidenote:
  > - [011: Агент/Инстансинг](./011_agent_instancing.md)

## От Плана к Процессу

`Plan` предоставляет конкретные, тактические шаги для достижения цели. Это стратегия агента, зафиксированная в виде графа `Calls`. Этот `Plan` является центральным компонентом **[Идеи Процесса](./203_idea_process.md)**, которая представляет собой полный, самодостаточный и сохраняющий состояние рабочий процесс. `Plan` — это «как», а `Идея Процесса` — это полная запись о том, «что, почему и как».
