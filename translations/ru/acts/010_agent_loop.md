# 010: Агент/Цикл

> [!DEFINITION] [Цикл](./000_glossary.md)
> Итеративная последовательность :term[Запросов]{canonical="Request"}, направленная на достижение цели. Агент продолжает вызывать :term[Запросы]{canonical="Request"}, обрабатывать результирующие :term[Вызовы]{canonical="Call"} и возвращать результат обратно в контекст до тех пор, пока LLM не сгенерирует :term[финальный вывод]{canonical="Final Output"}, сигнализируя о завершении задачи.

> Sidenote:
> - Требуется:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
>   - :term[008: Агент/Вывод]{href="./008_agent_output.md"}

:term[Цикл исполнения]{canonical="Execution Loop"} — это механизм, который организует все типы сообщений и протоколы из предыдущих глав. Он позволяет агенту выполнять многошаговые задачи путем итеративного создания :term[Запросов]{canonical="Request"}. Этот итеративный процесс сборки контекста, использования инструментов и обратной связи — это то, что обычно подразумевается под «агентом».

## Цикл Исполнения

Цикл исполнения — это основной механизм для автономного, многошагового выполнения. Он работает по принципу вложенной циклической структуры:

::::columns
:::column

1.  **Внешний цикл (генерация запросов):** Жизненный цикл агента — это последовательность :term[Запросов]{canonical="Request"}. Он начинается с начального контекста и входит в цикл.
2.  **Потоковая передача запросов и вызовов:** Внутри цикла он вызывает один :term[Запрос]{canonical="Request"}. :term[Запрос]{canonical="Request"} передает :term[Вызовы]{canonical="Call"} в потоковом режиме по мере их генерации. Они собираются в очередь ожидания.
3.  **Внутренний цикл (оркестрация вызовов):** Для каждого :term[Запроса]{canonical="Request"} внутренний цикл оркестрации отвечает за выполнение связанных с ним :term[Вызовов]{canonical="Call"}. Этот процесс представляет собой реактивный, управляемый событиями цикл, который запускается двумя событиями: новый :term[Вызов]{canonical="Call"} передается из LLM или завершается ранее запущенный :term[Вызов]{canonical="Call"}. Этот процесс является высококонкурентным:
    - Оркестратор непрерывно сканирует очередь ожидающих :term[Вызовов]{canonical="Call"}, чтобы найти все, которые в данный момент не заблокированы (т.е. их зависимости удовлетворены).
    - Все незаблокированные :term[Вызовы]{canonical="Call"} могут быть представлены для подтверждения, а затем выполнены параллельно. Это обеспечивает высокую пропускную способность, но требует осторожного управления состоянием. Если несколько одновременных :term[Вызовов]{canonical="Call"} записывают данные в один и тот же путь в :term[Состоянии]{canonical="State"}, окончательное значение будет определено последним завершенным вызовом, что может привести к недетерминированным результатам. Система использует подход «last-write-wins» для разрешения этих конфликтов.

      > Sidenote:
      > - [008: Агент/Вывод](./008_agent_output.md)

    - По мере завершения каждого :term[Вызова]{canonical="Call"} его результат обновляет общий контекст, потенциально разблокируя другие ожидающие :term[Вызовы]{canonical="Call"}.
    - Это реактивное, параллельное выполнение продолжается до тех пор, пока поток для текущего :term[Запроса]{canonical="Request"} не будет закрыт, а все его ожидающие :term[Вызовы]{canonical="Call"} не будут выполнены. Эта модель значительно снижает задержку, так как агент может начать работать над несколькими независимыми шагами одновременно, даже до того, как станет известен полный план.

4.  **Завершение и продолжение:** После завершения внутреннего цикла для данного :term[Запроса]{canonical="Request"} агент проверяет итоговое :term[Решение]{canonical="Solution"}. Решение о продолжении основывается на поле `output`:
    - **Если `output` равен `null`**, агент определяет, что его задача еще не завершена. Он возвращается к шагу 2, вызывая новый :term[Запрос]{canonical="Request"} с обогащенным контекстом, который теперь содержит результаты выполненных :term[Вызовов]{canonical="Call"}.
    - **Если `output` не `null`**, цель агента считается достигнутой. Внешний цикл завершается, и значение `output`, соответствующее определенной пользователем схеме вывода, возвращается в качестве окончательного результата. Агент может создать и `calls`, и финальный `output` за один шаг; наличие `output` является четким сигналом к остановке.

:::
:::column

```mermaid
graph TD
    Start[/"Агент(...)"/] --> Request["Агент.Запрос(...)"];
    Request -- потоком вызовы --> FindUnblocked{"Найти все незаблокированные вызовы"};

    FindUnblocked -- "найдены" --> ConfirmAndLaunch["Подтвердить и запустить все (параллельно)"];
    ConfirmAndLaunch -- "любой завершен" --> UpdateContext["Обновить контекст с результатом"];
    UpdateContext --> FindUnblocked;

    FindUnblocked -- "не найдены" --> CheckStreamAndPending{"Поток активен или есть ожидающие вызовы?"};
    CheckStreamAndPending -- Да --> Wait["Ожидать новые вызовы или завершения"];
    Wait --> FindUnblocked;

    CheckStreamAndPending -- Нет --> CheckTermination{"Решение содержит вывод?"};
    CheckTermination -- Нет --> Request;
    CheckTermination -- Да --> End[\"Вернуть контекст/решение"\];
```

:::
::::

## :term[Человек-в-цикле]{canonical="HITL"}

Новый :term[Цикл исполнения]{canonical="Execution Loop"} обеспечивает надежную поддержку человеческого контроля, помещая шаг подтверждения непосредственно перед исполнением. Это гарантирует, что пользователю будет предложено действовать только в отношении вызовов, готовых к выполнению:

- **Одобрение:** Перед выполнением незаблокированного :term[Вызова]{canonical="Call"} система может представить его пользователю для одобрения. Это эффективный подход, так как он избавляет пользователя от необходимости просматривать и подтверждать вызовы, которые могут быть заблокированы зависимостями и никогда не будут выполнены.
- **Коррекция:** Пользователь может изменять параметры :term[Вызова]{canonical="Call"} или даже заменять его другим.

Важно отметить, что эти конкретные механизмы :term[HITL]{canonical="HITL (Human-in-the-Loop)"} не являются частью основного протокола. Архитектура просто обеспечивает необходимое разделение между предложением действий и их выполнением, предоставляя разработчикам гибкость для реализации любого вида вмешательства, от простого ручного подтверждения до сложной автоматизированной системы с тайм-аутами.

Эта возможность критически важна для безопасности и для совместных задач, где агент выступает в роли ассистента. Корректировки и отзывы пользователя могут быть использованы :term[Планом]{canonical="Plan"}, позволяя агенту совершенствовать свою стратегию на основе человеческого ввода.

## От простых циклов к стратегическим планам

:term[Цикл исполнения]{canonical="Execution Loop"} обеспечивает динамическую структуру для поведения агента, но его сила заключается в выполнении тактических, одноразовых :term[Запросов]{canonical="Request"}. Для управления сложными, многошаговыми рабочими процессами с зависимостями требуется более продвинутая система стратегического планирования.

Следующий документ, :term[011: Агент/Выражения]{href="./011_agent_expressions.md"}, представляет протокол для определения этих долгосрочных стратегий в виде графа взаимосвязанных :term[Вызовов инструментов]{canonical="Call"}.
