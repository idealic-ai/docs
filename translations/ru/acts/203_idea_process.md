# 203: Идея/Процесс

> [!DEFINITION] [Идея Процесса](./000_glossary.md)
> Автономная [Идея](./101_concept_idea.md), которая содержит в себе стратегический [План](./010_agent_plan.md) и его текущее состояние выполнения. Её `schema` — это библиотека [Инструментов](./002_agent_tool.md), её `solution` — это _новый_ `План` для текущего шага, а её `context` содержит `Input`, `State` и предыдущий `Plan`.

- Требует:
  - [101: Концепция/Идея](./101_concept_idea.md)
  - [010: Агент/План](./010_agent_plan.md)
  - [009: Агент/Состояние](./009_agent_state.md)
  - [007: Агент/Ввод](./007_agent_input.md)
- Дополняется:
  - [011: Агент/Инстансинг](./011_agent_instancing.md)

Если [202: Идея/Носитель](./202_idea_vessel.md) отражает одно реактивное решение, то **Идея Процесса** воплощает проактивный и стратегический рабочий процесс. Это артефакт, создаваемый системой [010: Агент/План](./010_agent_plan.md) при выполнении сложной, многошаговой задачи. Таким образом, она становится полной записью как возможностей, доступных в рамках процесса, так и конкретной стратегии, выбранной агентом.

## Анатомия Плана

`Идея Процесса` использует тройку `Idea` для создания полного слепка рабочего процесса. Этот слепок содержит не только выбранную агентом стратегию (`План`), но и всю библиотеку возможностей, а также текущее состояние выполнения.

- **`schema` (Палитра):** Определяет библиотеку всех доступных [Инструментов](./002_agent_tool.md), из которых может быть построен `План`. Она представляет собой полный набор возможностей агента.

- **`context` (Ситуационная осведомленность):** Содержит всю информацию, необходимую агенту для планирования и выполнения текущего шага.
  - **Входящее сообщение (Input):** Первоначальный стимул, который запустил весь процесс. Обычно предоставляется один раз и остается неизменным.

    > Sidenote: [007: Агент/Ввод](./007_agent_input.md)

  - **Сообщение о состоянии (State):** Актуальные, постоянно меняющиеся данные рабочего процесса. Содержит сохраненные локальные переменные, которые образуют связи (ребра) между `Calls` в `Плане`.

    > Sidenote: [009: Агент/Состояние](./009_agent_state.md)

  - **Сообщение о плане (Plan):** Это сообщение содержит _утвержденный_ план с предыдущего шага, который агент может либо продолжать выполнять, либо скорректировать.

    > Sidenote: [010: Агент/План](./010_agent_plan.md)

- **`solution` (Новый План):** Направленный ациклический граф из `Calls`, который является выбранной стратегией агента на _текущий_ шаг. Он становится `Сообщением о плане` для следующего шага.

### Единство планирования и исполнения

Ключевой принцип этой архитектуры — слияние планирования и исполнения в единый процесс. В отличие от традиционных систем, где эти фазы разделены, здесь они происходят одновременно на каждом шаге. Агент не просто создает статичный план, а затем отдельно его выполняет; сам акт создания нового `solution` (нового `Плана`) _и есть_ шаг исполнения для текущего момента.

Именно это единство делает систему такой динамичной и эффективной. `План` — это живой граф, которому не обязательно быть завершенным, чтобы быть полезным. Он может быть частичным, работать с результатами предыдущего шага и адаптироваться на лету. `Calls`, генерируемые LLM, представляют собой одновременно и структуру конвейера, и данные, передаваемые внутри него. Эта двойственность позволяет одному запросу к LLM одновременно проверять текущее состояние, корректировать план на основе новых данных и выполнять следующий логический шаг. Нет никаких затрат на отдельные вызовы для перепланирования или проверки; исполнение — _это и есть_ проверка, планирование и корректировка, происходящие одновременно.

> Sidenote: [004: Агент/Вызов](./004_agent_call.md)

Эта единая модель дает два мощных преимущества. Во-первых, `План` можно создать и симулировать на основе одних только его схем, даже до того, как появятся конкретные данные. LLM может "сыграть роль" каждого шага, что позволяет проектировать и проверять сложные рабочие процессы с самого начала. Во-вторых, LLM действует как интеллектуальный адаптер между шагами. Если выходные данные одного `Call` не полностью соответствуют ожидаемым входным данным следующего, LLM может устранить этот разрыв, обеспечивая исключительную стабильность системы по мере ее развития. Такая устойчивость предотвращает каскадные сбои, характерные для традиционных систем с жесткими связями.

> Sidenote: [105: Концепция/ИИ-центричность](./105_concept_ai_native.md)

### Спектр гибкости Плана

Объект `State` обеспечивает мощный трехэтапный жизненный цикл для `Плана`, позволяя ему эволюционировать от гибкого исследовательского процесса до предсказуемого, детерминированного рабочего процесса:

> Sidenote: [009: Агент/Состояние](./009_agent_state.md)

1.  **Свободный План:** Изначально `State` можно определить без `schema`. Это дает агенту максимальную свободу для нахождения `Плана` путем создания новых связей (свойств в объекте `State`) на лету.

2.  **Определенные связи:** Следующий шаг в "закалке" `Плана` — зафиксировать `schema` для `State`, что определяет основные пути передачи данных. Это можно сделать в рамках спектра от более гибкого к менее гибкому:
    - **Открытые связи:** Схема может разрешать `additionalProperties`, что обеспечивает соблюдение основных путей данных, но при этом дает агенту свободу создавать новые связи для второстепенных или исключительных случаев.
    - **Закрытые связи:** Схема может установить `additionalProperties` в `false`, создавая жесткую структуру, которой агент должен строго следовать.

3.  **Завершенный План:** Это финальная стадия, на которой план считается полностью зрелым и предсказуемым. `Завершенный План` становится **Утвержденным Планом**, который передается как `Сообщение о плане` в `context` для последующих шагов. Завершенный план может существовать в двух формах стабильности:
    - **Оптимальный План:** Завершенный план, который описывает идеальный сценарий. Он обеспечивает высокоэффективный путь, но может потребовать корректировки в случае непредвиденных событий.
    - **Полный План:** Полностью завершенный план, который со временем был расширен для учета частых сбоев, альтернативных путей и других сценариев, что делает его крайне детерминированным.

Такая последовательность позволяет `Идее Процесса` эволюционировать от гибкого проекта до высоконадежного и многократно используемого актива.

## Неизменяемые процессы: Оркестрация, анализ и масштабирование

Сила `Идеи Процесса` заключается в ее неизменяемости. Каждый шаг рабочего процесса создает новый, полный слепок `Плана` и `Состояния` (`State`), сохраняя идеальную, проверяемую историю. Этот ключевой принцип создания цепочки неизменяемых артефактов лежит в основе самых продвинутых возможностей системы по оркестрации, анализу и масштабированию.

- **Надежное, адаптивное исполнение:** Цикл исполнения, основанный на "шагах", фундаментально надежен, поскольку каждый новый шаг работает с полным слепком предыдущего состояния. Эта атомарность предотвращает состояния гонки и гарантирует, что решение агента следовать `Плану` или скорректировать его основано на последовательном и предсказуемом видении мира. Результатом каждого шага является новая `Идея Процесса`, безопасно продвигающая рабочий процесс на один шаг вперед.

  > Sidenote: [005: Агент/Цикл](./005_agent_loop.md), [010: Агент/План](./010_agent_plan.md)

- **Устойчивая оркестрация:** `Идея Процесса` является самодостаточным артефактом, что делает оркестрацию невероятно надежной. Рабочий процесс можно приостановить, просто сохранив его последний слепок. Внешние системы или люди-супервайзеры могут затем изучить это замороженное состояние для принятия решений. Любые корректировки, такие как перепланирование или изменение состояния, приводят к созданию _новой_ `Идеи Процесса`, которую затем можно использовать для безопасного возобновления работы без изменения исторической записи.

  > Sidenote: [009: Агент/Состояние](./009_agent_state.md)

- **Высокоточная симуляция:** Эта архитектура является предпосылкой для интерактивного "путешествия во времени". Каждая историческая `Идея Процесса` — это идеальный, высокоточный слепок рабочего процесса в определенный момент. Это позволяет пользователям или другим агентам загружать любую точку в истории процесса для проведения аудита, отладки сложного поведения или запуска сценариев "что, если" путем создания ответвления процесса с этой точки.

  > Sidenote: [202: Идея/Носитель](./202_idea_vessel.md)

- **Согласованная параллельная обработка:** Архитектура на основе слепков достигает огромного масштаба благодаря протоколу Инстансинга. Этот паттерн рассматривает каждую задачу в пакете как независимый поток выполнения, каждый со своим изолированным слепком `State`. Единый `План` действует как стратегический шаблон, применяемый ко всем потокам одновременно. За один атомарный шаг агент выполняет параллельное планирование для всего пакета, генерируя согласованный набор `Calls`, адаптированный для каждого экземпляра. Это гарантирует последовательный результат для разнообразных задач, одновременно резко повышая эффективность.

  > Sidenote: [011: Агент/Инстансинг](./011_agent_instancing.md)

## От предсказуемого плана к управляемому исполнению

`Идея Процесса` может созреть до **Завершенного Плана** — высокопредсказуемого и надежного рабочего процесса. Хотя такая жесткость обеспечивает стабильность, она также может ограничивать гибкость. Системе нужен способ вводить тонкие, зависящие от контекста указания, не нарушая целостности установленного плана.

Эту роль выполняет **[Идея Инструкции](./204_idea_instruction.md)**. `Инструкция` — это структурированный рецепт действий, который обеспечивает более высокий уровень стратегического руководства. Она действует как "мысленная контрольная карта" или набор принципов, влияющих на рабочий процесс на двух уровнях: направляя агента при выборе или создании наиболее подходящего `Плана` для данного контекста и предоставляя целевые указания для отдельных выборов и логических шагов во время выполнения этого `Плана`. По сути, `Инструкция` улучшает _логику_ и _рассуждения_ в рабочем процессе, обеспечивая соответствие как общей стратегии, так и тактического исполнения желаемой методологии.

> Sidenote: [204: Идея/Инструкция](./204_idea_instruction.md)