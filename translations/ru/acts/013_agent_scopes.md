# 013: Агент/Области видимости

> [!DEFINITION] [Область видимости](./000_glossary.md)
> Механизм, который делает контролируемое подмножество контекста из родительской среды доступным для выполнения. Свойство `_scopes` действует как список разрешённых элементов, определяя сфокусированное и безопасное представление данных, к которым может получить доступ :term[Вызов]{canonical="Call"}.

> Sidenote:
> - Требования:
>   - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}
>   - :term[004: Агент/Вызов]{href="./004_agent_call.md"}

Паттерн **:term[ограниченного контекста]{canonical="scope"}** — это фундаментальный механизм для управления контекстом, доступным для :term[Вызова]{canonical="Call"}. В сложной агентной системе :term[Вызов]{canonical="Call"} редко выполняется в вакууме; ему часто требуется доступ к информации из родительской среды, такой как ввод пользователя, текущее состояние или результаты предыдущих шагов. Ограниченный контекст обеспечивает безопасный и явный способ контроля этого потока информации.

Ограничивая контекст, области видимости повышают безопасность, предотвращают случайную утечку данных и фокусируют LLM, что приводит к более предсказуемым и экономичным выполнениям. Этот контролируемый контекст также является ключом к модульности, позволяя таким компонентам, как :term[Идеи]{canonical="Idea"} и :term[Действия]{canonical="Activity"}, быть по-настоящему самодостаточными и повторно используемыми. Этот документ объясняет, как работает этот паттерн и как он сочетается с другими возможностями агента.

## Предоставление и запрос контекста

Схема свойства `_scopes` определяет, будет ли контекст **предоставлен** статически или **запрошен** динамически во время выполнения.

> Sidenote:
> ```mermaid
> graph TD
>     subgraph Родительский контекст
>         direction LR
>         input("ввод")
>         state("состояние")
>     end
>
>     subgraph Вызов инструмента
>         direction LR
>         filter{{"_scopes: ['input']"}}
>     end
>
>     input --> filter
>     state -.-> filter
>
>     subgraph Предоставленный контекст
>         Execute(Выполнить инструмент)
>     end
>
>     filter --> HITL{{Одобрение человеком}}
>     HITL --> Execute
>
>     classDef unused stroke-dasharray: 5, 5, stroke:#aaa, color:#aaa
>     class state unused
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

- **Статические области видимости (предоставление контекста)**: Схема `_scopes` может быть значением `const`, что означает, что контекст **предоставляется**. Разработчик жёстко закодировал точный контекст, который разрешено видеть инструменту.

  ```json
  {
    "_scopes": {
      "const": ["input"]
    }
  }
  ```

- **Динамические области видимости (запрос контекста)**: Схема `_scopes` может быть более гибкой, позволяя **запрашивать** контекст. LLM решает, какие из доступных областей видимости ей необходимы для генерации :term[Вызова]{canonical="Call"}.

  ```json
  {
    "_scopes": {
      "type": "array",
      "items": {
        "enum": ["state", "input"]
      }
    }
  }
  ```

  Этот динамический паттерн особенно эффективен в сочетании с системой утверждения человеком (human-in-the-loop), обеспечивая критически важный уровень прозрачности и контроля.

## Роль областей видимости в композиции вызовов

Свойство `_scopes` — это основной механизм для контроля контекста, доступного :term[Вызову]{canonical="Call"}. Оно действует как список разрешённых элементов, фильтруя родительскую среду для предоставления сфокусированного, ограниченного поля зрения для выполнения. Этот контролируемый контекст является основополагающим для обработки :term[Вызова]{canonical="Call"}, и его роль адаптируется для поддержки композиционной модели выполнения, где могут сочетаться различные возможности, такие как явная логика, экземплирование и модульность.

- **Скрытое выполнение**: При скрытом выполнении по умолчанию `_scopes` служат «подсказкой» для фокусировки внимания LLM на релевантных частях родительского контекста. Это рекомендация, а не строгий фильтр, но она крайне важна для повышения надёжности и экономичности рассуждений LLM за счёт уменьшения шума от нерелевантных данных. См. пример [Устранение неоднозначности с помощью областей видимости](#example-disambiguation-with-scopes).

  > Sidenote:
  > - :term[002: Агент/Инструмент]{href="./002_agent_tool.md"}.

- **Явное выполнение (`_activity`)**: Когда :term[Вызов]{canonical="Call"} подкреплён детерминированным :term[Действием]{canonical="Activity"}, роль областей видимости становится более прямой. Ограниченный контекст передаётся целиком в функцию :term[Действия]{canonical="Activity"} в качестве дополнительного параметра. Это даёт :term[Действию]{canonical="Activity"} полный доступ к необходимым контекстным данным, даже если эти данные не использовались LLM напрямую для генерации основных параметров :term[Вызова]{canonical="Call"}. См. пример [Предоставление контекста для Действия](#example-providing-context-to-an-activity).

  > Sidenote:
  > - :term[003: Агент/Действие]{href="./003_agent_activity.md"}.

- **Экземплирование (`_instance`)**: В запросе с несколькими экземплярами, где агент обрабатывает пакет схожих объектов данных, области видимости начинают учитывать экземпляры. Протокол гарантирует, что :term[Вызов]{canonical="Call"}, нацеленный на конкретный экземпляр, получает контекст только для *этого* экземпляра. Это критически важно для поддержания целостности данных и предотвращения «утечки» контекста между параллельными выполнениями.

  > Sidenote:
  > - :term[011: Агент/Экземплирование]{href="./011_agent_instancing.md"}

- **Изоляция через делегирование (`_delegate`)**: Когда :term[Вызов]{canonical="Call"} делегируется внешнему :term[Делегату]{canonical="Delegate"}, области видимости действуют как стражи контекста. Они определяют, что из родительской среды будет *добавлено* к собственному внутреннему контексту делегата, создавая окончательный контекст для изолированного подзапроса. Ничего из родительского контекста не доступно, если это явно не указано в областях видимости, что обеспечивает настоящую инкапсуляцию. См. примеры [Ограничение контекста Делегата](#example-scoping-a-delegates-context) и [Экземплирование с ограниченными Делегатами](#example-instancing-with-scoped-delegates).

  > Sidenote:
  > - :term[012: Агент/Делегат]{href="./012_agent_delegate.md"}

Свойство `_scopes` — это мост, который позволяет :term[Вызову]{canonical="Call"} получать контекст. Эта глава показала, как этот единый механизм адаптируется к различным режимам выполнения — от мягкого направления скрытого вызова до строгого определения всего контекста для делегированного. Именно эта гибкость делает его краеугольным камнем в построении сложных, безопасных и модульных агентных систем.

## Примеры

:::::details{title="Пример: Устранение неоднозначности с помощью областей видимости"}

::::columns
:::column{title="Неоднозначный контекст"}

В этом примере контекст неоднозначен. Он содержит двух разных пользователей: `currentUser` в `state` и `mentionedUser` в `input`. Агенту нужно отправить сообщение, но неясно, кому именно.

```json
[
  {
    "type": "state",
    "currentUser": { "id": "user_A", "name": "Alice" }
  },
  {
    "type": "input",
    "mentionedUser": { "id": "user_B", "name": "Bob" },
    "instruction": "Send a welcome message to the user mentioned above."
  }
]
```

:::
:::column{title="`Call` с областью видимости"}

Добавляя `_scopes: ["input"]`, вызывающая сторона даёт важную подсказку. Это указывает LLM сосредоточиться на сообщении из `input`, что эффективно устраняет неоднозначность и гарантирует отправку сообщения правильному получателю, Бобу.

```json
{
  "_tool": "sendMessage",
  "_scopes": ["input"],
  "recipientId": "user_B",
  "message": "Welcome, Bob!"
}
```

:::
::::
:::::

:::::details{title="Пример: Предоставление контекста для Действия"}

Здесь :term[Действие]{canonical="Activity"} нуждается в доступе к контекстной информации, которая не является прямым параметром инструмента. Инструмент `logEvent` принимает только `eventName`, но лежащему в его основе действию также необходимо знать `userId` для корректной работы.

::::columns
:::column{title="`Call` с областью видимости"}

:term[Вызов]{canonical="Call"} прост и предоставляет только `eventName`. Однако свойство `_scopes: ["state"]` указывает исполняющей среде передать объект `state` в действие.

```json
{
  "_tool": "logEvent",
  "_scopes": ["state"],
  "eventName": "user_login"
}
```

:::
:::column{title="Реализация Действия (TypeScript)"}

:term[Действие]{canonical="Activity"} регистрируется с функцией, которая деструктурирует свои параметры напрямую из вызова и из ограниченного контекста. Это обеспечивает чистый, прямой доступ как к `eventName`, так и к `userId`.

```typescript
// Параметры деструктурируются для прямого доступа к 'eventName'
// из вызова и к 'state' из ограниченного контекста.
Activity.register('logEvent', async ({ eventName }, { state }) => {
  const userId = state.userId;
  await analytics.track(eventName, { userId });
});
```

:::
::::
:::::

:::::details{title="Пример: Ограничение контекста Делегата"}

При делегировании `_scopes` определяют, что из родительского контекста будет *добавлено* к собственному внутреннему контексту делегата. Здесь высокоуровневый `Orchestrator` делегирует задачу, передавая весь объект `state` специализированному делегату `Summarizer`.

::::columns
:::column{title="Родительский `Call` с областью видимости"}

Агент `Orchestrator` имеет свой собственный контекст. Он делает `Call`, который ограничивает `state` для включения в контекст делегата.

```json
// Контекст и вызов Оркестратора
[
  {
    "type": "state",
    "articleText": "A long and complex article..."
  },
  {
    "_tool": "summarizeArticle",
    "_delegate": "SummarizerAgent",
    "_scopes": ["state"]
  }
]
```

:::
:::column{title="Контекст подзапроса Делегата"}

Среда выполнения `Summarizer` состоит из его собственного внутреннего контекста и данных, полученных из родительского контекста через области видимости. Это обеспечивает модульность, предоставляя при этом необходимую информацию.

```json
// Контекст, созданный для подзапроса Summarizer
[
  // Внутренний контекст Summarizer
  {
    "type": "system",
    "message": "You are an expert summarizer."
  },
  // Ограниченный контекст из родителя добавляется
  {
    "type": "state",
    "articleText": "A long and complex article..."
  }
]
```

:::
::::
:::::

:::::details{title="Пример: Экземплирование с ограниченными Делегатами"}

Этот пример показывает, как `_scopes` и `_instance` сочетаются, чтобы позволить одному агенту организовывать несколько изолированных вызовов делегатов параллельно.

::::columns
:::column{title="Родительский контекст и решение"}

У родительского агента есть два разных экземпляра `State`. Он генерирует `solution` с двумя `Calls` к `translatorDelegate`. Каждый вызов нацелен на свой экземпляр и корректно ограничивает только `state` для этого экземпляра.

```json
// РОДИТЕЛЬСКИЙ КОНТЕКСТ
[
  { "type": "state", "_instance": "①", "text": "Hello" },
  { "type": "state", "_instance": "②", "text": "Bonjour" }
]

// РЕШЕНИЕ LLM
{
  "calls": [
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "①",
      "_scopes": ["state"]
    },
    {
      "_tool": "translate",
      "_delegate": "translatorDelegate",
      "_instance": "②",
      "_scopes": ["state"]
    }
  ]
}
```

:::
:::column{title="Контексты подзапросов Делегатов"}

Исполняющая среда создаёт два независимых подзапроса. Свойства `_instance` и `_scopes` работают вместе, чтобы гарантировать, что каждый делегат получит только свой собственный, правильно ограниченный `state`.

```json
// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ①
[
  { "type": "system", "message": "You are a translator." },
  { "type": "state", "text": "Hello" }
]

// КОНТЕКСТ ДЛЯ ДЕЛЕГАТА ②
[
  { "type": "system", "message": "You are a translator." },
  { "type": "state", "text": "Bonjour" }
]
```

:::
::::
:::::
