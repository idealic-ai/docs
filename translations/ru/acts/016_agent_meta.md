# 015: Агент/Мета

> [!DEFINITION] [Мета-свойства](./000_glossary.md)
> Структурированный объект, который содержит явную идентификацию :term[Запроса]{canonical="Request"}, включая его имя, пространство имён, версию, дату создания и ассоциации с ветками. Он предоставляет стабильный, машиночитаемый якорь для отслеживания происхождения и адресуемости запроса.

> Sidenote:
> - Требует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
> - Дополняется:
>   - :term[107: Концепция/Идентичность]{href="./107_concept_identity.md"}
>   - :term[108: Концепция/Видимость]{href="./108_concept_visibility.md"}
>   - :term[110: Концепция/Адресация]{href="./110_concept_addressing.md"}

Хотя многие взаимодействия агентов могут быть эфемерными, для создания сложных систем с отслеживанием состояний требуется способ уникальной идентификации и отслеживания :term[Запроса]{href="./001_agent_request.md"} и его итогового :term[Решения]{href="./001_agent_request.md"}. Объект **`Meta`** служит именно этой цели. Это «визитная карточка» :term[Запроса]{canonical="Request"}, предоставляющая стабильный, машиночитаемый идентификатор, который обеспечивает сохранение, версионирование, маршрутизацию и историческое отслеживание.

Ключевым моментом является то, что, делая идентификацию явной частью `solution`, объект `Meta` даёт LLM возможность создавать новые идентификаторы или ответвлять существующие в прямой реакции на свой контекст, превращая простой ответ в акт творения.>

> Sidenote:
> :term[107: Концепция/Идентичность]{href="./107_concept_identity.md"}

## Объект Meta в жизненном цикле Запроса

Объект `Meta` является полноправным участником жизненного цикла :term[Запроса]{href="./001_agent_request.md"}. Он появляется в `context`, чтобы информировать LLM о текущей идентификации запроса, и в `schema` как обязательная часть `solution`.

- **В `context`**: Сообщение `meta` предоставляет LLM идентификатор состояния или процесса, который он в данный момент обновляет.
- **В `schema`**: Схема `solution` требует свойство `meta`, заставляя LLM рассматривать и обновлять идентификатор как часть своей задачи.
- **В `solution`**: LLM генерирует новый объект `meta`, часто с обновлённой версией, отражающей эволюцию процесса.

Этот цикл превращает LLM из простого обработчика в активного участника жизненного цикла версионируемой сущности с состоянием.

> [!HEADSUP] На заметку: От Запроса к Идее
> Весь этот конвейер :term[Запроса]{href="./001_agent_request.md"} — `context` (включая сообщение `Meta`), `schema` и итоговый `solution` — образует самодостаточную, воспроизводимую единицу. При сохранении эта единица становится тем, что система называет :term[Идеей]{href="./101_concept_idea.md"}. Объект `Meta` — это ключ, который превращает эфемерный `Request` в постоянную, адресуемую `Idea`.
>
> > Sidenote:
> > :term[101: Концепция/Идея]{href="./101_concept_idea.md"}

::::columns
:::column{title="Пример структуры Запроса"}

```json
// LLM получает текущие метаданные как контекст,
// и ей поручается создать новые в решении.
{
  "context": [
    {
      "type": "meta",
      "meta": {
        "domain": "reactor.ideas.services",
        "path": "/games/321",
        "version": "1.2.3",
        "branches": ["main"],
        "createdAt": "2025-10-26T10:00:00Z"
      }
    },
    {
      "type": "state",
      "state": {
        "...текущее состояние игры..."
      }
    }
  ],
  "schema": {
    "type": "object",
    "properties": {
      "meta": {
        "$ref": "MetaSchema"
      },
      "output": {
        "$ref": "GameSchema"
      }
    }
  }
}
```

:::
:::column{title="Пример Решения"}

```json
// Решение LLM включает следующее состояние игры
// и обновлённую версию в новом мета-объекте.
{
  "meta": {
    "domain": "reactor.ideas.services",
    "path": "/games/321",
    "version": "1.2.4",
    "branches": ["main"],
    "createdAt": "2025-10-26T10:05:00Z"
  },
  "output": {
    "...следующее состояние игры..."
  },
  "calls": []
}
```

:::
::::

## Автономная эволюция и версионирование

Ключевая роль объекта `Meta` заключается в обеспечении автономной эволюции агентных процессов. Включая текущую версию и ветки в `context` и требуя новую версию в `solution`, система поручает LLM обновление версии. Создание нового `solution` по той же `schema` считается совместимым изменением, и поэтому агент должен инкрементировать минорную версию. Это создаёт новый, неизменяемый снимок его состояния и логики, формируя полную и проверяемую историю действий агента с течением времени.

> Sidenote:
> - Принципы автономного улучшения описаны в :term[106: Концепция/Эволюция]{href="./106_concept_evolution.md"}.

Это создаёт проблему в распределённых системах: если два независимых процесса одновременно реагируют на разные события, они оба могут попытаться обновить версию с `1.2.3` до `1.2.4`, создавая состояние гонки.

Архитектура решает эту проблему с помощью механизма ветвления. При создании новой линии разработки процесс добавляет новую ветку в массив `branches` (например, `["main", "my-feature"]`) и создаёт разветвлённую версию. Версии становятся соответственно `1.2.3.branch-A.1` и `1.2.3.branch-B.1`. Это позволяет осуществлять параллельную, бесконфликтную эволюцию, при этом различные истории могут быть объединены или согласованы позже.

> Sidenote:
> - Это подробно описано в :term[108: Концепция/Видимость]{href="./108_concept_visibility.md"}.

## Связывание идентификатора с адресом

Поля в объекте `Meta` предоставляют все необходимые компоненты для присвоения :term[Запросу]{canonical="Request"} глобально уникального адреса. Это позволяет программно извлекать, маршрутизировать или ссылаться на конкретный версионированный экземпляр пары запрос/решение.

> Sidenote:
> - Конкретный синтаксис этой схемы адресации определён в :term[110: Концепция/Адресация]{href="./110_concept_addressing.md"}.

Процесс разрешения связывает динамический запрос с конкретным, неизменяемым результатом. Вот подробное описание:

- **Мета**: Свойства конкретного версионированного экземпляра.
  - _meta.domain:_ `my-project.com`
  - _meta.path:_ `bob`
  - _meta.version:_ `1.2.staging.1`
  - _meta.branches:_ `['staging']`
  - _meta.createdAt:_ `2025-10-26T10:00:00Z`

- **Ссылка**: Динамический запрос к сущности.
  - `idea://my-project.com/bob?1.2`
  - _Путь поиска:_ `['staging']`
  - _Дата отсечки:_ `2025-10-26T10:00:00Z` (из `createdAt`)

- **Разрешено**: Постоянный, однозначный URI, указывающий на найденный ресурс.
  - `idea://my-project.com/~:staging/bob?1.2:1.2.staging.1`
  - _Ветка:_ `~:staging`
    - _запрошено:_ любая ветка в пути поиска
    - _получено_: `staging`
  - _Версия:_ `1.2:1.2.staging.1`
    - _запрошено:_ последняя совместимая с `1.2`
    - _получено:_ `1.2.staging.1`

Это делает весь блок запрос-решение самоописываемым и адресуемым.
