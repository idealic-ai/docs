# 103: Концепция/Идеатор

> [!DEFINITION] [Идеатор](./000_glossary.md)
> Это :term[Идея]{canonical="Idea"}, которая принимает входные данные, обозначенные контекстным сообщением с `type: "input"`. Она действует как функция, преобразующая входные данные в выходные.

> Sidenote:
> - Требует:
>   - [101: Концепция/Идея](./101_concept_idea.md)
>   - [006: Агент/Ввод](./006_agent_input.md)
> - Позволяет:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [102: Концепция/Суверенитет](./102_concept_sovereignty.md)

Протокол для :term[Идеаторов]{canonical="Ideator"} и :term[Трансформеров Идей]{canonical="Idea Transformer"} определяет их как исполняемые, сервисные компоненты. Он основывается на базовом документе [101: Концепция/Идея](./101_concept_idea.md), который определяет основную структуру данных, и описывает, как :term[Идея]{canonical="Idea"} превращается в функциональную, вызываемую сущность.

Подробнее о различных моделях хостинга и развертывания см. в [102: Концепция/Суверенитет](./102_concept_sovereignty.md).

## От Идеи к Идеатору

**:term[Идеатор]{canonical="Ideator"}** — это не отдельная сущность, а функциональная роль, которую может выполнять любая :term[Идея]{canonical="Idea"}. Его можно рассматривать как функцию, которая выполняет работу, преобразуя входные данные в выходные в :term[скрытом состоянии]{canonical="Latent Execution"}. Это означает, что его логика не обязательно определяется явным кодом, а вместо этого руководствуется богатым `контекстом` :term[Идеи]{canonical="Idea"} — ее схемами, примерами и инструкциями на естественном языке, — который интерпретируется LLM.

Окончательным признаком того, что :term[Идея]{canonical="Idea"} является :term[Идеатором]{canonical="Ideator"}, является наличие сообщения в `контексте` с `type: "input"`. Это сообщение определяет схему данных, которые ожидает :term[Идеатор]{canonical="Ideator"}. _Исполняемый_ :term[Идеатор]{canonical="Ideator"} также может содержать сообщение в `контексте` с `type: "code"`, указывающее на явную реализацию.

### Трансформер Идей: Особый случай

Распространенный и мощный паттерн — это :term[Идеатор]{canonical="Ideator"}, входными данными для которого является другая :term[Идея]{canonical="Idea"}. Мы называем этот особый тип :term[Идеатора]{canonical="Ideator"} **:term[Трансформером Идей]{canonical="Idea Transformer"}**. Именно это позволяет создавать композиционные конвейеры, в которых :term[Идеи]{canonical="Idea"} объединяются в цепочки и развиваются.

## Реализации и Композиция

Архитектурные принципы, изложенные здесь, определяют **поведенческий контракт** для любого сервиса-:term[Идеатора]{canonical="Ideator"}. Этот контракт предназначен не для одной программы, а является стандартом для взаимодействия, что позволяет создавать множество реализаций и богатую, композиционную экосистему.

### Множество реализаций

Контракт сервиса-:term[Идеатора]{canonical="Ideator"} выполняется путем соблюдения его публичного API (прием одной :term[Идеи]{canonical="Idea"} и возврат другой). Это допускает множество конкретных реализаций, каждая из которых подходит для разных случаев использования:

- **Управляемые сервисы**: Провайдер может предложить хостинг в качестве управляемого облачного сервиса, абстрагируясь от инфраструктуры, как описано в Протоколе [:term[Суверенитета]{href="./102_concept_sovereignty.md"}](./102_concept_sovereignty.md).
- **Самостоятельно размещенные экземпляры**: Разработчик может запустить собственную реализацию сервиса на своей инфраструктуре, получая полный контроль.
- **Реализации в памяти**: Для локальной разработки и тестирования логика выполнения :term[Идеатора]{canonical="Ideator"} может быть запущена как простая функция в памяти, полностью минуя сеть, но при этом соблюдая основной контракт.

### Композиция и Системы Высшего Порядка

В этой экосистеме нет понятия «приватного API». Все сервисы созданы для взаимодействия через свои публичные, основанные на контрактах, интерфейсы.

Более сложные сервисы, которые можно рассматривать как **Системы Высшего Порядка**, создаются путем композиции других, более примитивных :term[Идеаторов]{canonical="Ideator"}. Внутренняя логика сервиса высшего порядка включает вызовы публичных API других :term[Идеаторов]{canonical="Ideator"}.

Например, система **:term[Реактор]{canonical="Reactor"}** — это :term[Идеатор]{canonical="Ideator"} высшего порядка. Чтобы управлять игрой, он может:

1.  Принять :term[Идею]{canonical="Idea"} о состоянии игры через свой публичный API.
2.  Внутренне вызвать публичный сервис `Player` для создания и управления идентификаторами игроков.
3.  Вызвать публичный сервис `Storage` для записи истории игры.
4.  Вернуть новую :term[Идею]{canonical="Idea"} о состоянии игры через свой публичный API.

Снаружи :term[Реактор]{canonical="Reactor"} — это просто еще один :term[Идеатор]{canonical="Ideator"}. Его сложность управляется внутри за счет композиции других независимых, публичных сервисов.

## Уточнитель: Идеатор для эволюции

В то время как большинство :term[Идеаторов]{canonical="Ideator"} работают в рамках ограничений заданной `схемы` для создания :term[Решения]{canonical="Solution"}, существует особый класс :term[Трансформеров Идей]{canonical="Idea Transformer"}, предназначенный для развития самой `схемы`. Это **:term[Уточнитель]{canonical="Refiner"}**.

:term[Уточнитель]{canonical="Refiner"} — это мета-операция, которая управляет структурной эволюцией :term[Идеи]{canonical="Idea"}. Он принимает на вход существующую :term[Идею]{canonical="Idea"} и подсказку (например, «Добавь поле 'author' к этой статье») и на выходе создает _новую_ :term[Идею]{canonical="Idea"}.

Эта новая :term[Идея]{canonical="Idea"} имеет:

- **Обновленную `схему`**.
- **Обновленное :term[Решение]{canonical="Solution"}**, соответствующее новой `схеме`.
- **Перенесенные данные** из исходного :term[Решения]{canonical="Solution"}. LLM, зная как старую, так и новую схемы, пытается разумно перенести данные.

:term[Уточнитель]{canonical="Refiner"} является основным механизмом для продвижения **:term[линии наследования]{canonical="Lineage"}** :term[Идеи]{canonical="Idea"}. Если изменение схемы несовместимо с предыдущими версиями, новая :term[Идея]{canonical="Idea"} будет представлять собой новую мажорную версию в своей цепочке версий. Это позволяет безопасно и явно развивать основные структуры данных системы, что управляется специальным, многоразовым :term[Идеатором]{canonical="Ideator"}.

Теперь, когда :term[Идеатор]{canonical="Ideator"} предоставляет основу для выполнения, следующий шаг — понять, как это выполнение происходит на самом деле. Это приводит нас к концепции :term[скрытого исполнения]{canonical="Latent Execution"}, где LLM интерпретирует контекст :term[Идеи]{canonical="Idea"} для генерации результата без явного кода.
