# 103: Концепция/Идеатор

> **Идеатор:** Это `Idea`, которая принимает входные данные, обозначенные сообщением `context` с `type: "input"`. Он действует как функция, преобразующая входные данные в выходные. — [Глоссарий](./000_glossary.md)

> Sidenote:
> - Требует:
>   - [101: Концепция/Идея](./101_concept_idea.md)
>   - [007: Агент/Ввод](./007_agent_input.md)
> - Открывает возможности для:
>   - [004: Агент/Вызов](./004_agent_call.md)
>   - [102: Концепция/Суверенитет](./102_concept_sovereignty.md)

## Введение

Этот документ описывает протокол для **Идеаторов** и **Трансформаторов Идей** как исполняемых компонентов на основе сервисов. Он основан на фундаментальном документе [101: Концепция/Идея](./101_concept_idea.md), который определяет базовую структуру данных, и описывает, как `Idea` превращается в функциональную, вызываемую сущность.

Подробнее о различных моделях хостинга и развертывания можно узнать в документе [102: Концепция/Суверенитет](./102_concept_sovereignty.md).

## От Идеи к Идеатору

**Идеатор** — это не отдельная сущность, а функциональная роль, которую может выполнять любая `Idea`. Его можно рассматривать как функцию, которая выполняет работу, преобразуя входные данные в выходные в **скрытом пространстве**. Это означает, что его логика не обязательно определяется явным кодом, а направляется богатым `context` самой `Idea` — её схемами, примерами и инструкциями на естественном языке, которые интерпретируются LLM.

Определяющим признаком того, что `Idea` является Идеатором, является наличие сообщения `context` с типом `type: "input"`. Это сообщение определяет схему данных, которые ожидает Идеатор. *Исполняемый* Идеатор также может включать сообщение `context` с типом `type: "code"`, указывающее на явную реализацию.

### Трансформатор Идей: особый случай

Распространенный и мощный паттерн — это Идеатор, входными данными для которого является другая `Idea`. Мы называем такой тип Идеатора **Трансформатором Идей**. Именно это делает возможными композиционные конвейеры, в которых Идеи связываются в цепочки и развиваются.

## Реализации и композиция

Архитектурные принципы, изложенные в этом документе, определяют **поведенческий контракт** для любого сервиса-Идеатора. Этот контракт предназначен не для одной программы, а является стандартом для взаимодействия, что позволяет создавать множество реализаций и богатую композиционную экосистему.

### Множество реализаций

Контракт сервиса-Идеатора считается выполненным, если он соблюдает свой публичный API (принимает одну `Idea` и возвращает другую). Это допускает множество конкретных реализаций, каждая из которых подходит для разных случаев:

- **Управляемые сервисы**: Провайдер может предлагать хостинг как управляемый облачный сервис, абстрагируя инфраструктуру, как описано в [Протоколе Суверенитета](./102_concept_sovereignty.md).
- **Собственные инсталляции**: Разработчик может запустить собственную реализацию сервиса на своей инфраструктуре, получая полный контроль.
- **Реализации в памяти**: для локальной разработки и тестирования логика выполнения Идеатора может быть запущена как простая функция в памяти, полностью минуя сеть, но при этом соблюдая основной контракт.

### Композиция и системы высшего порядка

В этой экосистеме нет понятия «приватного API». Все сервисы созданы для взаимодействия через свои публичные, основанные на контрактах, интерфейсы.

Более сложные сервисы, которые можно рассматривать как **Системы Высшего Порядка**, создаются путем композиции других, более примитивных `Идеаторов`. Внутренняя логика сервиса высшего порядка включает в себя вызовы публичных API других `Идеаторов`.

Например, система **Реактор** является `Идеатором` высшего порядка. Для управления игрой он может:

1. Принять `Idea` состояния игры через свой публичный API.
2. Внутри себя вызвать публичный сервис `Player` для создания и управления идентификаторами игроков.
3. Вызвать публичный сервис `Storage` для записи истории игры.
4. Вернуть новую `Idea` состояния игры через свой публичный API.

Снаружи Реактор — это просто еще один `Идеатор`. Его сложность управляется внутри за счёт композиции других независимых публичных сервисов. Это обеспечивает модульность, прозрачность и масштабируемость всей системы.
