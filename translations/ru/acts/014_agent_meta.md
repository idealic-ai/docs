# 014: Агент/Мета

> [!DEFINITION] [Мета-свойства](./000_glossary.md)
> Структурированный объект внутри :term[Идеи]{canonical="Idea"}, который содержит её явную идентичность, включая имя, пространство имён, версию, дату создания и ассоциации с ветками. Он обеспечивает стабильный, машиночитаемый якорь для происхождения и адресуемости :term[Идеи]{canonical="Idea"}.

> Sidenote:
> - Требует:
>   - :term[001: Агент/Запрос]{href="./001_agent_request.md"}
>   - :term[107: Концепция/Идентичность]{href="./107_concept_identity.md"}
> - Позволяет:
>   - :term[108: Концепция/Видимость]{href="./108_concept_visibility.md"}
>   - :term[110: Концепция/Адресация]{href="./110_concept_addressing.md"}

В то время как :term[Эмерджентная Идентичность]{href="./107_concept_identity.md"} возникает из сети взаимосвязей между :term[Идеями]{canonical="Idea"}, для программного взаимодействия необходима более прямая и явная форма идентичности. Объект **`Meta`** выполняет эту цель. Это «визитная карточка» :term[Идеи]{canonical="Idea"}, предоставляющая стабильный, машиночитаемый идентификатор для версионирования, адресации и самосознания.

## Объект `Meta` в жизненном цикле Запроса

Объект `Meta` — это первоклассный элемент в жизненном цикле :term[Запроса]{href="./001_agent_request.md"}. Он появляется в `context`, чтобы сообщить LLM о текущей идентичности :term[Идеи]{canonical="Idea"}, и в `schema` как обязательная часть `solution`.

- **В `context`**: Сообщение `meta` предоставляет LLM идентичность :term[Идеи]{canonical="Idea"}, которую она в данный момент обрабатывает.
- **В `schema`**: Схема `solution` требует свойство `meta`, заставляя LLM рассматривать и обновлять идентичность :term[Идеи]{canonical="Idea"} в рамках своей задачи.
- **В `solution`**: LLM генерирует новый объект `meta`, часто с обновлённой версией, отражая эволюцию :term[Идеи]{canonical="Idea"}.

Этот цикл превращает LLM из простого обработчика в активного участника жизненного цикла :term[Идеи]{canonical="Idea"}.

::::columns
:::column{title="Пример структуры Запроса"}

```json
// LLM получает текущие метаданные как контекст
// и должна создать новые в решении.
{
  "context": [
    {
      "type": "meta",
      "meta": {
        "domain": "reactor.ideas.services",
        "path": "/games/321",
        "version": "1.2.3",
        "branches": ["main"],
        "createdAt": "2025-10-26T10:00:00Z"
      }
    },
    {
      "type": "state",
      "state": {
        "...current game state..."
      }
    }
  ],
  "schema": {
    "type": "object",
    "properties": {
      "meta": {
        "$ref": "MetaSchema"
      },
      "output": {
        "$ref": "GameSchema"
      }
    }
  }
}
```

:::
:::column{title="Пример решения"}

```json
// Решение LLM включает следующее состояние игры
// и повышенную версию в новом мета-объекте.
{
  "meta": {
    "domain": "reactor.ideas.services",
    "path": "/games/321",
    "version": "1.2.4",
    "branches": ["main"],
    "createdAt": "2025-10-26T10:05:00Z"
  },
  "output": {
    "...next game state..."
  },
  "calls": []
}
```

:::
::::

## Автономная эволюция и версионирование

Ключевая роль объекта `Meta` — обеспечение автономной эволюции. Включая текущую версию и ветки в `context` и требуя новую версию в `solution`, система поручает LLM повышение версии. Каждый раз, когда агент реагирует на стимул, он может увеличить минорную версию :term[Идеи]{canonical="Idea"}, которую представляет, создавая новый, неизменяемый снимок её состояния и логики, сохраняя при этом связи с ветками.

Это создаёт проблему в распределённых системах: если два независимых процесса одновременно реагируют на разные события, они оба могут попытаться повысить версию с `1.2.3` до `1.2.4`, вызывая состояние гонки.

Архитектура решает эту проблему с помощью механизма ветвления, описанного в концепции :term[Видимости]{href="./108_concept_visibility.md"}. При создании новой линии разработки процесс добавляет новую ветку в массив `branches` (например, `["main", "my-feature"]`) и создаёт новую версию для ветки. Версии становятся, соответственно, `1.2.3.branch-A.1` и `1.2.3.branch-B.1`. Это позволяет вести параллельную, бесконфликтную эволюцию, а различные истории могут быть объединены или согласованы позже.

## Связь идентичности с адресом

Поля в объекте `Meta` напрямую соответствуют компонентам схемы URI :term[idea:]{href="./110_concept_addressing.md"}. Это создаёт неразрывную связь между явной идентичностью :term[Идеи]{canonical="Idea"} и её адресом в сети.

Эти свойства могут быть объединены в постоянный, полностью разрешённый URI, представляющий конкретное состояние :term[Идеи]{canonical="Idea"}: `idea://my-project.com/~staging/bob?1.2.3`

> Sidenote:
> - Схема URI :term[idea:]{href="./110_concept_addressing.md"} предоставляет конкретный синтаксис для ссылок и взаимодействия с этими развивающимися :term[Идеями]{canonical="Idea"}.

Этот постоянный URI может быть результатом разрешения более динамического ссылочного URI, например:

- Мета: `idea://my-project.com/~staging/bob?1.2.3`
  - _meta.domain:_ `my-project.com`
  - _meta.path:_ `bob`
  - _meta.version:_ `1.2.staging.1`
  - _meta.branches:_ `['staging']`
  - _meta.createdAt:_ `2025-10-26T10:00:00Z`

- Ссылка: `idea://my-project.com/bob?1.2`
  - _Путь поиска:_ `['staging']`
  - _Дата отсечения:_ `2025-10-26T10:00:00Z`

- Разрешённый: `idea://my-project.com/~:staging/bob?1.2:1.2.staging.1`
  - _Ветка:_ `~:staging`
    - _запрошено:_ любая ветка
    - _получено_: `staging`
  - _Версия:_ `1.2:1.2.staging.1`
    - _запрошено:_ `1.2`
    - _получено:_ `1.2.staging.1`

Это делает :term[Идею]{canonical="Idea"} самоописываемой. Её объект `Meta` содержит всю информацию, необходимую для создания постоянной, полностью разрешённой ссылки на саму себя.
