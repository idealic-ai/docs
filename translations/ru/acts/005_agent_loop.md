# 005: Агент/Цикл

> [!DEFINITION] [Цикл](./000_glossary.md)
> Последовательность `Request`-ов, направленная на достижение цели. Агент продолжает вызывать `Request`-ы, обрабатывать полученные `Call`-ы и возвращать результат в контекст для следующего `Request`-а до тех пор, пока не перестанут генерироваться `Call`-ы.

> Sidenote:
> - Требуется:
>   - [001: Агент/Запрос](./001_agent_request.md)
>   - [002: Агент/Инструмент](./002_agent_tool.md)
>   - [004: Агент/Вызов](./004_agent_call.md)

Этот документ описывает **цикл исполнения**, который позволяет агенту выполнять многошаговые задачи, итеративно создавая [001: Агент/Запрос](./001_agent_request.md). Этот итеративный процесс сборки контекста, использования инструментов и обратной связи и есть то, что обычно подразумевают под «агентом».

## Цикл исполнения

> Sidenote:
> ```mermaid
> graph TD
>     Start((Начало)) --> SchemaComposition(1. Композиция схемы)
>     SchemaComposition --> ContextAssembly(2. Сборка контекста)
>     ContextAssembly --> RequestInvocation(3. Вызов Запроса)
>     RequestInvocation --> CallProcessing(4. Обработка вызовов)
>     CallProcessing --> HasCalls{Есть вызовы?}
>     HasCalls -- Yes --> HITL{Участие человека в цикле}
>     HITL -- Approved --> Execution(5. Исполнение и обратная связь)
>     Execution -- Results --> ContextAssembly
>     HITL -- Corrected --> ContextAssembly
>     HasCalls -- No --> Termination(6. Завершение)
>     Termination --> OutputGeneration(7. Генерация вывода)
>     OutputGeneration --> End((Конец))
>     classDef optional stroke-dasharray: 5, 5
>     class HITL optional
> ```

Цикл исполнения — это основной механизм для автономного, многошагового выполнения задач. Он работает следующим образом:

1.  **Композиция схемы:** Цикл настраивается с помощью определённой пользователем _схемы вывода_ для конечного результата. Она автоматически объединяется со схемами доступных [Инструментов](./002_agent_tool.md) для создания единой схемы для `Request`, как описано в разделе [Композиция схем инструментов](./002_agent_tool.md#composing-schemas-for-the-llm).
2.  **Сборка контекста:** Цикл начинается со сборки начального контекста, который может включать цель пользователя и другую релевантную информацию.
3.  **Вызов Запроса:** Цикл вызывает [001: Агент/Запрос](./001_agent_request.md) с текущим контекстом и скомпонованной на предыдущем шаге схемой.
4.  **Обработка вызовов:** `Request` возвращает объект `solution`, содержащий массив из нуля или более [004: Агент/Вызов](./004_agent_call.md) в свойстве `calls`. Важно отметить, что на этом этапе эти `Call`-ы являются лишь предложенными действиями; они еще не выполнены.
5.  **Исполнение и обратная связь:**
    - Если массив `calls` в `solution` не пуст, цикл выполняет их. Для `Explicit` `Call`-ов это означает вызов соответствующего кода `Activity`.
    - Результаты этих `Call`-ов затем добавляются обратно в контекст для следующей итерации.
6.  **Завершение:** Если массив `calls` в `solution` пуст, агент считает свою цель достигнутой, и цикл завершается.
7.  **Генерация вывода:** По завершении поле `output` объекта `solution` содержит конечный результат, соответствующий определённой пользователем схеме вывода. Этот механизм позволяет агенту не только выполнять действия, но и создавать структурированный итоговый ответ. Содержимое `output` может быть преобразованием или обобщением контекста, накопленного в ходе цикла. Например, агент, которому поручен анализ данных, может выполнить несколько шагов обработки (каждый — это `Call`), а затем использовать поле `output` для возврата итогового отчета в формате JSON.

## Участие человека в цикле (HITL)

Ключевой особенностью цикла исполнения является его естественная поддержка контроля со стороны человека. Поскольку цикл разделяет генерацию `Call`-ов и их исполнение, это создает возможность для вмешательства пользователя:

- **Одобрение:** Перед выполнением `Call`-ов система может представить их пользователю для одобрения. Движок исполнения можно настроить с шагом подтверждения (например, функцией обратного вызова), который действует как точка останова, приостанавливая цикл до получения ввода от человека.
- **Корректировка:** Пользователь может изменять параметры `Call`-а или даже заменять его другим.

Важно отметить, что эти конкретные механизмы HITL не являются частью основного протокола. Архитектура просто обеспечивает необходимое разделение между предложением действий и их выполнением, предоставляя разработчикам гибкость для реализации любого вида вмешательства, от простого ручного одобрения до сложной автоматизированной системы с таймаутами.

Эта возможность критически важна для безопасности и совместных задач, где агент выступает в роли ассистента. Корректировки и обратная связь от пользователя могут быть использованы в [010: Агент/План](./010_agent_plan.md), позволяя агенту уточнять свою стратегию на основе человеческого ввода.

## Роль данных в цикле

Цикл исполнения обеспечивает динамическую структуру для поведения агента, но его мощь реализуется через данные, которые циркулируют внутри него. Контекст, входные и выходные данные, управляемые на каждом шаге цикла, позволяют агенту поддерживать контекст, учиться и выполнять сложные, многошаговые планы.

Следующий документ, [006: Агент/Данные](./006_agent_data.md), рассматривает протоколы для управления этими данными.
