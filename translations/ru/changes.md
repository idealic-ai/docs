# Обновления системы Агентов (Сессия от 30 октября 2025 г.)

Этот документ описывает ряд значительных обновлений основных протоколов :term[системы агентов]{canonical="Agent System"}, направленных на расширение возможностей :term[Действий]{canonical="Activity"}, формализацию :term[системы Планов]{canonical="Plan"} и уточнение семантики исполнения.

## 1. Расширенная сигнатура Действия и осведомленность о контексте (`003_agent_activity.md`)

Сигнатура обработчиков :term[Действий]{canonical="Activity"} была расширена, чтобы предоставить им больше контекста и контроля, что позволяет реализовывать более сложную детерминированную логику.

### Изменение:

- Обработчик :term[Действия]{canonical="Activity"} теперь принимает три аргумента: `(call, tool, context)`.
  - **`call`**: Полный объект вызова, включая все параметры и мета-свойства (`_outputPath`, `_instance` и т. д.).
  - **`tool`**: Схема исполняемого инструмента, позволяющая :term[действию]{canonical="Activity"} изучать свой собственный интерфейс, например, схему `_output`.
  - **`context`**: Массив сообщений, явно импортированных из родительской среды через протокол :term[Областей]{canonical="Scope"}.

### Обоснование:

Это изменение критически важно для реализации сложных, управляемых кодом рабочих процессов. Ранее :term[действие]{canonical="Activity"} было практически «слепо» к более широкому контексту своего исполнения. Теперь у него есть все необходимое, чтобы:

- **Реализовывать логику ветвления**: :term[Действие]{canonical="Activity"} может анализировать выражение ветвления `_outputPath` (например, `'†state.sunny || †state.rainy'`) и использовать собственную детерминированную логику для выбора пути, по которому будет записан результат.
- **Получать доступ к состоянию из Областей**: Оно может безопасно получать доступ к необходимой информации из родительского :term[состояния]{canonical="State"}, не имея доступа ко всему контексту.

## 2. Формализованная система Планов и режимы исполнения (`012_agent_plan.md`)

Концепция «планирования» была уточнена и формализована, став основной операционной моделью :term[агента]{canonical="Agent"}.

### Изменения:

- **Опциональное сохранение состояния**: Наличие сообщения :term[Плана]{canonical="Plan"} в запросе теперь явно указывает на итеративный рабочий процесс с сохранением состояния. Это дает команду :term[Циклу исполнения]{canonical="Execution Loop"} сохранять :term[план]{canonical="Plan"} и :term[состояние]{canonical="State"} между ходами. По умолчанию, если это сообщение отсутствует, запросы выполняются однократно и без сохранения состояния.
- **Режимы исполнения (`eager` против `lazy`)**: Сообщение :term[Плана]{canonical="Plan"} теперь включает свойство `mode` для управления стратегией исполнения.
  - **`eager` (по умолчанию)**: В этом режиме **планирование и есть исполнение**. LLM генерирует :term[план]{canonical="Plan"} и одновременно выполняет все :term[скрытые]{canonical="Latent"} шаги, которые может, в едином непрерывном потоке рассуждений. Промежуточный этап «проверки» отсутствует.
  - **`lazy`**: Этот режим обеспечивает строгое разделение. LLM действует как чистый планировщик, создавая полный декларативный граф потока данных без выполнения каких-либо :term[скрытых]{canonical="Latent"} операций. Это создает контрольную точку для валидации или утверждения человеком (human-in-the-loop, HITL) перед началом исполнения.
- **Уточнение скрытого ветвления**: Мы уточнили, что на **первой итерации** :term[плана]{canonical="Plan"} в режиме `eager` :term[скрытый вызов]{canonical="Latent Call"} не может ветвиться на основе своего собственного вывода. Поскольку планирование и исполнение происходят одновременно, процесс рассуждения LLM сворачивает любое потенциальное ветвление `_outputPath` в один конкретный путь для данного хода.

### Обоснование:

Эти изменения создают более строгую и гибкую основу для операций :term[агента]{canonical="Agent"}. Опциональное сохранение :term[плана]{canonical="Plan"} проясняет различие между простыми и сложными задачами. Режимы `eager`/`lazy` дают разработчикам точный контроль над автономией :term[агента]{canonical="Agent"}, позволяя реализовать как высокоскоростное реактивное исполнение, так и продуманные рабочие процессы под контролем человека, не изменяя при этом фундаментальную архитектуру.

## 3. Эфемерные вызовы и вызовы «вызвать и забыть» (`008_agent_output.md`)

Поведение для вызовов, в которых отсутствует свойство `_outputPath`, было четко определено, что открывает новые и мощные паттерны использования.

### Изменение:

- Добавлен новый раздел «Вызовы без пути вывода», объясняющий два различных варианта поведения:
  - **:term[Скрытые вызовы]{canonical="Latent Call"} (Эфемерные рассуждения)**: :term[Скрытый вызов]{canonical="Latent Call"} без `_outputPath` действует как промежуточная «мысль». Он обогащает контекст LLM для последующих шагов в рамках того же `solution`, но не сохраняется в :term[состоянии]{canonical="State"}, что предотвращает его загромождение. Это позволяет выстраивать более структурированные, многоэтапные рассуждения в рамках одного хода.
  - **Явные вызовы («вызвать и забыть»)**: Вызов :term[Действия]{canonical="Activity"} без `_outputPath` является операцией «вызвать и забыть». :term[Цикл исполнения]{canonical="Execution Loop"} вызывает :term[действие]{canonical="Activity"}, но не ожидает и не сохраняет результат.

### Обоснование:

Это уточнение подчеркивает, что отсутствие `_outputPath` является осознанным архитектурным решением. Оно позволяет LLM выполнять более сложные рассуждения, не создавая излишне подробной истории :term[состояния]{canonical="State"}, а также предоставляет понятный механизм для запуска побочных эффектов (таких как логирование или уведомления), которые не должны блокировать основной поток исполнения.