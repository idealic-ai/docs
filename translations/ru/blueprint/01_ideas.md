# Глава 1: Vibes и их проявления

## Новые идеи в этой главе

Эта глава знакомит с несколькими основополагающими концепциями, которые могут быть незнакомы, но важны для понимания нашей системы:

**Ключевое нововведение: Архитектура, ориентированная на контент (Content-First)**

- Традиционные системы фокусируются на объектах и скрывают их взаимодействия. Мы делаем наоборот: мы храним и изучаем сами **взаимодействия** (Vibes) как основную реальность.
- Представьте, что вы фокусируетесь на записанных разговорах, а не на людях, которые их ведут.

**Vibe: самодостаточная запись взаимодействия**

- Каждое взаимодействие становится неизменяемой записью, состоящей из трех частей: что его вызвало (`context`), как его обработать (`schema`) и что получилось в результате (`solution`).
- Это как полный отчет о лабораторном эксперименте, который содержит гипотезу, методологию и результаты в одном пакете.

**Четыре вычислительных паттерна как типы Vibe**

- **Role Vibes** (Vessels): Множество возможностей, работающих одновременно для создания эмерджентного поведения
- **Process Vibes** (Workflows): Пошаговые детерминированные последовательности для предсказуемых результатов
- **Record Vibes**: Самоописывающие данные, которые знают, как с собой взаимодействовать
- **Capability Vibes**: Разрешения, которые определяют, какие действия авторизованы

**Путешествие во времени через контент**

- Поскольку каждое взаимодействие сохраняется с полным контекстом, вы можете вернуться и продолжить диалог с любым прошлым состоянием системы.
- Это как иметь полную запись каждого принятого решения с возможностью создать новую ветвь с любой точки.

Эти концепции вместе создают систему, где контент учит созданию, функции возникают из данных, а сложное поведение появляется из простых, комбинируемых паттернов.

---

## Фундаментальная единица: Vibe

**Vibe** — это фундаментальная единица взаимодействия и знаний в нашей системе. Он представляет собой неизменяемую, самодостаточную запись конкретного взаимодействия, где `solution` определяется на основе `context` и руководящего определения `schema`. Каждый Vibe включает в себя:

1.  **context**: Контекстуальная информация и параметры (например, запрос пользователя, данные, память), которые определяют детали конкретного взаимодействия.
2.  **schema**: Это поле внутри Vibe содержит его полную структурную схему — объект JSON Schema. Это определение `schema` направляет определение `solution` и может также подразумевать или ссылаться на рабочие паттерны или встроенные инструменты. Концептуально это можно сравнить с «уравнением» или набором критериев, которым должен удовлетворять `solution`. Для Record Vibes это поле явно содержит JSON Schema, определяющую структуру его `solution`.
3.  **solution**: Итоговый контент или результат. Система или внешний агент, например LLM, _определяет_ или _находит_ `solution`, который _соответствует_ определению `schema` (находящемуся в поле `schema` у Vibe) с учетом конкретного `context`. Успех, характер и даже конкретное значение этого `solution` могут зависеть от возможностей агента, участвующего в его определении.

Эта тройка {context, поле `schema`, solution} образует **неизменяемую** и **самодостаточную** запись.

- **Неизменяемость (Immutability)**: Конкретный Vibe, однажды записанный с определенным `solution`, является фиксированным. Если для того же `context` и определения `schema` требуется другой `solution`, создается новый Vibe. Этот основной принцип важен для целостности системы и дает несколько преимуществ: он обеспечивает надежное версионирование и безопасное повторное использование `solutions`, предотвращает конфликты версий в совместной работе, создает стабильную основу для построения сложных взаимодействий из известных компонентов и позволяет проводить надежный исторический анализ и отладку.
- **Самодостаточность (Self-containment)**: Vibe функционирует как полная и независимая единица. Это происходит потому, что он **либо напрямую включает все необходимые компоненты** (свой `context`, конкретное определение`schema`, которому он соответствовал (в своем поле `schema`), и определенный `solution`), **либо содержит всю информацию, необходимую для восстановления этого полного контекста**. Следовательно, записанный результат Vibe стабилен, а его соответствие определению `schema` можно проверить. Vibe последовательно представляет понимание взаимодействия, независимо от какой-либо конкретной среды, и будет производить тот же концептуальный результат для своей `schema(context)` везде, где он обрабатывается.

Хотя отдельные Vibes хранятся постоянно, определения `schema` (концептуальные «формы уравнений» или структурные схемы) происходят из системных шаблонов или выводятся и развиваются из предыдущих Vibes. У любого Vibe всегда можно проверить определение `schema`, которому он соответствовал (в его поле `schema`), и `context`, который он обработал.

Этот подход означает, что:

- Чтобы получить _другой или уточненный `solution`_ для того же определения `schema` и `context`, создается новый Vibe.
- Когда определение `schema` _изменяется_, что означает эволюцию или уточнение:
  - Новые Vibes принимают это обновленное определение `schema` в свое поле `schema`. Это может привести к другим, часто более точным, `solutions`.
  - Это изменение представляет собой _уточнение_ концептуального типа Vibe. Это _расширение_ и _уточнение_ исходного определения `schema`, делающее его более конкретным путем добавления деталей или ограничений. Это гарантирует, что Vibe развивается согласованно, сохраняя свою фундаментальную природу, а не превращаясь в совершенно несвязанный тип, чье определение `schema` больше не будет удовлетворять исходным основным принципам. (Механика таких преобразований подробно описана позже.)
  - Поскольку это уточняющее расширение, любой `solution`, соответствующий новому, более конкретному определению `schema`, по своей сути будет также удовлетворять исходному, более общему определению `schema`, из которого он развился.
  - Важно отметить, что существующие Vibes всегда сохраняют свое исходное определение `schema` с момента их создания, обеспечивая сохранность прошлых записей.
- Для обработки _другого `context`_ с тем же определением `schema` создается новый Vibe, фиксирующий конкретный `solution` для этого случая.

Этот подход предлагает несколько ключевых архитектурных преимуществ:

- **Ориентация на контент (Content-Centricity)**: Наш фокус всегда на самих Vibes — конкретных свидетельствах взаимодействий и их `solutions` — а не на абстрактных концептуальных паттернах, которые предоставляют определения `schema`**. Это переворачивает традиционное объектно-ориентированное программирование, которое часто хранит внутренние состояния объектов, скрывая обмен сообщениями. Делая записи взаимодействий (Vibes) основными и постоянными, с системой становится гораздо проще работать и мигрировать.
- **Гибкость идентичности (Identity Flexibility)**: Концептуальные паттерны Vibe могут развиваться. Их определяющие `schema` (их «ДНК») могут обновляться или уточняться со временем, обычно в сторону большей конкретности. Эта эволюция означает, что новые Vibes, хотя и включают эти более подробные и конкретные определения `schema`, все еще могут пониматься как соответствующие исходному, более широкому концептуальному паттерну, из которого они произошли. Такие изменения в сторону конкретизации затрагивают только _будущие_ Vibes, созданные с новой версией определения `schema` (часто через трансформационные операции над существующими Vibes). Существующие Vibes, как неизменяемые исторические записи, остаются неизменными, сохраняя целостность прошлых взаимодействий. Это позволяет гибко развиваться, не нарушая исторический контекст, так как даже специализированные Vibes могут сохранять свою концептуальную преемственность с общим паттерном.
- **Улучшенная переносимость и воспроизводимость (Enhanced Portability & Reproducibility)**: Поскольку каждый Vibe является самодостаточным свидетельством, содержащим свой полный контекст (`context`, использованное определение `schema` из его поля `schema`, `solution`), его можно понять, проанализировать и его `solution` можно проверить независимо от какой-либо конкретной среды или состояния его исходного концептуального паттерна в более позднее время.
- **Эффективное хранение (Efficient Storage)**: Нам нужно хранить только Vibes — ощутимые «следы» взаимодействий. Нет необходимости поддерживать и хранить постоянный, активный экземпляр для каждого потенциального или фактического концептуального паттерна.

Эта перспектива помогает разрешить парадоксы, связанные с идентичностью и изменениями во времени. Подобно ДНК, Vibe — это фиксированная запись определенного момента. Даже если «исходный организм» (концептуальный паттерн) развивается, образец ДНК (Vibe) остается верной записью того, чем он был. Это обеспечивает прочную основу для версионирования, исторического анализа и понимания изменений в системе.

```llm
Концептуальные паттерны Vibe (подобно чертежам ДНК, некоторые из которых предоставляются системой) являются основой для Vibes.
Они не являются активными объектами. Когда определение `schema` паттерна (его конкретная «ДНК» в
определенный момент времени, хранящаяся в поле `schema` у Vibe) взаимодействует с `context`,
оно проявляет Vibe — неизменяемый «след» или доказательную запись этого взаимодействия.
Для Record Vibes это определение `schema` (например, JSON Schema) находится непосредственно в их поле
`schema`. Мы понимаем эти паттерны, изучая эти Vibes, которые содержат `context`,
использованное определение `schema` и `solution`. Когда несколько Record Vibes относятся к
«одному и тому же типу», их поля `schema` содержат идентичные определения. Эта модель,
ориентированная на контент, позволяет определениям развиваться для будущих взаимодействий (обычно
в сторону более конкретных схем), не изменяя прошлые доказательные Vibes, обеспечивая
сохранение истории при одновременной гибкости.
```

> **Алиса:** «То есть мы никогда не видим эти концептуальные паттерны, такие как 'Roles' или 'Record Schemas', в качестве активных агентов?»
> **Боб:** «Верно — только Vibes, которые они помогают определить. Они как их 'следы' или 'образцы ДНК'. Каждый Vibe — это конкретная запись, показывающая конкретное определение `schema` — 'ДНК' паттерна на тот момент, хранящееся в собственном поле `schema` у Vibe, — которое было использовано с `context` для получения `solution`.»
> **Алиса:** «И мы делаем вывод о природе паттерна, или о его 'профиле ДНК' на тот момент, изучая эти 'образцы' Vibe? Если у меня есть десять 'Invoice' Record Vibes, у всех них в поле `schema` будет одна и та же JSON-схема инвойса?»
> **Боб:** «Именно — Vibes являются доказательством. И да, у этих десяти Invoice Record Vibes в полях `schema` будет идентичная JSON-схема. Если концептуальный паттерн для 'Invoice' позже изменит свою 'ДНК' — скажем, добавится новое обязательное поле — это затронет только новые 'Invoice' Vibes, созданные с этого момента, обычно путем трансформации старого. Старые останутся неизменными записями прошлой активности.»

```question
Как мы понимаем концептуальные паттерны Vibe, если они не являются активными объектами в системе?
* [x] Изучая Vibes, которые действуют как «образцы ДНК» или «следы», предоставляя всю необходимую информацию (`context`, использованное определение `schema` из поля `schema` у Vibe, `solution`) из конкретного взаимодействия.
* [x] Мы делаем вывод о характеристиках концептуального паттерна (каким он был в определенный момент времени) из коллекции Vibes, которые он проявил. Для Record Vibes определение `schema` (например, JSON Schema) находится непосредственно в поле `schema` каждого Vibe.
* [x] Хотя определения концептуальных паттернов Vibe («ДНК») могут развиваться для будущих взаимодействий (обычно в сторону большей конкретности), существующие Vibes остаются неизменяемыми записями прошлых действий с конкретными версиями определений `schema`.
* [ ] Концептуальные паттерны поддерживают постоянное, активное состояние в системе, которое мы можем запрашивать напрямую.
* [ ] Каждый Vibe содержит только частичный «генетический маркер» своего концептуального паттерна, требуя много Vibes для восстановления одного определения `schema`.
* [ ] «Следы» (Vibes) изменяются задним числом, если «ДНК» концептуального паттерна развивается.
* [ ] Мы в основном понимаем концептуальные паттерны по их абстрактным определениям, а Vibes являются вторичными, иллюстративными примерами.
* [ ] Система клонирует активный концептуальный паттерн из его «ДНК» (Vibe) каждый раз, когда нам нужно с ним взаимодействовать.
* [ ] Все потенциальные концептуальные паттерны во «вселенной» постоянно активны и оставляют «следы».
* [ ] Vibes — это как «потенциальная ДНК», которая становится полной записью только в том случае, если концептуальный паттерн явно инстанцируется как объект.
```

## Архитектура, ориентированная на контент (Content-First)

Система работает по фундаментальному принципу: **мы изучаем коммуникацию и определенные результаты (Vibes, которые включают `context`, поле `schema` с его определением, и `solution`), а не фокусируемся на абстрактных сущностях или паттернах, которые предоставляют определения `schema`**. Это переворачивает традиционное объектно-ориентированное программирование, которое часто хранит внутренние состояния объектов, скрывая обмен сообщениями. Делая записи взаимодействий (Vibes) основными и постоянными, с системой становится гораздо проще работать и мигрировать.

1. **Контент учит созданию** — Встречая примеры контента, системы учатся создавать больше контента такого же типа.
2. **Функции возникают из данных** — Определение `schema` существующего контента может стать шаблоном для функций, генерирующих подобный контент.
3. **Оптимистичное исполнение** — Контент генерируется немедленно и может быть уточнен или разветвлен позже путем создания новых Vibes.

Этот подход предоставляет несколько критически важных преимуществ:

1.  **Нет сложного управления идентичностью для концептуальных паттернов** — Отказ от сложного поддержания идентичности для концептуальных паттернов упрощает ветвление, версионирование и разветвление историй взаимодействий (записанных как Vibes).
2.  **Контент рассказывает историю** — Каждый Vibe содержит все необходимое для понимания, какой `context` был обработан, какое определение `schema` (из его поля `schema`) руководило взаимодействием, и какой `solution` был определен.
3.  **Гибкое восстановление понимания концептуального паттерна** — Природа определения `schema` может быть выведена или восстановлена путем изучения примеров Vibes, определенных под его руководством.
4.  **Легкий откат** — Среды могут быть восстановлены простым изменением того, какие Vibes активны, фактически получая доступ к определенным точкам в истории взаимодействий.
5.  **Улучшенные эксперименты и воспроизведение** — Записанные `contexts` и определения `schema` из Vibes могут быть повторно обработаны (например, другими агентами или с измененными определениями `schema` из развившихся концептуальных паттернов) для определения новых `solutions`. Это позволяет проводить мощные сценарии «что, если» и тестирование, гибкость, которая часто теряется, когда состояние скрыто внутри менее инспектируемых традиционных абстрактных объектов.
6.  **Сосуществование версий** — Множество версий Vibe (например, разные `solutions` для одного и того же `context`+`schema` определения, или `solutions` на основе развившихся определений `schema`, которые обычно более конкретны) могут сосуществовать одновременно, с ясной родословной контента, заменяя сложное управление состоянием традиционных объектов.

Этот подход дает значительные преимущества. Поскольку концептуальные паттерны Vibe не требуют сложного управления идентичностью, операции, такие как ветвление, версионирование и разветвление историй взаимодействий (которые являются просто записанными сериями Vibes), становятся намного проще. Каждый Vibe по своей сути рассказывает свою собственную историю, содержащую `context`, руководящее определение `schema` (из его поля `schema`) и результирующий `solution`. Эта самодостаточная природа также позволяет гибко выводить или восстанавливать базовые характеристики определения `schema` концептуального паттерна, изучая Vibes, которые он произвел.

Более того, управление состоянием системы значительно упрощается: среды можно откатывать, изменяя, какие Vibes считаются активными, что обеспечивает прямой доступ к определенным точкам в истории взаимодействий. Модель, ориентированная на контент, способствует надежному экспериментированию и воспроизведению, поскольку записанные `contexts` и определения `schema` из существующих Vibes могут быть повторно обработаны — возможно, другими агентами или с развившимися определениями `schema` из обновленных концептуальных паттернов — для исследования альтернативных `solutions` и проведения мощных анализов «что, если». Это уровень гибкости, часто отсутствующий, когда критическое состояние скрыто внутри менее инспектируемых традиционных объектов. Наконец, эта архитектура естественным образом поддерживает сосуществование множества версий Vibe (таких как разные `solutions` для одного и того же `context` и определения `schema`, или `solutions`, полученные из развившихся, более конкретных определений `schema`), сохраняя при этом ясную родословную контента и избегая сложностей традиционного управления состоянием.

Система позволяет напрямую общаться с любым Vibe. Вместо того чтобы давать команду абстрактной сущности «перепиши эту статью», вы можете обратиться напрямую к Vibe, содержащему статью (конкретный `solution`): «Можешь ли ты определить `solution`, который является версией тебя с более техническим тоном?» Затем система способствует определению нового Vibe (нового `solution`), который основывается на оригинале, сохраняя его неизменяемую природу, что фактически позволяет преобразовывать старый контент, взаимодействуя с его исходным Vibe. Это означает, что множество версий Vibe могут сосуществовать, и сохраняется ясная родословная контента.

Это также позволяет контролировать распространение изменений — вы можете определить, какие последующие Vibes нуждаются в переопределении при замене версий Vibe. Родословная между Vibes сохраняется, при этом поддерживается целостность отдельных Vibes.

Временная непрерывность возникает потому, что каждый Vibe сохраняет полный контекст (`context` и определение `schema` из его поля `schema`) и определенный `solution` с момента его определения. Этот непрерывный «vibe-инг» — который включает **преобразование старых `solutions` путем взаимодействия с их исходным Vibe для определения новых, измененных `solutions`** — делает прошлые результаты взаимодействий легко доступными через их исторические Vibes, позволяя продолжать диалоги и взаимодействия с ними, как будто они происходят во время первоначального определения; полная точность того момента сохраняется. Это делает путешествие во времени подлинной возможностью системы. С де-эмфазисом на идентичности концептуальных паттернов, значение имеет паттерн взаимодействия (`context` -> определение `schema` -> `solution`), записанный в каждом Vibe.

```llm
Архитектура, ориентированная на контент, переворачивает традиционный дизайн — вместо сущностей,
которые определяют контент, существует только контент (как часть Vibe: {context, поле `schema`, solution})
как основная запись, а происхождение определений `schema` (например, системные шаблоны,
развившиеся определения) понимается концептуально. Это уменьшает значение абстрактных
объектов и делает их записи взаимодействий (Vibes) основными, создавая гораздо большую
гибкость.

Ключевые преимущества перед традиционными системами с идентичностью объектов вытекают из этого
подхода, ориентированного на контент: записанные `contexts` и определения `schema` (из поля
`schema` у Vibe) могут быть повторно обработаны для определения новых `solutions` с другими
агентами или развившимися определениями `schema`, что позволяет проводить мощные
эксперименты и изменять поведенческие паттерны, которые приводят к новым `solutions`
(гибкость, часто теряемая с традиционными абстрактными объектами). Истории взаимодействий
(Vibes) могут быть разветвлены без сложного управления отношениями объектов. Отслеживание
родословной контента (через Vibes) заменяет традиционное управление состоянием сущностей,
множество версий Vibe (разные `solutions`) могут сосуществовать, а откаты обращаются
к определенным точкам в истории Vibe, а не восстанавливают сложные состояния системы.

Концептуальные паттерны для определений `schema` существуют, но взаимодействие происходит
путем продолжения «vibe-инга» с существующим контентом. Если была определена статья
(`solution` внутри Vibe), можно взаимодействовать с ее исходным Vibe, чтобы изменить
структуру статьи (определить новый `solution`, соответствующий потенциально измененному
определению `schema`, которое будет храниться в поле `schema` нового Vibe), превратить статью
в инструмент агента или изменить ее базовый `context` или определение `schema` (что приведет
к новому Vibe с новым `solution`). Это непрерывное взаимодействие с любым историческим
Vibe напрямую позволяет преобразовывать старые `solutions`, определяя новые, измененные Vibes.

Это обеспечивает временную непрерывность: непрерывный «vibe-инг» (который включает
**преобразование старых `solutions` путем определения новых, измененных `solutions` из
оригинальных Vibes**) означает, что каждый Vibe сохраняет полный контекст (`context`,
определение `schema` из его поля `schema`) и конкретный `solution` с момента его определения.
Следовательно, прошлые результаты взаимодействий остаются доступными через их исторические Vibes,
позволяя вам взаимодействовать с любым предыдущим состоянием системы, как будто во время
первоначального определения. Изменение происходит путем создания альтернативных Vibes
(например, разных `solutions` или `solutions` из развившихся, обычно более конкретных, определений `schema`),
сохраняя оригиналы.

Идентичность концептуальных паттернов становится вторичной; паттерн взаимодействия, записанный
в каждом Vibe (`context` -> определение `schema` -> `solution`), является первостепенным.
Версионирование отслеживает родословную контента.
```

> **Алиса:** «То есть я могу говорить напрямую с `solution` любого Vibe, а не просто с каким-то абстрактным паттерном, который определил его `schema`?»
> **Боб:** «Именно — ты можешь обратиться к самому Vibe статьи и попросить его определить новую версию (новый `solution`) с другим тоном.»
> **Алиса:** «Но мы не изменяем оригинальный Vibe, верно?»
> **Боб:** «Верно — мы определяем новые Vibes (новые `solutions`) на основе оригинала, сохраняя его неизменяемую природу. Если определение `schema` меняется, новое определение находится в поле `schema` нового Vibe.»
> **Алиса:** «А как насчет контроля над тем, как изменения влияют на другие части системы?»
> **Боб:** «Ты можешь определить, какие последующие Vibes нуждаются в переопределении при замене версий Vibe.»
> **Алиса:** «И я все еще могу говорить со старыми версиями `solutions` (старыми Vibes)?»
> **Боб:** «Да — временная непрерывность означает, что каждый Vibe сохраняет полный контекст (`context`, определение `schema` из его поля `schema`) и конкретный `solution` с момента его определения.»
> **Алиса:** «То есть, когда я взаимодействую со старым Vibe, это ощущается так, будто я вернулась в прошлое к этому конкретному `solution`?»
> **Боб:** «Именно так — взаимодействия ощущаются точно так же, как если бы они происходили во время первоначального определения, со всем оригинальным контекстом (включая его конкретное определение `schema`) и конкретным `solution` в целости.»

```question
Как непрерывный «vibe-инг» обеспечивает временную непрерывность в системе?
* [x] Старые `solutions` (контент внутри Vibes) могут быть преобразованы путем взаимодействия с их исходным Vibe для определения новых `solutions`
* [x] Каждый Vibe сохраняет полный контекст (`context`, определение `schema` из его поля `schema`) и конкретный `solution` с момента его определения
* [ ] Vibes автоматически обновляются, чтобы отражать текущее состояние системы
* [x] Прошлые результаты взаимодействий (Vibes) остаются доступными через их историческую запись
* [ ] Временная непрерывность требует специальных механизмов путешествия во времени
* [x] Взаимодействия со старыми Vibes ощущаются так, как будто они происходят во время первоначального определения, с этим конкретным `solution`
* [ ] Система поддерживает центральную временную шкалу, которая координирует все взаимодействия
* [x] Новые версии Vibe (например, новые `solutions` или `solutions` из развившихся определений `schema`) могут быть созданы без уничтожения оригиналов
* [ ] Временная непрерывность работает только в рамках одной сессии
* [ ] Старые Vibes становятся недоступными после обновлений системы
```

```question
Какие преимущества предоставляет подход, ориентированный на контент, по сравнению с традиционными системами с идентичностью объектов?
* [x] Записанные `contexts` и определения `schema` (из поля `schema` у Vibe) могут быть повторно обработаны для определения новых `solutions` с другими агентами или развившимися определениями `schema`
* [x] Истории взаимодействий (серии Vibes) могут быть разветвлены без управления сложными отношениями абстрактных паттернов
* [ ] Все состояния сущностей автоматически синхронизируются по всей системе
* [x] Отслеживание родословной контента (через цепочки Vibes) заменяет сложное управление состоянием сущностей
* [ ] Требования к хранению записей полностью устранены
* [x] Множество версий Vibe (например, разные `solutions` для одного и того же `context`+`schema` определения) могут сосуществовать одновременно
* [ ] Конкурирующие определения `schema` автоматически разрешают конфликты
* [x] Откаты обращаются к определенным точкам в истории Vibe (конкретным записанным Vibes и их контекстам)
* [ ] Неизменяемость предотвращает все возможные системные ошибки
* [ ] Метрики производительности автоматически оптимизируются для всех операций
```

## Два режима эволюции Vibe

Система поддерживает два принципиально разных подхода к изменению Vibes, различающихся по **постоянству изменений** и **масштабу воздействия**:

### Редактирование решения (Edit Solution): Изменения на уровне экземпляра

**Редактирование решения (Edit Solution)** позволяет пользователям изменять отдельные экземпляры Vibe с помощью запросов или прямого манипулирования, не затрагивая другие экземпляры или схемы.

#### Как это работает:

- **На основе запроса**: Инструкции на естественном языке (например, «сделай это более техническим»)
- **Ручное редактирование**: Прямое манипулирование данными (тот же процесс, пользователь вносит изменения вместо LLM)
- **Обработка запроса**: Запросы на редактирование временно добавляются в контекст, но не сохраняются постоянно — Vibe «забывает» инструкции, сохраняя их эффекты

#### Ключевые характеристики:

- **Локальный масштаб**: Влияет только на конкретный изменяемый экземпляр
- **Сохранение решения**: Измененный контент сохраняется; каждое редактирование создает новую версию
- **Сохранение схемы**: Определение схемы остается неизменным
- **Стандартная авторизация**: Требуются только базовые права пользователя

#### Примеры:

```llm
- «Сделай эту статью более технической» → Техническая версия, запрос временный
- «Исправь грамматику» → Исправленная версия, запрос на редактирование забыт
- Создание Vessel: «Скопируй себя с новым ID» → Создан новый экземпляр
- Выполнение процесса: «User_Verification Process, запустить» → Новый экземпляр рабочего процесса
```

### Уточнение (Refinement): Постоянные архитектурные изменения

**Уточнение (Refinement)** создает постоянные изменения, затрагивающие целые концептуальные категории Vibes — мощный, но контролируемый механизм для архитектурной эволюции.

#### Ключевые характеристики:

- **Постоянные изменения схемы и контекста**: Может постоянно изменять определения схемы и/или контекст для всех будущих экземпляров
- **Универсальное воздействие**: Все существующие экземпляры должны синхронизироваться, чтобы отразить изменения
- **Строгая авторизация**: Требуются специальные Capability Vibes и Instruction Vibes
- **Аудируемый след**: Каждая операция требует документированных Instruction Vibes
- **Иерархические разрешения**: Высокоуровневые разрешения на настройку, низкоуровневые разрешения на редактирование

#### Примеры:

```llm
- Создание под-роли: «User-Reader» специализируется из «User»
- Эволюция схемы: Добавление обязательных полей во все описания продуктов
- Улучшение контекста: Постоянное добавление контекста или инструкций ко всем экземплярам
- Обновления контекста: Новая информация пересчитывается для всех экземпляров
- Обработка инструкций: Формальные процедуры изменения с документацией
```

### Рабочий процесс от редактирования к уточнению

Мощный паттерн для контролируемой эволюции:

**Фаза экспериментов**: Итеративное улучшение через Edit Solution (временно, низкий риск)
**Фаза формализации**: Успешные подходы становятся постоянными через Refinement (постоянно, в масштабах всей системы)

```llm
1. Edit Solution: «Сделать техническим» → Эксперимент с подходом
2. Пользователь доволен результатами → Решение о формализации
3. Refinement: Создать инструкцию «Техническое описание» → Постоянно для всех экземпляров
```

### Сравнение режимов эволюции

| Аспект                    | Edit Solution                        | Refinement                                   | Рабочий процесс Edit + Refinement |
| ------------------------- | ------------------------------------ | -------------------------------------------- | ---------------------------------- |
| **Масштаб изменения**     | Один экземпляр                       | Все экземпляры типа                          | Сначала один, потом все экземпляры |
| **Влияние на схему/контекст** | Нет                                  | Может постоянно изменять схему и/или контекст | Сначала нет, потом постоянное изменение |
| **Авторизация**           | Стандартные разрешения               | Требуются Capability + Instruction           | Сначала стандартные, потом Capability |
| **Постоянство изменения** | Решение сохраняется, запросы временные | Постоянные архитектурные изменения           | Экспериментально, потом постоянно    |
| **Применение**            | Уточнение контента                   | Архитектурная эволюция                      | Безопасные эксперименты до постоянных изменений |
| **Частота**               | Часто, рутинно                       | Редко, значительно                           | Планово, методично                 |

Эта система с двумя режимами позволяет проводить **безопасные эксперименты** через Edit Solution перед тем, как зафиксировать **постоянные архитектурные изменения** через Refinement, обеспечивая как операционную гибкость, так и стабильность системы.

## Типы Vibe и их паттерны активации

В своей основе наша система использует возможности, часто называемые «инструментами» LLM — дискретные единицы, выполняющие определенные функции. Мы называем эти инструменты [**мемами (memes)**](#memes), потому что они действуют как самораспространяющиеся единицы функциональности, подобно социальным мемам. Каждый такой инструмент представляет собой определенную возможность, от рассуждений и анализа до коммуникации и управления процессами.

Основное различие между основными **типами Vibe** (концептуальными категориями Vibes, основанными на природе их определения `schema`) заключается в том, как их врожденные определения `schema` активируют и организуют эти инструменты (или определяют структуру) для определения соответствующего `solution` на основе `context`. Это различие сделано для того, чтобы система могла эффективно моделировать широкий спектр вычислительных паттернов. Поле `schema` у Vibe содержит определение `schema`, которое руководит взаимодействием. Результирующий `solution` у Vibe будет соответствовать этому определению `schema` на основе заданного `context` и специфического операционного паттерна класса (например, Role-подобный, Process-подобный или Record-подобный).

```llm
Система имеет несколько основных типов Vibe, различающихся по методу активации
инструментов или определению структуры их `schema` для определения `solution`:
(1) Role Vibes используют одновременную активацию инструментов для композиционных эффектов в их `solutions`.
(2) Process Vibes организуют инструменты в детерминированные последовательные рабочие процессы для получения `solution`.
(3) Record Vibes имеют определения `schema` для структурированных данных `solutions`, которые могут встраивать инструменты для самоописания и взаимодействия.
(4) Capability Vibes имеют определения `schema`, которые представляют собой предоставление полномочий.
Эти паттерны создают комплексную вычислительную модель для определения различных видов `solutions`.
```

```question
Какие паттерны исполнения или структурные паттерны соответствуют основным типам Vibe, описанным в системе?
* [x] Role Vibes обеспечивают одновременную активацию инструментов для композиционных эффектов при определении их `solutions`
* [x] Process Vibes реализуют детерминированные последовательные рабочие процессы с использованием инструментов для получения их `solutions`
* [x] Record Vibes имеют определения `schema` для самоописывающих контентных `solutions`, объединяя структуру с инструментами и трекерами
* [x] Capability Vibes имеют определения `schema`, которые оцениваются как предоставление полномочий.
* [ ] Role Vibes определяют строго линейные пути выполнения инструментов для предсказуемых `solutions`
* [ ] Process Vibes используют только инструменты на основе LLM для всех шагов в своих рабочих процессах `solutions`
* [ ] Record Vibes в основном ориентированы на определение `solutions` для временных, находящихся в памяти состояний данных
* [ ] Role Vibes отвечают за генерацию определений `schema`, которые затем выполняют Process Vibes для нахождения `solutions`
* [ ] Process Vibes предназначены для активации одного инструмента для получения атомарных `solutions`
* [ ] Record Vibes активируют инструменты только один раз во время первоначального определения `solution` и не могут иметь трекеры (Трекеры активируются после определения)
* [ ] Все типы Vibe используют идентичный, взаимозаменяемый паттерн исполнения для их `solutions`
```

```question
Какова основная причина для различения основных типов Vibe (Role-подобный, Process-подобный, Record-подобный, Capability-подобный) в системе?
* [x] Каждый класс представляет собой разный фундаментальный подход к тому, как организуются инструменты (мемы) или как определяется структура для определения `solution` или представления полномочий.
* [x] Различие позволяет системе моделировать широкий спектр вычислительных паттернов, от эмерджентного поведения до детерминированных рабочих процессов, интерактивных данных и авторизации.
* [ ] Для обеспечения строгой иерархии, где Roles всегда управляют Processes, а Processes всегда управляют Record Types.
* [ ] Каждый тип Vibe ограничен использованием совершенно отдельного и несовместимого набора инструментов (мемов).
* [ ] Классы предназначены в основном для организации пользовательского интерфейса и не отражают базовых вычислительных различий.
* [ ] Только Processes способны произвести Vibe с `solution`.
* [ ] Roles предназначены для людей-пользователей, Processes для автоматизированных задач, а Record Types только для взаимодействий с LLM.
* [ ] Различие основано исключительно на количестве инструментов, которые может использовать тип Vibe.
* [ ] Для обеспечения того, чтобы только Record Types Vibes могли быть неизменяемыми.
* [ ] Классы были выбраны произвольно и не служат какой-либо конкретной архитектурной цели.
```

- **Role Vibes** имеют определения `schema`, которые организуют инструменты параллельно для определения `solutions`, демонстрирующих эмерджентное поведение. Экземпляр такого Vibe — это **Vessel**.
- **Process Vibes** имеют определения `schema`, которые упорядочивают инструменты в детерминированные рабочие процессы для получения `solution`. Экземпляр такого Vibe — это **Workflow Run**.
- **Record Vibes** имеют определения `schema`, которые определяют структурированные данные `solutions`, потенциально встраивая инструменты для самоописания и взаимодействия. `solution` у Record Vibe _является_ самим структурированным контентом.
- **Capability Vibes** имеют определения `schema`, которые определяют авторизованные действия (предоставление прав). Экземпляр — это **Capability**, чье определение `schema` напрямую представляет его полномочия, а его `solution` содержит метаданные о предоставлении прав. Его определение `schema` оценивается системой для авторизации операций.

### Role Vibes: Параллельная активация инструментов для сложных решений

**Role Vibe** имеет определение `schema`, состоящее из упорядоченной коллекции инструментов (мемов), которые могут активироваться параллельно. Экземпляр такого Vibe называется **Vessel** (например, конкретный бот). `solutions`, определяемые Vessel, воплощающим определение `schema` Role, имеют следующие характеристики:

```llm
Vibes, сгенерированные Vessel, воплощающим определение `schema` Role, характеризуются своей динамической
и композиционной природой. Множество инструментов (мемов) в `schema` Role
могут срабатывать одновременно в ответ на `context`, не блокируя основной
процесс определения `solution`. Эта параллельность позволяет создавать эмерджентное, композиционное поведение.

Эта модель, ориентированная на возможности, означает, что Roles, организуя различные наборы
инструментов (мемы, такие как фреймворки для рассуждений, доменные знания, протоколы
коммуникации, системы ценностей, стили поведения, проверки качества), определяют различные
типы Vessel. Эти Vessels могут выполнять разнообразные функции, формируя организационную
структуру, где информация и решения текут естественным образом. Эта универсальность позволяет
Vessels работать в разных временных масштабах и управлять различными типами работы на основе
конкретной конфигурации инструментов их Role.
```

Каждый инструмент представляет собой отдельную возможность. Определения `schema` Role могут быть сконфигурированы с различными наборами инструментов, определяя различные типы Vessels и, следовательно, различные паттерны для определения `solution`, что позволяет им выполнять разнообразные функции в системе. Эти возможности, реализуемые инструментами, охватывают такие области, как фреймворки для рассуждений (например, подходы к анализу или стратегии решения проблем), доменные знания (включая специализированные навыки и базы знаний), протоколы коммуникации, системы ценностей, стили поведения и проверки качества.

```question
Какие из следующих характеристик верны для Vibes, сгенерированных из определений `schema` Role (инстанцированных как Vessels)?
* [x] Инструменты могут срабатывать одновременно, не блокируя основное определение `solution`
* [x] Ранние активации инструментов могут влиять на последующее поведение при определении `solution`
* [x] Параллельность между инструментами позволяет создавать эмерджентные композиционные `solutions` (поведения)
* [ ] Vibes из Roles полагаются на один линейный поток выполнения для своего `solution`
* [ ] Активация инструментов всегда блокируется до тех пор, пока все не завершится, прежде чем будет найден `solution`
* [ ] Vibes из Roles ограничены определением `solutions` для проверки данных
* [ ] Vibes из Roles ограничены одной, предопределенной организационной ролью (Одно определение `schema` Role определяет одну роль, но может быть много разных Roles для разных типов Vibes)
* [ ] Сеть активации предотвращает взаимодействие инструментов при определении `solution`
```

```question
Каковы ключевые результаты или характеристики подхода, основанного на возможностях, используемого определениями `schema` Role для определения `solution`?
* [x] Vessels (экземпляры Role Vibes) могут быть сконфигурированы для выполнения разнообразных функций, от рабочих задач до принятия стратегических решений, путем комбинирования различных наборов инструментов в их определении `schema`.
* [x] Он поддерживает создание организационной структуры с естественными потоками информации и решений на основе возможностей, определенных в `schema` Roles.
* [x] Vessels могут работать в разных временных масштабах и обрабатывать различные типы работы на основе конфигураций инструментов их Role.
* [ ] Каждая Role ограничена одной, жестко определенной возможностью, такой как только рассуждение или только коммуникация.
* [ ] Подход, основанный на возможностях, означает, что все Vessels идентичны по функциям, независимо от их конкретного определения `schema` Role.
* [ ] Инструменты в `schema` Role всегда активируются в строгой, предопределенной последовательности, никогда параллельно.
* [ ] Этот подход устраняет необходимость в каком-либо `context` для Vessel, поскольку его возможности полностью самодостаточны.
* [ ] Информация в основном течет вниз в иерархии на основе Role, с минимальной передачей отчетов вверх.
* [ ] Roles спроектированы так, что их `solutions` всегда просты и атомарны, никогда не композиционны.
* [ ] Основной результат — обеспечить, чтобы каждый Vibe, произведенный Role, был идентичен Vibes из Process или Record Vibes.
```

> **Алиса:** «То есть Vessels, как экземпляры Role Vibes, могут активировать несколько инструментов одновременно при определении `solution`?»
> **Боб:** «Именно — создавая мощные композиционные эффекты, где различные возможности взаимодействуют, чтобы сформировать `solution`.»
> **Алиса:** «И эти инструменты и возможности, которые они представляют, определяют `schema` Role, и, следовательно, функцию Vessel в определении конкретных видов `solutions`?»
> **Боб:** «Верно — комбинируя различные наборы инструментов в `schema` Role, мы определяем типы Vessels, такие как рабочие, руководители или топ-менеджеры, каждый из которых нацелен на определение различных классов `solutions`.»
> **Алиса:** «То есть одна и та же фундаментальная структура Vibe (Vibe с `schema` Role в его поле `schema`) поддерживает разные функции в зависимости от инструментов, с которыми он сконфигурирован, что приводит к разнообразным Vibes?»
> **Боб:** «Именно — это подход, основанный на возможностях, для создания организационной структуры через определяемые Roles, реализуемые экземплярами Vessel, каждый из которых определяет Vibes в соответствии со своим определением `schema`.»

_(Подробные примеры Role Vibes см. в `01_vibes_examples.md`.)_

### Process Vibes: Последовательные детерминированные шаги для структурированных решений

**Process Vibe** имеет определение `schema`, которое указывает последовательный рабочий процесс детерминированных шагов (которые можно рассматривать как вызовы конкретных инструментов или программную логику), преобразующих `contexts` через определенный конвейер для получения `solution`. Это формирует направленный ациклический граф (DAG), где каждый шаг объявляет свои зависимости. Экземпляр Process Vibe — это **Workflow Run**. `solutions`, определяемые Workflow Run, выполняющим `schema` Process, имеют следующие характеристики:

```llm
Process Vibes (инстанцированные как Workflow Runs) реализуют ориентированную на рабочий процесс
вычислительную модель, сфокусированную на детерминизме и предсказуемости в поиске `solution`.
Их определения `schema` указывают направленный ациклический граф последовательных шагов (вызовов
инструментов или кода) с явными зависимостями, что позволяет создавать надежные конвейеры
преобразований для определения `solution`. Эти определения `schema` также подчеркивают строгую
типизацию ввода/вывода, явные механизмы обработки ошибок и встроенную наблюдаемость. Каждый
шаг может быть программным кодом, функцией LLM или гибридным, соединяя традиционные
вычисления и возможности LLM. Process Vibes превосходно справляются с уменьшением энтропии,
заменяя творческую неопределенность структурированными рабочими процессами для определения их `solutions`,
сохраняя при этом гибкость для включения рассуждений LLM там, где это полезно. Они воплощают
способность системы настраивать детерминизм в определении `solution`.
```

Vibes, получаемые в результате Workflow Runs, которые выполняют `schema` Process, хорошо подходят для соединения творческой работы LLM с детерминированными вычислениями. Они спроектированы для эффективной работы с потоками данных и пакетами. Шаги в этих определениях `schema` являются композируемыми и могут быть повторно использованы в различных определениях `schema` Process, создавая библиотеку операций. Кроме того, определения `schema` Process включают явную обработку ошибок для сбоев и крайних случаев, строгую типизацию ввода/вывода для обеспечения правильного потока данных и встроенную наблюдаемость через логирование и мониторинг производительности выполнения во время определения `solution`.

Определения `schema` Process идеально подходят для предсказуемых рабочих процессов, которые требуют как надежности, так и гибкости при определении их `solutions`. Распространенные случаи использования включают конвейеры преобразования данных, многоэтапный поиск `solution` для контента или сложные потоки обработки данных, которые эффективно сочетают возможности LLM с традиционными вычислениями. Результирующие Workflow Runs производят Vibes, которые содержат эти структурированные, определенные `solutions`.

> **Алиса:** «Процессы больше связаны с определением предсказуемого, последовательного выполнения для их Workflow Runs, чтобы определить `solution`?»
> **Боб:** «Да — заменяя креативность детерминизмом, когда это необходимо, и организуя это в конвейер, указанный в `schema` Process, чтобы получить `solution`.»
> **Алиса:** «Так Vibes из Workflow Runs, руководствуясь `schema` Process, содержат `solutions`, которые соединяют творческую работу LLM и традиционные вычисления?»
> **Боб:** «Именно — сочетая лучшее из обоих миров со строгой типизацией и обработкой ошибок, как указано в `schema` Process, чтобы определить надежный `solution`.»

_(Подробные примеры Process Vibes см. в `01_vibes_examples.md`.)_

```question
Выберите все утверждения, которые правильно описывают преимущества или свойства Vibes, сгенерированных из определений `schema` Process (инстанцированных как Workflow Runs).
* [x] Их определения `schema` образуют направленный ациклический граф, где каждый шаг объявляет свои зависимости для определения `solution`
* [x] Их определения `schema` могут смешивать программный код и логику, управляемую LLM, в рамках одного рабочего процесса для поиска `solution`
* [x] Они уменьшают энтропию, заменяя открытую генерацию структурированными шагами при определении `solution`
* [ ] Они гарантируют обработку `solution` в реальном времени, выполняя каждый шаг параллельно
* [ ] Они не допускают никаких рассуждений LLM для поддержания строгого детерминизма в их `solutions`
* [ ] Они требуют отдельного микросервиса на каждый шаг для работы по поиску `solution`
* [ ] Они намеренно игнорируют соображения обработки ошибок для упрощения кода `solution`
* [ ] Они не подходят для конвейеров преобразования данных, включающих потоки, при определении `solutions`
```

```question
Что в первую очередь отличает Process Vibes от Roles, с точки зрения их определения `schema` и определения `solution`?
* [x] Processes определяют `schema` как последовательные, детерминированные рабочие процессы (DAG), в то время как Roles используют одновременную активацию инструментов для эмерджентных `solutions`.
* [x] Processes превосходно справляются с уменьшением творческой неопределенности, заменяя ее структурированными шагами, тогда как Roles используют параллелизм для композиционных эффектов.
* [x] Определения `schema` Process подчеркивают строгую типизацию, явную обработку ошибок и наблюдаемость для предсказуемых конвейеров `solution`.
* [ ] Processes неспособны включать какие-либо рассуждения LLM, в отличие от Roles, которые полагаются на них исключительно.
* [ ] Roles генерируют `solutions` намного быстрее, чем Processes, из-за параллельного выполнения, в то время как Processes всегда медленнее, но более тщательны.
* [ ] Только Process Vibes могут считаться самодостаточными; Role Vibes всегда требуют внешнего контекста.
* [ ] Определения `schema` Process определяются одним, монолитным инструментом, в то время как определения `schema` Role — это коллекции многих небольших инструментов.
* [ ] `solutions` от Processes всегда являются простыми преобразованиями данных, в то время как Roles производят сложные, повествовательные `solutions`.
* [ ] Processes не допускают композируемости своих шагов, каждое определение `schema` Process является уникальным и автономным.
* [ ] В отличие от Roles, Processes не могут работать с потоками данных или пакетами при определении `solutions`.
```

### Record Vibes: Самоописывающие контентные решения

**Record Vibe** имеет определение `schema` в своем поле `schema`, которое указывает как структуру его контентного `solution` (часто JSON Schema), так и потенциально встроенные «инструменты данных» для работы с этим `solution`. `solution` у Record Vibe _является_ самим структурированным контентом, соответствующим этому определению `schema`, с учетом конкретного `context`. Например, конкретный документ-счет является Record Vibe, чей `solution` — это структурированные данные счета, а его поле `schema` содержит JSON Schema, определяющую счет. Vibes, представляющие эту запись (как `solution`), имеют следующие характеристики:

- Поле `schema` у Record Vibe описывает допустимую структуру контента для его `solution`.
- Определение `schema` может также ссылаться на или подразумевать связанные инструменты, которые знают, как работать с `solution` записи. Некоторые из этих инструментов подобны методам, представляя потенциальные действия, которые могут быть добровольно вызваны позже для `solution`.
- Определение `schema` может также описывать самоактивирующиеся **трекеры (trackers)** (специализированные инструменты), которые отслеживают взаимодействия с `solution` записи. Эти трекеры активируются после определения первоначального `solution` записи.
- Это фактически делает результирующий Record Vibe (содержащий `solution` записи и его структурное определение `schema`) самоописывающим и интерактивным.

Паттерн активации для Record Vibe заключается в том, что его `solution` (структурированный контент) определяется немедленно на основе его определения `schema` (из его поля `schema`) и заданного `context`. Затем трекеры активируются на основе своих триггеров (например, когда `solution` записи просматривается или используется). Другие встроенные инструменты, которые больше похожи на методы, представляют потенциальные действия, которые могут быть вызваны для `solution` записи позже.

Record Vibes превращают пассивный контент в активные ресурсы с помощью нескольких механизмов.
Определение `schema` в их поле `schema` гарантирует, что экземпляр `solution` записи
поддерживает целостность через проверку схемы и следует определенным паттернам. `solution` записи
обладает контекстуальной осведомленностью, понимая свою собственную цель, происхождение и
отношение к другим данным, как это предписано его определением `schema`. Операции (инструменты), которые
могут быть выполнены над экземпляром `solution` записи, связаны с ним его определением `schema`,
которое также предоставляет встроенную самодокументацию относительно полей, ограничений и
паттернов использования. Это позволяет экземплярам `solution` записи демонстрировать
интерактивное поведение, отвечая на запросы, преобразуясь или запуская действия на
основе инструментов и трекеров, связанных с их определением `schema`.

Инструменты записи, связанные через определение `schema`, включают возможности, такие
как преобразование формата, визуализация, суммирование, анализ и интеграция для `solutions` записи.
В отличие от традиционных статических форматов данных, Record Vibes несут в себе как свою
структуру (в поле `schema`), так и свои операционные возможности.

[**Трекеры (Trackers)**](#trackers) — это специализированные инструменты, связанные с `schema`
Record Vibe, которые активируются автоматически на основе триггеров, позволяя результирующему
`solution` записи реагировать на просмотр или использование. Они создают распределенную систему
осведомленности, где:

- `solution` записи знает, когда к нему обращаются и кто
- Паттерны использования могут вызывать уведомления или адаптации
- Метрики могут собираться без явных механизмов отчетности
- `solution` записи становится активным участником рабочих процессов, а не пассивным ресурсом

> **Алиса:** «Так у Record Vibes их `schema`, вроде JSON Schema, находится прямо в их поле `schema`, определяя и структуру, и поведение для `solutions` записи, которые они содержат?»
> **Боб:** «Верно — определение `schema` в поле `schema` делает результирующий `solution` записи самоописывающим и может включать или подразумевать встроенные инструменты и трекеры.»
> **Алиса:** «А трекеры делают `solution` записи почти живым, активируясь после его определения?»
> **Боб:** «Именно — он может реагировать на просмотр, адаптироваться и общаться в ответ, основываясь на спецификациях его определения `schema` для `solution`.»
> **Алиса:** «То есть Record, как экземпляр `solution` из Record Vibe, становится активным участником, а не просто информацией?»
> **Боб:** «Именно! Так что Record Vibes не просто определяют статические данные; они помогают создавать `solutions` записи, которые больше похожи на активные возможности, а не на скучные факты или цифры, потому что их поле `schema` так много в себя вмещает.»

```question
Относительно Record Vibes, какова роль и характеристика активации трекеров?
* [x] Трекеры — это специализированные инструменты, связанные с определением `schema` Record Vibe, которые активируются автоматически на основе триггеров *после* определения первоначального `solution` записи.
* [x] Они позволяют `solution` записи реагировать на просмотр или использование, делая его активным участником.
* [x] Трекеры способствуют созданию распределенной системы осведомленности, позволяя `solutions` записи отслеживать собственное использование и потенциально запускать адаптации или уведомления.
* [ ] Трекеры — это основные инструменты, которые изначально определяют и структурируют сам `solution` записи.
* [ ] Трекеры активируются только один раз, когда первоначально создается определение `schema`, а не в отношении отдельных экземпляров `solution` записи.
* [ ] Активация трекеров требует явного ручного вызова пользователем или другим компонентом системы для каждого взаимодействия.
* [ ] `solutions` записи могут иметь встроенные инструменты или трекеры, но не оба одновременно. (Они могут иметь и то, и другое)
* [ ] Трекеры используются исключительно для проверки схемы и обеспечения целостности данных, а не для мониторинга взаимодействий.
* [ ] Наличие трекеров делает `solution` записи неизменяемым и предотвращает любые дальнейшие операции с ним.
* [ ] Трекеры определяются в Role Vibes и делегируются Record Vibes для выполнения над `solutions` записи.
```

### Capability Vibes: Определение полномочий и ресурсов

**Capability Vibe** представляет собой единое предоставление полномочий и ресурсов. Экземпляр такого Vibe — это **Capability**. Это мощная, универсальная структура, которая служит разрешением, кошельком, бюджетом и определением задачи — все в одном.

`solution` у Capability Vibe содержит его основную логику, которая обычно включает:

- **`provisions`**: Объект, определяющий ресурсы, которые эта возможность содержит или предоставляет, например, денежный бюджет (например, `{ "totalUsd": 50000 }`), кредиты API или другие цифровые активы. Это аспект «кошелька».
- **`permits`**: Массив объектов разрешений, где каждое разрешение определяет конкретную операцию `refine`, которую разрешает возможность. Это аспект «разрешения». Каждое разрешение указывает:
  - `targetSchema`: Схема для `target` Vibe(s) вызова `refine`.
  - `instructionSchema`: Схема для `instruction` Vibe(s).
  - `cost`: Объект, который связывает разрешенное действие с `provisions`, определяя, какая часть ресурса потребляется при использовании разрешения.

Эта интегрированная структура означает, что Capability не просто говорит, _что_ вы можете делать, но и предоставляет _средства_ для этого. Определение `schema` у Capability определяет допустимую структуру для этих `provisions` и `permits`.

Вместо того чтобы выполняться для получения вывода данных, `solution` у Capability оценивается системой, когда он представляется в качестве авторизации для операции `refine`. Система проверяет, соответствуют ли `target` и `instruction` схемам разрешения и достаточны ли `provisions` для покрытия `cost` действия.

**Делегирование и бюджетирование:** Делегирование полномочий или выделение бюджета осуществляется путем `refine` родительского Capability. Это создает новый, более конкретный Capability с ограниченными разрешениями или меньшей частью исходных `provisions`. Исходный Capability обновляется, чтобы отразить выделенные ресурсы, создавая ясную, аудируемую родословную того, как распределяются полномочия и бюджеты.

Этот единый подход имеет решающее значение для управления разрешениями, бюджетами и задачами контролируемым, аудируемым и децентрализованным способом. Как и все Vibes, Capabilities неизменяемы; изменения в разрешениях или бюджетах приводят к созданию новых Capability Vibes.

```llm
Capability Vibe — это единое предоставление полномочий и ресурсов, выступающее в роли
разрешения, кошелька и бюджета в одном. Его `solution` содержит `provisions`
(ресурсы, которые он хранит, например, бюджет) и массив `permits`. Каждое разрешение
авторизует определенную операцию `refine`, определяя схемы для `target`
и `instruction`, а также `cost`, который связывает действие с `provisions`.
Система проверяет Capability, сверяя разрешения и обеспечивая достаточность
`provisions`. Делегирование и бюджетирование осуществляются путем `refine` родительского
Capability для создания нового, более конкретного, обеспечивая аудируемую родословную.
```

> **Алиса:** «Так один Capability — это теперь и разрешение, и кошелек вместе? Он говорит, что я могу заказать статью, _и_ в нем есть $500 на оплату?»
> **Боб:** «Именно. Массив `permits` говорит, что ты можешь делать, а объект `provisions` содержит бюджет. Поле `cost` внутри каждого разрешения связывает их, указывая, какая часть бюджета может быть потрачена на это конкретное действие.»
> **Алиса:** «А если я хочу дать своему коллеге $100 из этого бюджета, чтобы он заказал небольшой пост в блог?»
> **Боб:** «Ты бы сделала `refine` своего основного Capability. Это создало бы два новых: один для твоего коллеги с `provision` в $100 и разрешением на посты в блог, и обновленную версию твоего собственного Capability, теперь показывающую оставшийся бюджет в $400. Все связано и отслеживаемо.»

```question
Как единый Capability Vibe интегрирует разрешения и ресурсы?
* [x] `solution` содержит как `provisions` (ресурсы, такие как бюджет), так и `permits` (разрешенные действия).
* [x] Каждое разрешение содержит поле `cost`, которое явно связывает разрешенное действие с конкретным выделением ресурсов в `provisions`.
* [x] Делегирование части бюджета осуществляется путем `refine`'инга Capability, что создает новый Capability с меньшей суммой `provision`.
* [ ] `provisions` хранятся в отдельном Resource Vibe, на который необходимо ссылаться.
* [ ] Capability может только определять разрешения или хранить ресурсы, но не оба одновременно.
* [ ] `cost` действия определяется LLM во время выполнения, а не определяется в разрешении.
```

_(Подробные примеры Capability Vibes см. в `01_vibes_examples.md`.)_

## Объединяющие принципы

Несмотря на различные операционные паттерны их классов (Role-подобный, Process-подобный, Record-подобный и Capability-подобный), все **Vibes** сами по себе, как фундаментальные единицы взаимодействия, разделяют набор основных, объединяющих характеристик. Это:

```llm
Четыре основных типа Vibe (Role, Process, Record, Capability) имеют определения `schema` в своих полях `schema`, которые руководят взаимодействиями, но результирующие **Vibes** все разделяют фундаментальные свойства:
- **Общая структура**: Все используют паттерн {context, поле `schema`, solution}. Поле `schema` содержит определение `schema`.
- **Неизменяемость**: Вся тройка {context, поле `schema`, solution} неизменяема после создания.
- **Самодостаточность**: Каждый Vibe имеет все необходимое для того, чтобы его `solution` был понят, а его соответствие определению `schema` воспроизведено (или всю информацию для восстановления этого контекста).
- **Прямая адресуемость**: Любой Vibe (и его `solution`) может быть точкой взаимодействия.
- **Ориентация на контент**: Контент `solution` у Vibe является основным, а не абстрактные процессы (для экземпляров Capability, определение `schema` *является* полномочием, а `solution` — метаданными).
- **Оптимистичное исполнение**: Vibes с начальными `solutions` определяются легко.
- **Выборочное уточнение**: Улучшения или вариации любого Vibe производятся путем создания новых Vibes с новыми или уточненными `solutions` (и потенциально уточненными, более конкретными определениями `schema` в их поле `schema`), что позволяет целенаправленно вносить изменения, не изменяя оригинал. Это относится к любому Vibe, независимо от его класса или сложности (для экземпляров Capability, так делегирование создает более конкретные возможности, создавая новые экземпляры Capability с более конкретными определениями `schema`).
- **Различные механизмы типов**: Хотя Vibes разделяют эти свойства, их классовые паттерны (Role, Process, Record, Capability) используют различные базовые механизмы и паттерны оркестровки/оценки инструментов на основе их определений `schema` для определения этих Vibes, как подробно описано в соответствующих разделах.

Это архитектурное единство обеспечивает последовательную обработку и композиционную гибкость во всей системе.
```

Как было подчеркнуто, хотя разные типы Vibe, такие как Role, Process, Record и Capability, определяют различные операционные паттерны для определения `solutions` или определения полномочий через их `schema`, все результирующие **Vibes** в своей основе придерживаются общего набора архитектурных принципов. Каждый Vibe разделяет структуру {context, поле `schema`, solution} (где поле `schema` содержит определение `schema`) и является неизменяемым после записи в реестр; конкретный `solution` для данного `context` и `schema` является фиксированным (для экземпляров `Capability` само определение `schema` фиксируется при создании и определяет его полномочия). Каждый Vibe является самодостаточным, содержащим всю необходимую информацию для того, чтобы его `solution` был понят, а его соответствие определению `schema` проверено (для экземпляров `Capability` его `schema` является основной для его функции). Более того, все Vibes (и их `solutions`/`schema`) напрямую адресуемы как первоклассные сущности для диалога, воплощая подход системы, ориентированный на контент. Vibes определяются с начальным `solution` легко (оптимистичное исполнение) и поддерживают выборочное уточнение: улучшения или вариации приводят к созданию новых Vibes (для экземпляров `Capability` делегирование создает новый `Capability` с более конкретным определением `schema` в его поле `schema`). Этот универсальный принцип позволяет итеративно разрабатывать и развивать все типы Vibe, при этом развивающиеся определения `schema` обычно становятся более конкретными.

Это архитектурное единство обеспечивает последовательную обработку и композиционную гибкость, позволяя бесшовно комбинировать различные типы Vibe, их различия служат различным вычислительным потребностям, не создавая концептуальных барьеров. Метаданные реестра Vibe (UUID, временная метка, автор, родительский Vibe) хранятся отдельно, обеспечивая чистоту и легкость хеширования основного контента Vibe.

> **Алиса:** «Так четыре типа Vibe — это на самом деле просто разные способы классификации Vibes на основе природы определения `schema` в их поле `schema`, которое затем диктует, как определяются `solutions` или, в случае экземпляров `Capability`, как определяются полномочия?»
> **Боб:** «Именно — тот же фундаментальный паттерн {context, поле `schema`, solution}. Поле `schema` содержит определение `schema`. Определение `schema` в поле `schema` делает результирующий `solution` записи самоописывающим и может включать или подразумевать встроенные инструменты и трекеры.»