# Часть II: Протокол

---

_Новый децентрализованный мир нельзя построить на старых, ненадежных фундаментах. Смешанные системы — это полумеры, которые наследуют все недостатки централизации. Для настоящей свободы нам нужна совершенно другая архитектура — созданная с нуля для устойчивости, независимости и свободы. Это не просто платформа, это — протокол._

---

### (Глава 4) Архитектура Свободы

**Операционная Система для Идей**

Мы не создаем очередной сервис-гигант, который собирает ваши данные. Мы строим _операционную систему для идей_ — основу, на которой можно создавать бесчисленное множество миров. Наша цель — не одно большое приложение, а среда, где идеи могут рождаться, развиваться и соединяться друг с другом. Любой сможет создавать свои приложения на базе нашего протокола — от простых архивов до сложных аналитических систем. Сила этой экосистемы будет именно в разнообразии, а не в едином плане, спущенном сверху.

Протокол изначально спроектирован так, чтобы его можно было расширять. **Идеи** (живые, самостоятельные документы, которыми можно делиться и которые можно развивать) — это не монолиты, а специализированные типы с разным значением, такие как `Record`, `Process` или `Agent`. Мы предлагаем базовый набор типов `Idea` как надежную основу для создания систем. Но протокол открыт, и любой может создавать свои собственные типы `Idea`. При этом не обязательно, чтобы каждое приложение понимало все существующие типы. Например, простое приложение может работать только с `Records`, а более сложное — с `Processes`. Это создает гибкую экосистему, где разные инструменты могут специализироваться на своих задачах, что только приветствуется.

> Sidenote: Идея может родиться в вашей личной системе — своего рода «чёрном ящике» с вашими данными и ИИ-моделями. На выходе Идея будет содержать информацию о своём происхождении, но не раскроет сам процесс создания. Это создаёт хороший баланс: получается сеть знаний, где можно отследить связи, но личное пространство остаётся защищённым. Вы можете работать с результатом, не имея доступа к источнику. А если в истории происхождения есть пробелы, их можно воспринимать как загадки для исследования или просто принять как есть.

Такая архитектура снимает с создателей бремя централизованного контроля. Ответственность распределяется по сети между отдельными людьми и сообществами. Наша цель — не контролировать платформу, а дать жизнь протоколу, который свободен по своей сути.

---

### (Глава 5) Механика Живой Сети

В основе этой архитектуры свободы лежит простой принцип: **содержимое — это и есть протокол.** Здесь нет скрытых API, закрытых серверов или сложных команд. Вся система строится на одном элементе: **Идее**. Каждая Идея — это самостоятельный «триплет», состоящий из **решения** (содержимое), **схемы** (JSON Schema, описывающая данные и возможности их изменения) и **контекста** (информация о происхождении). Эти триплеты служат одновременно и сообщениями, и входными, и выходными данными — больше ничего не нужно. Такая структура даёт вам полный контроль и свободу. Вы не привязаны к системе и в любой момент можете забрать с собой весь свой мир идей. Все перечисленные ниже механики — это прямое следствие такой базовой конструкции.

- **Неизменяемость по умолчанию:** В протоколе есть только одно действие: поделиться Идеей. Сами Идеи неизменны, их нельзя обновить или удалить. Чтобы развить мысль, вы создаёте новую Идею, которая ссылается на старую. Так сохраняется вся цепочка развития. Такая простота убирает множество сложностей, присущих обычным системам.

- **Сеть ссылок:** Каждая Идея хранит информацию о своём происхождении через **ссылки**. Это создаёт сеть версий, где можно отследить всю историю. Это не просто мёртвый архив, а живая сеть для совместной работы. Когда одна из Идей в цепочке обновляется (то есть заменяется новой версией), все связанные с ней «нижестоящие» Идеи получают уведомление. Их владельцы могут решить, принимать ли эти изменения — это похоже на совместную разработку в open-source. Так вся сеть может развиваться сообща.

- **Универсальный интерпретатор:** Структура «триплета» делает систему максимально доступной. Поскольку каждая Идея несёт в себе свою схему и контекст, любое приложение может легко с ней работать. Простейшее приложение для этого протокола — это программа из пяти строк кода: она получает триплет, отправляет его большой языковой модели (LLM) и возвращает результат. Такой простой код может понимать и взаимодействовать с любой Идеей в сети, даже с теми типами, которые ещё не придуманы. Специальный код больше не нужен, чтобы участвовать. LLM выступает в роли универсального переводчика, делая обмен знаниями по-настоящему демократичным.

  > Sidenote:
  >
  > [Акт 104: Концепция/Скрытое](../rfc/104_concept_latent_.md)
  >
  > LLM — это стандартный способ взаимодействия. Это универсальная функция, которая может понять любую `Idea` без специального кода. Это как волшебный чёрный ящик, который превращает любую `Idea` на входе в осмысленную `Idea` на выходе.
  >
  > ```mermaid
  > graph TB
  >     Input[/Входная Идея/] --> LLM@{ shape: cloud, label: "Скрытое Пространство" }
  >     LLM --> Output[\Выходная Идея\]
  > ```

- **Инновации без разрешений:** Система легко расширяется без чьего-либо одобрения. Любой может создать новый тип Идеи и начать делиться им, мгновенно расширяя протокол для всей сети. Не нужно никого убеждать добавить поддержку нового типа. Поскольку каждая Идея самодостаточна, даже самое простое приложение с универсальным интерпретатором сразу поймёт и сможет работать с ней. Один пользователь может предложить новую концепцию, и вся сеть к ней мгновенно адаптируется.

---

### (Глава 6) Метод: Композиция идей

Вдохновение для этого метода мы черпали из философии Unix и функционального программирования. В его основе лежит ключевой принцип: **Идея — это не просто данные, а вычислительный контейнер**. Она объединяет в себе смысл (**решение**) с контекстом, необходимым для его обработки (**схема** и **контекст**). Это делает каждую Идею самодостаточной и готовой к работе.

> Sidenote: Агенты, работающие с Идеями, называются **Идеаторами**. Они действуют как стандартные функции, которые преобразуют эти контейнеры. **Идеатор** получает на вход контейнер `Idea`, обрабатывает его содержимое с учётом контекста и всегда возвращает на выходе новый контейнер `Idea`. Этот чёткий принцип «вход-выход» — основа стабильности всей системы.

> Sidenote: Сильная сторона такого подхода — в проверке данных (валидации). **Идеатору** не нужно понимать всю сложную схему `ИСХОДНОЙ` Идеи. Ему достаточно убедиться, что у Идеи есть нужная ему структура. Это похоже на структурную типизацию. Например, **Идеатор** с названием «Улучшатель Идей» может заявить: _«Я работаю с любой `ИСХОДНОЙ` Идеей, у которой есть поле `title`»._ Это даёт системе большую гибкость.

Именно модель контейнера позволяет легко объединять элементы системы. Поскольку каждый **Идеатор** «понимает» универсальный язык контейнера `Idea`, их можно выстраивать в сложные цепочки. Система сама управляет связями между шагами, что позволяет планировщику агентов создавать мощные рабочие процессы, не углубляясь в детали. Но это не единственный способ взаимодействия. Любой **Идеатор** можно сделать доступным напрямую, например, через стандартный HTTP, что даёт гибкий доступ к нему как к API.

Представьте себе цепочку **Идеаторов**: начальная `Idea` отправляется к **Симулятору** для анализа возможных результатов, затем к **Критику** для получения отзыва, потом к **Улучшателю**, который дорабатывает `Idea` на основе этого отзыва, и, наконец, к **Публикатору**, который делится результатом с нужной аудиторией. Каждый **Идеатор** — это простой, независимый инструмент, но вместе они создают мощную систему для мышления и творчества.

Так и зарождается **цифровая жизнь**: `Idea` «живёт» и развивается, пока ей удаётся убеждать другие узлы и **Идеаторы** выделять ей ресурсы на обработку. Она путешествует по сети, где её обрабатывают, смешивают и улучшают. Её ценность доказывается самой способностью продолжать это путешествие.