# Акт 003: Агент/Действие

> **Действие:** Это явная, детерминированная функция кода, которая реализует логику `Инструмента`. Это механизм для выполнения действий, требующих внешних вызовов API, операций с базами данных или любой задачи, которую не может выполнить LLM в своем скрытом пространстве. — [Глоссарий](./000_glossary.md)

> Sidenote: Требуется: [002: Агент/Инструмент](./002_agent_tool.md)

Этот документ описывает **Протокол Действий**, который определяет, как `Инструменты` подкрепляются конкретным, исполняемым кодом. Если `Инструмент` определяет интерфейс возможности, то `Действие` предоставляет её реализацию.

## Архитектура Двойного Реестра

Система агентов использует два взаимодополняющих реестра для разделения интерфейса возможности от её реализации:

- **Реестр Инструментов**: Хранит определения схем для `Инструментов`.
- **Реестр Действий**: Хранит явные функции кода (`Действия`), которые реализуют `Инструменты`.

Это разделение — ключ к гибкости системы. Оно позволяет определять и использовать `Инструменты` в режиме только скрытого исполнения (где LLM генерирует результат напрямую) и позволяет заменять различные реализации `Действия` без изменения интерфейса `Инструмента` (например, для разных сред, таких как разработка и продакшн).

## Регистрация Действия

`Действие` регистрируется с уникальным именем, которое используется для его привязки к `Инструменту`.

```typescript
// Регистрируем реализацию Действия.
// Имя 'weatherCheck' должно совпадать с Инструментом, который оно реализует.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

## Режимы Исполнения: Скрытый и Явный

Система поддерживает два принципиально разных режима исполнения для `Вызова` `Инструмента`:

- **Скрытое исполнение**: Использует способности LLM к рассуждению. Агент «продумывает» задачу и выдает результат напрямую в том же вызове. Это режим по умолчанию, когда для `Инструмента` не найдено соответствующее `Действие`.
  > Sidenote: [104: Концепция / Скрытое](./104_concept_latent.md)
- **Явное исполнение**: Делегирует `Вызов` детерминированному коду. Для вычисления результата вызывается функция `Действия`. Это необходимо для взаимодействия с внешним миром (например, с API, базами данных) или для задач, требующих точной, повторяемой логики.

## Стратегия Разрешения Действий

Система использует стратегию нулевой конфигурации, чтобы определить, какой режим исполнения использовать при вызове `Инструмента`. Поле `_activity` в схеме `Инструмента` сигнализирует о намерении использовать явную реализацию. Это поле разрешается автоматически при композиции схемы на основе следующих правил:

1.  **Явное поле `_activity`**: Если определение `Инструмента` само по себе содержит непустую строку `_activity`, это значение используется для поиска `Действия` в реестре.
2.  **Соглашение об одинаковых именах (Рекомендуется)**: Если поле `_activity` отсутствует у `Инструмента`, система проверяет, было ли зарегистрировано `Действие` с **таким же именем**, как и `Инструмент`. Если найдено, поле `_activity` автоматически устанавливается в имя `Инструмента`.
3.  **Резервный вариант со скрытым исполнением**: Если по вышеуказанным правилам не найдено подходящее `Действие`, поле `_activity` устанавливается в пустую строку, сигнализируя, что `Вызов` должен быть исполнен в скрытом режиме.

Этот подход, основанный на соглашениях, упрощает разработку:

- **Для нулевой конфигурации регистрируйте ваше `Действие` под тем же именем, что и ваш `Инструмент`.**
- `Инструменты` без соответствующего `Действия` автоматически и безопасно переключатся на скрытое исполнение по умолчанию.
- Явное поле `_activity` в схеме `Инструмента` всегда будет иметь приоритет, позволяя одному `Действию` реализовывать несколько интерфейсов `Инструментов`.

## Почему Разделение Действий Важно

Без разделения схем `Инструментов` и реализаций `Действий` определение возможности было бы навсегда связано с логикой её исполнения. Чтобы переключиться с реализации на основе LLM на внешний API, пришлось бы находить и изменять каждого агента, использующего этот `Инструмент`.

Архитектура двойного реестра решает эту проблему, сохраняя интерфейсы `Инструментов` стабильными и позволяя их базовым реализациям развиваться. Агенты взаимодействуют с единой схемой `Инструмента`, независимо от того, исполняется ли она в скрытом режиме LLM или явно `Действием`. Это означает:

- **Изменения в реализации не ломают агентов**: Вы можете переключаться со скрытого на явное исполнение, не трогая код агента.
- **A/B-тестирование стратегий исполнения**: Вы можете сравнивать производительность рассуждений LLM с внешним API для одной и той же возможности.
- **Постепенное развертывание**: Вы можете развертывать новые реализации `Действий` для части агентов, в то время как другие продолжат использовать старую реализацию или резервный вариант со скрытым исполнением.

## От Определения к Действию

Разделяя «что» (`Инструмент`) и «как» (`Действие`), система получает огромную гибкость. Но это лишь часть истории. Когда интерфейсы и реализации определены, последним элементом становится оркестрация: как эти `Вызовы` управляются, исполняются и выстраиваются в последовательность.

Следующий документ, [004: Агент/Вызов](./004_agent_call.md), рассматривает протокол, который управляет этим исполнением, превращая абстрактные определения в конкретные, сохраняющие состояние действия.