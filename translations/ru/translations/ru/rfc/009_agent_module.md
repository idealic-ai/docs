# 009: Агент/Модуль

> **Модуль** — это внешний, многоразовый блок логики (`Действие` или `Idea`), который можно вызвать с помощью `Call` в его собственной, изолированной среде. Он обозначается свойством `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ описывает **Протокол Модулей** — правила, которые позволяют выполнять `Инструменты` в изолированной среде. Это можно сделать, сославшись на другую `Идею` или вызвав `Действие` в новом, отдельном подзапросе. Это главный способ создавать сложное поведение агента, собирая его из самостоятельных, многоразовых компонентов.

## Проблема: Монолитные Инструменты и Смешение Контекста

Когда у агента появляется много возможностей, хранить все его `Инструменты` в одном общем пространстве становится неудобно.

1.  **Большие схемы**: У больших языковых моделей (LLM) есть предел сложности схем, которые они могут понять за один раз. Если собрать вместе много сложных `Инструментов`, этот предел можно превысить. Тогда LLM не сможет правильно разобраться в доступных вариантах.
2.  **Смешение контекста**: Когда все `Инструменты` находятся в одном общем пространстве, LLM может запутаться в лишней информации. Это может привести к тому, что модель выберет не тот `Инструмент` или неправильно укажет его параметры.
3.  **Сложность повторного использования**: `Инструмент`, созданный для одного агента, сложно использовать для другого. Придётся копировать не только сам инструмент, но и всё его окружение (контекст).

Протокол Модулей решает эти проблемы с помощью **области видимости Модуля** (`Module Scope`). Это способ передать выполнение `Вызова` во внешнюю, изолированную среду.

## Свойство `_module`

На область видимости Модуля указывает свойство `_module` в схеме `Инструмента`. Это свойство говорит системе, что `Вызов` нужно обработать не как внутреннюю операцию, а как запрос к внешнему модулю.

Свойство `_module` является строкой (`string`).

- **`_module: 'idea://<idea-name>'`**: Указывает на конкретную `Идею`. Это инструкция для исполнителя запустить `Вызов` в контексте этой `Идеи`.
- **`_module: 'anonymous'`**: Специальное слово, которое означает анонимный модуль. Он нужен, когда требуется изолированная среда для `Действия`, но без загрузки полного контекста `Идеи`.

## Выполнение в «чистой комнате»

Модуль создаёт «чистую комнату» для своей работы. `Вызов` выполняется не в окружении (контексте) родительского агента, а в новом, изолированном подзапросе. Контекст для этого подзапроса создаётся с нуля, а не наследуется.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** играет ключевую роль. Свойство `_imports` в схеме `Инструмента` работает как мост: оно точно указывает, какие части родительского контекста нужно передать в «чистую комнату» модуля. Так родительский агент полностью контролирует, какую информацию получит модуль. Это предотвращает путаницу с контекстом и обеспечивает полную изоляцию модуля.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Композиция и Переиспользуемость: Композитор и Звукорежиссёр

Модули дают мощные возможности для создания сложных систем. `Идеи` могут работать как самостоятельные сервисы, которыми управляют другие агенты. Это создаёт понятную иерархию: агенты высокого уровня занимаются общей координацией (оркестрацией), передавая узкоспециализированные задачи модулям более низкого уровня.

Рассмотрим пример с высокоуровневым агентом-**`Composer`** (Композитором) и низкоуровневым модулем **`Sound-Designer`** (Звукорежиссёром).

- **`Sound-Designer`** — это самостоятельная `Идея` (`idea://sound-designer`). Её контекст содержит экспертные знания о работе с синтезатором. Это многоразовый, специализированный инструмент, который принимает музыкальную концепцию и возвращает готовые аудиоданные.

- Задача агента-**`Composer`** — создать законченную песню. Сначала он генерирует основную музыкальную идею, а затем создаёт для неё звуки. У `Composer` есть собственный `Инструмент` `createMelody` для первой части. Для второй части он использует `Инструмент` `synthesizeSound`, который передаёт работу модулю, указывая `_module: 'idea://sound-designer'`.

Процесс работы `Composer` состоит из нескольких шагов и сочетает в себе как внутренние операции, так и вызовы модулей:

1.  **Внутренняя работа**: Сначала `Composer` вызывает свой собственный инструмент, `createMelody`. Эта операция выполняется внутри самого `Composer` и создаёт структуру мелодии и историю для песни.

2.  **Передача задач (делегирование)**: Получив мелодию и историю, `Composer` несколько раз вызывает `Инструмент` `synthesizeSound` — для основной партии, для басовой линии и т.д. Каждый такой вызов обрабатывается следующим образом:
    1.  Создаётся новый, изолированный подзапрос.
    2.  Загружается `Идея` `Sound-Designer`. Её собственный контекст с экспертными знаниями (например, «Ты — звукорежиссёр мирового класса, специализирующийся на аналоговых синтезаторах...») становится основой для новой среды.
    3.  `Composer` с помощью `_imports` выбирает нужные части своего контекста (мелодию, историю) и передаёт их. Этот импортированный контекст **дополняет** базовый контекст `Sound-Designer`.
    4.  LLM в этом подзапросе получает **объединённый контекст**: экспертные инструкции от модуля и конкретную творческую задачу от `Composer`.
    5.  `Sound-Designer` использует свои знания, чтобы выполнить задачу и создать нужный звук. Этот звук возвращается как результат вызова `synthesizeSound`.

3.  **Сборка**: `Composer` собирает все звуки, полученные от `Sound-Designer`, и соединяет их с основной мелодией, создавая готовую песню. Таким образом, `Composer` занимается творчеством на высоком уровне, а для решения технических деталей управляет работой специализированных модулей.

## Обработка больших схем

Протокол Модулей также помогает работать с `Инструментами`, у которых очень большие или сложные схемы вывода. Вместо того чтобы включать громоздкую схему `_output` в основной запрос (что может помешать другим инструментам), можно определить `Инструмент` только с его входными параметрами (`input`) и указателем `_module`.

LLM может спланировать `Вызов`, зная только входные данные. Сложный результат будет создан позже, в изолированном подзапросе модуля. Это позволяет агенту планировать последовательность сложных действий, не видя всех деталей каждого шага одновременно. Модель просто доверяет, что модуль вернёт правильный результат, который можно будет использовать дальше.

## Стратегии разрешения Модулей

`Инструмент` становится `Модулем`, если в его схему добавлено свойство `_module`. Это сигнал, что `Вызов` нужно передать другому компоненту. Главный вопрос — *когда* происходит эта передача. Система поддерживает две стратегии, которые позволяют найти баланс между строгим контролем и гибкостью.

### 1. Разрешение во время выполнения (по умолчанию)

Стандартный и наиболее гибкий подход — это разрешение модуля во **время выполнения**, после того как агент уже сгенерировал `Вызов`.

Этот метод открывает новую, мощную модель работы, невозможную в обычном программировании: **LLM выступает в роли умного «переводчика» или связующего звена.** Агент может сделать `Вызов` с параметрами, которые не совсем точно совпадают со схемой `input` модуля. Во время выполнения система передаст и контекст модуля, и параметры вызова в подзапрос, и уже там другая LLM получит задачу «состыковать» их.

Это большое преимущество, так как модули могут обновляться и меняться независимо друг от друга. Даже если схема ввода в модуле изменится, агенты, которые его вызывают, не «сломаются» сразу. LLM постарается адаптировать старый формат `Вызова` к новой схеме `input`. Это обеспечивает устойчивость и независимость компонентов (слабую связность), что является уникальной особенностью такой архитектуры.

Процесс выглядит так:

1.  Агент создаёт `Вызов` для `Инструмента`-модуля.
2.  Исполнитель видит свойство `_module` и запускает нужный протокол.
3.  **Сборка контекста**: Исполнитель находит `Идею` модуля (если модуль не анонимный) и загружает её базовый контекст. Затем с помощью `_imports` он добавляет информацию от вызывающего агента.
4.  **Сопоставление входа**: Параметры (`params`) из `Вызова` добавляются в контекст как входное сообщение. Здесь и проявляется «связующая» роль LLM: она использует эти параметры для работы модуля, даже если их формат не полностью совпадает с ожидаемой схемой.
5.  **Выполнение**: Создаётся новый, изолированный `Запрос` с собранным контекстом. Его результат возвращается как ответ на первоначальный `Вызов`.

### 2. Предварительное разрешение (опционально)

В ситуациях, где нужна повышенная надёжность, информация о модуле может быть загружена **заранее** — ещё до того, как основной `Запрос` будет отправлен агенту.

В этом режиме система заранее загружает `Идею` модуля и объединяет её схему `input` со схемой параметров `Инструмента`. Благодаря этому LLM агента сразу видит точные требования модуля и может сгенерировать `Вызов`, который идеально им соответствует (то есть будет типобезопасным).

Этот подход даёт надёжность, сравнимую с традиционными API, но в ущерб гибкости, которую даёт разрешение во время выполнения. Его стоит использовать для самых важных взаимодействий, где строгие правила важнее адаптивности.