# 009: Агент/Модуль

> **Модуль**: Внешняя, многократно используемая единица логики (`Activity` или `Idea`), которую можно вызвать через `Call` с `Module Scope`. Обозначается свойством `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Agent/Call](./004_agent_call.md)
> - Дополняется:
>   - [008: Agent/Imports](./008_agent_imports.md)

Этот документ описывает **Протокол Модулей**. Он позволяет `Инструментам` работать в изолированной среде. Это можно сделать, сославшись на другую `Idea` или вызвав `Действие` в отдельном, «чистом» подзапросе. Так мы создаем сложное поведение агентов из независимых, многократно используемых частей.

## Проблема: Монолитные Инструменты и Утечка Контекста

По мере роста возможностей агентов, определение всех `Инструментов` в едином, монолитном контексте становится непрактичным.

1.  **Большие схемы**: У больших языковых моделей (LLM) есть предел сложности схем, которые они могут эффективно обработать за один раз. Если объединить много сложных `Инструментов`, этот предел может быть превышен. В результате LLM будет сложно понять, какие варианты ей доступны.
2.  **Утечка Контекста**: Когда все `Инструменты` работают в одном и том же контексте, LLM может находиться под влиянием нерелевантной информации. Это приводит к неправильному выбору `Инструмента` или ошибкам в его параметрах.
3.  **Отсутствие Повторного Использования**: `Инструмент`, определенный для одного агента, нелегко перенести на другой, не перетаскивая с собой весь его контекст.

Протокол Модулей решает эти проблемы, вводя **Область Видимости Модуля (Module Scope)** — способ делегировать `Call` во внешнюю, изолированную среду выполнения.

## Свойство `_module`

Область Видимости Модуля обозначается свойством `_module` в схеме `Инструмента`. Это свойство указывает системе рассматривать `Call` не как встроенную операцию, а как запрос к внешнему модулю.

Свойство `_module` является строкой (`string`).

- **`_module: 'idea://<idea-name>'`**: Строка, обычно URI, которая указывает на конкретную `Idea`. Это говорит исполнителю запустить `Call` в контексте указанной `Idea`.
- **`_module: 'anonymous'`**: Строковый литерал, который сигнализирует об анонимном модуле. Это используется, когда нужна изолированная среда для `Действия`, но без необходимости загружать целый контекст `Idea`.

## Исполнение в Чистой Среде

Модуль предоставляет «чистую комнату» для исполнения. Вместо выполнения в оживленном контексте родительского агента, `Call` обрабатывается в новом, изолированном подзапросе. Контекст для этого подзапроса тщательно создается, а не наследуется.

Именно здесь **[Протокол Импортов](./008_agent_imports.md)** становится критически важным. Свойство `_imports` в схеме `Инструмента` действует как мост, явно объявляя, какие части родительского контекста должны быть «импортированы» в чистую комнату модуля. Это даёт родительскому агенту полный контроль над тем, какую информацию получит модуль, что предотвращает утечку лишнего контекста и обеспечивает полную независимость модуля.

## Композиция и Повторное Использование: Композитор и Звукорежиссер

Модули позволяют эффективно комбинировать `Idea`, давая им возможность работать как независимые сервисы, которыми могут пользоваться другие агенты.

Рассмотрим агента `Composer` (Композитор) и агента `Sound-Designer` (Звукорежиссер).

- **`Sound-Designer`** — это автономная `Idea` (`idea://sound-designer`). Её контекст содержит подробные инструкции по использованию синтезатора. Она определяет свою собственную схему `input` для создания звуков. Это повторно используемый, автономный эксперт.
- Задача агента **`Composer`** — создать песню. Один из его `Инструментов` — `createMelody`. Этот `Инструмент` сам не реализует логику звукового дизайна. Вместо этого он делегирует задачу эксперту, указывая `_module: 'idea://sound-designer'`.

Когда `Composer` решает использовать инструмент `createMelody`, он создает `Call`. Выполнение этого `Call` будет включать:

1.  Создание нового, изолированного подзапроса.
2.  Загрузка `Idea` `Sound-Designer` с его инструкциями для синтезатора.
3.  Использование `_imports` для внедрения «сюжета песни» от `Composer` в контекст `Sound-Designer`.
4.  Теперь LLM агента `Sound-Designer` видит свои экспертные инструкции вместе с конкретной творческой задачей от `Composer`.
5.  Он генерирует мелодию, которая возвращается как результат `Call` для `createMelody`.

`Composer` не нужно знать, как работать с синтезатором, а `Sound-Designer` не нужно знать о существовании `Composer`. Это независимые модули, объединенные во время выполнения для достижения сложной цели.

## Обработка Больших Схем

Протокол Модулей также предлагает решение для управления `Инструментами` с очень большими или сложными схемами вывода. Вместо включения огромной схемы `_output` в основной запрос, что потенциально может вытеснить другие инструменты, `Инструмент` можно определить только с его параметрами `input` и указателем `_module`.

LLM может спланировать `Call`, имея только входные данные, а сложный вывод будет сгенерирован в изолированном подзапросе модуля. Это позволяет агенту рассуждать о последовательности сложных операций, не «видя» всей подробной схемы для каждого шага в одном окне контекста. LLM доверяет, что модуль произведет правильный вывод, который он получит и использует на последующих шагах.