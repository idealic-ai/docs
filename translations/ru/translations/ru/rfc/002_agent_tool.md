# Акт 002: Агент/Инструмент

> **Инструмент**: Схема, определяющая возможность, которую может использовать агент. Она предоставляется LLM как часть запроса и действует как структурированный интерфейс для потенциального действия. LLM активирует инструмент, создавая `Call` с определёнными параметрами, который затем выполняется либо в скрытом состоянии самой LLM, либо явно зарегистрированной функцией (`Activity`). — [Глоссарий](./000_glossary.md)

> Sidenote: Требуется: [Акт 001: Агент/Запрос](./001_agent_request.md). Дополняется: [Акт 003: Агент/Действие](./003_agent_activity.md).

Этот документ описывает Инструмент — базовый, основанный на схемах интерфейс, который позволяет агентам понимать и использовать структурированные возможности.

## Что такое Инструменты?

**Инструменты — это краеугольный камень** систем действий агентов. Они открывают новый тип возможностей: **выбор действия в контексте**, позволяя агентам выбирать и выполнять подходящие действия в зависимости от текущей ситуации.

Инструменты предоставляют:

- **Структурированные интерфейсы**: Определённые схемой возможности, которые агенты могут обнаруживать и понимать
- **Типобезопасность**: Чёткие контракты для входных и выходных данных
- **Компонуемость**: Строительные блоки, которые объединяются в сложное поведение агента
- **Интеграцию с LLM**: Схемы, которые языковые модели могут анализировать и выбирать

Когда агент заполняет определённые параметры для Инструмента, он создаёт **Вызов (Call)** — экземпляр Инструмента со всеми заполненными параметрами, представляющий собой конкретный запрос на исполнение (подробнее об исполнении Вызова см. в [Акт 004: Агент/Вызов](./004_agent_call.md)).

> **Примечание**: Хотя любой запрос к LLM можно представить как Идею (что хорошо подходит для простого генерирования структурированного контента), Инструменты предоставляют механизм для более сложных сценариев, требующих динамического выбора действий. Подробнее о том, как Идеи могут быть преобразованы в Инструменты с помощью схем ввода, см. в [Акт 007: Агент/Ввод](./007_agent_input.md).

## Когда использовать систему Инструментов

Используйте систему Инструментов, когда вашим агентам нужно:

- **Динамически выбирать действия** в зависимости от контекста и ситуации
- **Выбирать между несколькими возможностями** для достижения цели
- **Выполнять разные реализации** одной и той же возможности (например, разные поисковые системы)
- **Сочетать рассуждения LLM с явной логикой** в процессе принятия решений

## Архитектура системы Инструментов

### Основной принцип: Схема как интерфейс

Система Инструментов построена на фундаментальном принципе: **Инструменты — это чистые схемы**, которые определяют интерфейсы, не требуя конкретных реализаций. Выполнение Инструмента обеспечивается либо скрытыми рассуждениями LLM, либо конкретной реализацией в коде, называемой **[Акт 003: Агент/Действие](./003_agent_activity.md)**.

Схема Инструмента определяет:

- **Что делает инструмент** (описание)
- **Что ему нужно** (входные параметры)

> Sidenote: Расширения:

- `_instance`: См. [Акт 011: Агент/Инстансинг](./011_agent_instancing.md)
- `_module`: См. [Акт 009: Агент/Модуль](./009_agent_module.md)
- **Что он производит** (структура `_output`)
- **Как он идентифицируется** (имя `_tool`)
- **Как он выполняется** (поле `_activity`, подробнее см. в [Акт 003: Агент/Действие](./003_agent_activity.md))

### Мета-поля схемы Инструмента

Схемы Инструментов используют мета-поля (с префиксом в виде подчёркивания) для определения свойств системного уровня:

- **_tool**: Уникальный идентификатор для инструмента (обязательно)
- **_activity**: Указывает, какое `Activity` (если таковое имеется) должно выполнить этот инструмент. См. стратегию разрешения в [Акт 003: Агент/Действие](./003_agent_activity.md).
- **_output**: Ожидаемая структура вывода (система делает её nullable)
- **_reasoningForCall**: Объяснение агента, почему был создан этот Вызов (добавляется системой)

Любое поле без префикса-подчёркивания считается параметром инструмента. Мета-поля всегда идут первыми в порядке композиции схемы, обеспечивая единообразную структуру для понимания LLM.

### Границы системы

Система Инструментов отвечает за:

- **Регистрацию Инструментов** (определение и хранение схем)
- **Заполнение параметров** (извлечение из контекста с помощью LLM)
- **Маршрутизацию выполнения** (определение, использовать ли скрытое выполнение или `Activity`)

Протоколы более высокого уровня (такие как [Акт 004: Агент/Вызов](./004_agent_call.md)) строят оркестрацию рабочих процессов, управление состоянием и политики выполнения поверх этих примитивов.

## Определение Инструмента

Инструменты определяются как JSON-схемы. Пример ниже показывает `Tool` для анализа тональности. Этот `Tool` предназначен для скрытого выполнения, так как он полагается на встроенное понимание языка LLM и не требует внешней функции.

```typescript
Tool.register('sentimentAnalysis', {
  type: 'object',
  description: 'Анализирует тональность текста',
  properties: {
    _tool: { type: 'string', const: 'sentimentAnalysis' },
    text: { type: 'string', description: 'Текст для анализа' },
    _output: {
      type: 'object',
      properties: {
        sentiment: { type: 'string' },
        confidence: { type: 'number' },
      },
    },
  },
});
```

## Композиция схемы и Вызов

Хотя отдельные Инструменты определяют дискретные возможности, их мощь раскрывается при их композиции. Система представляет все доступные схемы `Tool` для LLM в рамках одного запроса, обычно в виде массива. Это позволяет LLM выбрать наиболее подходящий `Tool` для конкретной ситуации. Когда LLM выбирает `Tool` и предоставляет необходимые параметры, создаётся **Вызов (Call)** — конкретный, исполняемый экземпляр этого `Tool`. `Call` является фундаментальной единицей действия, которая передаётся на исполнение.

> Sidenote: - [Акт 004: Агент/Вызов](./004_agent_call.md).

## Скрытое и явное выполнение

Схема `Tool` сама по себе является лишь интерфейсом. Исполнение её `Call` может происходить двумя способами. По умолчанию используется **скрытое выполнение**, когда LLM использует собственные внутренние рассуждения для генерации вывода, что идеально подходит для языковых или основанных на знаниях задач. Для действий, требующих взаимодействия с внешним миром — например, вызова API или доступа к базе данных — `Tool` должен быть связан с детерминированной функцией в коде. Эта явная реализация называется **Действием (Activity)**.

Разделение интерфейса `Tool` от реализации `Activity` является ключевым принципом проектирования. Это позволяет определять возможности агента и рассуждать о них абстрактно, в то время как логику их выполнения можно заменять или обновлять независимо. Следующий документ, **[Акт 003: Агент/Действие](./003_agent_activity.md)**, описывает, как `Activities` предоставляют конкретную логику для `Tools`.

> Sidenote: - [Акт 003: Агент/Действие](./003_agent_activity.md).
