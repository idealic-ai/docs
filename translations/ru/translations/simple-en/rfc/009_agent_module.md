# 009: Агент/Модуль

> **Модуль**: Представьте Модуль как специалиста, которого можно позвать на помощь. Это самостоятельный эксперт по одной теме (`Действие` или `Идея`), которого можно нанять для выполнения конкретной задачи с помощью `Вызова`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требуется:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ объясняет, как мы заставляем разные «Инструменты» ИИ работать вместе чисто и организованно. Это как строить из LEGO — можно использовать отдельные, многоразовые кубики для создания чего-то большого и сложного.

## Проблема: Беспорядок в инструментах и путаница в диалогах

Когда ИИ становится мощнее, просто сваливать все его «Инструменты» в одну большую кучу создаёт проблемы.

1.  **Слишком много Инструментов**: Представьте, что вы пытаетесь найти нужную отвёртку в ящике с миллионом разных инструментов. У ИИ есть предел того, сколько инструментов он может понять за раз. Если дать ему слишком много, он перегрузится и не сможет выбрать правильный.
2.  **Путаница в диалогах**: Когда все инструменты находятся в одном рабочем пространстве, возникает путаница. Это как пытаться испечь торт, пока кто-то другой в той же комнате говорит о ремонте машины. ИИ может запутаться в информации, не относящейся к его текущей задаче.
3.  **Сложность повторного использования Инструментов**: Если вы создали отличный инструмент для одного ИИ, его сложно использовать с другим. Придётся переносить всю беспорядочную мастерскую вместе с ним.

Эта система решает эти проблемы, создавая **контекст Модуля**. Представьте, что вы отправляете конкретную задачу специалисту в другую комнату, чтобы он мог сосредоточиться без отвлекающих факторов.

## Тег `_module`

Чтобы указать системе отправить задачу специалисту, мы используем специальную метку под названием `_module` внутри инструкций Инструмента.

Метка `_module` — это простая текстовая строка:

- **`_module: 'idea://<idea-name>'`**: Это как конкретный адрес. Он указывает системе отправить работу известному эксперту, `Идее`, у которого есть своя мастерская и знания.
- **`_module: 'anonymous'`**: Это как сказать: «Мне нужна чистая, пустая мастерская только для этой одной задачи». Это создаёт временное, изолированное пространство для выполнения работы, не требуя постоянного эксперта.

## Работа в чистой комнате

Модуль — это как «чистая комната» — идеально чистое, изолированное пространство для работы. Вместо того чтобы выполнять задачу посреди шумной, хаотичной мастерской, она отправляется в эту новую, пустую комнату. Ничто извне не попадёт внутрь, если его специально не пригласят.

И здесь **[Протокол Импортов](./008_agent_imports.md)** играет очень важную роль. Тег `_imports` в Инструменте работает как специальный пропуск. Он перечисляет точные фрагменты информации из основной мастерской, которым разрешён доступ в чистую комнату. Это даёт главному ИИ полный контроль над тем, что может видеть модуль-специалист, предотвращая любую путаницу.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Собираем большое из малого: Композитор и Саунд-дизайнер

Модули позволяют создавать удивительные вещи. У вас могут быть ИИ, которые видят общую картину и действуют как менеджеры, а затем поручают более мелкие, конкретные задачи ИИ-специалистам.

Представьте себе ИИ, отвечающий за написание песни, назовём его **`Композитор`**. И другой ИИ-специалист, **`Саунд-дизайнер`**, который является экспертом в создании крутых звуков с помощью синтезаторов.

- **`Саунд-дизайнер`** — это самостоятельный эксперт (`idea://sound-designer`). Он знает всё о синтезаторах. Это многоразовый специалист, которому можно дать музыкальную идею, и он вернёт вам настоящий аудиофайл.

- Задача **`Композитора`** — создать целую песню. Для этого он сначала придумывает мелодию. Затем ему нужно превратить эту мелодию в настоящий звук. `Композитор` может создать мелодию сам, но для создания звуков он использует Инструмент под названием `synthesizeSound`. У этого инструмента есть тег: `_module: 'idea://sound-designer'`, который указывает ему делегировать работу эксперту.

Вот как `Композитор` создаёт песню:

1.  **Придумывание идеи**: Сначала `Композитор` самостоятельно работает над созданием мелодии и истории для песни.

2.  **Наём эксперта**: Когда мелодия готова, `Композитор` вызывает Инструмент `synthesizeSound`, возможно, один раз для основной мелодии, один раз для баса и так далее. Каждый раз, когда он вызывает эксперта, происходит следующее:
    1.  Для задачи создаётся совершенно новая, пустая «чистая комната».
    2.  В комнату приглашается эксперт `Саунд-дизайнер`. Его собственные знания (например, «Я эксперт по аналоговым синтезаторам») — это первое, что появляется в комнате.
    3.  `Композитор` использует `_imports`, чтобы передать конкретные инструкции для этой работы, такие как мелодия и история.
    4.  ИИ в чистой комнате получает оба набора инструкций: постоянные знания `Саунд-дизайнера` и конкретные творческие идеи `Композитора` для этой задачи.
    5.  `Саунд-дизайнер` применяет свои знания к творческим инструкциям, чтобы сгенерировать звук, и отправляет аудиофайл обратно.

3.  **Сборка воедино**: `Композитор` собирает все аудиофайлы от `Саунд-дизайнера` и объединяет их со своей оригинальной мелодией, чтобы создать финальную песню. `Композитор` фокусируется на общей картине, в то время как специалист занимается техническими деталями.

## Обработка огромных инструкций

Модули также помогают, когда инструменту нужно создать что-то действительно большое и сложное. Вместо того чтобы загромождать рабочее пространство главного ИИ гигантским руководством о том, как должен выглядеть результат, можно просто указать на модуль.

ИИ может планировать свои шаги, зная только то, что ему нужно *передать* модулю. Он доверяет, что модуль выполнит свою работу и правильно создаст сложный результат. Это позволяет ИИ планировать комплексные проекты, не увязая в каждой мелочи сразу.

## Когда вызывать специалиста

Когда у Инструмента есть тег `_module`, это сигнал, что задачу нужно отправить специалисту. Но когда именно система делает вызов? Есть два способа это сделать.

### 1. Выяснение на лету (способ по умолчанию)

Самый распространённый и гибкий способ — это выяснять детали уже в процессе выполнения работы.

Это позволяет ИИ действовать как умный соединитель. Главный ИИ может сделать запрос, который не идеально соответствует ожиданиям модуля-специалиста. Когда задача передаётся, ИИ внутри «чистой комнаты» модуля достаточно умён, чтобы проанализировать запрос и понять, как заставить его работать. Он действует как интеллектуальный клей.

Это огромное преимущество, потому что вы можете обновлять своих специалистов, ничего не ломая. Даже если специалист изменит принцип своей работы, другие ИИ всё равно смогут с ним общаться, а «клейкий» ИИ попытается устранить разрыв. Это делает всю систему более устойчивой и гибкой.

Вот как это работает:

1.  Главный ИИ решает вызвать Инструмент-специалист.
2.  Система видит тег `_module` и запускает процесс.
3.  **Подготовка комнаты**: Система готовит «чистую комнату» специалиста и использует `_imports`, чтобы перенести необходимую информацию от главного ИИ.
4.  **Передача записки**: Инструкции от главного ИИ передаются специалисту. Здесь и происходит магия — ИИ-специалист сам разбирается, как использовать эти инструкции, даже если они не в идеальном формате.
5.  **Выполнение работы**: В чистой комнате создаётся новый, отдельный запрос, и результат отправляется обратно главному ИИ.

### 2. Проверка всего заранее (более безопасный способ)

Для задач, где нельзя допускать ошибок, можно проверить всё заранее, ещё до того, как главный ИИ начнёт свою работу.

В этом режиме система заранее находит модуль-специалист и объединяет его требования непосредственно со списком инструментов главного ИИ. Это означает, что главный ИИ с самого начала знает *точные* инструкции, которые нужны специалисту. Это похоже на заполнение очень строгой формы, где каждое поле должно быть заполнено идеально.

Это намного безопаснее и гарантирует, что запрос будет понят идеально, но вы теряете гибкость другого метода. Этот способ лучше всего подходит для действительно важных соединений, где вы хотите, чтобы всё работало как традиционная, предсказуемая компьютерная программа.