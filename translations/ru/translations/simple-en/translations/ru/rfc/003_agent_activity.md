# Акт 003: Агент/Действие

> **Действие:** Представьте Действие как реальный фрагмент кода, который выполняет конкретную работу. Это двигатель, который заставляет `Tool` работать. Вы используете Действие для задач, для которых ИИ не может просто «придумать» ответ, например, для общения с другим веб-сайтом, поиска информации в базе данных или выполнения любых других действий в реальном мире. — [Глоссарий](./000_glossary.md)

> Sidenote: Сначала прочтите: [Акт 002: Агент/Инструмент](./002_agent_tool.md)

Этот документ объясняет **Протокол Действий**. Это набор правил, по которым `Tools` связываются с реальным, работающим кодом. Если `Tool` — это *идея* того, что можно сделать (например, кнопка с надписью «Проверить погоду»), то `Activity` — это *фактический код*, который идёт и получает прогноз погоды.

## Система двух библиотек

Система агентов использует две разные «библиотеки», чтобы отделить *идею* задачи от *инструкций* по её выполнению.

- **Библиотека Инструментов**: Здесь хранятся черновики для всех `Tools`. Она описывает, *что* может делать каждый инструмент.
- **Библиотека Действий**: Здесь хранится фактический код (`Activities`), который выполняет инструкции. Она знает, *как* выполнять работу.

Это разделение очень важно. Оно позволяет ИИ иногда просто *делать вид*, что он использует инструмент, придумывая реалистичный ответ. Это также означает, что вы можете заменять *как* выполняется задача, не меняя *что* она делает. Например, вы можете переключиться с одного погодного сервиса на другой, не меняя сам `Tool` «Проверить погоду».

## Добавление Действия в библиотеку

Чтобы сделать `Activity` доступным, вы даёте ему уникальное имя и добавляете в систему. По этому имени `Tool` находит соответствующий ему код.

```typescript
// Мы добавляем новое Действие в библиотеку.
// Имя 'weatherCheck' должно совпадать с Инструментом, для которого оно создано.
Activity.register('weatherCheck', async call => {
  const data = await weatherAPI.get(call.location);
  return { temperature: data.temp, conditions: data.desc };
});
```

## Как выполняются задачи: «Мышление» против «Действия»

Когда используется `Tool`, система может выполнить задачу двумя совершенно разными способами:

- **Мышление (скрытое исполнение)**: ИИ использует свой огромный мозг, чтобы «подумать» о задаче и сразу же предложить ответ. Это происходит по умолчанию, если к `Tool` не привязан реальный код (`Activity`).
  > Sidenote: [104: Концепция / Скрытое](./104_concept_latent.md)
- **Действие (явное исполнение)**: Система находит соответствующее `Activity` (реальный код) и запускает его. Это всё равно что приказать компьютеру действительно *сделать* что-то — например, посетить веб-сайт или вычислить число. Это необходимо для задач, требующих реальной, точной информации из внешнего мира.

## Как система связывает Инструмент с его кодом

Система умеет определять, «думать» или «действовать» для данного `Tool`. Она следует этим простым правилам, чтобы найти нужный код (`Activity`):

1.  **Поиск прямой заметки**: Сначала система проверяет черновик `Tool`. Если там есть специальная заметка (называемая `_activity`), которая говорит: «Используй этот код», — система так и делает. Всё просто.
2.  **Сопоставление имён (простой способ)**: Если заметки нет, система ищет `Activity` с **точно таким же именем**, как у `Tool`. Если находит, то связывает их автоматически.
3.  **Возврат к «мышлению» по умолчанию**: Если не удаётся найти совпадение по первым двум правилам, система прекращает поиск кода. Вместо этого она поручает ИИ просто «придумать» ответ.

Это упрощает жизнь разработчикам:

- **Просто дайте вашему `Tool` и `Activity` одинаковые имена**, и они соединятся автоматически. Никакой дополнительной настройки не требуется.
- `Tools`, у которых нет соответствующего кода, будут безопасно использовать мозг ИИ по умолчанию.
- Вы всегда можете уточнить и добавить заметку к `Tool`, чтобы указать на другое `Activity`, что даёт вам больше контроля.

## Почему это разделение так важно

Представьте, что кнопки на пульте от телевизора были бы жёстко привязаны только к вашей текущей модели телевизора. Купив новый телевизор, вам пришлось бы покупать новый пульт и заново учиться им пользоваться. Вот что было бы, если бы `Tools` и `Activities` были неразделимы.

Разделяя их (в наших двух библиотеках), мы получаем огромные преимущества. Агенту нужно знать только о кнопке (`Tool`), а не об электронике внутри. Это означает:

- **Простота обновлений**: Вы можете переключиться с «мышления» ИИ на использование реального кода (`Activity`), не меняя самого агента. Это как поменять батарейки в пульте — все кнопки продолжают выполнять те же функции.
- **Возможность тестировать разные подходы**: У вас может быть два разных `Activity` для одного и того же `Tool`, чтобы проверить, какой из них работает лучше. Догадка ИИ эффективнее, чем получение реальных данных с веб-сайта? Теперь вы можете это выяснить.
- **Безопасное внедрение изменений**: Вы можете дать новое, экспериментальное `Activity` лишь нескольким агентам для тестирования, в то время как все остальные продолжат использовать старое, надёжное.

## От Черновика к Действию

Разделив *что* (`Tool`) и *как* (`Activity`), мы сделали систему невероятно гибкой. Но это только первый шаг. Теперь, когда у нас есть черновики и инструкции, нам нужен менеджер, который будет всем управлять. Нам нужно что-то, что будет контролировать, какие инструменты, когда и в каком порядке используются.

Следующий документ, [Акт 004: Агент/Вызов](./004_agent_call.md), подробно описывает, как система с этим справляется, превращая наши простые идеи в последовательность реальных, взаимосвязанных действий.