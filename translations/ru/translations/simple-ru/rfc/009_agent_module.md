# 009: Агент/Модуль

> **Модуль**: Это как отдельный, многоразовый «кубик Лего» с логикой (может быть `Activity` или `Idea`), который можно вызвать с помощью команды `Call`. Для этого используется специальное свойство `_module`.
>
> — [Глоссарий](./000_glossary.md)

> Sidenote:
>
> - Требует для понимания:
>   - [004: Агент/Вызов](./004_agent_call.md)
> - Дополняется документом:
>   - [008: Агент/Импорты](./008_agent_imports.md)

Этот документ описывает **Протокол Модулей**. Он позволяет запускать `Инструменты` в отдельном, изолированном пространстве. Представь, что у каждого инструмента есть своя чистая комната, где он может работать, не мешая другим. Это достигается либо ссылкой на другую `Идею`, либо запуском `Действия` в совершенно новом «подзапросе». Это главный способ собирать сложное поведение агента из маленьких, самостоятельных и многоразовых частей.

## Проблема: Громоздкие инструменты и путаница в «голове»

Когда у агента появляется всё больше способностей, хранить описание всех его `инструментов` в одном большом файле становится очень неудобно. Почему?

1.  **Слишком большие инструкции**: У искусственного интеллекта (ИИ) есть предел того, сколько информации он может обработать за раз. Если дать ему гигантский список со сложными `инструментами`, он может запутаться и не сможет правильно выбрать нужный.
2.  **Смешение контекста**: Представь, что ты готовишь и торт, и суп на одном столе. Ты можешь случайно насыпать сахар в суп. То же самое с ИИ: когда все `инструменты` находятся в одном «контексте» (на одном рабочем столе), ИИ может запутаться в ненужной информации и выбрать не тот инструмент или использовать его неправильно.
3.  **Сложно использовать повторно**: `Инструмент`, созданный для одного агента, нельзя просто так взять и перенести в другой. Придётся тащить с собой весь «рабочий стол» со всеми остальными инструментами.

Протокол Модулей решает эти проблемы, вводя **Область видимости Модуля** — способ передать команду (`Call`) кому-то другому, кто выполнит её в своей чистой и изолированной среде.

## Свойство `_module`

Область видимости Модуля включается с помощью специального свойства `_module` в схеме `инструмента`. Это свойство — как записка для системы: «Эту команду выполняй не здесь, а передай внешнему модулю».

Свойство `_module` — это строка текста.

- **`_module: 'idea://<idea-name>'`**: Это как адрес, который указывает на конкретную `Идею`. Система понимает, что нужно выполнить команду в контексте этой `Идеи`.
- **`_module: 'anonymous'`**: Эта специальная фраза означает «безымянный модуль». Используется, когда тебе нужна чистая рабочая среда для `Действия`, но без создания целой отдельной `Идеи`.

## Работа в «чистой комнате»

Модуль предоставляет «чистую комнату» для работы. Вместо того чтобы выполняться в шумном и забитом контексте родительского агента, команда (`Call`) обрабатывается в новом, отдельном подзапросе. Контекст для этого подзапроса создаётся с нуля, а не наследуется.

И здесь на сцену выходит **[Протокол Импортов](./008_agent_imports.md)**. Свойство `_imports` в схеме `инструмента` работает как мост. Оно явно указывает, какие именно кусочки информации из родительского контекста нужно «импортировать» в чистую комнату модуля. Это даёт главному агенту точный контроль над тем, что увидит модуль, предотвращая путаницу и позволяя создавать по-настоящему независимые компоненты.

> Sidenote:
>
> - [008: Агент/Импорты](./008_agent_imports.md)

## Сочетание и повторное использование: Композитор и Звукорежиссёр

Модули позволяют создавать мощные комбинации, где одни `Идеи` работают как отдельные сервисы, которыми управляют другие агенты. Это создаёт понятную иерархию: агенты высокого уровня могут сосредоточиться на общей картине (дирижировании оркестром), передавая узкоспециализированные задачи модулям низкого уровня.

Представь себе агента-**`Композитора`** высокого уровня и модуль-**`Звукорежиссёра`** низкого уровня.

- **`Звукорежиссёр`** — это самостоятельная `Идея` (`idea://sound-designer`). В её контексте хранятся глубокие знания о том, как работать с синтезатором. Это многоразовый инструмент-специалист, который принимает музыкальную идею, а возвращает готовый аудиофайл.

- Задача агента-**`Композитора`** — создать целую песню. Сначала он придумывает основную музыкальную идею, а затем создаёт звуки для её воплощения. Для первой части у `Композитора` есть свой собственный `инструмент`, `createMelody`. А для второй части он использует `инструмент` под названием `synthesizeSound`, который передаёт работу специалисту, указывая `_module: 'idea://sound-designer'`.

Рабочий процесс `Композитора` состоит из нескольких шагов, смешивая внутреннюю работу и вызов модулей:

1.  **Внутренняя работа**: Сначала `Композитор` вызывает свой собственный инструмент `createMelody`. Это происходит внутри его собственного контекста. В результате появляются ноты и история для песни.

2.  **Передача задачи**: Теперь, имея на руках мелодию и историю, `Композитор` вызывает `инструмент` `synthesizeSound` несколько раз — один раз для основной мелодии, другой для басовой линии и так далее. Каждый такой вызов (`Call`) выглядит так:
    1.  Создаётся новый, изолированный подзапрос (как бы открывается новый проект).
    2.  Загружается `Идея` `Звукорежиссёра`. Его собственный `контекст`, содержащий все его экспертные знания (например, «Ты — звукорежиссёр мирового класса, специализирующийся на аналоговых синтезаторах...»), становится основой для новой рабочей среды.
    3.  `Композитор` использует `_imports`, чтобы выбрать нужные части своего контекста (мелодию, историю песни) и передать их. Этот импортированный контекст **добавляется** к базовому контексту `Звукорежиссёра`.
    4.  ИИ в этом подзапросе получает **объединённый контекст**: постоянные инструкции эксперта-модуля, а за ними — конкретные, временные творческие указания от заказчика (`Композитора`).
    5.  `Звукорежиссёр` применяет свои знания к полученному творческому заданию и создаёт нужный звук, который возвращается как результат вызова `synthesizeSound`.

3.  **Сборка**: `Композитор` собирает все результаты своих `Вызовов` к `Звукорежиссёру` и соединяет их со своей оригинальной мелодией в готовую песню. Таким образом, `Композитор` выполняет высокоуровневую творческую работу, а затем управляет модулями-специалистами, которые занимаются деталями реализации.

## Работа с огромными инструкциями

Протокол Модулей также помогает справляться с `инструментами`, у которых очень большие или сложные схемы вывода. Вместо того чтобы включать гигантскую схему `_output` в основной запрос (что может «забить эфир» и помешать другим инструментам), `инструмент` можно описать только с его входными параметрами `input` и указателем `_module`.

ИИ может спланировать вызов (`Call`), зная только входные данные, а сложный результат будет сгенерирован уже внутри изолированного подзапроса модуля. Это позволяет агенту размышлять о последовательности сложных действий, не видя перед собой гигантские, подробные инструкции для каждого шага. ИИ как бы доверяет модулю, что тот создаст правильный результат, который он получит и сможет использовать на следующих шагах.

## Стратегии определения модулей

`Инструмент` становится `Модулем`, как только в его схеме появляется свойство `_module`. Это сигнал, что `Вызов` нужно передать кому-то другому. Ключевой вопрос — *когда* система должна разобраться, что это за модуль. Есть две стратегии, позволяющие выбирать между строгой безопасностью и динамической гибкостью.

### 1. Определение во время выполнения (по умолчанию)

Самый гибкий и стандартный подход — определять модуль **во время выполнения**, то есть уже после того, как агент сгенерировал `Вызов`.

Этот метод позволяет делать то, что невозможно в обычном программировании: **ИИ выступает в роли умного «клея»**. Агент может сгенерировать `Вызов` с параметрами, которые не совсем точно совпадают со схемой `input`, ожидаемой модулем. Во время выполнения система собирает контекст модуля и данные от вызывающего, и ИИ внутри подзапроса получает задачу «склеить» их, поняв, что от него требуется.

Это огромное преимущество, потому что модули могут обновляться и развиваться независимо друг от друга. Даже если модуль изменит структуру своих входных данных, агенты, которые его вызывают, не сломаются сразу. ИИ попытается адаптировать старый формат `Вызова` к новой схеме `input`, обеспечивая гибкость и «слабую связанность», уникальную для этой архитектуры.

Процесс выглядит так:

1.  Агент генерирует `Вызов` к модульному `инструменту`.
2.  Исполнитель видит свойство `_module` и запускает протокол.
3.  **Сборка контекста**: Исполнитель находит нужную `Идею` модуля и собирает его базовый контекст. Затем с помощью `_imports` добавляет контекст от вызывающего агента.
4.  **Сопоставление ввода**: Параметры (`params`) из `Вызова` упаковываются во `Входное Сообщение` и добавляются в контекст. Именно здесь и проявляется способность ИИ быть «клеем», так как он будет использовать эти входные данные для выполнения логики модуля, даже если схемы не совпадают идеально.
5.  **Выполнение**: Создаётся новый, изолированный `Запрос` с объединённым контекстом. Его результат возвращается как итог первоначального `Вызова`.

### 2. Предварительное определение (опционально)

В ситуациях, требующих более строгих гарантий, модуль можно определить **заранее**, ещё до того, как первоначальный `Запрос` будет отправлен агенту.

В этом режиме система заранее находит `Идею` модуля и объединяет его схему `input` со схемой параметров `инструмента`. Это позволяет ИИ агента с самого начала видеть точные требования модуля и гарантирует, что сгенерированный `Вызов` будет идеально сформирован и типобезопасен.

Этот подход даёт надёжность, как у традиционных программных контрактов (API), но жертвует гибкостью, которую даёт определение во время выполнения. Он лучше всего подходит для критически важных, чётко определённых интеграций, где гибкость не является главной целью.