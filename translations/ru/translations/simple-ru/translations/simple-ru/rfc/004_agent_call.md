# 004: Agent/Call

> **Call:** Imagine you have a magic wand (a "Tool"). A "Call" is when you wave the wand and cast a spell, specifying the exact details. It's the command that says, *"Do this right now!"*.
>
> — [Glossary](./000_glossary.md)

> Sidenote:
>
> - Requires:
>   - [103: Concept/Ideator](./103_concept_ideator.md)
> - Enables:
>   - [008: Agent/Imports](./008_agent_imports.md)
>   - [011: Agent/Instancing](./011_agent_instancing.md)
>   - [202: Idea/Vessel](./202_idea_vessel.md)
>   - [203: Idea/Process](./203_idea_process.md)

In [101: Concept/Idea](./101_concept_idea.md), we learned that an "Idea" is like a little chest of knowledge. And in [002: Agent/Tool](./002_agent_tool.md), we found out that a computer has "Tools"—instructions that explain what it can do. This document is about the **004: Agent/Call**, which takes these Tools and puts them to work using two switches: "Scope" (where to do it?) and "Method" (how to do it?).

A **Call** is essentially a Tool that has been given a specific task. If a Tool is a recipe, then a Call is the act of cooking that recipe with specific ingredients.

## The Path from Idea to Call

Let's imagine you want to make a sandwich.

1.  **Idea**: You have a general thought: "I want a sandwich." This is just the knowledge that sandwiches exist.
2.  **Tool**: Your "Idea" turns into a recipe the computer can understand. The recipe specifies what "ingredients" (`parameters`) are needed. For example: we need `bread`, `filling`, and `cheese`. (Learn more about this in [002: Agent/Tool](./002_agent_tool.md)).
3.  **Call**: Now for the fun part! An Artificial Intelligence (AI) decides to use your recipe. It takes specific ingredients: `two slices of white bread`, `three slices of ham`, and `one slice of cheese`. The **Call** is that exact moment when you take the recipe and the specific ingredients and start cooking.

The main rule is this: **Any Idea can be turned into a Tool, and any Tool can be used through a Call.**

To learn how Ideas are made ready for use, check out **[007: Agent/Input](./007_agent_input.md)**.

## How to Control Execution: Scope and Method

To decide exactly how our `Call` will work, we have two "switches": **Scope** (where it works) and **Method** (how it works). These can be controlled with special commands like `_module`, `_activity`, and `_output`.

### Two Ways to Control

1.  **Scope (Do it yourself or ask a friend?)**
    Scope decides where the task will be executed: right here and now, or somewhere else.
    - **Do It Yourself (Inline Scope)**: This is the default mode. The task is executed immediately, on the spot. It's like making the sandwich yourself in your own kitchen.
    - **Ask a Friend (Module Scope)**: This is enabled with the `_module` command. The task is delegated to someone else. It's like ordering a pizza: you place the order (the `Call`), but another "kitchen" (another module or Idea) does the cooking.

2.  **Method (By the book or like an artist?)**
    Method decides how the result will be obtained: by following strict instructions or creatively.
    - **By the Book (Explicit Method)**: This is enabled with the `_activity` command. The result is generated by an explicitly written code, step by step. You'll always get the same outcome, just like cooking from a grandma's recipe.
    - **Like an Artist (Latent Method)**: This is the default mode if there's no `_activity` command. The result is conceived by the AI itself. It's like telling a chef, "Surprise me!" and they create something new based on what they know you like (`_output`).

These switches can be combined to create a wide variety of ways to execute tasks. To decide what knowledge can be used in the process, there are imports. You can read about them in **[008: Agent/Imports](./008_agent_imports.md)**.

## Building Complex Things from Simple Parts

A `Call` is like a single LEGO brick. On its own, it's simple, but with many bricks, you can build a huge castle. It is `Calls` that launch complex "Ideas" like **[202: Idea/Vessel](./202_idea_vessel.md)** and **[203: Idea/Process](./203_idea_process.md)**. A `Vessel`, for example, is like a LEGO box. It has everything: an instruction manual with a list of parts (`Tools`), the parts themselves (`context`), and the decision of which bricks (`Calls`) to use for building.

> Sidenote:
>
> - [202: Idea/Vessel](./202_idea_vessel.md)
> - [203: Idea/Process](./203_idea_process.md)

## How to Execute Calls

When an agent has multiple tasks (Calls), it can execute them in different ways. Imagine it's your to-do list for the evening.

```typescript
// Do one task from the list
const result = await Tool(call);

// Do all tasks on the list and wait for each to be completed
const results = await Tool.all(calls);

// Try tasks one by one and stop as soon as the first one succeeds
const result = await Tool.any(calls);

// Start all tasks at the same time and see which one finishes first (regardless of success or failure)
const result = await Tool.race(calls);
```

Such methods allow you to:

- **Full Control**: Do tasks one at a time, one after another.
- **Do Everything at Once**: If tasks don't depend on each other (like doing homework and washing dishes), you can do them simultaneously to be faster.
- **Find Quick Solutions**: If you need an answer to a question and you've asked three friends, you'll stop as soon as the first one gives you the answer (`.any()`).
- **All or Nothing**: If building a LEGO castle requires completing every step in the instructions, you would use `.all()` to make sure everything is done correctly.