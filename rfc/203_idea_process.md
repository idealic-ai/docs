# 203: Idea/Process

> **Process Idea:** A self-contained [Idea](./101_concept_idea.md) that captures a strategic [Plan](./012_agent_plan.md) and its live execution state. Its `schema` is the library of [Tools](./002_agent_tool.md), its `solution` is the _new_ `Plan` for the current tick, and its `context` contains the `Input`, `State`, and the previous `Plan`.
>
> — [Glossary](./000_glossary.md)

> Sidenote:
>
> - Requires:
>   - [101: Concept/Idea](./101_concept_idea.md)
>   - [012: Agent/Plan](./012_agent_plan.md)
>   - [010: Agent/State](./010_agent_state.md)
>   - [007: Agent/Input](./007_agent_input.md)
> - Complemented by:
>   - [011: Agent/Instancing](./011_agent_instancing.md)

Where a [202: Idea/Vessel](./202_idea_vessel.md) captures a single, reactive decision, a **Process Idea** embodies a proactive and strategic workflow. It is the artifact generated by the [012: Agent/Plan](./012_agent_plan.md) system as it orchestrates a complex, multi-step task over time. This makes it a complete record of both the capabilities available to the workflow and the specific strategy chosen by the agent.

## The Anatomy of a Plan

A `Process Idea` uses the `Idea` triplet to provide a complete snapshot of a workflow. This snapshot contains not only the agent's chosen strategy (the `Plan`) but also the full library of capabilities and the live state of the execution.

- **`schema` (The Palette):** Defines the library of all available [Tools](./002_agent_tool.md) from which a `Plan` can be constructed. It represents the agent's full set of capabilities.

- **`solution` (The New Plan):** The directed acyclic graph (DAG) of `Calls` that is the agent's chosen strategy for the _current_ tick. This becomes the `Plan Message` for the next tick.

- **`context` (Situational Awareness):** This holds all the information necessary for the agent to plan and execute the current tick.
  - **Input Message:** The initial stimulus that kicked off the entire process. This is typically provided only once and remains constant.

    > Sidenote:
    >
    > - [007: Agent/Input](./007_agent_input.md)

  - **State Message:** The live, evolving data for the workflow. It contains the persisted local variables that form the connections (edges) between the `Calls` in the `Plan`.

    > Sidenote:
    >
    > - [010: Agent/State](./010_agent_state.md)

  - **Plan Message:** This message contains the **Committed Plan** from the previous tick, which the agent can choose to follow or readjust.

    > Sidenote:
    >
    > - [012: Agent/Plan](./012_agent_plan.md)

### The Unity of Planning and Execution

A core principle of this architecture is the fusion of planning and execution into a single, unified process. Unlike traditional systems that separate these phases, here they happen concurrently within each tick. The agent doesn't just create a static plan and then separately execute it; the very act of generating the next `solution` (the new `Plan`) _is_ the execution step for the current tick.

This unity is what makes the system so dynamic and efficient. The `Plan` is a living graph that doesn't need to be complete to be useful. It can be partial, operate on the results of the previous tick, and adapt on the fly. The `Calls` generated by the LLM represent both the structure of the pipeline and the messages flowing within it. This duality allows a single LLM request to simultaneously validate the current state, adjust the plan based on new data, and execute the next logical step. There is no costly overhead for separate re-planning or validation calls; execution _is_ validation, planning, and adjustment, all happening at once.

> Sidenote:
>
> - [004: Agent/Call](./004_agent_call.md)

### The Flexibility Spectrum of a Plan

The `State` object enables a powerful, three-stage lifecycle for a `Plan`, allowing it to evolve from a flexible discovery process into a predictable, deterministic workflow:

1.  **Freeform Plan:** Initially, the `State` can be defined without a `schema`. This gives the agent maximum freedom to discover a `Plan` by creating new connections (properties in the `State` object) on the fly.

2.  **Specified Connections:** The next step in hardening a `Plan` is to freeze the `State`'s `schema`, which specifies the primary data pathways. This can be done on a spectrum from more to less flexible:
    - **Open Connections:** The schema can allow `additionalProperties`, which enforces the core data pathways while still giving the agent the freedom to create new connections for minor or exceptional paths.
    - **Closed Connections:** The schema can set `additionalProperties` to `false`, creating a rigid structure that the agent must follow precisely.

3.  **Resolved Plan:** This is the final stage, where a plan is considered fully mature and predictable. A `Resolved Plan` becomes the **Committed Plan** that is passed as the `Plan Message` in the `context` for subsequent ticks. A resolved plan can exist in two forms of stability:
    - **Happy Plan:** A resolved plan that covers the ideal case. It provides a highly efficient path but may still require adjustment if unexpected events occur.
    - **Complete Plan:** A fully resolved plan that has been expanded over time to account for common failures, alternatives, and other scenarios, making it highly deterministic.

This progression allows a `Process Idea` to evolve from a fluid design into a highly reliable and reusable asset.

## Immutable Workflows: Orchestration, Analysis, and Scaling

The power of a `Process Idea` comes from its immutability. Each step in a workflow generates a new, complete snapshot of the `Plan` and `State`, preserving a perfect, auditable history. This core principle of creating a chain of immutable artifacts is what enables the system's most advanced capabilities for orchestration, analysis, and scaling.

- **Reliable, Adaptive Execution:** The "tick-based" execution loop is fundamentally reliable because each new tick operates on a complete snapshot of the previous state. This atomicity prevents race conditions and ensures that the agent's decision to follow or readjust the `Plan` is based on a consistent and predictable world-view. The result of each tick is a new `Process Idea`, safely advancing the workflow one step at a time.

  > Sidenote:
  >
  > - [005: Agent/Loop](./005_agent_loop.md)
  > - [012: Agent/Plan](./012_agent_plan.md)

- **Resilient Orchestration:** A `Process Idea` is a self-contained artifact, which makes orchestration incredibly robust. A workflow can be paused simply by persisting its latest snapshot. External systems—or human supervisors—can then inspect this frozen state to make decisions. Any adjustments, such as replanning or state modification, result in the creation of a _new_ `Process Idea`, which can then be used to safely resume the workflow without altering the historical record.

  > Sidenote:
  >
  > - [010: Agent/State](./010_agent_state.md)

- **High-Fidelity Simulation:** This architecture is the prerequisite for interactive time travel. Every historical `Process Idea` is a perfect, high-fidelity snapshot of the workflow at a specific moment. This allows users or other agents to load any point in the process's history to perform audits, debug complex behavior, or run "what-if" scenarios by forking the process from that point.

  > Sidenote:
  >
  > - [202: Idea/Vessel](./202_idea_vessel.md)

- **Consistent Batch Processing:** The snapshot-based approach ensures consistency when scaling workflows with the Instancing protocol. A `Plan` acts as a template that is applied across a batch of independent `State` objects. Because both the `Plan` and the starting `State` of each instance are well-defined snapshots, the agent can process the entire batch in a single, atomic tick, guaranteeing a coherent and predictable outcome for every instance.

  > Sidenote:
  >
  > - [011: Agent/Instancing](./011_agent_instancing.md)

## From a Predictable Plan to Guided Execution

A `Process Idea` can mature into a **Resolved Plan**—a highly predictable and reliable workflow. While this rigidity provides stability, it can also limit flexibility. The system needs a way to introduce nuanced, context-specific guidance without sacrificing the integrity of the established plan.

This is the role of an **[Instruction Idea](./204_idea_instruction.md)**. An `Instruction` is a structured recipe for action that can be composed with a stable `Process`. Instead of altering the plan's structure, it provides targeted guidance for individual choices _within_ that structure. This allows an `Instruction` to direct specific reasoning steps, add new checks, or influence a decision at a particular node in the graph, providing an extra layer of control while retaining all the guarantees of the predictable plan. It is the mechanism for enhancing the _logic_ of a workflow, not just its sequence of actions.

> Sidenote:
>
> - [204: Idea/Instruction](./204_idea_instruction.md)
