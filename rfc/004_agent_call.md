# 004: Agent/Call

> **Call:** A concrete, executable instance of a `Tool`, with specific values for its `params`. It's an invocation-focused request for what _should be done_.
>
> — [Glossary](./000_glossary.md)

> Sidenote:
>
> - Requires:
>   - [103: Concept/Ideator](./103_concept_ideator.md)
> - Enables:
>   - [008: Agent/Imports](./008_agent_imports.md)
>   - [011: Agent/Instancing](./011_agent_instancing.md)
>   - [202: Idea/Vessel](./202_idea_vessel.md)
>   - [203: Idea/Process](./203_idea_process.md)

The [101: Concept/Idea](./101_concept_idea.md) defines a powerful, self-contained data structure for representing knowledge and latent logic. The [002: Agent/Tool](./002_agent_tool.md) establishes the foundational schema-driven interface that enables agents to understand structured capabilities. This document describes the **004: Agent/Call** protocol, which builds upon Tools to define how execution happens through Scope and Method controls.

A **Call** is a concrete instance of a Tool with specific parameter values, ready for execution. Where Tools define _what can be done_, Calls define _how it gets executed_.

This concept can be extended to create reusable, reproducible requests. By giving a request a formal input structure, it can be inverted into a discoverable `Tool` that an agent can execute. This powerful pattern of creating a reproducible request is the core of what the system calls an **[101: Concept/Idea](./101_concept_idea.md)**. The process of defining inputs to turn an `Idea` into a `Tool` is detailed in **[007: Agent/Input](./007_agent_input.md)**.

## The Controls of Execution: Scope and Method

A `Call`'s execution is defined by two independent properties: the **Scope** (where it runs) and the **Method** (how it runs). These controls are signaled by special properties (`_module`, `_activity`, `_output`) in the tool's schema.

### The Two Axes of Execution

1.  **Scope (Inline vs. Module)**
    The scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.
    - **Inline Scope**: The default mode where the `Call` is processed directly.
    - **Module Scope**: Signaled by `_module`, this delegates the `Call` to an external `Activity` or `Idea`.

2.  **Method (Explicit vs. Latent)**
    The method determines whether the output is generated by deterministic code or by an LLM.
    - **Explicit Method**: Signaled by the presence of an `_activity` property, the `Call`'s output is generated by deterministic code.
    - **Latent Method**: The default behavior when `_activity` is absent. The `Call`'s output is generated by an LLM. Requires the optional `_output` property to be present.

These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the **[008: Agent/Imports](./008_agent_imports.md)**.

## Enabling Complex Workflows

The `Call` is the primitive that enables more complex, structured workflows. Under the COILS protocol, it is the mechanism that can initiate higher-level executable `Ideas` like the **[202: Idea/Vessel](./202_idea_vessel.md)** and the **[203: Idea/Process](./203_idea_process.md)**. A `Vessel`, for instance, represents a single, reactive moment of decision-making. It encapsulates the entire request to an agent—including the rich `context` and a `schema` defining the set of available `Tools`—and the agent's response, which is a `solution` containing an array of zero or more `Calls` to be executed.

> Sidenote:
>
> - [202: Idea/Vessel](./202_idea_vessel.md)
> - [203: Idea/Process](./203_idea_process.md)

## Call Execution Patterns

When an agent generates multiple Calls, different execution strategies can be applied based on the application's needs:

```typescript
// Single Call execution
const result = await Tool(call);

// Execute all Calls, wait for all results
const results = await Tool.all(calls);

// Execute all Calls, return first success
const result = await Tool.any(calls);

// Execute all Calls, return first completion (success or failure)
const result = await Tool.race(calls);
```

These patterns enable:

- **Fine-Grained Control**: Process Calls individually with custom logic between executions
- **Batch Processing**: Execute independent Calls in parallel for maximum performance
- **Fail-Fast Strategies**: Stop on first success (`.any()`) or first completion (`.race()`)
- **All-or-Nothing Operations**: Ensure all Calls succeed together (`.all()`), maintaining consistency when Calls are logically grouped
