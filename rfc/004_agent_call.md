# 004: Agent/Call

> **Call:** A concrete, executable instance of a `Tool`, with specific values for its `params`. It's an invocation-focused request for what _should be done_. — [Glossary](./000_glossary.md)

> Sidenote:
>
> - Requires: [103: Concept/Ideator](./103_concept_ideator.md)
> - Enables: [008: Agent/Imports](./008_agent_imports.md), [011: Agent/Instancing](./011_agent_instancing.md)

The [101: Concept/Idea](./101_concept_idea.md) defines a powerful, self-contained data structure for representing knowledge and latent logic. The [002: Agent/Tool](./002_agent_tool.md) establishes the foundational schema-driven interface that enables agents to understand structured capabilities. This document describes the **Call Protocol**, which builds upon Tools to define how execution happens through Scope and Method controls.

A **Call** is a concrete instance of a Tool with specific parameter values, ready for execution. Where Tools define _what can be done_, Calls define _how it gets executed_.

## The Idea-to-Call Pipeline

1.  **Idea**: A self-contained, output-focused document representing knowledge or a process.
2.  **Tool**: An `Idea` inverted into an interface-focused schema, registered in the agent's tool system (see [002: Agent/Tool](./002_agent_tool.md) for details on Tool schemas, registration, and the dual registry architecture).
3.  **Call**: When the LLM decides to use a `Tool`, it fills in specific parameters, creating a **Call**. A `Call` is a single, concrete instance of a `Tool` being called.

The core principle: **any Idea can be turned into a Tool, which can then be called as a Call.**

For a detailed explanation of how an `Idea`'s input schema is inverted to become a `Tool`s parameter schema, see the **[007: Agent/Input](./007_agent_input.md)**.

## The Controls of Execution: Scope and Method

A `Call`'s execution is defined by two independent properties: the **Scope** (where it runs) and the **Method** (how it runs). These controls are signaled by special properties (`_module`, `_activity`, `_output`) in the tool's schema.

### The Two Axes of Execution

1.  **Scope (Inline vs. Module)**
    The scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.
    - **Inline Scope**: The default mode where the `Call` is processed directly.
    - **Module Scope**: Signaled by `_module`, this delegates the `Call` to an external `Activity` or `Idea`.

2.  **Method (Explicit vs. Latent)**
    The method determines whether the output is generated by deterministic code or by an LLM.
    - **Explicit Method**: Signaled by the presence of an `_activity` property, the `Call`'s output is generated by deterministic code.
    - **Latent Method**: The default behavior when `_activity` is absent. The `Call`'s output is generated by an LLM. Requires the optional `_output` property to be present.

These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the **[008: Agent/Imports](./008_agent_imports.md)**.

## Idea, Tool, and Call: A Spectrum of Focus

To understand the bridge, we must understand the fundamental difference in focus between these three concepts.

- An **Idea** is **output-focused**. Its primary purpose is to represent a complete thought or result. The `schema` defines the shape of the `solution` (the output), which was generated from the `context`. It is a record of what _was_ or _could be_.

- A **Tool** is **interface-focused**. Its schema defines parameters (inputs) and `_output` structure. It's an abstract template for an action—a function signature waiting to be called.

- A **Call** is **invocation-focused**. It is a concrete, executable instance of a `Tool`. It takes the `Tool`'s parameter-focused interface and fills it with specific values, making it a ready-to-run request for what _should be done_.

## The Vessel Idea: A single moment of decision

When an agent needs to make a decision, the complete request sent to the LLM is structured as a specific type of `Idea` that we call a **Vessel Idea**. It represents a single, self-contained moment of decision-making.

A Vessel Idea bundles the two key ingredients required for the LLM to make a choice:

1.  **The Context**: This includes all relevant information the agent needs, such as the user's request, memory, and other environmental data.
2.  **The Schema**: For a Vessel Idea, the schema's primary role is to define the "Vessel" — the set of possible `Tools` the agent is allowed to use in this specific situation.

The LLM processes this entire `Idea`—the context and the schema of available tools—and its `solution` is the result of that decision: an array of zero or more `Calls` to be executed.

This structure allows a single, coherent `Idea` to represent a complex, multi-step action.

## Call Execution Patterns

When a Vessel Idea produces multiple Calls, different execution strategies can be applied based on the application's needs:

```typescript
// Single Call execution
const result = await Tool(call);

// Execute all Calls, wait for all results
const results = await Tool.all(calls);

// Execute all Calls, return first success
const result = await Tool.any(calls);

// Execute all Calls, return first completion (success or failure)
const result = await Tool.race(calls);
```

These patterns enable:

- **Fine-Grained Control**: Process Calls individually with custom logic between executions
- **Batch Processing**: Execute independent Calls in parallel for maximum performance
- **Fail-Fast Strategies**: Stop on first success (`.any()`) or first completion (`.race()`)
- **All-or-Nothing Operations**: Ensure all Calls succeed together (`.all()`), maintaining consistency when Calls are logically grouped
