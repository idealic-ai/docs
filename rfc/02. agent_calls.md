# From Ideas to Action: The Call Protocol

_For definitions of key terms used in this document, please refer to the [Glossary](./00. glossary.md)._

The [Idea Protocol](./01. system_ideas.md) defines a powerful, self-contained data structure for representing knowledge and latent logic. This document describes the **Call Protocol**, which bridges the declarative world of `Ideas` with the imperative world of execution.

This protocol is a formalization of the agent tool system we have already designed. It renames the concept of a "tool activation" to a **Call** to better distinguish between the definition of a tool and its specific use.

## The Idea-to-Call Pipeline

1.  **Idea**: A self-contained, output-focused document representing knowledge or a process.
2.  **Tool**: An `Idea` can be inverted and registered within the agent's tool system, making it an executable **Tool**. It becomes a function signature, ready to be used.
3.  **Call**: When the LLM decides to use a `Tool`, it fills in the specific `params`, creating a **Call**. A `Call` is a single, concrete instance of a `Tool` being activated.

The core principle remains: **any Idea can be turned into a Tool, which can then be activated as a Call.**

## The Inversion: From Idea to Tool

The mechanical process of turning an output-focused `Idea` into an interface-focused `Tool` is an **inversion**. We restructure the `Idea`'s components to prioritize its inputs.

An `Idea` is a triplet defined by its output `schema` and `solution`:
`{ context, schema, solution }`

To convert it into a `Tool`, we look inside its `context` for the `input` definition. The primary step of inversion is to **promote** the `input` schema to become the top-level `params` schema for the `Tool`.

This creates a `Tool` definition, which is essentially a function signature ready to be registered in our system.

## The Controls of Execution: Scope and Method

A `Call`'s execution is defined by two independent properties: the **Scope** (where it runs) and the **Method** (how it runs). These controls are signaled by special properties (`_module`, `_activity`, `_output`) in the tool's schema.

### The Two Axes of Execution

1.  **Scope (Inline vs. Module)**
    The scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.
    - **Inline Scope**: The default mode where the `Call` is processed directly.
    - **Module Scope**: Signaled by `_module`, this delegates the `Call` to an external `Activity` or `Idea`.

2.  **Method (Explicit vs. Latent)**
    The method determines whether the output is generated by deterministic code or by an LLM.
    - **Explicit Method**: Signaled by the presence of an `_activity` property, the `Call`'s output is generated by deterministic code.
    - **Latent Method**: The default behavior when `_activity` is absent. The `Call`'s output is generated by an LLM. Requires the optional `_output` property to be present.

These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the **[Imports Protocol](./03. agent_imports.md)**.

## Idea, Tool, and Call: A Spectrum of Focus

To understand the bridge, we must understand the fundamental difference in focus between these three concepts.

- An **Idea** is **output-focused**. Its primary purpose is to represent a complete thought or result. The `schema` defines the shape of the `solution` (the output), which was generated from the `context`. It is a record of what _was_ or _could be_.

- A **Tool** is **interface-focused**. Its definition centers on the `params` it requires to run. It's an abstract template for an action—a function signature waiting to be invoked.

- A **Call** is **invocation-focused**. It is a concrete, executable instance of a `Tool`. It takes the `Tool`'s parameter-focused interface and fills it with specific values, making it a ready-to-run request for what _should be done_.

## The Vessel Idea: A single moment of decision

When an agent needs to make a decision, the complete request sent to the LLM is structured as a specific type of `Idea` that we call a **Vessel Idea**. It represents a single, self-contained moment of decision-making.

A Vessel Idea bundles the two key ingredients required for the LLM to make a choice:

1.  **The Context**: This includes all relevant information the agent needs, such as the user's request, memory, and other environmental data.
2.  **The Schema**: For a Vessel Idea, the schema's primary role is to define the "Vessel" — the set of possible `Tools` the agent is allowed to use in this specific situation.

The LLM processes this entire `Idea`—the context and the schema of available tools—and its `solution` is the result of that decision: an array of zero or more `Calls` to be executed.

This structure allows a single, coherent `Idea` to represent a complex, multi-step action.
