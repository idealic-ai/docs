[
  [
    {
      "body": "это че тут? ты кастишь булеан в схема обьект?",
      "created_at": "2025-11-18T05:53:41Z",
      "diff_hunk": "@@ -0,0 +1,1128 @@\n+import { filter } from '../Schema/utils/filter';\n+import { Schema } from '../types';\n+\n+describe('Schema.filter', () => {\n+  describe('Basic functionality', () => {\n+    it('should return schema unchanged when all properties pass predicate', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          foo: { type: 'string' },\n+          bar: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, () => true);\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should not mutate original schema', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          foo: { type: 'string' },\n+          _output: { type: 'number' },\n+        },\n+        required: ['foo', '_output'],\n+      } as const satisfies Schema;\n+      const original = JSON.parse(JSON.stringify(schema));\n+\n+      filter(schema, (_, context) => {\n+        const name = context.path[context.path.length - 1];\n+        return name !== '_output';\n+      });\n+\n+      expect(schema).toEqual(original);\n+    });\n+  });\n+\n+  describe('Property filtering', () => {\n+    it('should remove properties based on predicate', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          _output: { type: 'number' },\n+          age: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        const name = context.path[context.path.length - 1];\n+        return name !== '_output';\n+      }) as Schema.Object & { properties: Record<string, Schema.Definition> };\n+\n+      expect(result.properties).toHaveProperty('name');\n+      expect(result.properties).toHaveProperty('age');\n+      expect(result.properties).not.toHaveProperty('_output');\n+    });\n+\n+    it('should remove properties by prefix', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          _internal1: { type: 'number' },\n+          _internal2: { type: 'string' },\n+          age: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        const name = context.path[context.path.length - 1];\n+        return typeof name === 'string' && !name.startsWith('_internal');\n+      }) as Schema.Object & { properties: Record<string, Schema.Definition> };\n+\n+      expect(result.properties).toHaveProperty('name');\n+      expect(result.properties).toHaveProperty('age');\n+      expect(result.properties).not.toHaveProperty('_internal1');\n+      expect(result.properties).not.toHaveProperty('_internal2');\n+    });\n+\n+    it('should filter based on schema type', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          age: { type: 'number' },\n+          count: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, node => !('type' in node) || node.type !== 'number') as Schema.Object & {",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2536408308",
      "id": 2536408308,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "а, понял.... это фильетр целиком кастится.\n\n",
      "created_at": "2025-11-18T05:56:24Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2536414092",
      "id": 2536414092,
      "in_reply_to_id": 2536408308,
      "user": "Inviz"
    },
    {
      "body": "а зачем? у тебя же на выходе будет тот же тип что и на входе по дефолту",
      "created_at": "2025-11-18T05:57:20Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2536416282",
      "id": 2536416282,
      "in_reply_to_id": 2536408308,
      "user": "Inviz"
    }
  ],
  [
    {
      "body": "не супер эффективно, но пох и так сойдет",
      "created_at": "2025-11-21T00:10:11Z",
      "diff_hunk": "@@ -0,0 +1,245 @@\n+import { Schema } from '../Schema';\n+\n+export type MapContext = {\n+  /** Current path through schema structure */\n+  path: (string | number)[];\n+  /** Last segment of path (property name, array index, field name) */\n+  key: string | number | undefined;\n+  /** Second-to-last segment of path (e.g., 'properties', 'allOf', 'anyOf') */\n+  parent: string | number | undefined;\n+};\n+\n+export type MapVisitor = (\n+  node: Schema.Definition,\n+  context: MapContext\n+) => Schema.Definition | undefined;\n+\n+// Field mapping configuration\n+type MapperType = 'record' | 'array' | 'single';\n+\n+const fieldMappers: Record<string, MapperType> = {\n+  // Object record fields\n+  properties: 'record',\n+  patternProperties: 'record',\n+  dependencies: 'record',\n+  dependentSchemas: 'record',\n+  $defs: 'record',\n+\n+  // Object single schema fields\n+  additionalProperties: 'single',\n+  propertyNames: 'single',\n+  unevaluatedProperties: 'single',\n+\n+  // Array single schema fields\n+  items: 'single',\n+  additionalItems: 'single',\n+  contains: 'single',\n+\n+  // Array tuple fields\n+  prefixItems: 'array',\n+\n+  // Union fields\n+  anyOf: 'array',\n+  oneOf: 'array',\n+\n+  // Concatenation\n+  allOf: 'array',\n+\n+  // Not\n+  not: 'single',\n+\n+  // Conditional\n+  if: 'single',\n+  then: 'single',\n+  else: 'single',\n+};\n+\n+// Dependent field types for property-dependent cleanup\n+type DependentFieldType = 'array' | 'record';\n+\n+const dependentMappers: Record<string, DependentFieldType> = {\n+  // String arrays - filter items to existing properties\n+  required: 'array',\n+  propertyOrdering: 'array',\n+\n+  // Records - filter keys to existing properties, filter array values\n+  dependencies: 'record',\n+  dependentRequired: 'record',\n+  dependentSchemas: 'record',\n+};\n+\n+/**\n+ * Recursively maps over a schema tree, applying a visitor function to each node.\n+ * Returns a new schema without mutating the original.\n+ *\n+ * Every schema node is visited (including those with anyOf/allOf/oneOf).\n+ * The visitor receives the node and context (path) and returns the transformed node.\n+ *\n+ * Important behaviors:\n+ * - Accepts Schema.Definition: schema objects or booleans\n+ * - Visitor can return undefined to remove a schema node or property\n+ * - Undefined values in result objects are automatically filtered out (JSON spec compliance)\n+ * - Does not traverse into $ref children - visitor is called but children are not mapped\n+ * - String arrays in dependencies are passed through without visiting (handled by cleanup)\n+ *\n+ * @param schema The schema node to map over (schema or boolean)\n+ * @param visitor Function to transform each node (return undefined to remove)\n+ * @param context Internal context tracking (automatically managed)\n+ * @returns Transformed schema node\n+ */\n+export function map<S extends Schema.Definition>(\n+  schema: S,\n+  visitor: MapVisitor,\n+  context: MapContext = { path: [], key: undefined, parent: undefined }\n+): S {\n+  // For non-object schemas (booleans) and $ref, just apply visitor directly\n+  if (typeof schema !== 'object' || schema === null || '$ref' in schema) {\n+    return visitor(schema, context) as S;\n+  }\n+\n+  // Build updates by reducing over all field mappers\n+  const updates = Object.entries(fieldMappers).reduce(\n+    (acc, [field, mapperType]) => {\n+      if (!(field in schema)) {\n+        return acc;\n+      }\n+\n+      const value = (schema as Record<string, unknown>)[field];\n+\n+      if (value === undefined) {\n+        return acc;\n+      }\n+\n+      let mapped: unknown;\n+\n+      switch (mapperType) {\n+        case 'record':\n+          mapped = Object.entries(\n+            value as Record<string, Schema.Definition | readonly string[]>\n+          ).reduce(\n+            (recAcc, [name, recValue]) => {\n+              // String arrays in dependencies are passed through without visiting\n+              // They are handled by dependentMappers cleanup, similar to required/dependentRequired\n+              if (Array.isArray(recValue)) {\n+                return { ...recAcc, [name]: recValue };\n+              }\n+\n+              const childPath = [...context.path, field, name];\n+              const childContext = {\n+                path: childPath,\n+                key: name,\n+                parent: field,\n+              };\n+\n+              let mappedValue: Schema.Definition | undefined;\n+\n+              // If value is a schema object, map it recursively\n+              if (typeof recValue === 'object' && recValue !== null) {\n+                mappedValue = map(recValue as Schema, visitor, childContext);\n+              } else {\n+                // For booleans, call visitor directly\n+                mappedValue = visitor(recValue, childContext);\n+              }\n+\n+              if (mappedValue === undefined) {\n+                return recAcc;\n+              }\n+\n+              return { ...recAcc, [name]: mappedValue };\n+            },\n+            {} as Record<string, Schema.Definition | readonly string[]>\n+          );\n+          break;\n+\n+        case 'array':\n+          mapped = (value as readonly Schema.Definition[]).map((s, index) => {\n+            const childPath = [...context.path, field, index];\n+            return map(s as Schema, visitor, {\n+              path: childPath,\n+              key: index,\n+              parent: field,\n+            });\n+          });\n+          break;\n+\n+        case 'single': {\n+          const childPath = [...context.path, field];\n+          mapped = map(value as Schema.Definition, visitor, {\n+            path: childPath,\n+            key: field,\n+            parent: context.path[context.path.length - 1],\n+          });\n+          break;\n+        }\n+      }\n+\n+      return { ...acc, [field]: mapped };\n+    },\n+    {} as Record<string, unknown>\n+  );\n+\n+  // Apply updates\n+  let transformed = { ...schema, ...updates };\n+\n+  // Update property-dependent fields if properties were mapped\n+  if ('properties' in transformed && transformed.properties) {\n+    const propertyNames = new Set(Object.keys(transformed.properties));\n+    const propUpdates = Object.entries(dependentMappers).reduce(\n+      (depUpdates, [field, mapperType]) => {",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2548106175",
      "id": 2548106175,
      "in_reply_to_id": null,
      "user": "Inviz"
    }
  ],
  [
    {
      "body": "какая-то тут набуровленность. Ты сверху кастишь в этот тип, а потом опять тут. А в array перекащщиваешь. Ваще касты канеш не супер, но лучше так, чем ошибки тайпскприпта. Но здесь хотя бы не надо value два раза подряд тип менять, убери вне switch каст и/или не задавай value там",
      "created_at": "2025-11-21T00:12:06Z",
      "diff_hunk": "@@ -0,0 +1,245 @@\n+import { Schema } from '../Schema';\n+\n+export type MapContext = {\n+  /** Current path through schema structure */\n+  path: (string | number)[];\n+  /** Last segment of path (property name, array index, field name) */\n+  key: string | number | undefined;\n+  /** Second-to-last segment of path (e.g., 'properties', 'allOf', 'anyOf') */\n+  parent: string | number | undefined;\n+};\n+\n+export type MapVisitor = (\n+  node: Schema.Definition,\n+  context: MapContext\n+) => Schema.Definition | undefined;\n+\n+// Field mapping configuration\n+type MapperType = 'record' | 'array' | 'single';\n+\n+const fieldMappers: Record<string, MapperType> = {\n+  // Object record fields\n+  properties: 'record',\n+  patternProperties: 'record',\n+  dependencies: 'record',\n+  dependentSchemas: 'record',\n+  $defs: 'record',\n+\n+  // Object single schema fields\n+  additionalProperties: 'single',\n+  propertyNames: 'single',\n+  unevaluatedProperties: 'single',\n+\n+  // Array single schema fields\n+  items: 'single',\n+  additionalItems: 'single',\n+  contains: 'single',\n+\n+  // Array tuple fields\n+  prefixItems: 'array',\n+\n+  // Union fields\n+  anyOf: 'array',\n+  oneOf: 'array',\n+\n+  // Concatenation\n+  allOf: 'array',\n+\n+  // Not\n+  not: 'single',\n+\n+  // Conditional\n+  if: 'single',\n+  then: 'single',\n+  else: 'single',\n+};\n+\n+// Dependent field types for property-dependent cleanup\n+type DependentFieldType = 'array' | 'record';\n+\n+const dependentMappers: Record<string, DependentFieldType> = {\n+  // String arrays - filter items to existing properties\n+  required: 'array',\n+  propertyOrdering: 'array',\n+\n+  // Records - filter keys to existing properties, filter array values\n+  dependencies: 'record',\n+  dependentRequired: 'record',\n+  dependentSchemas: 'record',\n+};\n+\n+/**\n+ * Recursively maps over a schema tree, applying a visitor function to each node.\n+ * Returns a new schema without mutating the original.\n+ *\n+ * Every schema node is visited (including those with anyOf/allOf/oneOf).\n+ * The visitor receives the node and context (path) and returns the transformed node.\n+ *\n+ * Important behaviors:\n+ * - Accepts Schema.Definition: schema objects or booleans\n+ * - Visitor can return undefined to remove a schema node or property\n+ * - Undefined values in result objects are automatically filtered out (JSON spec compliance)\n+ * - Does not traverse into $ref children - visitor is called but children are not mapped\n+ * - String arrays in dependencies are passed through without visiting (handled by cleanup)\n+ *\n+ * @param schema The schema node to map over (schema or boolean)\n+ * @param visitor Function to transform each node (return undefined to remove)\n+ * @param context Internal context tracking (automatically managed)\n+ * @returns Transformed schema node\n+ */\n+export function map<S extends Schema.Definition>(\n+  schema: S,\n+  visitor: MapVisitor,\n+  context: MapContext = { path: [], key: undefined, parent: undefined }\n+): S {\n+  // For non-object schemas (booleans) and $ref, just apply visitor directly\n+  if (typeof schema !== 'object' || schema === null || '$ref' in schema) {\n+    return visitor(schema, context) as S;\n+  }\n+\n+  // Build updates by reducing over all field mappers\n+  const updates = Object.entries(fieldMappers).reduce(\n+    (acc, [field, mapperType]) => {\n+      if (!(field in schema)) {\n+        return acc;\n+      }\n+\n+      const value = (schema as Record<string, unknown>)[field];\n+\n+      if (value === undefined) {\n+        return acc;\n+      }\n+\n+      let mapped: unknown;\n+\n+      switch (mapperType) {\n+        case 'record':\n+          mapped = Object.entries(\n+            value as Record<string, Schema.Definition | readonly string[]>\n+          ).reduce(\n+            (recAcc, [name, recValue]) => {\n+              // String arrays in dependencies are passed through without visiting\n+              // They are handled by dependentMappers cleanup, similar to required/dependentRequired\n+              if (Array.isArray(recValue)) {\n+                return { ...recAcc, [name]: recValue };\n+              }\n+\n+              const childPath = [...context.path, field, name];\n+              const childContext = {\n+                path: childPath,\n+                key: name,\n+                parent: field,\n+              };\n+\n+              let mappedValue: Schema.Definition | undefined;\n+\n+              // If value is a schema object, map it recursively\n+              if (typeof recValue === 'object' && recValue !== null) {\n+                mappedValue = map(recValue as Schema, visitor, childContext);\n+              } else {\n+                // For booleans, call visitor directly\n+                mappedValue = visitor(recValue, childContext);\n+              }\n+\n+              if (mappedValue === undefined) {\n+                return recAcc;\n+              }\n+\n+              return { ...recAcc, [name]: mappedValue };\n+            },\n+            {} as Record<string, Schema.Definition | readonly string[]>\n+          );\n+          break;\n+\n+        case 'array':\n+          mapped = (value as readonly Schema.Definition[]).map((s, index) => {\n+            const childPath = [...context.path, field, index];\n+            return map(s as Schema, visitor, {\n+              path: childPath,\n+              key: index,\n+              parent: field,\n+            });\n+          });\n+          break;\n+\n+        case 'single': {\n+          const childPath = [...context.path, field];\n+          mapped = map(value as Schema.Definition, visitor, {\n+            path: childPath,\n+            key: field,\n+            parent: context.path[context.path.length - 1],\n+          });\n+          break;\n+        }\n+      }\n+\n+      return { ...acc, [field]: mapped };\n+    },\n+    {} as Record<string, unknown>\n+  );\n+\n+  // Apply updates\n+  let transformed = { ...schema, ...updates };\n+\n+  // Update property-dependent fields if properties were mapped\n+  if ('properties' in transformed && transformed.properties) {\n+    const propertyNames = new Set(Object.keys(transformed.properties));\n+    const propUpdates = Object.entries(dependentMappers).reduce(\n+      (depUpdates, [field, mapperType]) => {\n+        if (!(field in transformed)) {\n+          return depUpdates;\n+        }\n+\n+        const value = (transformed as Record<string, unknown>)[field];\n+        if (value === undefined) {\n+          return depUpdates;\n+        }\n+\n+        let filtered: unknown;\n+\n+        switch (mapperType) {\n+          case 'array': {\n+            const arr = value as readonly string[];\n+            const result = arr.filter(item => propertyNames.has(item));\n+            filtered = result.length > 0 ? result : undefined;\n+            break;\n+          }\n+\n+          case 'record': {\n+            const record = value as Record<string, unknown>;",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2548108806",
      "id": 2548108806,
      "in_reply_to_id": null,
      "user": "Inviz"
    }
  ],
  [
    {
      "body": "это жопа что тип теряется и надо кастить по результату. Почему так? Фильтр должен сохранять тип",
      "created_at": "2025-11-21T00:15:02Z",
      "diff_hunk": "@@ -0,0 +1,1281 @@\n+import { filter } from '../Schema/utils/filter';\n+import { isNumber } from '../Schema/utils/guards';\n+import { Schema } from '../types';\n+\n+describe('Schema.filter', () => {\n+  describe('Basic functionality', () => {\n+    it('should return schema unchanged when all properties pass predicate', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          foo: { type: 'string' },\n+          bar: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, () => true);\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should not mutate original schema', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          foo: { type: 'string' },\n+          _output: { type: 'number' },\n+        },\n+        required: ['foo', '_output'],\n+      } as const satisfies Schema;\n+      const original = JSON.parse(JSON.stringify(schema));\n+\n+      filter(schema, (_, context) => {\n+        return context.key !== '_output';\n+      });\n+\n+      expect(schema).toEqual(original);\n+    });\n+  });\n+\n+  describe('Property filtering', () => {\n+    it('should remove properties based on predicate', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          _output: { type: 'number' },\n+          age: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        return context.key !== '_output';\n+      }) as Schema.Object & { properties: Record<string, Schema.Definition> };\n+\n+      expect(result.properties).toHaveProperty('name');\n+      expect(result.properties).toHaveProperty('age');\n+      expect(result.properties).not.toHaveProperty('_output');\n+    });\n+\n+    it('should remove properties by prefix', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          _internal1: { type: 'number' },\n+          _internal2: { type: 'string' },\n+          age: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        return typeof context.key === 'string' && !context.key.startsWith('_internal');\n+      }) as Schema.Object & { properties: Record<string, Schema.Definition> };\n+\n+      expect(result.properties).toHaveProperty('name');\n+      expect(result.properties).toHaveProperty('age');\n+      expect(result.properties).not.toHaveProperty('_internal1');\n+      expect(result.properties).not.toHaveProperty('_internal2');\n+    });\n+\n+    it('should filter based on schema type', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          age: { type: 'number' },\n+          count: { type: 'number' },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, node => !isNumber(node)) as Schema.Object & {\n+        properties: Record<string, Schema.Definition>;\n+      };\n+\n+      expect(result.properties).toHaveProperty('name');\n+      expect(result.properties).not.toHaveProperty('age');\n+      expect(result.properties).not.toHaveProperty('count');\n+    });\n+\n+    it('should update required array when properties are removed', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          name: { type: 'string' },\n+          _output: { type: 'number' },\n+          age: { type: 'number' },\n+        },\n+        required: ['name', '_output', 'age'],\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        return context.key !== '_output';\n+      }) as Schema.Object;\n+\n+      expect(result.required).toEqual(['name', 'age']);\n+      expect(result.required).not.toContain('_output');\n+    });\n+\n+    it('should remove required array if empty after filtering', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          _output: { type: 'number' },\n+        },\n+        required: ['_output'],\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        return context.key !== '_output';\n+      });\n+\n+      expect(result).not.toHaveProperty('required');\n+    });\n+  });\n+\n+  describe('Nested properties', () => {\n+    it('should filter nested properties', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          data: {\n+            type: 'object',\n+            properties: {\n+              name: { type: 'string' },\n+              _output: { type: 'number' },\n+            },\n+          },\n+        },\n+      } as const satisfies Schema;\n+\n+      const result = filter(schema, (_, context) => {\n+        return context.key !== '_output';\n+      }) as Schema.Object & { properties: Record<string, Schema.Definition> };",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2548113069",
      "id": 2548113069,
      "in_reply_to_id": null,
      "user": "Inviz"
    }
  ],
  [
    {
      "body": "мапинг опциональный параметр вроде",
      "created_at": "2025-11-27T03:29:08Z",
      "diff_hunk": "@@ -45,25 +43,28 @@ export function extractDiscriminatedMetadata(\n  * Extract metadata from mapping-based discriminator\n  */\n function extractFromMappingDiscriminator(\n-  schema: Schema.Definition,\n+  schema: Schema & {\n+    discriminator: {\n+      propertyName: string;\n+      mapping: Record<string, string>;",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567069483",
      "id": 2567069483,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "> The mapping property within a JSON Schema discriminator is optional.\r\nWhile it is recommended to use mapping explicitly for clarity and better control over how schema names relate to discriminated property values, it is not strictly required by the OpenAPI Specification.\r\nIf mapping is not explicitly declared, the discriminator will implicitly infer the mapping from the schema names within the allOf, anyOf, or oneOf keywords. In this case, the values of the discriminated property in the data must exactly match the names of the corresponding schemas.\r\nHowever, using mapping provides the flexibility to define custom mappings between the discriminated property values and the schema names, allowing for cases where the values might not directly correspond to the schema names. This enhances readability and maintainability of the schema.",
      "created_at": "2025-11-27T03:30:10Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567070581",
      "id": 2567070581,
      "in_reply_to_id": 2567069483,
      "user": "Inviz"
    },
    {
      "body": "А там до этого вызывается `hasDiscriminatorWithMapping`, который делает `mapping` определенным.",
      "created_at": "2025-11-27T03:56:09Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567100436",
      "id": 2567100436,
      "in_reply_to_id": 2567069483,
      "user": "akoppela"
    }
  ],
  [
    {
      "body": "вроде хорошая идея но одновременно добавляет неопределнности - то фильтрует, то нет. Но наверное это нормальный компромисс. Не могу лучше решения придумать.\r\n\r\nно раз уж пишу, то придерусь что два раза проверяем hasMinProperties(schema)",
      "created_at": "2025-11-27T03:34:17Z",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+import { Schema } from '../Schema';\n+import {\n+  isObject,\n+  hasProperties,\n+  hasDependencies,\n+  hasDependentSchemas,\n+  hasDependentRequired,\n+  hasRequired,\n+  hasPropertyOrdering,\n+  hasMinProperties,\n+} from './guards';\n+\n+export type PropertyPredicate = (propertyName: string) => boolean;\n+\n+/**\n+ * Filters properties in an object schema based on a predicate function.\n+ * Also updates dependent fields (required, dependencies, etc.) to only reference existing properties.\n+ * Non-recursive - only processes the top-level schema.\n+ *\n+ * Note: Only works with object schemas. Caller should check isObject() before calling.\n+ */\n+export function filterProperties<S extends Schema.Object>(\n+  schema: S,\n+  predicate: PropertyPredicate\n+): S {\n+  if (!hasProperties(schema)) {\n+    return schema;\n+  }\n+\n+  // Filter properties based on predicate\n+  const filteredProperties = Object.entries(schema.properties).reduce(\n+    (acc, [key, value]) => {\n+      if (predicate(key)) {\n+        acc[key] = value;\n+      }\n+      return acc;\n+    },\n+    {} as Record<string, Schema.Definition>\n+  );\n+\n+  // Helper to check if a property name exists in filtered properties\n+  const hasFilteredProp = (propName: string) => propName in filteredProperties;\n+\n+  // Helper to filter array of property names\n+  const filterPropArray = (arr: readonly string[]) => arr.filter(hasFilteredProp);\n+\n+  // Filter required\n+  const filteredRequired = hasRequired(schema) ? filterPropArray(schema.required) : undefined;\n+\n+  // Filter propertyOrdering\n+  const filteredPropertyOrdering = hasPropertyOrdering(schema)\n+    ? filterPropArray(schema.propertyOrdering)\n+    : undefined;\n+\n+  // Filter dependencies\n+  const filteredDependencies = hasDependencies(schema)\n+    ? Object.entries(schema.dependencies).reduce(\n+        (acc, [key, value]) => {\n+          if (hasFilteredProp(key)) {\n+            if (Array.isArray(value)) {\n+              const filtered = filterPropArray(value);\n+              if (filtered.length > 0) {\n+                acc[key] = filtered;\n+              }\n+            } else {\n+              acc[key] = value;\n+            }\n+          }\n+          return acc;\n+        },\n+        {} as Record<string, Schema.CouldBePartial | readonly string[]>\n+      )\n+    : undefined;\n+\n+  // Filter dependentRequired\n+  const filteredDependentRequired = hasDependentRequired(schema)\n+    ? Object.entries(schema.dependentRequired).reduce(\n+        (acc, [key, value]) => {\n+          if (hasFilteredProp(key)) {\n+            const filtered = filterPropArray(value);\n+            if (filtered.length > 0) {\n+              acc[key] = filtered;\n+            }\n+          }\n+          return acc;\n+        },\n+        {} as Record<string, readonly string[]>\n+      )\n+    : undefined;\n+\n+  // Filter dependentSchemas\n+  const filteredDependentSchemas = hasDependentSchemas(schema)\n+    ? Object.entries(schema.dependentSchemas).reduce(\n+        (acc, [key, value]) => {\n+          if (hasFilteredProp(key)) {\n+            acc[key] = value;\n+          }\n+          return acc;\n+        },\n+        {} as Record<string, Schema.CouldBePartial>\n+      )\n+    : undefined;\n+\n+  // Calculate filtered property count for numeric constraints\n+  const filteredPropertyCount = Object.keys(filteredProperties).length;\n+\n+  // Adjust minProperties - cap it at the filtered count (can't require more than we have)\n+  const adjustedMinProperties =",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567075049",
      "id": 2567075049,
      "in_reply_to_id": null,
      "user": "Inviz"
    }
  ],
  [
    {
      "body": "не думал сделать общий \r\n\r\n`has<S extends Schema, T extends keyof Schema.Composite)(schema, property: T) : schema is S & Pick<Schema.Composite, T>`\r\n\r\n?\r\n\r\nА про Tuple/Uniform я б переименовал в isUniformArray() / isTuple() \r\n\r\n",
      "created_at": "2025-11-27T03:38:37Z",
      "diff_hunk": "@@ -1,83 +1,299 @@\n import { Schema } from '../Schema';\n \n-// Helper to check if a property is an array in the schema\n-export function isArray(schema?: Schema.Composite.Definition | undefined): schema is Schema.Array {\n+// Helper to check if a schema is a string type\n+export function isString(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema.String {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'type' in schema && schema.type === 'string';\n+}\n+\n+// Helper to check if a schema is a number type\n+export function isNumber(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema.Number {\n   if (!schema || typeof schema !== 'object') return false;\n-  return schema.type === 'array' || schema.items !== undefined;\n+  return 'type' in schema && (schema.type === 'number' || schema.type === 'integer');\n }\n \n-// Helper to check if array schema has single items definition (not tuple)\n-export function isArrayWithSingleItems(\n+export function isInteger(\n   schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Array & { items: Schema.Composite.Definition } {\n-  return isArray(schema) && schema.items !== undefined && !Array.isArray(schema.items);\n+): schema is Schema.Integer {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'type' in schema && schema.type === 'integer';\n+}\n+\n+// Helper to check if a property is an array in the schema\n+export function isArray(schema?: Schema.Composite.Definition | undefined): schema is Schema.Array {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'type' in schema && schema.type === 'array';\n }\n \n // Helper to check if a property is an object in the schema\n export function isObject(\n   schema?: Schema.Composite.Definition | undefined\n ): schema is Schema.Object {\n   if (!schema || typeof schema !== 'object') return false;\n-  return (\n-    schema.type === 'object' ||\n-    (schema.properties !== undefined && typeof schema.properties === 'object')\n-  );\n+  return 'type' in schema && schema.type === 'object';\n }\n \n-export function isContent(\n+export function isBoolean(\n   schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Content {\n+): schema is Schema.Boolean {\n   if (!schema || typeof schema !== 'object') return false;\n-  return schema.$ref == null;\n+  return 'type' in schema && schema.type === 'boolean';\n }\n \n-export function isStringConst(\n+export function isNull(schema?: Schema.Composite.Definition | undefined): schema is Schema.Null {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'type' in schema && schema.type === 'null';\n+}\n+\n+export function isContent(\n   schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Composite.Definition & { const: string } {\n+): schema is Schema.Content {\n   if (!schema || typeof schema !== 'object') return false;\n-  return 'const' in schema && typeof schema.const === 'string';\n+  return !('$ref' in schema);\n }\n \n-export function isRef(schema?: Schema.Any): schema is Schema.Ref {\n+export function isRef(schema?: Schema.Composite.Definition | undefined): schema is Schema.Ref {\n   if (!schema || typeof schema !== 'object') return false;\n   return '$ref' in schema;\n }\n \n-export function isUnion(schema?: Schema.Any): schema is Schema.Union {\n+export function isUnion(schema?: Schema.Composite.Definition | undefined): schema is Schema.Union {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'anyOf' in schema || 'oneOf' in schema;\n }\n \n export function isAnyOfUnion(\n   schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Union & { anyOf: readonly Schema.Composite.Definition[] } {\n+): schema is Schema.Union & { anyOf: readonly Schema.CouldBePartial[] } {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'anyOf' in schema;\n }\n \n-export function isConcatenation(schema?: Schema.Any): schema is Schema.Concatenation {\n+export function isOneOfUnion(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema.Union & { oneOf: readonly Schema.CouldBePartial[] } {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'oneOf' in schema;\n+}\n+\n+export function isConcatenation(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema.Concatenation {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'allOf' in schema;\n }\n \n-export function isEnum(schema?: Schema.Any): schema is Schema.Enum {\n+export function isEnum(schema?: Schema.Composite.Definition | undefined): schema is Schema.Enum {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'enum' in schema;\n }\n \n-export function isConditional(schema?: Schema.Any): schema is Schema.Conditional {\n+export function isConditional(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema.Conditional {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'if' in schema;\n }\n \n-export function isNot(schema?: Schema.Any): schema is Schema.Not {\n+export function isNot(schema?: Schema.Composite.Definition | undefined): schema is Schema.Not {\n   if (!schema || typeof schema !== 'object') return false;\n   return 'not' in schema;\n }\n \n-export function isDefs(\n+// Guards for common schema fields\n+export function hasConst(\n   schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Object & { $defs: Record<string, Schema> } {\n+): schema is Schema & { const: unknown } {\n+  if (!schema || typeof schema !== 'object') return false;\n+  return 'const' in schema;\n+}\n+\n+export function hasDefs(\n+  schema?: Schema.Composite.Definition | undefined\n+): schema is Schema & { $defs: Record<string, Schema.Definition> } {\n   if (!schema || typeof schema !== 'object') return false;\n   return '$defs' in schema;\n }\n+\n+// Guards for object schema fields\n+export function hasProperties(\n+  schema?: Schema.Composite.Definition | undefined",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567080500",
      "id": 2567080500,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "Хорошая идея",
      "created_at": "2025-11-27T03:57:26Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567101871",
      "id": 2567101871,
      "in_reply_to_id": 2567080500,
      "user": "akoppela"
    }
  ],
  [
    {
      "body": "можно убрать один обертыш",
      "created_at": "2025-11-27T03:41:21Z",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+import { Schema } from '../types';\n+import { filterProperties, pickProperties, omitProperties } from '../Schema/utils/filterProperties';\n+import { map } from '../Schema/utils/map';\n+\n+describe('filterProperties', () => {\n+  describe('filterProperties', () => {",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567083569",
      "id": 2567083569,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "Логично, пропустил",
      "created_at": "2025-11-27T03:57:40Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567102103",
      "id": 2567102103,
      "in_reply_to_id": 2567083569,
      "user": "akoppela"
    }
  ],
  [
    {
      "body": "вот вопрос такой концептуальный. У нас щас в пути присутсвтует anyOf и properties. То есть это путь в схеме, а не в финальном обьекте данных.\r\n\r\nЕсли бы я хотел пофильтровать по шейпу данных, а не схемы, то мне пришлось бы\r\n1) Патчить путь убирать из него лишнее\r\n2) Фильтровать контексты тоже\r\n\r\nможем ли мы это улучшить?  Один из вариантов был бы добавить что у контекста в сегментах еще есть какое-то свойство типа isData: true/false - true только для не-паршиалов aka схем с type. Чтоб можно было восстановить путь лехше если нужно. Или по идее я так же динамически мог бы это сделать? Типа фильтрануть контекст по isData() и получить только те сегменты, которые будут в финальных данных соответствюущих схеме?",
      "created_at": "2025-11-27T03:50:16Z",
      "diff_hunk": "@@ -0,0 +1,2743 @@\n+import {\n+  isArray,\n+  isAnyOfUnion,\n+  isBoolean,\n+  isConditional,\n+  isConcatenation,\n+  isNot,\n+  isNumber,\n+  isObject,\n+  isOneOfUnion,\n+  hasProperties,\n+  hasRequired,\n+  hasUniformItems,\n+  isRef,\n+  isString,\n+  isValid,\n+  hasAdditionalItems,\n+  hasAdditionalProperties,\n+  hasContains,\n+  hasDefs,\n+  hasDependencies,\n+  hasDependentSchemas,\n+  hasElse,\n+  hasPatternProperties,\n+  hasPropertyNames,\n+  hasThen,\n+  hasTupleItems,\n+  hasUnevaluatedProperties,\n+  hasMinProperties,\n+  hasMaxProperties,\n+} from '../Schema/utils/guards';\n+import { map } from '../Schema/utils/map';\n+import { Schema } from '../types';\n+\n+describe('Schema.map', () => {\n+  describe('Boolean schemas', () => {\n+    it('should handle boolean true schema', () => {\n+      const result = map(true, node => node);\n+      expect(result).toBe(true);\n+    });\n+\n+    it('should handle boolean false schema', () => {\n+      const result = map(false, node => node);\n+      expect(result).toBe(false);\n+    });\n+\n+    it('should allow visitor to transform boolean schemas', () => {\n+      const result = map(true, node => {\n+        if (node === true) {\n+          return { type: 'object' } as const satisfies Schema.Object;\n+        }\n+        return node;\n+      });\n+\n+      expect(isObject(result)).toBe(true);\n+    });\n+\n+    it('should allow visitor to transform schema to boolean', () => {\n+      const schema = {\n+        type: 'object',\n+        additionalProperties: { type: 'string' },\n+      } as const satisfies Schema.Object;\n+\n+      const result = map(schema, (node, context) => {\n+        if (context.key === 'additionalProperties') {\n+          return false;\n+        }\n+        return node;\n+      });\n+\n+      expect(isObject(result) && hasAdditionalProperties(result)).toBe(true);\n+      if (isObject(result) && hasAdditionalProperties(result)) {\n+        expect(result.additionalProperties).toBe(false);\n+      }\n+    });\n+\n+    it('should track full traversal path', () => {\n+      const paths: string[] = [];\n+      map(true, (node, context) => {\n+        paths.push(context.path.join('.') || 'root');\n+        return node;\n+      });\n+\n+      expect(paths).toEqual(['root']);\n+    });\n+  });\n+\n+  describe('Primitive schemas', () => {\n+    it('should handle string schema', () => {\n+      const schema = { type: 'string' } as const satisfies Schema.String;\n+      const result = map(schema, node => node);\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should handle number schema', () => {\n+      const schema = { type: 'number' } as const satisfies Schema.Number;\n+      const result = map(schema, node => node);\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should handle null schema', () => {\n+      const schema = { type: 'null' } as const satisfies Schema.Null;\n+      const result = map(schema, node => node);\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should not mutate original schema', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: { foo: { type: 'string' } },\n+      } as const satisfies Schema.Object;\n+      const original = JSON.parse(JSON.stringify(schema));\n+\n+      map(schema, node => {\n+        if (isString(node)) {\n+          return { ...node, minLength: 1 };\n+        }\n+        return node;\n+      });\n+\n+      expect(schema).toEqual(original);\n+    });\n+\n+    it('should track full traversal path', () => {\n+      const schema = { type: 'string', minLength: 5 } as const satisfies Schema.String;\n+      const paths: string[] = [];\n+\n+      map(schema, (node, context) => {\n+        paths.push(context.path.join('.') || 'root');\n+        return node;\n+      });\n+\n+      expect(paths).toEqual(['root']);\n+    });\n+  });\n+\n+  describe('$ref schemas', () => {\n+    it('should visit $ref but not traverse into it', () => {\n+      const schema = { $ref: '#/$defs/MyDef' } as const satisfies Schema.Ref;\n+      const visitedNodes: (Schema.Definition | Schema.Partial)[] = [];\n+\n+      const result = map(schema, node => {\n+        visitedNodes.push(node);\n+        return node;\n+      });\n+\n+      expect(visitedNodes).toHaveLength(1);\n+      expect(visitedNodes[0]).toEqual({ $ref: '#/$defs/MyDef' });\n+      expect(result).toEqual(schema);\n+    });\n+\n+    it('should allow visitor to transform $ref values', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          user: { $ref: '#/$defs/User' },\n+          admin: { $ref: '#/$defs/Admin' },\n+        },\n+      } as const satisfies Schema.Object;\n+\n+      const result = map(schema, node => {\n+        if (isRef(node)) {\n+          return { $ref: node.$ref.replace('#/$defs/', '#/components/schemas/') };\n+        }\n+        return node;\n+      });\n+\n+      expect(isObject(result) && hasProperties(result)).toBe(true);\n+      if (isObject(result) && hasProperties(result)) {\n+        expect(isRef(result.properties.user)).toBe(true);\n+        if (isRef(result.properties.user)) {\n+          expect(result.properties.user.$ref).toBe('#/components/schemas/User');\n+        }\n+        expect(isRef(result.properties.admin)).toBe(true);\n+        if (isRef(result.properties.admin)) {\n+          expect(result.properties.admin.$ref).toBe('#/components/schemas/Admin');\n+        }\n+      }\n+    });\n+\n+    it('should provide correct path for $ref nodes', () => {\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          nested: {\n+            type: 'object',\n+            properties: {\n+              ref: { $ref: '#/$defs/MyDef' },\n+            },\n+          },\n+        },\n+      } as const satisfies Schema.Object;\n+\n+      const paths: (string | number)[][] = [];\n+      map(schema, (node, context) => {\n+        if (isRef(node)) {\n+          paths.push(context.path);\n+        }\n+        return node;\n+      });\n+\n+      expect(paths).toContainEqual(['properties', 'nested', 'properties', 'ref']);\n+    });\n+\n+    it('should track full traversal path', () => {\n+      const schema = { $ref: '#/$defs/MyDef' } as const satisfies Schema.Ref;\n+      const paths: string[] = [];\n+\n+      map(schema, (node, context) => {\n+        paths.push(context.path.join('.') || 'root');\n+        return node;\n+      });\n+\n+      expect(paths).toEqual(['root']);\n+    });\n+  });\n+\n+  describe('Concatenation (allOf)', () => {\n+    it('should map over allOf schemas', () => {\n+      const schema = {\n+        allOf: [\n+          { type: 'object', properties: { foo: { type: 'string' } } },\n+          { type: 'object', properties: { bar: { type: 'number' } } },\n+        ],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const result = map(schema, node => {\n+        if (isObject(node)) {\n+          return { ...node, additionalProperties: false };\n+        }\n+        return node;\n+      });\n+\n+      expect(isConcatenation(result)).toBe(true);\n+      if (isConcatenation(result)) {\n+        expect(result.allOf[0]).toHaveProperty('additionalProperties', false);\n+        expect(result.allOf[1]).toHaveProperty('additionalProperties', false);\n+      }\n+    });\n+\n+    it('should provide correct path for allOf items', () => {\n+      const schema = {\n+        allOf: [{ type: 'object' }, { type: 'object' }],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const paths: (string | number)[][] = [];\n+      map(schema, (node, context) => {\n+        paths.push([...context.path]);\n+        return node;\n+      });\n+\n+      expect(paths).toContainEqual(['allOf', 0]);\n+      expect(paths).toContainEqual(['allOf', 1]);\n+    });\n+\n+    it('should handle empty allOf array', () => {\n+      const schema = {\n+        allOf: [],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const result = map(schema, node => node);\n+      expect(isConcatenation(result)).toBe(true);\n+      if (isConcatenation(result)) {\n+        expect(result.allOf).toEqual([]);\n+      }\n+    });\n+\n+    it('should handle nested allOf', () => {\n+      const schema = {\n+        allOf: [\n+          { type: 'object', properties: { a: { type: 'string' } } },\n+          {\n+            allOf: [\n+              { type: 'object', properties: { b: { type: 'number' } } },\n+              { type: 'object', properties: { c: { type: 'boolean' } } },\n+            ],\n+          },\n+        ],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const paths: (string | number)[][] = [];\n+      map(schema, (node, context) => {\n+        paths.push([...context.path]);\n+        return node;\n+      });\n+\n+      expect(paths).toContainEqual(['allOf', 0]);\n+      expect(paths).toContainEqual(['allOf', 1]);\n+      expect(paths).toContainEqual(['allOf', 1, 'allOf', 0]);\n+      expect(paths).toContainEqual(['allOf', 1, 'allOf', 1]);\n+    });\n+\n+    it('should track full traversal path', () => {\n+      const schema = {\n+        allOf: [\n+          { type: 'object', properties: { foo: { type: 'string' } } },\n+          { type: 'object', properties: { bar: { type: 'number' } } },\n+        ],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const paths: string[] = [];\n+      map(schema, (node, context) => {\n+        paths.push(context.path.join('.') || 'root');\n+        return node;\n+      });\n+\n+      expect(paths).toEqual([\n+        'allOf.0.properties.foo',\n+        'allOf.0',\n+        'allOf.1.properties.bar',\n+        'allOf.1',\n+        'root',\n+      ]);\n+    });\n+\n+    it('should recursively traverse nested properties in allOf items (Schema.Partial)', () => {\n+      // Real use case: merging constraints from multiple partial schemas\n+      // This validates an object that must satisfy all constraints\n+      const schema = {\n+        allOf: [\n+          {\n+            type: 'object',\n+            // First constraint: must have name property\n+            properties: {\n+              name: { type: 'string' },\n+            },\n+            required: ['name'],\n+          },\n+          {\n+            type: 'object',\n+            // Second constraint: must have age property\n+            properties: {\n+              age: { type: 'number' },\n+            },\n+            required: ['age'],\n+          },\n+          {\n+            type: 'object',\n+            // Third constraint: nested validation rules\n+            properties: {\n+              address: {\n+                type: 'object',\n+                properties: {\n+                  city: { type: 'string' },\n+                  zip: { type: 'string' },\n+                },\n+              },\n+            },\n+          },\n+        ],\n+      } as const satisfies Schema.Concatenation;\n+\n+      const paths: string[] = [];\n+      map(schema, (node, context) => {\n+        if (isString(node) || isNumber(node)) {\n+          paths.push(context.path.join('.'));\n+        }\n+        return node;\n+      });\n+\n+      expect(paths).toContain('allOf.0.properties.name');\n+      expect(paths).toContain('allOf.1.properties.age');\n+      expect(paths).toContain('allOf.2.properties.address.properties.city');\n+      expect(paths).toContain('allOf.2.properties.address.properties.zip');\n+    });\n+  });\n+\n+  describe('Union (anyOf/oneOf)', () => {\n+    describe('anyOf', () => {\n+      it('should map over anyOf schemas', () => {\n+        const schema = {\n+          anyOf: [{ type: 'string' }, { type: 'number' }],\n+        } as const satisfies Schema.Union;\n+\n+        const result = map(schema, node => {\n+          if (isString(node)) {\n+            return { ...node, minLength: 1 };\n+          }\n+          return node;\n+        });\n+\n+        expect(isAnyOfUnion(result)).toBe(true);\n+        if (isAnyOfUnion(result)) {\n+          expect(result.anyOf[0]).toEqual({ type: 'string', minLength: 1 });\n+          expect(result.anyOf[1]).toEqual({ type: 'number' });\n+        }\n+      });\n+\n+      it('should provide correct path for anyOf items', () => {\n+        const schema = {\n+          anyOf: [{ type: 'string' }, { type: 'number' }],\n+        } as const satisfies Schema.Union;\n+\n+        const paths: (string | number)[][] = [];\n+        map(schema, (node, context) => {\n+          paths.push([...context.path]);\n+          return node;\n+        });\n+\n+        expect(paths).toContainEqual(['anyOf', 0]);\n+        expect(paths).toContainEqual(['anyOf', 1]);\n+      });\n+\n+      it('should handle empty anyOf array', () => {\n+        const schema = {\n+          anyOf: [],\n+        } as const satisfies Schema.Union;\n+\n+        const result = map(schema, node => node);\n+        expect(isAnyOfUnion(result)).toBe(true);\n+        if (isAnyOfUnion(result)) {\n+          expect(result.anyOf).toEqual([]);\n+        }\n+      });\n+\n+      it('should recursively traverse nested properties in anyOf items (Schema.Partial)', () => {\n+        // Real use case: polymorphic validation where object can match any alternative\n+        const schema = {\n+          anyOf: [\n+            {\n+              type: 'object',\n+              // Option 1: User with email\n+              properties: {\n+                email: { type: 'string' },\n+                verified: { type: 'boolean' },\n+              },\n+              required: ['email'],\n+            },\n+            {\n+              type: 'object',\n+              // Option 2: User with phone\n+              properties: {\n+                phone: { type: 'string' },\n+                countryCode: { type: 'string' },\n+              },\n+              required: ['phone'],\n+            },\n+          ],\n+        } as const satisfies Schema.Union;\n+\n+        const paths: string[] = [];\n+        map(schema, (node, context) => {\n+          if (isString(node) || isBoolean(node)) {\n+            paths.push(context.path.join('.'));\n+          }\n+          return node;\n+        });\n+\n+        expect(paths).toContain('anyOf.0.properties.email');",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567093837",
      "id": 2567093837,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "Это путь весь выдается, но визитор только на Schema.Definition вызывается.",
      "created_at": "2025-11-27T09:46:57Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567828975",
      "id": 2567828975,
      "in_reply_to_id": 2567093837,
      "user": "akoppela"
    },
    {
      "body": "хочется иметь возможность посмотреть на путь с точки зрения финального джейсона, в котором уже нет allOf.1 и прочих .properties, а есть только user.role.name например",
      "created_at": "2025-11-27T09:49:55Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567838379",
      "id": 2567838379,
      "in_reply_to_id": 2567093837,
      "user": "Inviz"
    },
    {
      "body": "Тут нужно пояснения, я не совсем понимаю",
      "created_at": "2025-11-27T09:51:06Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567842403",
      "id": 2567842403,
      "in_reply_to_id": 2567093837,
      "user": "akoppela"
    },
    {
      "body": "Ну представь что у тебя есть схема данных. Например описаывает пост с автором. Ты хочешь например убрать свойство `password` из `post.user`. По идее просто делаешь фильтр что `path != \"post.properties.user.properties.password\"`. \r\n\r\nНо что если схема у юзера а-ля `allOf: [Person, Authenticable]`? Тогда путь то ли `post.properties.user.properties.allOf[0].password` то ли `post.properties.user.properties.allOf[1].password` то ли и то и то.\r\n\r\nХотя  путь к `password` в обьекте соответствующим схеме будет  `\"post.user.password\"` во всех трех случаях.\r\n\r\nЕсли у сегментов в контексте будет свойство а-ля `isPresentInData` которое будет возвращать false на сегменты а-ля `allOf`, `allOf.1`, `properties`, `items` - так чтобы можно было отфильтровать эти сегменты и восстановить некий `dataPath` а-ля `post.user.password` \r\n\r\nПотому что мы позволяем взять какую то схему и усложнить её, обернув что-то в oneOf/allOf, код который как-то мапит-фильтрует данные перестает работать тогда, если структура схемы меняется от усложнения. Имея возможность оперировать неким `dataPath` мы можем более гибко фильтровать схемы с точки зрения данных",
      "created_at": "2025-11-27T10:24:42Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567951871",
      "id": 2567951871,
      "in_reply_to_id": 2567093837,
      "user": "Inviz"
    },
    {
      "body": "У нас контекст передается в котором полный path есть. С ним дальше что угодно можно делать. Password выпиливается через omitProperties. Path - это список строк и чисел. Можно написать функцию, которая этот массив берет и возвращает реальный путь к полю.\r\n\r\nдумаешь это должно быть частью мапа? Я думаю должно быть внешняя хелпкр функция. ",
      "created_at": "2025-11-27T11:51:07Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2568286326",
      "id": 2568286326,
      "in_reply_to_id": 2567093837,
      "user": "akoppela"
    }
  ],
  [
    {
      "body": "это тут было для проверки того что это работает и тип выводится и кешируется, но видимо не допинал асерты",
      "created_at": "2025-11-27T03:51:30Z",
      "diff_hunk": "@@ -76,26 +76,6 @@ describe('Integration', () => {\n       )\n     );\n \n-    const T = S.compute(",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567095241",
      "id": 2567095241,
      "in_reply_to_id": null,
      "user": "Inviz"
    },
    {
      "body": "S.compute выводит тип с FromSchema и сохраняет его на обьекте, так что потом этот вывдеенный тип может быстро скомпозится в другие более вложенные типы. Это обход ограничений тайпскрипта на глубину рекурсии",
      "created_at": "2025-11-27T03:52:44Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567096768",
      "id": 2567096768,
      "in_reply_to_id": 2567095241,
      "user": "Inviz"
    },
    {
      "body": "Тут TS ругался, что но не используется",
      "created_at": "2025-11-27T03:58:50Z",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567103506",
      "id": 2567103506,
      "in_reply_to_id": 2567095241,
      "user": "akoppela"
    }
  ],
  [
    {
      "body": "если бы это был я, то бы не заморачивался и просто сделал бы != null, но я думаю ты верно сделал",
      "created_at": "2025-11-27T10:34:19Z",
      "diff_hunk": "@@ -118,137 +121,172 @@ export function isNot(schema?: Schema.Composite.Definition | undefined): schema\n   return 'not' in schema;\n }\n \n-// Guards for common schema fields\n-export function hasConst(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { const: unknown } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'const' in schema;\n-}\n-\n-export function hasDefs(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { $defs: Record<string, Schema.Definition> } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return '$defs' in schema;\n-}\n-\n-// Guards for object schema fields\n-export function hasProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { properties: Record<string, Schema.Definition> } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'properties' in schema;\n-}\n-\n-export function hasPatternProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { patternProperties: Record<string, Schema.Definition> } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'patternProperties' in schema;\n-}\n-\n-export function hasAdditionalProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { additionalProperties: Schema.Definition } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'additionalProperties' in schema;\n-}\n+// PROPERTY GUARDS\n \n-export function hasPropertyNames(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { propertyNames: Schema.CouldBePartial } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'propertyNames' in schema;\n-}\n-\n-export function hasUnevaluatedProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { unevaluatedProperties: Schema.Definition } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'unevaluatedProperties' in schema;\n+/**\n+ * Helper to validate that a value is a non-null object\n+ */\n+function isNonNullObject(value: unknown): value is Record<string, unknown> {\n+  return typeof value === 'object' && value !== null && !Array.isArray(value);\n }\n \n-export function hasDependencies(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & {\n-  dependencies: Record<string, Schema.CouldBePartial | readonly string[]>;\n-} {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'dependencies' in schema;\n-}\n-\n-export function hasDependentSchemas(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { dependentSchemas: Record<string, Schema.CouldBePartial> } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'dependentSchemas' in schema;\n+/**\n+ * Helper to validate a Record where all values are schemas\n+ */\n+function isRecordOfSchemas(value: unknown): boolean {\n+  if (!isNonNullObject(value)) return false;\n+  return Object.values(value).every(v => isValid(v));\n }\n \n-export function hasDependentRequired(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { dependentRequired: Record<string, readonly string[]> } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'dependentRequired' in schema;\n-}\n-\n-export function hasRequired(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { required: readonly string[] } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'required' in schema && Array.isArray(schema.required);\n-}\n-\n-export function hasPropertyOrdering(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { propertyOrdering: readonly string[] } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'propertyOrdering' in schema && Array.isArray(schema.propertyOrdering);\n-}\n-\n-export function hasMinProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { minProperties: number } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'minProperties' in schema && typeof schema.minProperties === 'number';\n-}\n-\n-export function hasMaxProperties(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { maxProperties: number } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'maxProperties' in schema && typeof schema.maxProperties === 'number';\n-}\n-\n-// Guards for array schema fields\n-export function hasAdditionalItems(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { additionalItems: Schema.Definition } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'additionalItems' in schema;\n-}\n-\n-export function hasContains(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema & { contains: Schema.Definition } {\n-  if (!schema || typeof schema !== 'object') return false;\n-  return 'contains' in schema;\n-}\n-\n-// Guards for conditional schemas - specific fields\n-export function hasThen(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Conditional & { then: Schema.CouldBePartial } {\n-  if (!isConditional(schema)) return false;\n-  return 'then' in schema;\n+/**\n+ * Helper to validate a Record where all values are either schemas or string arrays\n+ */\n+function isRecordOfSchemasOrStringArrays(value: unknown): boolean {\n+  if (!isNonNullObject(value)) return false;\n+  return Object.values(value).every(\n+    v => isValid(v) || (Array.isArray(v) && v.every(i => typeof i === 'string'))\n+  );\n }\n \n-export function hasElse(\n-  schema?: Schema.Composite.Definition | undefined\n-): schema is Schema.Conditional & { else: Schema.CouldBePartial } {\n-  if (!isConditional(schema)) return false;\n-  return 'else' in schema;\n-}\n+/**\n+ * Helper to validate a Record where all values are string arrays\n+ */\n+function isRecordOfStringArrays(value: unknown): boolean {\n+  if (!isNonNullObject(value)) return false;\n+  return Object.values(value).every(v => Array.isArray(v) && v.every(i => typeof i === 'string'));\n+}\n+\n+/**\n+ * Helper to validate an array where all items are schemas\n+ */\n+function isArrayOfSchemas(value: unknown): boolean {\n+  if (!Array.isArray(value)) return false;\n+  return value.every(v => isValid(v));\n+}\n+\n+/**\n+ * Helper to validate an array where all items are strings\n+ */\n+function isArrayOfStrings(value: unknown): boolean {\n+  if (!Array.isArray(value)) return false;\n+  return value.every(v => typeof v === 'string');\n+}\n+\n+/**\n+ * Runtime type validators for schema property values\n+ * TypeScript will error if any keys of Schema.Composite are missing from this Record\n+ */\n+const propertyTypeValidators: Record<keyof Schema.Composite, (value: unknown) => boolean> = {\n+  // Shared\n+  type: (value: unknown) => typeof value === 'string' || isArrayOfStrings(value),\n+  $defs: (value: unknown) => isRecordOfSchemas(value),\n+  $id: (value: unknown) => typeof value === 'string',\n+  $schema: (value: unknown) => typeof value === 'string',\n+  $comment: (value: unknown) => typeof value === 'string',\n+  $anchor: (value: unknown) => typeof value === 'string',\n+  $ref: (value: unknown) => typeof value === 'string',\n+  title: (value: unknown) => typeof value === 'string',\n+  description: (value: unknown) => typeof value === 'string',\n+  default: () => true,\n+  readOnly: (value: unknown) => typeof value === 'boolean',\n+  writeOnly: (value: unknown) => typeof value === 'boolean',\n+  examples: (value: unknown) => Array.isArray(value),\n+  nullable: (value: unknown) => typeof value === 'boolean',\n+  const: () => true,\n+  format: (value: unknown) => typeof value === 'string',\n+  contentMediaType: (value: unknown) => typeof value === 'string',\n+  contentEncoding: (value: unknown) => typeof value === 'string',\n+  allOf: (value: unknown) => isArrayOfSchemas(value),\n+  anyOf: (value: unknown) => isArrayOfSchemas(value),\n+  oneOf: (value: unknown) => isArrayOfSchemas(value),\n+  if: (value: unknown) => isValid(value),\n+  then: (value: unknown) => isValid(value),\n+  else: (value: unknown) => isValid(value),\n+  not: (value: unknown) => isValid(value),\n+\n+  // Object schema\n+  properties: (value: unknown) => isRecordOfSchemas(value),\n+  additionalProperties: (value: unknown) => isValid(value),\n+  required: (value: unknown) => isArrayOfStrings(value),\n+  patternProperties: (value: unknown) => isRecordOfSchemas(value),\n+  propertyNames: (value: unknown) => isValid(value),\n+  maxProperties: (value: unknown) => typeof value === 'number',\n+  minProperties: (value: unknown) => typeof value === 'number',\n+  dependencies: (value: unknown) => isRecordOfSchemasOrStringArrays(value),\n+  unevaluatedProperties: (value: unknown) => isValid(value),\n+  dependentSchemas: (value: unknown) => isRecordOfSchemas(value),\n+  dependentRequired: (value: unknown) => isRecordOfStringArrays(value),\n+  propertyOrdering: (value: unknown) => isArrayOfStrings(value),\n+\n+  // Array schema\n+  items: (value: unknown) => isValid(value) || isArrayOfSchemas(value),\n+  additionalItems: (value: unknown) => isValid(value),\n+  contains: (value: unknown) => isValid(value),\n+  maxItems: (value: unknown) => typeof value === 'number',\n+  minItems: (value: unknown) => typeof value === 'number',\n+  uniqueItems: (value: unknown) => typeof value === 'boolean',\n+\n+  // String schema\n+  maxLength: (value: unknown) => typeof value === 'number',\n+  minLength: (value: unknown) => typeof value === 'number',\n+  pattern: (value: unknown) => typeof value === 'string',\n+\n+  // Numeric schema\n+  multipleOf: (value: unknown) => typeof value === 'number',\n+  maximum: (value: unknown) => typeof value === 'number',\n+  exclusiveMaximum: (value: unknown) => typeof value === 'number',\n+  minimum: (value: unknown) => typeof value === 'number',\n+  exclusiveMinimum: (value: unknown) => typeof value === 'number',\n+  enum: (value: unknown) => Array.isArray(value),\n+\n+  // Extended properties\n+  [$JSONSchema]: () => true,\n+  definitions: (value: unknown) => isRecordOfSchemas(value),\n+  discriminator: (value: unknown) => {\n+    if (!isNonNullObject(value)) return false;\n+    if (!('propertyName' in value) || typeof value.propertyName !== 'string') return false;\n+    if ('mapping' in value) {\n+      return (\n+        isNonNullObject(value.mapping) &&\n+        Object.values(value.mapping).every(v => typeof v === 'string')\n+      );\n+    }\n+    return true;\n+  },\n+  discriminated: (value: unknown) => {\n+    if (!isNonNullObject(value)) return false;\n+    return Object.values(value).every(v => {\n+      if (!isNonNullObject(v)) return false;\n+      if ('title' in v && typeof v.title !== 'string') return false;\n+      if ('description' in v && typeof v.description !== 'string') return false;\n+      return true;\n+    });\n+  },\n+  ui: () => true,\n+  prompt: (value: unknown) => typeof value === 'string',\n+  help: (value: unknown) => typeof value === 'string',\n+  example: (value: unknown) => typeof value === 'string',\n+};\n+\n+/**\n+ * Generic property checker that narrows schema type based on presence of a property.\n+ * Also validates the runtime type of the property value.\n+ * @param schema - The schema to check\n+ * @param property - The property key to check for\n+ * @returns Type predicate narrowing to Schema.Definition with the specified property\n+ */\n+export function has<T extends keyof Schema.Composite>(\n+  schema: Schema.Composite.Definition | undefined,\n+  property: T\n+): schema is Schema.Definition & Pick<Required<Schema.Composite>, T> {\n+  if (!schema || typeof schema !== 'object') return false;\n+  if (!(property in schema)) return false;\n+\n+  // Validate the property type using the validator\n+  return propertyTypeValidators[property](schema[property]);",
      "html_url": "https://github.com/idealic-ai/platform/pull/60#discussion_r2567985004",
      "id": 2567985004,
      "in_reply_to_id": null,
      "user": "Inviz"
    }
  ]
]
