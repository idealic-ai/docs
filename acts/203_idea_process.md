# 203: Idea/Process

> [!DEFINITION] [Process Idea](./000_glossary.md)
> A self-contained [Idea](./101_concept_idea.md) that captures a strategic [Plan](./010_agent_plan.md) and its live execution state. Its `schema` is the library of [Tools](./002_agent_tool.md), its `solution` is the _new_ `Plan` for the current tick, and its `context` contains the `Input`, `State`, and the previous `Plan`.

> Sidenote:
>
> - Requires:
>   - [101: Concept/Idea](./101_concept_idea.md)
>   - [010: Agent/Plan](./010_agent_plan.md)
>   - [009: Agent/State](./009_agent_state.md)
>   - [007: Agent/Input](./007_agent_input.md)
> - Complemented by:
>   - [011: Agent/Instancing](./011_agent_instancing.md)

Where a [202: Idea/Vessel](./202_idea_vessel.md) captures a single, reactive decision, a **Process Idea** embodies a proactive and strategic workflow. It is the artifact generated by the [010: Agent/Plan](./010_agent_plan.md) system as it orchestrates a complex, multi-step task over time. This makes it a complete record of both the capabilities available to the workflow and the specific strategy chosen by the agent.

## The Anatomy of a Plan

A `Process Idea` uses the `Idea` triplet to provide a complete snapshot of a workflow. This snapshot contains not only the agent's chosen strategy (the `Plan`) but also the full library of capabilities and the live state of the execution.

- **`schema` (The Palette):** Defines the library of all available [Tools](./002_agent_tool.md) from which a `Plan` can be constructed. It represents the agent's full set of capabilities.

- **`context` (Situational Awareness):** This holds all the information necessary for the agent to plan and execute the current tick.
  - **Input Message:** The initial stimulus that kicked off the entire process. This is typically provided only once and remains constant.

    > Sidenote:
    >
    > - [007: Agent/Input](./007_agent_input.md)

  - **State Message:** The live, evolving data for the workflow. It contains the persisted local variables that form the connections (edges) between the `Calls` in the `Plan`.

    > Sidenote:
    >
    > - [009: Agent/State](./009_agent_state.md)

  - **Plan Message:** This message contains the _commited_ plan from the previous tick, which the agent can choose to follow or readjust.

    > Sidenote:
    >
    > - [010: Agent/Plan](./010_agent_plan.md)

- **`solution` (The New Plan):** The directed acyclic graph of `Calls` that is the agent's chosen strategy for the _current_ tick. This becomes the `Plan Message` for the next tick.

### The Unity of Planning and Execution

A core principle of this architecture is the fusion of planning and execution into a single, unified process. Unlike traditional systems that separate these phases, here they happen concurrently within each tick. The agent doesn't just create a static plan and then separately execute it; the very act of generating the next `solution` (the new `Plan`) _is_ the execution step for the current tick.

This unity is what makes the system so dynamic and efficient. The `Plan` is a living graph that doesn't need to be complete to be useful. It can be partial, operate on the results of the previous tick, and adapt on the fly. The `Calls` generated by the LLM represent both the structure of the pipeline and the messages flowing within it. This duality allows a single LLM request to simultaneously validate the current state, adjust the plan based on new data, and execute the next logical step. There is no costly overhead for separate re-planning or validation calls; execution _is_ validation, planning, and adjustment, all happening at once.

> Sidenote:
>
> - [004: Agent/Call](./004_agent_call.md)

This unified model provides two powerful advantages. First, a `Plan` can be established and simulated based on its schemas alone, even before concrete data is available. The LLM can "role-play" the behavior of each step, allowing for the design and validation of complex workflows from day one. Second, the LLM acts as an intelligent adapter between steps. If the output of one `Call` doesn't perfectly match the expected input of the next, the LLM can bridge the gap, providing extraordinary stability as the system evolves. This resilience prevents the cascading failures that plague traditional, rigidly-connected systems.

> Sidenote:
>
> - [105: Concept/AI-Native](./105_concept_ai_native.md)

### The Flexibility Spectrum of a Plan

The `State` object enables a powerful, three-stage lifecycle for a `Plan`, allowing it to evolve from a flexible discovery process into a predictable, deterministic workflow:

> Sidenote:
>
> - [009: Agent/State](./009_agent_state.md)

1.  **Freeform Plan:** Initially, the `State` can be defined without a `schema`. This gives the agent maximum freedom to discover a `Plan` by creating new connections (properties in the `State` object) on the fly.

2.  **Specified Connections:** The next step in hardening a `Plan` is to freeze the `State`'s `schema`, which specifies the primary data pathways. This can be done on a spectrum from more to less flexible:
    - **Open Connections:** The schema can allow `additionalProperties`, which enforces the core data pathways while still giving the agent the freedom to create new connections for minor or exceptional paths.
    - **Closed Connections:** The schema can set `additionalProperties` to `false`, creating a rigid structure that the agent must follow precisely.

3.  **Resolved Plan:** This is the final stage, where a plan is considered fully mature and predictable. A `Resolved Plan` becomes the **Committed Plan** that is passed as the `Plan Message` in the `context` for subsequent ticks. A resolved plan can exist in two forms of stability:
    - **Happy Plan:** A resolved plan that covers the ideal case. It provides a highly efficient path but may still require adjustment if unexpected events occur.
    - **Complete Plan:** A fully resolved plan that has been expanded over time to account for common failures, alternatives, and other scenarios, making it highly deterministic.

This progression allows a `Process Idea` to evolve from a fluid design into a highly reliable and reusable asset.

## Immutable Workflows: Orchestration, Analysis, and Scaling

The power of a `Process Idea` comes from its immutability. Each step in a workflow generates a new, complete snapshot of the `Plan` and `State`, preserving a perfect, auditable history. This core principle of creating a chain of immutable artifacts is what enables the system's most advanced capabilities for orchestration, analysis, and scaling.

- **Reliable, Adaptive Execution:** The "tick-based" execution loop is fundamentally reliable because each new tick operates on a complete snapshot of the previous state. This atomicity prevents race conditions and ensures that the agent's decision to follow or readjust the `Plan` is based on a consistent and predictable world-view. The result of each tick is a new `Process Idea`, safely advancing the workflow one step at a time.

  > Sidenote:
  >
  > - [005: Agent/Loop](./005_agent_loop.md)
  > - [010: Agent/Plan](./010_agent_plan.md)

- **Resilient Orchestration:** A `Process Idea` is a self-contained artifact, which makes orchestration incredibly robust. A workflow can be paused simply by persisting its latest snapshot. External systems—or human supervisors—can then inspect this frozen state to make decisions. Any adjustments, such as replanning or state modification, result in the creation of a _new_ `Process Idea`, which can then be used to safely resume the workflow without altering the historical record.

  > Sidenote:
  >
  > - [009: Agent/State](./009_agent_state.md)

- **High-Fidelity Simulation:** This architecture is the prerequisite for interactive time travel. Every historical `Process Idea` is a perfect, high-fidelity snapshot of the workflow at a specific moment. This allows users or other agents to load any point in the process's history to perform audits, debug complex behavior, or run "what-if" scenarios by forking the process from that point.

  > Sidenote:
  >
  > - [202: Idea/Vessel](./202_idea_vessel.md)

- **Consistent Parallel Processing:** The snapshot-based architecture achieves massive scale through the Instancing protocol. This pattern treats each task in a batch as an independent execution thread, each with its own isolated `State` snapshot. A single `Plan` acts as a strategic template applied to all threads simultaneously. In one atomic tick, the agent performs parallel planning for the entire batch, generating a coherent set of `Calls` tailored to each instance. This guarantees a consistent outcome across diverse tasks while dramatically increasing efficiency.

  > Sidenote:
  >
  > - [011: Agent/Instancing](./011_agent_instancing.md)

## From a Predictable Plan to Guided Execution

A `Process Idea` can mature into a **Resolved Plan**—a highly predictable and reliable workflow. While this rigidity provides stability, it can also limit flexibility. The system needs a way to introduce nuanced, context-specific guidance without sacrificing the integrity of the established plan.

This is the role of an **[Instruction Idea](./204_idea_instruction.md)**. An `Instruction` is a structured recipe for action that provides a higher level of strategic guidance. It acts as a "mental checklist" or a set of principles that influences the workflow at two levels: guiding the agent in selecting or generating the most appropriate `Plan` for a given context, and providing targeted guidance for individual choices and reasoning steps during the execution of that `Plan`. In essence, an `Instruction` enhances the _logic_ and _reasoning_ of a workflow, ensuring that both the overall strategy and the tactical execution align with a desired methodology.

> Sidenote:
>
> - [204: Idea/Instruction](./204_idea_instruction.md)
