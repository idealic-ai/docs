<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/docs/assets/static/src_assets_tufte-2d3b6576.BrVfN5Rs.css">
        <meta charset="UTF-8" />
        
    <title>My Vike App</title><meta property="og:title" content="My Vike App" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="/docs/assets/static/logo.DLJJsk-H.svg"/>
    
    <meta name="description" content="Demo showcasing Vike" /><meta property="og:description" content="Demo showcasing Vike" />
    
  
      </head>
      <body>
        
        <div id="root"><div><nav><div><strong><a href="/docs/manifesto/">Manifesto</a></strong>: <span><a href="/docs/manifesto/01_call.md">Call</a> | </span><span><a href="/docs/manifesto/02_inner_journey.md">Inner Journey</a> | </span><span><a href="/docs/manifesto/03_outer_work.md">Outer Work</a></span></div><div><strong><a href="/docs/rfc/">RFCs</a></strong></div><div><strong><a href="/docs/blueprint/">Blueprint</a></strong></div></nav><main><article><section><h3>Detailed Example: Evolving Record Vibe Schemas</h3>
<p>The &quot;schema refinement principle&quot; discussed during bootstrapping—making schemas more specific—isn&#39;t limited to the initial setup of the system. It&#39;s a fundamental aspect of how the system adapts and evolves. Just as Capabilities can authorize changes <em>to the data</em> within a Record Vibe&#39;s <code>solution</code>, they can also authorize changes <em>to the very structure</em> defined in a Record Vibe&#39;s own <code>schema</code> field. This is achieved by <code>Refine</code>ing a Record Vibe with an <code>instruction</code> Vibe, whose <code>solution</code> defines the evolution of the target Vibe. This process results in a new Record Vibe with an evolved <code>schema</code> field and a <code>solution</code> conforming to this new structure. This allows for controlled evolution of data structures as business needs change, aligning with the content-first philosophy where interactions with content drive its transformation.</p>
<p>Consider the scenario of evolving a simple promotional website into a full-fledged e-commerce platform.</p>
<p><strong>Initial State:</strong>
The company initially has Record Vibes for its products, such as <code>aug:products/superwidget?1</code> (where <code>?1</code> means revision). These Vibes conform to the structure defined in an exemplar Vibe, say <code>aug:products/example?1</code> (representing a basic product structure).</p>
<ul>
<li>The <code>schema</code> field of <code>aug:products/example?1</code> (and thus of <code>aug:products/superwidget?1</code>) holds the JSON Schema definition for this initial basic product structure.</li>
<li>The <code>solution</code> field of <code>aug:products/example?1</code> contains placeholder/example data for a basic product.</li>
</ul>
<p>This initial structure (<code>aug:products/example?1#schema</code>) might look like this:</p>
<pre><code class="language-json">// Content of the `schema` field for `aug:products/example?1` and its derivatives
{
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; }
  },
  &quot;required&quot;: [&quot;productName&quot;, &quot;description&quot;]
}
</code></pre>
<p><strong>The Business Goal &amp; Required Schema Change:</strong>
As the business decides to launch a full online shop, a critical new requirement emerges: tracking inventory and price. This necessitates evolving product Record Vibes to include <code>stockLevel</code> and <code>price</code> fields, meaning the JSON Schema definition in their <code>schema</code> field must change.</p>
<p><strong>The <code>Refine</code> Operation: Evolving the Vibe&#39;s Schema and Solution</strong>
To implement this, a <code>Refine</code> operation targets the existing <code>aug:products/superwidget?1</code> (let&#39;s consider its initial state to be <code>aug:products/superwidget?1</code>):</p>
<ul>
<li><strong><code>target</code></strong>: <code>aug:products/superwidget?1</code>.</li>
<li><strong><code>instruction</code></strong>: An <code>aug:migrations/evolve-to-shop-item?1</code> Vibe. The <code>solution</code> of this instruction Vibe is crucial; it specifies how to modify the JSON Schema definition found in the target Vibe&#39;s <code>schema</code> field, and how the target&#39;s <code>solution</code> (data) should adapt:<pre><code class="language-json">// Example: Content of aug:migrations/evolve-to-shop-item?1\&#39;s solution
// The format does not matter
{
  &quot;schemaModifications&quot;: {
    &quot;addProperties&quot;: {
      &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0, &quot;description&quot;: &quot;Current available stock&quot; },
      &quot;price&quot;: { &quot;type&quot;: &quot;number&quot;, &quot;format&quot;: &quot;currency&quot;, &quot;description&quot;: &quot;Retail price&quot; }
    },
    &quot;addToRequired&quot;: [&quot;stockLevel&quot;, &quot;price&quot;]
  },
  &quot;solutionUpdate&quot;: {
    &quot;stockLevel&quot;: 0, // Initialize new stockLevel field in the solution
    &quot;price&quot;: &quot;0.00&quot; // Initialize new price field in the solution
  }
}
</code></pre>
</li>
<li><strong><code>capability</code></strong>: A Capability held by a role like &quot;System Architect,&quot; authorizing the refinement of basic products to shop-ready products.</li>
</ul>
<p>The <code>Refine</code> call would effectively be:</p>
<p><code>aug:products/superwidget?2 = Refine(aug:products/superwidget?1, aug:migrations/evolve-to-shop-item?1, aug:capability-architect-master?1)</code></p>
<p>This operation results in a new revision of the same conceptual Vibe (<code>aug:products/superwidget?1</code>) because the <code>migrations/evolve-to-shop-item?1</code> leads to a schema that is a compatible refinement (more specific version) of the original. This means that any system or process that was designed to understand the basic product structure can still understand this new, evolved structure; it would simply ignore the new <code>stockLevel</code> and <code>price</code> fields if it wasn&#39;t programmed to use them. The system&#39;s ledger records this as the next revision for <code>aug:products/superwidget?1</code>. Had the schema change been fundamentally incompatible, it would typically result in a Vibe with a new distinct identity.</p>
<p>The result is a <strong>new revision</strong> of the Vibe, now identifiable as <code>aug:products/superwidget?2</code> (the system manages actual versioning internally, this notation is for example clarity). This new revision <em>is</em> the shop-ready version:</p>
<ul>
<li>Its <code>schema</code> field now contains the new, evolved JSON Schema definition (the &quot;Shop Product Structure&quot;):<pre><code class="language-json">// Content of the `schema` field for aug:products/superwidget?2
{
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; },
    &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0, &quot;description&quot;: &quot;Current available stock&quot; },
    &quot;price&quot;: { &quot;type&quot;: &quot;number&quot;, &quot;format&quot;: &quot;currency&quot;, &quot;description&quot;: &quot;Retail price&quot; }
  },
  &quot;required&quot;: [&quot;productName&quot;, &quot;description&quot;, &quot;stockLevel&quot;, &quot;price&quot;]
}
</code></pre>
</li>
<li>Its <code>solution</code> field now contains the original data plus the newly initialized <code>stockLevel</code> and <code>price</code> fields, conforming to this new &quot;Shop Product Structure&quot;:<pre><code class="language-json">// aug:products/superwidget?2#solution
{
  &quot;productName&quot;: &quot;Super Widget&quot;,
  &quot;description&quot;: &quot;The best widget for your needs.&quot;,
  &quot;promoImage&quot;: &quot;http://example.com/superwidget.png&quot;,
  &quot;stockLevel&quot;: 0,
  &quot;price&quot;: &quot;0.00&quot;
}
</code></pre>
The original <code>aug:products/superwidget?1</code> remains untouched in the ledger. Other existing basic product Vibes (like <code>aug:products/anotheritem?1</code>) would undergo similar <code>Refine</code> operations to evolve them into their respective shop-ready iterations (e.g., <code>aug:products/anotheritem?2</code>).</li>
</ul>
<p><strong>Subsequent Data Updates under the Evolved Schema:</strong>
With <code>aug:products/superwidget?2</code> now having the &quot;Shop Product Structure&quot; in its <code>schema</code> field, an &quot;Inventory Manager&quot; can be granted capabilities to update its <code>solution</code>.</p>
<ul>
<li><strong><code>target</code></strong>: <code>aug:products/superwidget?2</code>.</li>
<li><strong><code>instruction</code></strong>: An <code>aug:updates/update-stock?1</code> Vibe, whose <code>solution</code> specifies <code>{ &quot;stockLevel&quot;: 150 }</code>.</li>
<li><strong><code>capability</code></strong>: A Capability held by the &quot;Inventory Manager.&quot;</li>
</ul>
<p>The <code>Refine</code> call:
<code>aug:products/superwidget?3 = Refine(aug:products/superwidget?2, aug:updates/update-stock?1, aug:capability-inventory-mgr?1)</code></p>
<p>This produces <code>aug:products/superwidget?3</code>, a new revision of the product Vibe with the updated stock count in its <code>solution</code>. Its <code>schema</code> field remains the &quot;Shop Product Structure&quot; (as defined in <code>aug:products/superwidget?2</code>).</p>
<h3>Advanced Schema Evolution: Migrating to a New Schema Version</h3>
<p>The previous example showed additive schema refinement. However, when a more fundamental &quot;breaking&quot; change is needed (e.g., renaming a field, significantly altering its type, or removing it entirely), a robust strategy is to migrate product instances to conform to a new schema version. This aligns with the content-first principle: the new schema isn&#39;t an independent, abstract Vibe but is defined directly within the <code>schema</code> field of the new product Vibe instances.</p>
<p>The core idea is to use an old product Vibe&#39;s data (as an <code>instruction</code>) to populate and finalize a new product Vibe (<code>target</code>) that is already structured according to the new schema version and represents the specific entity being migrated.</p>
<p><strong>Scenario: Introducing <code>priceInCents</code> and removing <code>price</code></strong></p>
<p>Let&#39;s say our existing V1 product Vibes (e.g., <code>aug:products/superwidget?3</code>) were created based on an exemplar Vibe, named <code>aug:products/example?1</code>.</p>
<ul>
<li>The <code>schema</code> field of <code>aug:products/example?1</code> (and thus of <code>aug:products/superwidget?3</code>) defines a V1 product structure that includes a <code>price</code> string field.</li>
<li>The <code>solution</code> field of <code>aug:products/example?1</code> would contain example placeholder values for a V1 product.</li>
</ul>
<p>We now want to migrate these V1 products to a new V2 structure, represented by a new exemplar Vibe, <code>aug:products/example-v2?1</code>. This new V2 structure will use an integer <code>priceInCents</code> field for better precision and will omit the old <code>price</code> field.</p>
<ol>
<li><p><strong>Conceptualize the <code>aug:products/example-v2?1</code> Exemplar Vibe</strong>:
This Vibe establishes the pattern for all V2 products. It would encapsulate:</p>
<pre><code>- **`input`**: Example or typical input fields relevant for `aug:products/example-v2?1` (e.g., `{&quot;id&quot;: &quot;generic-products/example-v2-guid&quot;, &quot;productId&quot;: &quot;PROD-V2-EXEMPLAR&quot;}`).
- **`schema`**: This field contains the new &quot;ProductSchemaV2&quot; JSON definition:
  ```json
  // &quot;ProductSchemaV2&quot; - to be embedded in the .schema field of `aug:products/example-v2?1` and its derivatives
  {
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
      &quot;productId&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;Unique business identifier for the product&quot;
      },
      &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },
      &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },
      &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; },
      &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0 },
      &quot;priceInCents&quot;: {
        &quot;type&quot;: &quot;integer&quot;,
        &quot;minimum&quot;: 0,
        &quot;description&quot;: &quot;Retail price in cents&quot;
      }
    },
    &quot;required&quot;: [&quot;productId&quot;, &quot;productName&quot;, &quot;description&quot;, &quot;stockLevel&quot;, &quot;priceInCents&quot;]
  }
  ```
- **`solution`**: An example `solution` conforming to &quot;ProductSchemaV2&quot;, showing default or typical V2 data for `aug:products/example-v2?1`:
  ```json
  {
    &quot;productId&quot;: &quot;PROD-V2-EXEMPLAR&quot;,
    &quot;productName&quot;: &quot;Generic Product V2&quot;,
    &quot;description&quot;: &quot;This is a standard Version 2 product.&quot;,
    &quot;promoImage&quot;: &quot;http://example.com/generic-v2.png&quot;,
    &quot;stockLevel&quot;: 0,
    &quot;priceInCents&quot;: 0
  }
  ```
  When migrating a specific product like SuperWidget, the `target` Vibe (e.g., `aug:products/superwidget-v2-base?1`) will be an instance or derivative that adopts this V2 structure (i.e., its `schema` field will be identical to `aug:products/example-v2?1#schema`, and its `solution` will have V2-specific fields based on `aug:products/example-v2?1#solution` and SuperWidget specifics).
</code></pre>
</li>
<li><p><strong>The <code>Refine</code> Operation for Migration (Example: SuperWidget)</strong>:
To create a V2 Vibe for SuperWidget, conforming to the structure defined in <code>aug:products/example-v2?1#schema</code> and populated with data from <code>aug:products/superwidget?1</code>:</p>
<pre><code>- **`target`**: The `aug:products/example-v2?1` exemplar Vibe itself. This Vibe (defined in Step 1) provides the structural blueprint (its `schema` field) and default V2 values (its `solution` field) for the new Vibe to be created.

- **`instruction`**:
  Generally, the `instruction` Vibe\&#39;s `solution` provides the data or directives for the `Refine` operation. Its format is highly flexible and is not prescribed by the system; it could be natural language, executable code, structured data (like JSON or XML), or even before-and-after examples. The process authorized by the `capability` is responsible for interpreting this `solution`, potentially using tools like LLMs or specific parsers and logic.

  In this specific migration scenario, we illustrate a straightforward approach where the existing V1 product Vibe itself serves as the `instruction`. For migrating SuperWidget:
    - The `instruction` is `aug:products/superwidget?3` (the V1 SuperWidget Vibe, using the revision number from your prior edits).
    - Its `solution` (containing all V1 product data like original `productName`, `description`, `price`, `stockLevel`, etc.) directly provides the source material for the migration.

  The process authorized by the `capability` (see below) is then responsible for interpreting this V1 data. It will typically:
    - Use the `aug:products/example-v2?1#schema` (from the `target` Vibe) as the structural template for the new V2 product.
    - Extract relevant data from the `instruction` Vibe\&#39;s `solution` (i.e., `aug:products/superwidget?3#solution`).
    - Perform necessary transformations (e.g., converting a `price` string to an integer `priceInCents`).
    - Populate the new V2 structure. Any V2-specific fields not directly derivable from the V1 data (e.g., a new `productId` for the V2 version if desired, or default values for entirely new V2 fields) would either be generated by this migration process logic or taken from the default `solution` of the `target` exemplar (`aug:products/example-v2?1#solution`).

- **`capability`**: A Capability, say `aug:migrations/product#v1-to-v2`. This permit authorizes `Refine`ing the `aug:products/example-v2?1` exemplar using a V1 product Vibe (like `aug:products/superwidget?3`) as the instruction to produce a new V2 product Vibe. The logic for data transformation and V2 field population is encapsulated by the process acting under this capability.

The `Refine` call would then result in a new Vibe with a distinct identity:
`aug:products/superwidget-v2?1 = Refine(target: aug:products/example-v2?1, instruction: aug:products/superwidget?3, capability: aug:migrations/product#v1-to-v2)`
</code></pre>
</li>
<li><p><strong>Result (SuperWidget)</strong>:
A <strong>new</strong> Record Vibe, <code>aug:products/superwidget-v2?1</code>, is created (note the new identity):</p>
<ul>
<li>Its <code>schema</code> field is identical to <code>aug:products/example-v2?1#schema</code> (inherited from the <code>target</code> exemplar).</li>
<li>Its <code>solution</code> field is now populated according to <code>aug:products/example-v2?1#schema</code>. The data is derived by the migration process (authorized by the <code>capability</code>) using the V1 data from <code>aug:products/superwidget?3#solution</code> as the primary input:<pre><code class="language-json">// aug:products/superwidget-v2?1#solution
{
  &quot;productId&quot;: &quot;SW-001&quot;, // Carried over from V1 to maintain product identity
  &quot;productName&quot;: &quot;SuperWidget Pro&quot;, // Potentially updated by the migration process
  &quot;description&quot;: &quot;The next generation SuperWidget.&quot;, // Potentially updated by the migration process
  &quot;promoImage&quot;: &quot;http://example.com/superwidget-v2.png&quot;, // Potentially updated by the migration process
  &quot;stockLevel&quot;: 150, // Carried over from V1 data (aug:products/superwidget?3#solution)
  &quot;priceInCents&quot;: 1999 // Transformed from V1 price (aug:products/superwidget?3#solution)
}
</code></pre>
</li>
<li>The original Vibes (<code>aug:products/superwidget?3</code> and <code>aug:products/example-v2?1</code>) remain untouched.</li>
</ul>
<p><em>(Note: The <code>productId</code> shown here is the business identifier for the product, defined by its schema and part of its <code>solution</code>. This is distinct from the Vibe&#39;s unique system/ledger UUID, which is metadata external to the <code>solution</code>.)</em></p>
</li>
<li><p><strong>Migrating Another Product (e.g., SuperGizmo)</strong>:
To migrate another V1 product, say <code>aug:products/supergizmo?1</code> (assuming it&#39;s a V1 product), to its V2 version:</p>
<ul>
<li>The <code>target</code> remains the <code>aug:products/example-v2?1</code> exemplar Vibe.</li>
<li>The <code>instruction</code> would be <code>aug:products/supergizmo?1</code> itself.</li>
<li>The same <code>capability</code> (<code>aug:migrations/product#v1-to-v2</code>) can be used.</li>
<li>The <code>Refine</code> call:
<code>aug:products/supergizmo-v2?1 = Refine(target: aug:products/example-v2?1, instruction: aug:products/supergizmo?1, capability: aug:migrations/product#v1-to-v2)</code>
This creates <code>aug:products/supergizmo-v2?1</code> conforming to the schema defined in <code>aug:products/example-v2?1#schema</code>.</li>
</ul>
</li>
</ol>
<p><strong>Benefits of this Migration Approach:</strong></p>
<ul>
<li><strong>Clean Schema Versions</strong>: New Vibes (<code>aug:products/superwidget?1</code>) are clean instances of the new schema version without carrying legacy fields directly in their structure.</li>
<li><strong>Explicit Transformation Logic</strong>: The <code>instruction</code> Vibe (or the process interpreting it, as authorized by a <code>capability</code>) explicitly defines the transformation or migration logic from V1 to V2. This logic is itself auditable and can be versioned.</li>
<li><strong>Full Immutability and Lineage</strong>: The historical Vibe (<code>aug:products/superwidget?1</code>) remains, providing a complete audit trail. The lineage of <code>aug:products/superwidget?1</code> back to its V1 origins is clear.</li>
<li><strong>Phased Rollout Possible</strong>: Systems consuming product data can be updated over time to understand &quot;ProductSchemaV2&quot;. During a transition, some systems might read V1 Vibes (if they still exist and are relevant) and others V2 Vibes.</li>
</ul>
<p>This strategy allows for robust and clean evolution of data structures, fully embracing the system&#39;s immutability and explicit transformation principles. It provides a structured way to handle significant schema changes beyond simple additive refinement.</p>
<p><strong>Chain of Authorization and Evolution:</strong>
This example illustrates a chain:</p>
<ol>
<li>A high-level business need (launching a shop) triggers...</li>
<li>Authorized personnel (System Architect) to perform schema evolution by <code>Refine</code>ing existing Record Vibes with specific <code>instruction</code> Vibes. The <code>solution</code> of these <code>instruction</code> Vibes dictates changes to both the <code>schema</code> field content (the structure) and the <code>solution</code> field content (the data) of the target Record Vibe, under an authorizing Capability.</li>
<li>This results in new Record Vibes, each containing the evolved structural definition in its <code>schema</code> field and corresponding data in its <code>solution</code> field.</li>
<li>This evolved structure then enables other roles (Inventory Manager) to be granted Capabilities to perform new types of data operations on the <code>solutions</code> of these evolved Record Vibes.</li>
</ol>
<p>This capability-driven approach treats schema evolution as an integral part of data evolution. Changes to a Vibe&#39;s structure (its <code>schema</code> field) are managed through the same <code>Refine</code> primitive and permit-based authorization that governs all other transformations, ensuring that data structures can evolve in a controlled, auditable, and secure manner directly reflecting changes in business requirements.</p>
<hr>
<h2>Practical Permission Management for <code>Refine</code> Operations</h2>
<p>Permissions are granular and task-oriented, granted via specific permits. These permits can authorize actions on specific Vibe instances or, more powerfully, on any Vibe that conforms to a specified schema (as defined in an exemplar Vibe). Here are e-commerce examples illustrating this, with each scenario broken down into steps, using <code>aug:/...</code> for global/absolute paths and <code>aug:...</code> for local paths (implicitly within the current company context):</p>
<ul>
<li><p><strong>Product Managers &amp; New Product Launch:</strong>
A Product Manager is launching various new electronic gadgets.</p>
<ul>
<li><strong>Permit Issued:</strong> &quot;Permit to Create New Product Listings from Approved Product Exemplars using Standard Launch Instructions,&quot; an instance of <code>aug:/permits/spawn-policy?1</code>.</li>
<li><strong>Action:</strong> The Product Manager is authorized to <em>refine</em> any target exemplar Vibe whose <code>schema</code> field defines an electronics product structure (e.g., <code>aug:products/electronics-product?1</code>, which serves as the base Vibe for electronic products) using any <code>instruction</code> that conforms to schema <code>aug:schema-instruction-launch?1</code>.</li>
<li><strong>Outcome:</strong> This allows creation of various new product Vibes. For instance, to create a specific smartwatch, the <code>target</code> might be <code>aug:products/smartwatch?1</code> (an exemplar Vibe for smartwatches, itself potentially derived from <code>aug:products/electronics-product?1</code>), and the <code>instruction</code> would be <code>aug:announcements/smartwatch-gen5-details?1</code>. The result would be <code>aug:products/smartwatch-gen5?1</code>. Similarly for <code>aug:products/earbuds-pro?1</code> from an <code>aug:products/earbuds?1</code> exemplar.</li>
</ul>
</li>
<li><p><strong>Inventory Managers &amp; Stock Level Adjustments:</strong>
An Inventory Manager needs to update stock levels for any product based on incoming feeds.</p>
<ul>
<li><strong>Permit Issued:</strong> &quot;Permit to Update Stock Counts for Any Inventory-Tracked Product via System Feeds,&quot; an instance of <code>aug:/permits/input-change?1</code>.</li>
<li><strong>Action:</strong> The Inventory Manager is authorized to <em>refine</em> any target product Vibe whose <code>schema</code> field conforms to the structure defined in an <code>aug:products/inventory-tracked-product?1</code> exemplar, using a specific instruction like <code>aug:feeds/stock-feed?1</code>.</li>
<li><strong>Outcome:</strong> The <code>stockLevel</code> field within any valid product Vibe (e.g., <code>aug:products/smartwatch-gen5?1</code>, <code>aug:products/charger-c30?1</code>) can be updated.</li>
</ul>
</li>
<li><p><strong>Marketing Specialists &amp; Promotional Campaign Setup:</strong>
A Marketing Specialist needs to define various types of discount rules for sales events.</p>
<ul>
<li><strong>Permit Issued:</strong> &quot;Permit to Define New Discount Rules in Promotion Engine via Approved Rule Structures,&quot; an instance of <code>aug:/permits/schema-govern?1</code>.</li>
<li><strong>Action:</strong> The Marketing Specialist is authorized to <em>refine</em> the target <code>aug:schema-promo-rules?1</code> using any instruction Vibe that conforms to <code>aug:schema-instruction-discount?1</code> (e.g., instructions for percentage-off, BOGO, or tiered discounts).</li>
<li><strong>Outcome:</strong> Various new discount rule structures (e.g., <code>percentage-off-category-x</code>, <code>bogo-on-accessories</code>) can be added to the global promotion rules schema.</li>
</ul>
</li>
<li><p><strong>Content Writers &amp; Product Description Updates:</strong>
A Content Writer needs to update marketing copy for any product page.</p>
<ul>
<li><strong>Permit Issued:</strong> &quot;Permit to Update Product Page Content for Any Product via SEO Guidelines,&quot; an instance of <code>aug:/permits/editorial?1</code>.</li>
<li><strong>Action:</strong> The Content Writer is authorized to <em>refine</em> any target product page Vibe conforming to schema <code>aug:schema-prod-page?1</code> using the specific instruction <code>aug:guide-seo-desc?1</code>.</li>
<li><strong>Outcome:</strong> The <code>description</code> and <code>marketingCopy</code> fields in the solution of any valid product page Vibe (e.g., <code>aug:products/smartwatch-gen5?1</code>) can be updated.</li>
</ul>
</li>
<li><p><strong>Customer Support Leads &amp; Order Adjustments:</strong>
A Customer Support Lead needs to process various types of standard order adjustments.</p>
<ul>
<li><strong>Permit Issued:</strong> &quot;Permit to Adjust Customer Orders via Standard Service Protocols,&quot; an instance of <code>aug:/permits/merge-policy?1</code> (or a more specific adjustment permit).</li>
<li><strong>Action:</strong> The Support Lead is authorized to <em>refine</em> any target customer order Vibe conforming to schema <code>aug:schema-order?1</code> using any instruction that conforms to an approved <code>aug:schema-instruction-order-adj?1</code> (e.g., for partial refunds, shipping changes, item swaps defined by specific protocols).</li>
<li><strong>Outcome:</strong> New versions of various customer order Vibes (e.g., <code>aug:order-12345?1</code>, <code>aug:order-67890?1</code>) can be created, reflecting the authorized adjustments.</li>
</ul>
</li>
</ul>
<p>When any Vibe attempts to <em>refine</em> another, the system verifies it holds a Capability containing a valid permit. This permit must explicitly authorize the <code>target</code> (either a specific Vibe or one matching a schema) to be transformed by the specific <code>instruction</code> (either a specific Vibe or one matching a schema). The permit itself, through its definition and associated schemas for the target and instruction using these ID conventions (global <code>aug:/</code> vs. local <code>aug:</code>), clearly defines the scope and constraints of the authorized action.</p>
</section></article></main></div></div>
        
        <script id="vike_pageContext" type="application/json">{"_urlRewrite":null,"pageId":"\\/src\\/@document\\/@chapter","routeParams":{"document":"blueprint","chapterSlug":"04_refinements_examples"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"\\/manifesto\\/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"\\/manifesto\\/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"\\/manifesto\\/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"\\/rfc\\/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"\\/rfc\\/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"\\/rfc\\/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"\\/rfc\\/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"\\/rfc\\/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"\\/rfc\\/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"\\/rfc\\/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"\\/blueprint\\/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"\\/blueprint\\/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"\\/blueprint\\/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"\\/blueprint\\/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"\\/blueprint\\/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"\\/blueprint\\/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"\\/blueprint\\/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"\\/blueprint\\/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"\\/blueprint\\/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"\\/blueprint\\/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"\\/blueprint\\/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"\\/blueprint\\/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"\\/blueprint\\/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"\\/blueprint\\/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"\\/blueprint\\/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"\\/blueprint\\/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"\\/blueprint\\/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"\\/blueprint\\/12_determinism.md"}]},"content":"\u003ch3>Detailed Example: Evolving Record Vibe Schemas\u003c\\/h3>\n\u003cp>The &quot;schema refinement principle&quot; discussed during bootstrapping—making schemas more specific—isn&#39;t limited to the initial setup of the system. It&#39;s a fundamental aspect of how the system adapts and evolves. Just as Capabilities can authorize changes \u003cem>to the data\u003c\\/em> within a Record Vibe&#39;s \u003ccode>solution\u003c\\/code>, they can also authorize changes \u003cem>to the very structure\u003c\\/em> defined in a Record Vibe&#39;s own \u003ccode>schema\u003c\\/code> field. This is achieved by \u003ccode>Refine\u003c\\/code>ing a Record Vibe with an \u003ccode>instruction\u003c\\/code> Vibe, whose \u003ccode>solution\u003c\\/code> defines the evolution of the target Vibe. This process results in a new Record Vibe with an evolved \u003ccode>schema\u003c\\/code> field and a \u003ccode>solution\u003c\\/code> conforming to this new structure. This allows for controlled evolution of data structures as business needs change, aligning with the content-first philosophy where interactions with content drive its transformation.\u003c\\/p>\n\u003cp>Consider the scenario of evolving a simple promotional website into a full-fledged e-commerce platform.\u003c\\/p>\n\u003cp>\u003cstrong>Initial State:\u003c\\/strong>\nThe company initially has Record Vibes for its products, such as \u003ccode>aug:products\\/superwidget?1\u003c\\/code> (where \u003ccode>?1\u003c\\/code> means revision). These Vibes conform to the structure defined in an exemplar Vibe, say \u003ccode>aug:products\\/example?1\u003c\\/code> (representing a basic product structure).\u003c\\/p>\n\u003cul>\n\u003cli>The \u003ccode>schema\u003c\\/code> field of \u003ccode>aug:products\\/example?1\u003c\\/code> (and thus of \u003ccode>aug:products\\/superwidget?1\u003c\\/code>) holds the JSON Schema definition for this initial basic product structure.\u003c\\/li>\n\u003cli>The \u003ccode>solution\u003c\\/code> field of \u003ccode>aug:products\\/example?1\u003c\\/code> contains placeholder\\/example data for a basic product.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>This initial structure (\u003ccode>aug:products\\/example?1#schema\u003c\\/code>) might look like this:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">\\/\\/ Content of the `schema` field for `aug:products\\/example?1` and its derivatives\n{\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; }\n  },\n  &quot;required&quot;: [&quot;productName&quot;, &quot;description&quot;]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003cp>\u003cstrong>The Business Goal &amp; Required Schema Change:\u003c\\/strong>\nAs the business decides to launch a full online shop, a critical new requirement emerges: tracking inventory and price. This necessitates evolving product Record Vibes to include \u003ccode>stockLevel\u003c\\/code> and \u003ccode>price\u003c\\/code> fields, meaning the JSON Schema definition in their \u003ccode>schema\u003c\\/code> field must change.\u003c\\/p>\n\u003cp>\u003cstrong>The \u003ccode>Refine\u003c\\/code> Operation: Evolving the Vibe&#39;s Schema and Solution\u003c\\/strong>\nTo implement this, a \u003ccode>Refine\u003c\\/code> operation targets the existing \u003ccode>aug:products\\/superwidget?1\u003c\\/code> (let&#39;s consider its initial state to be \u003ccode>aug:products\\/superwidget?1\u003c\\/code>):\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>\u003ccode>target\u003c\\/code>\u003c\\/strong>: \u003ccode>aug:products\\/superwidget?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>instruction\u003c\\/code>\u003c\\/strong>: An \u003ccode>aug:migrations\\/evolve-to-shop-item?1\u003c\\/code> Vibe. The \u003ccode>solution\u003c\\/code> of this instruction Vibe is crucial; it specifies how to modify the JSON Schema definition found in the target Vibe&#39;s \u003ccode>schema\u003c\\/code> field, and how the target&#39;s \u003ccode>solution\u003c\\/code> (data) should adapt:\u003cpre>\u003ccode class=\"language-json\">\\/\\/ Example: Content of aug:migrations\\/evolve-to-shop-item?1\\&#39;s solution\n\\/\\/ The format does not matter\n{\n  &quot;schemaModifications&quot;: {\n    &quot;addProperties&quot;: {\n      &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0, &quot;description&quot;: &quot;Current available stock&quot; },\n      &quot;price&quot;: { &quot;type&quot;: &quot;number&quot;, &quot;format&quot;: &quot;currency&quot;, &quot;description&quot;: &quot;Retail price&quot; }\n    },\n    &quot;addToRequired&quot;: [&quot;stockLevel&quot;, &quot;price&quot;]\n  },\n  &quot;solutionUpdate&quot;: {\n    &quot;stockLevel&quot;: 0, \\/\\/ Initialize new stockLevel field in the solution\n    &quot;price&quot;: &quot;0.00&quot; \\/\\/ Initialize new price field in the solution\n  }\n}\n\u003c\\/code>\u003c\\/pre>\n\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>capability\u003c\\/code>\u003c\\/strong>: A Capability held by a role like &quot;System Architect,&quot; authorizing the refinement of basic products to shop-ready products.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>The \u003ccode>Refine\u003c\\/code> call would effectively be:\u003c\\/p>\n\u003cp>\u003ccode>aug:products\\/superwidget?2 = Refine(aug:products\\/superwidget?1, aug:migrations\\/evolve-to-shop-item?1, aug:capability-architect-master?1)\u003c\\/code>\u003c\\/p>\n\u003cp>This operation results in a new revision of the same conceptual Vibe (\u003ccode>aug:products\\/superwidget?1\u003c\\/code>) because the \u003ccode>migrations\\/evolve-to-shop-item?1\u003c\\/code> leads to a schema that is a compatible refinement (more specific version) of the original. This means that any system or process that was designed to understand the basic product structure can still understand this new, evolved structure; it would simply ignore the new \u003ccode>stockLevel\u003c\\/code> and \u003ccode>price\u003c\\/code> fields if it wasn&#39;t programmed to use them. The system&#39;s ledger records this as the next revision for \u003ccode>aug:products\\/superwidget?1\u003c\\/code>. Had the schema change been fundamentally incompatible, it would typically result in a Vibe with a new distinct identity.\u003c\\/p>\n\u003cp>The result is a \u003cstrong>new revision\u003c\\/strong> of the Vibe, now identifiable as \u003ccode>aug:products\\/superwidget?2\u003c\\/code> (the system manages actual versioning internally, this notation is for example clarity). This new revision \u003cem>is\u003c\\/em> the shop-ready version:\u003c\\/p>\n\u003cul>\n\u003cli>Its \u003ccode>schema\u003c\\/code> field now contains the new, evolved JSON Schema definition (the &quot;Shop Product Structure&quot;):\u003cpre>\u003ccode class=\"language-json\">\\/\\/ Content of the `schema` field for aug:products\\/superwidget?2\n{\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; },\n    &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0, &quot;description&quot;: &quot;Current available stock&quot; },\n    &quot;price&quot;: { &quot;type&quot;: &quot;number&quot;, &quot;format&quot;: &quot;currency&quot;, &quot;description&quot;: &quot;Retail price&quot; }\n  },\n  &quot;required&quot;: [&quot;productName&quot;, &quot;description&quot;, &quot;stockLevel&quot;, &quot;price&quot;]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003c\\/li>\n\u003cli>Its \u003ccode>solution\u003c\\/code> field now contains the original data plus the newly initialized \u003ccode>stockLevel\u003c\\/code> and \u003ccode>price\u003c\\/code> fields, conforming to this new &quot;Shop Product Structure&quot;:\u003cpre>\u003ccode class=\"language-json\">\\/\\/ aug:products\\/superwidget?2#solution\n{\n  &quot;productName&quot;: &quot;Super Widget&quot;,\n  &quot;description&quot;: &quot;The best widget for your needs.&quot;,\n  &quot;promoImage&quot;: &quot;http:\\/\\/example.com\\/superwidget.png&quot;,\n  &quot;stockLevel&quot;: 0,\n  &quot;price&quot;: &quot;0.00&quot;\n}\n\u003c\\/code>\u003c\\/pre>\nThe original \u003ccode>aug:products\\/superwidget?1\u003c\\/code> remains untouched in the ledger. Other existing basic product Vibes (like \u003ccode>aug:products\\/anotheritem?1\u003c\\/code>) would undergo similar \u003ccode>Refine\u003c\\/code> operations to evolve them into their respective shop-ready iterations (e.g., \u003ccode>aug:products\\/anotheritem?2\u003c\\/code>).\u003c\\/li>\n\u003c\\/ul>\n\u003cp>\u003cstrong>Subsequent Data Updates under the Evolved Schema:\u003c\\/strong>\nWith \u003ccode>aug:products\\/superwidget?2\u003c\\/code> now having the &quot;Shop Product Structure&quot; in its \u003ccode>schema\u003c\\/code> field, an &quot;Inventory Manager&quot; can be granted capabilities to update its \u003ccode>solution\u003c\\/code>.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>\u003ccode>target\u003c\\/code>\u003c\\/strong>: \u003ccode>aug:products\\/superwidget?2\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>instruction\u003c\\/code>\u003c\\/strong>: An \u003ccode>aug:updates\\/update-stock?1\u003c\\/code> Vibe, whose \u003ccode>solution\u003c\\/code> specifies \u003ccode>{ &quot;stockLevel&quot;: 150 }\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>capability\u003c\\/code>\u003c\\/strong>: A Capability held by the &quot;Inventory Manager.&quot;\u003c\\/li>\n\u003c\\/ul>\n\u003cp>The \u003ccode>Refine\u003c\\/code> call:\n\u003ccode>aug:products\\/superwidget?3 = Refine(aug:products\\/superwidget?2, aug:updates\\/update-stock?1, aug:capability-inventory-mgr?1)\u003c\\/code>\u003c\\/p>\n\u003cp>This produces \u003ccode>aug:products\\/superwidget?3\u003c\\/code>, a new revision of the product Vibe with the updated stock count in its \u003ccode>solution\u003c\\/code>. Its \u003ccode>schema\u003c\\/code> field remains the &quot;Shop Product Structure&quot; (as defined in \u003ccode>aug:products\\/superwidget?2\u003c\\/code>).\u003c\\/p>\n\u003ch3>Advanced Schema Evolution: Migrating to a New Schema Version\u003c\\/h3>\n\u003cp>The previous example showed additive schema refinement. However, when a more fundamental &quot;breaking&quot; change is needed (e.g., renaming a field, significantly altering its type, or removing it entirely), a robust strategy is to migrate product instances to conform to a new schema version. This aligns with the content-first principle: the new schema isn&#39;t an independent, abstract Vibe but is defined directly within the \u003ccode>schema\u003c\\/code> field of the new product Vibe instances.\u003c\\/p>\n\u003cp>The core idea is to use an old product Vibe&#39;s data (as an \u003ccode>instruction\u003c\\/code>) to populate and finalize a new product Vibe (\u003ccode>target\u003c\\/code>) that is already structured according to the new schema version and represents the specific entity being migrated.\u003c\\/p>\n\u003cp>\u003cstrong>Scenario: Introducing \u003ccode>priceInCents\u003c\\/code> and removing \u003ccode>price\u003c\\/code>\u003c\\/strong>\u003c\\/p>\n\u003cp>Let&#39;s say our existing V1 product Vibes (e.g., \u003ccode>aug:products\\/superwidget?3\u003c\\/code>) were created based on an exemplar Vibe, named \u003ccode>aug:products\\/example?1\u003c\\/code>.\u003c\\/p>\n\u003cul>\n\u003cli>The \u003ccode>schema\u003c\\/code> field of \u003ccode>aug:products\\/example?1\u003c\\/code> (and thus of \u003ccode>aug:products\\/superwidget?3\u003c\\/code>) defines a V1 product structure that includes a \u003ccode>price\u003c\\/code> string field.\u003c\\/li>\n\u003cli>The \u003ccode>solution\u003c\\/code> field of \u003ccode>aug:products\\/example?1\u003c\\/code> would contain example placeholder values for a V1 product.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>We now want to migrate these V1 products to a new V2 structure, represented by a new exemplar Vibe, \u003ccode>aug:products\\/example-v2?1\u003c\\/code>. This new V2 structure will use an integer \u003ccode>priceInCents\u003c\\/code> field for better precision and will omit the old \u003ccode>price\u003c\\/code> field.\u003c\\/p>\n\u003col>\n\u003cli>\u003cp>\u003cstrong>Conceptualize the \u003ccode>aug:products\\/example-v2?1\u003c\\/code> Exemplar Vibe\u003c\\/strong>:\nThis Vibe establishes the pattern for all V2 products. It would encapsulate:\u003c\\/p>\n\u003cpre>\u003ccode>- **`input`**: Example or typical input fields relevant for `aug:products\\/example-v2?1` (e.g., `{&quot;id&quot;: &quot;generic-products\\/example-v2-guid&quot;, &quot;productId&quot;: &quot;PROD-V2-EXEMPLAR&quot;}`).\n- **`schema`**: This field contains the new &quot;ProductSchemaV2&quot; JSON definition:\n  ```json\n  \\/\\/ &quot;ProductSchemaV2&quot; - to be embedded in the .schema field of `aug:products\\/example-v2?1` and its derivatives\n  {\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n      &quot;productId&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;Unique business identifier for the product&quot;\n      },\n      &quot;productName&quot;: { &quot;type&quot;: &quot;string&quot; },\n      &quot;description&quot;: { &quot;type&quot;: &quot;string&quot; },\n      &quot;promoImage&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;uri&quot; },\n      &quot;stockLevel&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0 },\n      &quot;priceInCents&quot;: {\n        &quot;type&quot;: &quot;integer&quot;,\n        &quot;minimum&quot;: 0,\n        &quot;description&quot;: &quot;Retail price in cents&quot;\n      }\n    },\n    &quot;required&quot;: [&quot;productId&quot;, &quot;productName&quot;, &quot;description&quot;, &quot;stockLevel&quot;, &quot;priceInCents&quot;]\n  }\n  ```\n- **`solution`**: An example `solution` conforming to &quot;ProductSchemaV2&quot;, showing default or typical V2 data for `aug:products\\/example-v2?1`:\n  ```json\n  {\n    &quot;productId&quot;: &quot;PROD-V2-EXEMPLAR&quot;,\n    &quot;productName&quot;: &quot;Generic Product V2&quot;,\n    &quot;description&quot;: &quot;This is a standard Version 2 product.&quot;,\n    &quot;promoImage&quot;: &quot;http:\\/\\/example.com\\/generic-v2.png&quot;,\n    &quot;stockLevel&quot;: 0,\n    &quot;priceInCents&quot;: 0\n  }\n  ```\n  When migrating a specific product like SuperWidget, the `target` Vibe (e.g., `aug:products\\/superwidget-v2-base?1`) will be an instance or derivative that adopts this V2 structure (i.e., its `schema` field will be identical to `aug:products\\/example-v2?1#schema`, and its `solution` will have V2-specific fields based on `aug:products\\/example-v2?1#solution` and SuperWidget specifics).\n\u003c\\/code>\u003c\\/pre>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>The \u003ccode>Refine\u003c\\/code> Operation for Migration (Example: SuperWidget)\u003c\\/strong>:\nTo create a V2 Vibe for SuperWidget, conforming to the structure defined in \u003ccode>aug:products\\/example-v2?1#schema\u003c\\/code> and populated with data from \u003ccode>aug:products\\/superwidget?1\u003c\\/code>:\u003c\\/p>\n\u003cpre>\u003ccode>- **`target`**: The `aug:products\\/example-v2?1` exemplar Vibe itself. This Vibe (defined in Step 1) provides the structural blueprint (its `schema` field) and default V2 values (its `solution` field) for the new Vibe to be created.\n\n- **`instruction`**:\n  Generally, the `instruction` Vibe\\&#39;s `solution` provides the data or directives for the `Refine` operation. Its format is highly flexible and is not prescribed by the system; it could be natural language, executable code, structured data (like JSON or XML), or even before-and-after examples. The process authorized by the `capability` is responsible for interpreting this `solution`, potentially using tools like LLMs or specific parsers and logic.\n\n  In this specific migration scenario, we illustrate a straightforward approach where the existing V1 product Vibe itself serves as the `instruction`. For migrating SuperWidget:\n    - The `instruction` is `aug:products\\/superwidget?3` (the V1 SuperWidget Vibe, using the revision number from your prior edits).\n    - Its `solution` (containing all V1 product data like original `productName`, `description`, `price`, `stockLevel`, etc.) directly provides the source material for the migration.\n\n  The process authorized by the `capability` (see below) is then responsible for interpreting this V1 data. It will typically:\n    - Use the `aug:products\\/example-v2?1#schema` (from the `target` Vibe) as the structural template for the new V2 product.\n    - Extract relevant data from the `instruction` Vibe\\&#39;s `solution` (i.e., `aug:products\\/superwidget?3#solution`).\n    - Perform necessary transformations (e.g., converting a `price` string to an integer `priceInCents`).\n    - Populate the new V2 structure. Any V2-specific fields not directly derivable from the V1 data (e.g., a new `productId` for the V2 version if desired, or default values for entirely new V2 fields) would either be generated by this migration process logic or taken from the default `solution` of the `target` exemplar (`aug:products\\/example-v2?1#solution`).\n\n- **`capability`**: A Capability, say `aug:migrations\\/product#v1-to-v2`. This permit authorizes `Refine`ing the `aug:products\\/example-v2?1` exemplar using a V1 product Vibe (like `aug:products\\/superwidget?3`) as the instruction to produce a new V2 product Vibe. The logic for data transformation and V2 field population is encapsulated by the process acting under this capability.\n\nThe `Refine` call would then result in a new Vibe with a distinct identity:\n`aug:products\\/superwidget-v2?1 = Refine(target: aug:products\\/example-v2?1, instruction: aug:products\\/superwidget?3, capability: aug:migrations\\/product#v1-to-v2)`\n\u003c\\/code>\u003c\\/pre>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Result (SuperWidget)\u003c\\/strong>:\nA \u003cstrong>new\u003c\\/strong> Record Vibe, \u003ccode>aug:products\\/superwidget-v2?1\u003c\\/code>, is created (note the new identity):\u003c\\/p>\n\u003cul>\n\u003cli>Its \u003ccode>schema\u003c\\/code> field is identical to \u003ccode>aug:products\\/example-v2?1#schema\u003c\\/code> (inherited from the \u003ccode>target\u003c\\/code> exemplar).\u003c\\/li>\n\u003cli>Its \u003ccode>solution\u003c\\/code> field is now populated according to \u003ccode>aug:products\\/example-v2?1#schema\u003c\\/code>. The data is derived by the migration process (authorized by the \u003ccode>capability\u003c\\/code>) using the V1 data from \u003ccode>aug:products\\/superwidget?3#solution\u003c\\/code> as the primary input:\u003cpre>\u003ccode class=\"language-json\">\\/\\/ aug:products\\/superwidget-v2?1#solution\n{\n  &quot;productId&quot;: &quot;SW-001&quot;, \\/\\/ Carried over from V1 to maintain product identity\n  &quot;productName&quot;: &quot;SuperWidget Pro&quot;, \\/\\/ Potentially updated by the migration process\n  &quot;description&quot;: &quot;The next generation SuperWidget.&quot;, \\/\\/ Potentially updated by the migration process\n  &quot;promoImage&quot;: &quot;http:\\/\\/example.com\\/superwidget-v2.png&quot;, \\/\\/ Potentially updated by the migration process\n  &quot;stockLevel&quot;: 150, \\/\\/ Carried over from V1 data (aug:products\\/superwidget?3#solution)\n  &quot;priceInCents&quot;: 1999 \\/\\/ Transformed from V1 price (aug:products\\/superwidget?3#solution)\n}\n\u003c\\/code>\u003c\\/pre>\n\u003c\\/li>\n\u003cli>The original Vibes (\u003ccode>aug:products\\/superwidget?3\u003c\\/code> and \u003ccode>aug:products\\/example-v2?1\u003c\\/code>) remain untouched.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>\u003cem>(Note: The \u003ccode>productId\u003c\\/code> shown here is the business identifier for the product, defined by its schema and part of its \u003ccode>solution\u003c\\/code>. This is distinct from the Vibe&#39;s unique system\\/ledger UUID, which is metadata external to the \u003ccode>solution\u003c\\/code>.)\u003c\\/em>\u003c\\/p>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Migrating Another Product (e.g., SuperGizmo)\u003c\\/strong>:\nTo migrate another V1 product, say \u003ccode>aug:products\\/supergizmo?1\u003c\\/code> (assuming it&#39;s a V1 product), to its V2 version:\u003c\\/p>\n\u003cul>\n\u003cli>The \u003ccode>target\u003c\\/code> remains the \u003ccode>aug:products\\/example-v2?1\u003c\\/code> exemplar Vibe.\u003c\\/li>\n\u003cli>The \u003ccode>instruction\u003c\\/code> would be \u003ccode>aug:products\\/supergizmo?1\u003c\\/code> itself.\u003c\\/li>\n\u003cli>The same \u003ccode>capability\u003c\\/code> (\u003ccode>aug:migrations\\/product#v1-to-v2\u003c\\/code>) can be used.\u003c\\/li>\n\u003cli>The \u003ccode>Refine\u003c\\/code> call:\n\u003ccode>aug:products\\/supergizmo-v2?1 = Refine(target: aug:products\\/example-v2?1, instruction: aug:products\\/supergizmo?1, capability: aug:migrations\\/product#v1-to-v2)\u003c\\/code>\nThis creates \u003ccode>aug:products\\/supergizmo-v2?1\u003c\\/code> conforming to the schema defined in \u003ccode>aug:products\\/example-v2?1#schema\u003c\\/code>.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003c\\/ol>\n\u003cp>\u003cstrong>Benefits of this Migration Approach:\u003c\\/strong>\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Clean Schema Versions\u003c\\/strong>: New Vibes (\u003ccode>aug:products\\/superwidget?1\u003c\\/code>) are clean instances of the new schema version without carrying legacy fields directly in their structure.\u003c\\/li>\n\u003cli>\u003cstrong>Explicit Transformation Logic\u003c\\/strong>: The \u003ccode>instruction\u003c\\/code> Vibe (or the process interpreting it, as authorized by a \u003ccode>capability\u003c\\/code>) explicitly defines the transformation or migration logic from V1 to V2. This logic is itself auditable and can be versioned.\u003c\\/li>\n\u003cli>\u003cstrong>Full Immutability and Lineage\u003c\\/strong>: The historical Vibe (\u003ccode>aug:products\\/superwidget?1\u003c\\/code>) remains, providing a complete audit trail. The lineage of \u003ccode>aug:products\\/superwidget?1\u003c\\/code> back to its V1 origins is clear.\u003c\\/li>\n\u003cli>\u003cstrong>Phased Rollout Possible\u003c\\/strong>: Systems consuming product data can be updated over time to understand &quot;ProductSchemaV2&quot;. During a transition, some systems might read V1 Vibes (if they still exist and are relevant) and others V2 Vibes.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>This strategy allows for robust and clean evolution of data structures, fully embracing the system&#39;s immutability and explicit transformation principles. It provides a structured way to handle significant schema changes beyond simple additive refinement.\u003c\\/p>\n\u003cp>\u003cstrong>Chain of Authorization and Evolution:\u003c\\/strong>\nThis example illustrates a chain:\u003c\\/p>\n\u003col>\n\u003cli>A high-level business need (launching a shop) triggers...\u003c\\/li>\n\u003cli>Authorized personnel (System Architect) to perform schema evolution by \u003ccode>Refine\u003c\\/code>ing existing Record Vibes with specific \u003ccode>instruction\u003c\\/code> Vibes. The \u003ccode>solution\u003c\\/code> of these \u003ccode>instruction\u003c\\/code> Vibes dictates changes to both the \u003ccode>schema\u003c\\/code> field content (the structure) and the \u003ccode>solution\u003c\\/code> field content (the data) of the target Record Vibe, under an authorizing Capability.\u003c\\/li>\n\u003cli>This results in new Record Vibes, each containing the evolved structural definition in its \u003ccode>schema\u003c\\/code> field and corresponding data in its \u003ccode>solution\u003c\\/code> field.\u003c\\/li>\n\u003cli>This evolved structure then enables other roles (Inventory Manager) to be granted Capabilities to perform new types of data operations on the \u003ccode>solutions\u003c\\/code> of these evolved Record Vibes.\u003c\\/li>\n\u003c\\/ol>\n\u003cp>This capability-driven approach treats schema evolution as an integral part of data evolution. Changes to a Vibe&#39;s structure (its \u003ccode>schema\u003c\\/code> field) are managed through the same \u003ccode>Refine\u003c\\/code> primitive and permit-based authorization that governs all other transformations, ensuring that data structures can evolve in a controlled, auditable, and secure manner directly reflecting changes in business requirements.\u003c\\/p>\n\u003chr>\n\u003ch2>Practical Permission Management for \u003ccode>Refine\u003c\\/code> Operations\u003c\\/h2>\n\u003cp>Permissions are granular and task-oriented, granted via specific permits. These permits can authorize actions on specific Vibe instances or, more powerfully, on any Vibe that conforms to a specified schema (as defined in an exemplar Vibe). Here are e-commerce examples illustrating this, with each scenario broken down into steps, using \u003ccode>aug:\\/...\u003c\\/code> for global\\/absolute paths and \u003ccode>aug:...\u003c\\/code> for local paths (implicitly within the current company context):\u003c\\/p>\n\u003cul>\n\u003cli>\u003cp>\u003cstrong>Product Managers &amp; New Product Launch:\u003c\\/strong>\nA Product Manager is launching various new electronic gadgets.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Permit Issued:\u003c\\/strong> &quot;Permit to Create New Product Listings from Approved Product Exemplars using Standard Launch Instructions,&quot; an instance of \u003ccode>aug:\\/permits\\/spawn-policy?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Action:\u003c\\/strong> The Product Manager is authorized to \u003cem>refine\u003c\\/em> any target exemplar Vibe whose \u003ccode>schema\u003c\\/code> field defines an electronics product structure (e.g., \u003ccode>aug:products\\/electronics-product?1\u003c\\/code>, which serves as the base Vibe for electronic products) using any \u003ccode>instruction\u003c\\/code> that conforms to schema \u003ccode>aug:schema-instruction-launch?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Outcome:\u003c\\/strong> This allows creation of various new product Vibes. For instance, to create a specific smartwatch, the \u003ccode>target\u003c\\/code> might be \u003ccode>aug:products\\/smartwatch?1\u003c\\/code> (an exemplar Vibe for smartwatches, itself potentially derived from \u003ccode>aug:products\\/electronics-product?1\u003c\\/code>), and the \u003ccode>instruction\u003c\\/code> would be \u003ccode>aug:announcements\\/smartwatch-gen5-details?1\u003c\\/code>. The result would be \u003ccode>aug:products\\/smartwatch-gen5?1\u003c\\/code>. Similarly for \u003ccode>aug:products\\/earbuds-pro?1\u003c\\/code> from an \u003ccode>aug:products\\/earbuds?1\u003c\\/code> exemplar.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Inventory Managers &amp; Stock Level Adjustments:\u003c\\/strong>\nAn Inventory Manager needs to update stock levels for any product based on incoming feeds.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Permit Issued:\u003c\\/strong> &quot;Permit to Update Stock Counts for Any Inventory-Tracked Product via System Feeds,&quot; an instance of \u003ccode>aug:\\/permits\\/input-change?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Action:\u003c\\/strong> The Inventory Manager is authorized to \u003cem>refine\u003c\\/em> any target product Vibe whose \u003ccode>schema\u003c\\/code> field conforms to the structure defined in an \u003ccode>aug:products\\/inventory-tracked-product?1\u003c\\/code> exemplar, using a specific instruction like \u003ccode>aug:feeds\\/stock-feed?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Outcome:\u003c\\/strong> The \u003ccode>stockLevel\u003c\\/code> field within any valid product Vibe (e.g., \u003ccode>aug:products\\/smartwatch-gen5?1\u003c\\/code>, \u003ccode>aug:products\\/charger-c30?1\u003c\\/code>) can be updated.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Marketing Specialists &amp; Promotional Campaign Setup:\u003c\\/strong>\nA Marketing Specialist needs to define various types of discount rules for sales events.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Permit Issued:\u003c\\/strong> &quot;Permit to Define New Discount Rules in Promotion Engine via Approved Rule Structures,&quot; an instance of \u003ccode>aug:\\/permits\\/schema-govern?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Action:\u003c\\/strong> The Marketing Specialist is authorized to \u003cem>refine\u003c\\/em> the target \u003ccode>aug:schema-promo-rules?1\u003c\\/code> using any instruction Vibe that conforms to \u003ccode>aug:schema-instruction-discount?1\u003c\\/code> (e.g., instructions for percentage-off, BOGO, or tiered discounts).\u003c\\/li>\n\u003cli>\u003cstrong>Outcome:\u003c\\/strong> Various new discount rule structures (e.g., \u003ccode>percentage-off-category-x\u003c\\/code>, \u003ccode>bogo-on-accessories\u003c\\/code>) can be added to the global promotion rules schema.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Content Writers &amp; Product Description Updates:\u003c\\/strong>\nA Content Writer needs to update marketing copy for any product page.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Permit Issued:\u003c\\/strong> &quot;Permit to Update Product Page Content for Any Product via SEO Guidelines,&quot; an instance of \u003ccode>aug:\\/permits\\/editorial?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Action:\u003c\\/strong> The Content Writer is authorized to \u003cem>refine\u003c\\/em> any target product page Vibe conforming to schema \u003ccode>aug:schema-prod-page?1\u003c\\/code> using the specific instruction \u003ccode>aug:guide-seo-desc?1\u003c\\/code>.\u003c\\/li>\n\u003cli>\u003cstrong>Outcome:\u003c\\/strong> The \u003ccode>description\u003c\\/code> and \u003ccode>marketingCopy\u003c\\/code> fields in the solution of any valid product page Vibe (e.g., \u003ccode>aug:products\\/smartwatch-gen5?1\u003c\\/code>) can be updated.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Customer Support Leads &amp; Order Adjustments:\u003c\\/strong>\nA Customer Support Lead needs to process various types of standard order adjustments.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Permit Issued:\u003c\\/strong> &quot;Permit to Adjust Customer Orders via Standard Service Protocols,&quot; an instance of \u003ccode>aug:\\/permits\\/merge-policy?1\u003c\\/code> (or a more specific adjustment permit).\u003c\\/li>\n\u003cli>\u003cstrong>Action:\u003c\\/strong> The Support Lead is authorized to \u003cem>refine\u003c\\/em> any target customer order Vibe conforming to schema \u003ccode>aug:schema-order?1\u003c\\/code> using any instruction that conforms to an approved \u003ccode>aug:schema-instruction-order-adj?1\u003c\\/code> (e.g., for partial refunds, shipping changes, item swaps defined by specific protocols).\u003c\\/li>\n\u003cli>\u003cstrong>Outcome:\u003c\\/strong> New versions of various customer order Vibes (e.g., \u003ccode>aug:order-12345?1\u003c\\/code>, \u003ccode>aug:order-67890?1\u003c\\/code>) can be created, reflecting the authorized adjustments.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003c\\/ul>\n\u003cp>When any Vibe attempts to \u003cem>refine\u003c\\/em> another, the system verifies it holds a Capability containing a valid permit. This permit must explicitly authorize the \u003ccode>target\u003c\\/code> (either a specific Vibe or one matching a schema) to be transformed by the specific \u003ccode>instruction\u003c\\/code> (either a specific Vibe or one matching a schema). The permit itself, through its definition and associated schemas for the target and instruction using these ID conventions (global \u003ccode>aug:\\/\u003c\\/code> vs. local \u003ccode>aug:\u003c\\/code>), clearly defines the scope and constraints of the authorized action.\u003c\\/p>\n","currentChapter":"Detailed Example: Evolving Record Vibe Schemas"}}</script>
        <script id="vike_globalContext" type="application/json">{}</script>
        <script src="/docs/assets/entries/entry-client-routing.CGxaIKAB.js" type="module" async></script>
        <link rel="modulepreload" href="/docs/assets/entries/src_-document_-chapter.C_7418N7.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-FZmpFa9c.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-tfHUaCBC.js" as="script" type="text/javascript">
      </body>
    </html>