{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"blueprint","chapterSlug":"02_instructions_guidance"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>Chapter 2.2: Instruction Guidance</h1>\n<p>This document explains the key concepts and mechanisms behind the Instruction system demonstrated in the examples. It covers how context switches are handled, how Instructions can be composed like macros, and how data flows between steps.</p>\n<h2>Context Switching with Execution Environments</h2>\n<h3>Understanding Context Suffixes</h3>\n<p>The Instruction system uses naming conventions to signal which execution environment should handle a particular step:</p>\n<ul>\n<li><strong>Base name (e.g., <code>IdentifyParticipants</code>)</strong>: Executed in the LLM context by default</li>\n<li><strong><code>_Activity</code> suffix (e.g., <code>FetchAvailability_Activity</code>)</strong>: Executed on the server</li>\n<li><strong><code>_User</code> suffix (e.g., <code>ConfirmInvitation_User</code>)</strong>: Requires user interaction</li>\n</ul>\n<p>These suffixes provide clear visual signals in the code about where execution will happen and help the system route operations to the appropriate environment.</p>\n<pre><code class=\"language-ts\">// LLM operation (default)\nconst participants = IdentifyParticipants(prompt);\n\n// LLM operation to prepare parameters\nconst availabilityParams = FetchAvailability(participants);\n\n// Server operation\nconst availabilityData = FetchAvailability_Activity(availabilityParams);\n\n// User interaction\nconst approval = ConfirmInvitation_User(invitation);\n</code></pre>\n<h3>Context Containers</h3>\n<p>In the flattened representation, we explicitly group operations by their execution context:</p>\n<pre><code class=\"language-ts\">Process(\n  // LLM operations\n  LLM_Context({\n    participants: IdentifyParticipants(prompt),\n    availabilityParams: FetchAvailability({ participants }),\n  }),\n\n  // Server operations\n  Server_Context({\n    availabilityData: FetchAvailability_Activity({ availabilityParams }),\n  })\n\n  // More contexts...\n);\n</code></pre>\n<p>This structure creates a clear separation of concerns, ensuring that operations run in their appropriate environments while maintaining data flow between them.</p>\n<h2>Instruction Composition and Macros</h2>\n<p>Instructions can be composed like mixins, with one Instruction wrapping or enhancing another. This is accomplished through JSON Schema composition.</p>\n<h3>Schema Merging</h3>\n<p>When Instructions are composed, their schemas are merged following JSON Schema&#39;s <code>allOf</code> semantics. This preserves the structure and requirements of both schemas while combining them into a single, coherent interface.</p>\n<p>The key insight is that JSON Schema preserves property order, which enables mixin-like behavior:</p>\n<pre><code class=\"language-json\">{\n  &quot;properties&quot;: {\n    &quot;_considerations&quot;: { &quot;type&quot;: &quot;string&quot; },\n    &quot;default&quot;: true, // This is a placeholder that gets replaced\n    &quot;_feedback&quot;: { &quot;type&quot;: &quot;string&quot; }\n  }\n}\n</code></pre>\n<p>When this schema composes with another, the <code>default</code> property acts as a slot that gets replaced by the other schema&#39;s properties. This creates a wrapper pattern where the mixin can inject properties before and after the wrapped schema&#39;s properties.</p>\n<h3>Creating Mixin Instructions</h3>\n<p>The <code>Introspect_Mixin</code> demonstrates this pattern:</p>\n<pre><code class=\"language-json\">{\n  &quot;title&quot;: &quot;Introspection_Mixin&quot;,\n  &quot;properties&quot;: {\n    &quot;_considerations&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;description&quot;: &quot;Before performing the action, analyze the request and outline key considerations.&quot;\n    },\n    &quot;default&quot;: true, // Placeholder for the wrapped schema\n    &quot;_feedback&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;description&quot;: &quot;After completing the action, provide feedback about the decisions made.&quot;\n    }\n  }\n}\n</code></pre>\n<p>When applied to another Instruction, it injects cognitive steps before and after the main task:</p>\n<pre><code class=\"language-ts\">Introspect_Mixin({\n  default: {\n    identifyParticipants: IdentifyParticipants(prompt),\n    fetchAvailability: FetchAvailability({ participants }),\n  },\n});\n</code></pre>\n<p>This composition creates a new schema that guides the LLM to:</p>\n<ol>\n<li>Think through considerations before acting</li>\n<li>Perform the main operations</li>\n<li>Reflect on the results afterward</li>\n</ol>\n<h2>Data Flow Between Instructions</h2>\n<h3>Implicit Parameter Passing</h3>\n<p>Instructions can implicitly pass data between steps through their descriptions and the LLM&#39;s understanding of context. This is shown in the examples where participant information flows from <code>identifyParticipants</code> to <code>fetchAvailability</code>.</p>\n<pre><code class=\"language-ts\">fetchAvailability: {\n  organizerEmail: &#39;alice@example.com&#39;, // Reused from identifyParticipants\n  attendeeEmail: &#39;bob@example.com&#39;,    // Reused from identifyParticipants\n  timeRange: { /* ... */ }\n}\n</code></pre>\n<p>The description in the schema explicitly instructs this data reuse. The actual schema structure uses <code>allOf</code> to combine the base schema reference with additional instructions:</p>\n<pre><code class=\"language-json\">&quot;fetchAvailability&quot;: {\n  &quot;allOf&quot;: [\n    { &quot;$ref&quot;: &quot;aug:processes/schedule-meeting:1#fetchAvailability&quot; },\n    { &quot;description&quot;: &quot;Retrieves calendar availability data for identified participants, reusing participant emails from the identification step to check their schedules&quot; }\n  ]\n}\n</code></pre>\n<p>This pattern allows us to:</p>\n<ol>\n<li>Reference the base functionality and structure from the process definition</li>\n<li>Extend it with contextual instructions specific to this usage</li>\n<li>Guide the LLM on how to reuse data between steps without requiring explicit parameter declarations</li>\n</ol>\n<h3>Explicit References</h3>\n<p>For more complex dependencies, Instructions can use explicit references to declare which previous steps they depend on:</p>\n<pre><code class=\"language-json\">&quot;findCommonSlot&quot;: {\n  &quot;references&quot;: [\n    &quot;LLM_1.identifyParticipants&quot;,\n    &quot;SERVER_1.fetchAvailabilityOutput&quot;\n  ]\n}\n</code></pre>\n<p>These references serve multiple purposes:</p>\n<ol>\n<li>They document data dependencies clearly</li>\n<li>They guide the LLM in understanding which data to use</li>\n<li>They help the system ensure that referenced data is available when needed</li>\n</ol>\n<h2>Process Instantiation and Execution</h2>\n<h3>Process Prototypes</h3>\n<p>Processes are defined as &quot;vibes&quot; - reusable prototypes that can be instantiated:</p>\n<pre><code>aug:processes/schedule-meeting:1\n</code></pre>\n<p>These prototypes define the complete structure of a process, including all steps, contexts, and data dependencies.</p>\n<h3>Process Initiation</h3>\n<p>A process is instantiated when a vessel completes its first step:</p>\n<pre><code class=\"language-ts\">StartProcess({\n  name: &#39;ScheduleMeeting&#39;,\n  LLM_1: {\n    // First step data...\n  },\n});\n</code></pre>\n<p>This creates a new instance of the process that will carry state through its lifecycle.</p>\n<h3>Process Continuation</h3>\n<p>After initiation, the process continues automatically through its defined steps, with each step having access to the data it needs from previous steps. The vessel carries the process state, ensuring continuity across context switches.</p>\n<h2>Best Practices for Instruction Design</h2>\n<ol>\n<li><strong>Use clear naming conventions</strong> for context switching (base, _Activity, _User)</li>\n<li><strong>Design modular Instructions</strong> that can be composed and reused</li>\n<li><strong>Use descriptions to guide data flow</strong> between steps</li>\n<li><strong>Explicitly document references</strong> for complex dependencies</li>\n<li><strong>Create macro Instructions</strong> for common patterns like introspection, validation, or error handling</li>\n<li><strong>Start with the minimal entry point</strong> needed to initiate a process</li>\n</ol>\n<p>By following these practices, you can create Instructions that are both powerful and flexible, enabling complex workflows that span multiple execution environments while maintaining clear data flow and dependencies.</p>\n","currentChapter":"Context Switching with Execution Environments"}}