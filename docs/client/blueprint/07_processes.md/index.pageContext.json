{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"blueprint","chapterSlug":"07_processes"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>Chapter 8: Processes and Compiled Instructions</h1>\n<h2>New Ideas in This Chapter</h2>\n<ul>\n<li><strong>Instruction Composition Modes</strong>: We define three ways Instructions combine: implicitly (contextual influence), fusion (compile-time merging into a single LLM call), and sequential (pipelines for dependent steps).</li>\n<li><strong>Compiled &amp; Partitioned Pipelines</strong>: Complex workflows are not interpreted on the fly. They are designed as pipelines that are <strong>compiled</strong> and <strong>partitioned</strong> into context-aware chunks (LLM vs. Server), creating durable, efficient, and self-describing <code>Process</code> Vibes.</li>\n<li><strong>The <code>LaunchProcess</code> Adapter</strong>: We introduce a universal <code>Instruction</code> that acts as a macro. It provides a consistent interface for <code>Vessels</code> to launch any stateful <code>Process</code>, decoupling the lightweight agent from the complex, long-running workflow.</li>\n<li><strong>Focused Context via <code>references</code></strong>: To manage LLM context windows, <code>Process</code> steps explicitly declare their data dependencies via a <code>references</code> meta-property. The workflow engine uses this to inject only the necessary data from the process&#39;s state into the LLM prompt, ensuring efficiency and scalability.</li>\n</ul>\n<hr>\n<p>Based on our discussion, this chapter outlines a powerful architecture for defining and executing complex, multi-step workflows that seamlessly blend LLM-native cognition with robust, server-side computation. The core challenge is to create a system that is expressive, composable, and highly efficient, primarily by minimizing context-switching and intelligently handling stateful, long-running, and data-intensive tasks like batching and multiplexing.</p>\n<p>The vision is to move beyond simple, blocking &quot;tool calls.&quot; We aim for a model where tasks can be defined as dynamic, compilable pipelines that are intelligently partitioned to run in the most appropriate contextâ€”either as a single, consolidated request to an LLM or as a stateful, server-managed process for more complex jobs.</p>\n<h2>The Foundation: Instructions as Composable Tools</h2>\n<p>At the heart of the system is the <strong>Instruction</strong>: a JSON Schema that acts as a tool or &quot;thinking primitive&quot; for an LLM. However, unlike traditional LLM tools, these are not just simple triggers for external actions. They are part of a rich compositional ecosystem with three distinct modes.</p>\n<h3>The Three Modes of Instruction Composition</h3>\n<ol>\n<li><p><strong>Implicit Composition</strong>: Instructions can exist side-by-side and influence each other&#39;s behavior contextually. An Instruction to &quot;be polite&quot; naturally affects the output of a separate &quot;answer the user&quot; Instruction without them being explicitly linked. This allows for emergent, nuanced behavior.</p>\n</li>\n<li><p><strong>Fusion Composition (Macros)</strong>: An Instruction can act as a &quot;macro&quot; that wraps another Instruction or schema. This is a compile-time operation where the schemas are fused into a single, flattened blueprint for the LLM. The wrapper can interleave its own steps (e.g., for planning, analysis, or evaluation) with the steps of the wrapped Instruction. By convention, these &quot;thinking&quot; or metadata steps are prefixed with an underscore (<code>_</code>) to distinguish them from the final output properties. This allows for creating complex, guided thought processes that still execute as a single, efficient LLM call.</p>\n</li>\n<li><p><strong>Sequential Composition (Pipelines)</strong>: For tasks that require an explicit sequence of dependent steps, instructions are composed into a pipeline. A conceptual task like scheduling a meeting, which might be thought of as <code>Schedule(FindSlot(FetchAvailability(FindParticipants(p))))</code>, can be represented more clearly as a pipeline:</p>\n<p><code>&quot;Schedule a meeting&quot; | FindParticipants | FetchAvailability | FindCommonSlot | DraftInvitation</code></p>\n<p>This pipeline is then compiled into a single schema with ordered properties like <code>step1_identify_participants</code>, <code>step2_fetch_availability</code>, etc. Crucially, later steps can reference the outputs of earlier steps, forcing the LLM to follow a logical dependency graph.</p>\n</li>\n</ol>\n<h2>Executing Server-Side Logic</h2>\n<p>A key challenge is orchestrating work that needs to happen outside the LLM&#39;s immediate context. Our architecture defines two distinct patterns for this, chosen by the compiler based on the complexity and requirements of the task.</p>\n<h3>1. Direct Server Calls (Fire-and-Forget)</h3>\n<p>For simple, non-blocking side effects, a full <code>Process</code> Vibe is overkill. If an instruction&#39;s only server-side requirement is to trigger a single, self-contained action where the result is not immediately needed, it can be handled as a <strong>Direct Server Call</strong>.</p>\n<ul>\n<li><strong>Use Case</strong>: Ideal for actions like logging, sending a notification, or incrementing a counter.</li>\n<li><strong>Execution</strong>: The <code>Vessel</code>&#39;s LLM executes an instruction whose final step is a non-blocking request to a specific server activity.</li>\n<li><strong>No <code>Process</code> Vibe</strong>: The server executes the activity, and the interaction ends. The underlying workflow engine (e.g., Temporal) ensures the activity is reliably executed with retries if needed, but no stateful <code>Process</code> Vibe is created as the pipeline does not continue. This is a lightweight, efficient way to handle simple side effects.</li>\n</ul>\n<blockquote>\n<p><strong>Alice:</strong> &quot;So for something simple like sending a &#39;like&#39; to a post, the system uses a &#39;Direct Server Call&#39; which is like a fire-and-forget missile? My Vessel just sends it and moves on?&quot;\n<strong>Bob:</strong> &quot;Exactly. It&#39;s efficient for simple side effects. But for anything more complex, like booking a flight, where you have multiple stepsâ€”find flights, select seat, pay, confirmâ€”it needs a &#39;Stateful Process&#39;. That&#39;s a <code>Process</code> Vibe, which acts like a project manager, keeping track of every step and making sure nothing gets lost, even if it has to wait for an external API.&quot;</p>\n</blockquote>\n<h3>2. Stateful Processes (Managed Workflows)</h3>\n<p>For any task that is long-running, stateful, or involves blocking server actions that feed into subsequent steps, the system uses a <strong>Stateful <code>Process</code></strong>. This is the role of the <strong><code>Process</code></strong> Vibe.</p>\n<p>These processes run within a resilient workflow engine like <strong>Temporal</strong>, which provides several critical benefits out-of-the-box:</p>\n<ul>\n<li><strong>Durability</strong>: The state of the process is preserved across server restarts or failures.</li>\n<li><strong>Reliability</strong>: It automatically handles retries for failed server-side actions (activities).</li>\n<li><strong>State Management</strong>: It transparently saves the results of each step, so intermediate computations are never lost.</li>\n</ul>\n<h4>The Process Lifecycle: Design, Compilation, and Execution</h4>\n<p>The journey from a complex idea to an executable <code>Process</code> is not an on-demand event but a structured design lifecycle.</p>\n<ol>\n<li><p><strong>Design &amp; Analysis</strong>: A new <code>Process</code> is designed as a pipeline. During this design stage, the pipeline is compiled. The compiler analyzes the entire dependency graph to determine the execution pattern.</p>\n<ul>\n<li>If the pipeline resolves to a single, terminal, non-blocking server action, it generates a &quot;Direct Server Call Instruction&quot;.</li>\n<li>For all other cases, it partitions the pipeline into <strong>context-aware chunks</strong> (LLM vs. Server) and proceeds with generating a <code>Process</code> entrypoint.</li>\n</ul>\n</li>\n<li><p><strong>Entrypoint Generation</strong>: (For Stateful Processes) The compiler extracts the first purely LLM-based chunk of the pipeline. This becomes the <code>Process</code>&#39;s <strong>Entrypoint Instruction</strong>â€”a compact, self-contained schema that can be integrated directly into a <code>Vessel</code>&#39;s toolkit.</p>\n</li>\n<li><p><strong>Vessel-Initiated Execution &amp; Process Instantiation</strong>: A <code>Vessel</code>&#39;s LLM executes the <code>Entrypoint Instruction</code>. The very last step of this instruction is a request to the server to start the full workflow. The server-side workflow engine receives this request and <strong>immediately instantiates the <code>Process</code> Vibe</strong>.</p>\n</li>\n<li><p><strong>Process-Led Execution</strong>: From this moment on, the <code>Process</code> Vibe exists and controls the entire execution flow. Its first action is to make the first blocking server call (e.g., the database query). Because the process is durable, it will wait as long as needed for the result. When the server action completes, the result is transparently passed back to the running process. The process can also execute non-blocking, fire-and-forget steps (like the Direct Server Calls described above) as part of its flow without waiting for their completion. The <code>Vessel</code> is no longer involved.</p>\n</li>\n</ol>\n<p>This model allows <code>Vessels</code> to remain lightweight and responsive, initiating complex processes without being burdened by their full complexity. The state, intermediate results, and long-running logic are reliably managed by the dedicated <code>Process</code> Vibe and its underlying workflow engine.</p>\n<h4>Focused Context Management via <code>references</code></h4>\n<p>To maintain efficiency and stay within LLM context/schema limits, the workflow engine does not send the entire process history to the LLM for every step. Instead, it practices <strong>focused context management</strong>, orchestrated by an explicit, machine-readable dependency declaration.</p>\n<ol>\n<li><p><strong>The <code>references</code> Meta-Property</strong>: Each step in a compiled pipeline schema can contain a special meta-property named <code>references</code>. This property holds an array of strings, with each string being a path to a specific output from a previous step that the current step needs (e.g., <code>[&quot;step1_define_rules&quot;, &quot;step4_find_user.output&quot;]</code>). This metadata is for the workflow engine only and is <strong>stripped from the schema</strong> before it is sent to the LLM.</p>\n</li>\n<li><p><strong>State Held by Workflow Engine</strong>: The complete state and all intermediate results for the entire process are securely held by the underlying workflow engine (e.g., Temporal).</p>\n</li>\n<li><p><strong>Just-in-Time Context Injection</strong>: When the process needs to execute a chunk of LLM-based steps, the engine reads the <code>references</code> array for that step. It uses these paths to retrieve only the necessary data from its state, constructing a minimal context object.</p>\n</li>\n<li><p><strong>Minimal LLM Prompt</strong>: The final prompt sent to the LLM contains only the schema for the current chunk of work (without the <code>references</code> property) and the minimal context object containing only the data explicitly requested.</p>\n</li>\n</ol>\n<p>This ensures the LLM receives only the information it needs, preventing context overload. Let&#39;s see it in action.</p>\n<h5>Example: Data Flow with <code>references</code></h5>\n<p>After a blocking step <code>step4_find_user</code> completes, the next step <code>step5_draft_email</code> is defined with its data dependencies in the <code>references</code> array:</p>\n<pre><code class=\"language-json\">&quot;step5_draft_email&quot;: {\n    &quot;description&quot;: &quot;Draft a personalized email to the user found in the previous step.&quot;,\n    &quot;references&quot;: [ &quot;step4_find_user.output&quot; ],\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n        &quot;recipientName&quot;: {\n            &quot;description&quot;: &quot;Use the &#39;userName&#39; field from the &#39;step4_find_user.output&#39; object provided in the prompt context.&quot;,\n            &quot;type&quot;: &quot;string&quot;\n        },\n        &quot;emailBody&quot;: { &quot;type&quot;: &quot;string&quot; }\n    }\n}\n</code></pre>\n<p>The workflow engine processes this:</p>\n<ol>\n<li>It sees <code>references: [ &quot;step4_find_user.output&quot; ]</code>.</li>\n<li>It retrieves the entire output object <code>{ &quot;userId&quot;: &quot;...&quot;, &quot;userName&quot;: &quot;...&quot; }</code> from its state.</li>\n<li>It constructs a minimal context and injects it into the prompt for the LLM.</li>\n</ol>\n<pre><code>--- Context from previous steps ---\n{\n    &quot;step4_find_user&quot;: {\n        &quot;output&quot;: {\n            &quot;userId&quot;: &quot;u-12345&quot;,\n            &quot;userName&quot;: &quot;Jane Doe&quot;\n        }\n    }\n}\n--- End Context ---\n\nPlease generate the JSON for the `step5_draft_email` step using the information provided above.\n</code></pre>\n<ol start=\"4\">\n<li>It sends the schema for <code>step5_draft_email</code> to the LLM, but <strong>without the <code>references</code> property</strong>. The LLM then uses the provided context to follow the instructions in the <code>description</code> fields. This provides a clean and powerful mechanism for piping data from server-side actions back into the LLM&#39;s reasoning process.</li>\n</ol>\n<blockquote>\n<p><strong>Alice:</strong> &quot;This <code>references</code> thing sounds clever. So instead of the workflow engine sending the entire history of the process to the LLM for every little step, it just sends the specific outputs it needs?&quot;\n<strong>Bob:</strong> &quot;Precisely. It&#39;s like asking a colleague for help. You don&#39;t retell them the entire history of the project; you just say, &#39;Here&#39;s the customer&#39;s email from yesterday, can you draft a reply?&#39; It keeps the conversation focused and efficient.&quot;</p>\n</blockquote>\n<h2>Integrating Processes with Vessels via a Launcher Macro</h2>\n<p>We&#39;ve established that <code>Vessels</code> operate using a toolkit of <code>Instructions</code>, and that <code>Processes</code> are complex, stateful workflows. The final step is to elegantly connect them. We do this by maintaining the rule that <strong>Vessels only interact with Instructions</strong>, and introducing a generic, reusable macro for kicking off workflows.</p>\n<h3>The <code>LaunchProcess</code> Instruction</h3>\n<p>Instead of having <code>Vessels</code> use <code>Processes</code> directly, they use a special, generic <code>Instruction</code> called <code>LaunchProcess</code>. This <code>Instruction</code> functions as a <strong>macro</strong> that takes a <code>Process</code> Vibe as its main argument.</p>\n<h3>How it Works: Dynamic Fusion at Runtime</h3>\n<ol>\n<li><p><strong>Vessel Action</strong>: A <code>Vessel</code>&#39;s LLM decides it needs to perform a complex task. It chooses the <code>LaunchProcess</code> tool from its toolkit and targets a specific <code>Process</code> Vibe (e.g., <code>BillingReportProcess</code>).</p>\n</li>\n<li><p><strong>Macro Expansion</strong>: The system intercepts this. Instead of showing the LLM the generic <code>LaunchProcess</code> schema, it performs a dynamic fusion:</p>\n<ul>\n<li>It inspects the target <code>BillingReportProcess</code> Vibe.</li>\n<li>It retrieves the pre-compiled <strong>Entrypoint Instruction</strong> (the first LLM-based chunk of the process).</li>\n<li>It wraps this specific Entrypoint Instruction within the <code>LaunchProcess</code> macro&#39;s structure.</li>\n</ul>\n</li>\n<li><p><strong>Unified Tool Presentation</strong>: The LLM is presented with a single, dynamically generated tool schema that looks specific to the task (e.g., &quot;Generate Billing Report&quot;). It contains all the fields from the process&#39;s Entrypoint Instruction.</p>\n</li>\n<li><p><strong>Process Instantiation</strong>: The LLM fills out the fields. The very last step, handled by the <code>LaunchProcess</code> macro&#39;s logic, is the call to the server that instantiates the <code>BillingReportProcess</code> workflow, passing the data the LLM just generated.</p>\n</li>\n</ol>\n<p>This pattern is incredibly powerful:</p>\n<ul>\n<li><strong>Simplicity</strong>: <code>Vessels</code> don&#39;t need to know the internal details of a <code>Process</code>. They only need one tool: <code>LaunchProcess</code>.</li>\n<li><strong>Consistency</strong>: All complex, stateful actions are initiated via the same mechanism.</li>\n<li><strong>Decoupling</strong>: <code>Processes</code> can be designed and updated independently, and as long as their Entrypoint Instruction is valid, any <code>Vessel</code> can launch them.</li>\n</ul>\n<p>By using a macro <code>Instruction</code> as the universal adapter, we create a clean, robust, and scalable bridge between our immediate-execution <code>Vessels</code> and our stateful <code>Processes</code>.</p>\n<blockquote>\n<p><strong>Alice:</strong> &quot;Okay, so my Vessel never actually talks to a <code>Process</code> directly. It just knows one Instruction: <code>LaunchProcess</code>. It&#39;s like having a universal &#39;start button&#39; for any big job?&quot;\n<strong>Bob:</strong> &quot;You&#39;ve got it. The Vessel says, &#39;I want to <code>LaunchProcess</code> for <code>BillingReport</code>.&#39; The system then looks up the <code>BillingReportProcess</code>, finds its specific starting instructions, and hands that &#39;customized&#39; start button back to the Vessel&#39;s LLM to fill out. The Vessel stays clean and simple, while the complex machinery is handled by the Process.&quot;</p>\n</blockquote>\n<h3>The Anatomy of a Compiled <code>Process</code> Vibe</h3>\n<p>To make a <code>Process</code> self-contained and executable, the results of the compilation and partitioning are stored directly within the <code>Process</code> Vibe&#39;s own <code>schema</code>.</p>\n<p>The <code>schema</code> of a <code>Process</code> Vibe contains a standard JSON Schema <code>$defs</code> block. This block holds the entire partitioned pipeline, with each chunk stored as a separate definition. We use a clear naming convention to distinguish the context for each chunk:</p>\n<ul>\n<li><strong><code>LLM_&lt;chunk_name&gt;</code></strong>: A schema for a chunk of steps to be executed in a single call by an LLM.</li>\n<li><strong><code>SERVER_&lt;chunk_name&gt;</code></strong>: A definition for a chunk of one or more activities to be executed on the server by the workflow engine.</li>\n</ul>\n<p>The <code>Process</code>&#39;s <strong>Entrypoint Instruction</strong> is simply a reference to the first <code>LLM_</code> chunk in its <code>$defs</code> (e.g., <code>&quot;$ref&quot;: &quot;#/$defs/LLM_InitialPrompt&quot;</code>).</p>\n<p>When the <code>LaunchProcess</code> macro is used, it dynamically reads the target <code>Process</code> Vibe&#39;s schema, finds the first <code>LLM_</code> definition, and presents that as the tool for the <code>Vessel</code> to execute. This makes every <code>Process</code> a self-describing, launchable entity.</p>\n<h2>Advanced Process Capabilities</h2>\n<p>The <code>Process</code> architecture is built for industrial-scale work, with batching, multiplexing, and concurrency as first-class citizens.</p>\n<h3>Batching, Multiplexing, and Server-Side Iteration</h3>\n<p>A <code>Process</code> is designed to operate on asynchronous streams of data, not just single instances. When a process needs to handle multiple items at once (multiplexing), it does so within a single context switch.</p>\n<ul>\n<li><p><strong>Schema-Level Multiplexing</strong>: The compiled pipeline is a single, flat JSON object where each step is a property, multiplied by the batch size. To manage schema complexity limits and make the structure predictable for the LLM, we avoid nested arrays for batches. Instead, each item in a batch for each step becomes a distinct property. For example, a pipeline with <strong>4 steps</strong> processing a batch of <strong>3 items</strong> would be compiled into a single flat object with <strong>12 top-level properties</strong> (e.g., <code>step1_item1</code>, <code>step1_item2</code>, <code>step1_item3</code>, <code>step2_item1</code>, etc.). This allows the LLM to process the entire batch of work as a single, large object, which is highly efficient.</p>\n</li>\n<li><p><strong>Native Async Iteration</strong>: On the server, the compiled process pipeline maps directly onto an asynchronous iterator, leveraging our <code>@augceo/iterators</code> library. This allows for highly efficient, concurrent processing of both LLM-based and programmatic steps, with built-in support for back-pressure and resource management. This minimizes context switches on the server as well, allowing multiple programmatic steps to execute before needing to call an LLM again.</p>\n</li>\n</ul>\n<p>By combining a powerful, composable <code>Instruction</code> system with a robust, stateful, and batch-oriented <code>Process</code> architecture, we can create a highly scalable and efficient system. <code>Vessels</code> use <code>Instructions</code> for immediate, single-shot tasks, and they act as the initiators for complex <code>Processes</code>, which handle the heavy lifting of stateful, long-running, and data-intensive workflows.</p>\n<h2>Schema Conventions for Compiled Pipelines</h2>\n<p>To make the compiled pipelines unambiguous for both the LLM and the server-side workflow engine, we use a set of clear conventions directly within the JSON schema.</p>\n<h3>1. Prefixes for Special Properties</h3>\n<ul>\n<li><strong><code>_</code> (Underscore Prefix)</strong>: Denotes an internal &quot;thinking&quot; step for the LLM. These are fields the LLM must fill out as part of its reasoning process, but they are considered intermediate work and are not part of the final, primary output.</li>\n<li><strong><code>$</code> (Dollar Sign Prefix)</strong>: Denotes a metric to be logged. When the LLM populates a field like <code>&quot;$qualityScore&quot;: 8</code>, the system automatically captures this as a metric associated with the task, without it cluttering the primary output.</li>\n</ul>\n<h3>2. Defining Pipeline Steps: LLM vs. Server Context</h3>\n<p>Any property within the pipeline schema represents a step. The schema defines how to distinguish between a simple, non-blocking step executed within the LLM&#39;s context and a blocking step that requires a server-side round trip.</p>\n<h4>LLM-Context Steps (Non-Blocking)</h4>\n<p>By default, every step in a pipeline chunk being executed by the LLM is <strong>non-blocking</strong>. The LLM simply fills out the properties of the step&#39;s schema and moves to the next.</p>\n<p>From the LLM&#39;s perspective, there is little difference between a &quot;thinking&quot; step and a step that triggers a fire-and-forget server action. The server-side interpreter is responsible for noticing if the step name (e.g., <code>step3_log_event</code>) matches a registered server activity and executing it asynchronously. The pipeline itself does not wait.</p>\n<pre><code class=\"language-json\">&quot;step3_log_event&quot;: {\n    &quot;description&quot;: &quot;Log an event to the server. Does not block pipeline execution.&quot;,\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n        &quot;eventName&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;const&quot;: &quot;UserAction&quot; },\n        &quot;details&quot;: { &quot;$ref&quot;: &quot;#/properties/_reasoning_for_action&quot; }\n    }\n}\n</code></pre>\n<h4>Server-Context Steps (Blocking)</h4>\n<p>A step is explicitly defined as a <strong>blocking server call</strong> if its schema contains a top-level <code>output</code> property. This property signals to the workflow engine that it must pause execution, run a server-side activity, and wait for a result that conforms to the <code>output</code> schema. The other properties of the step implicitly define its input.</p>\n<p>To make the schema consistent, the <code>output</code> property is made <code>nullable</code>. When an LLM generates a pipeline that includes a blocking step, its job is to set the <code>output</code> field to `</p>\n<pre><code class=\"language-question\">When should a Stateful Process be used instead of a Direct Server Call?\n* [x] For any task that is long-running or needs to survive server restarts.\n* [x] When a server-side action is blocking and its output is required by a subsequent step in the pipeline.\n* [x] For any workflow that requires durable state management for intermediate results.\n* [ ] For any simple, non-blocking side effect like logging or sending a notification.\n* [ ] When the entire workflow can be completed within a single LLM call.\n</code></pre>\n","currentChapter":"New Ideas in This Chapter"}}