<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/docs/assets/static/src_assets_tufte-2d3b6576.BrVfN5Rs.css">
        <meta charset="UTF-8" />
        
    <title>My Vike App</title><meta property="og:title" content="My Vike App" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="/docs/assets/static/logo.DLJJsk-H.svg"/>
    
    <meta name="description" content="Demo showcasing Vike" /><meta property="og:description" content="Demo showcasing Vike" />
    
  
      </head>
      <body>
        
        <div id="root"></div>
        
        <script id="vike_pageContext" type="application/json">{"_urlRewrite":null,"pageId":"\\/src\\/@document\\/@chapter","routeParams":{"document":"blueprint","chapterSlug":"01_vibes_database"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"\\/manifesto\\/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"\\/manifesto\\/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"\\/manifesto\\/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"\\/rfc\\/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"\\/rfc\\/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"\\/rfc\\/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"\\/rfc\\/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"\\/rfc\\/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"\\/rfc\\/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"\\/rfc\\/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"\\/blueprint\\/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"\\/blueprint\\/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"\\/blueprint\\/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"\\/blueprint\\/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"\\/blueprint\\/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"\\/blueprint\\/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"\\/blueprint\\/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"\\/blueprint\\/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"\\/blueprint\\/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"\\/blueprint\\/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"\\/blueprint\\/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"\\/blueprint\\/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"\\/blueprint\\/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"\\/blueprint\\/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"\\/blueprint\\/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"\\/blueprint\\/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"\\/blueprint\\/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"\\/blueprint\\/12_determinism.md"}]},"content":"\u003ch1>Chapter 1 (Appendix): Vibe Database Structure\u003c\\/h1>\n\u003cp>This document details the underlying PostgreSQL database structure that stores and manages Vibes, providing the foundation for the system&#39;s principles of immutability, content-addressability, and verifiable lineage. The design is centered around two core tables, \u003ccode>vibes\u003c\\/code> and \u003ccode>refinements\u003c\\/code>, and a powerful set of functions for dynamically resolving Vibe schemas.\u003c\\/p>\n\u003ch2>Core Tables\u003c\\/h2>\n\u003ch3>The \u003ccode>vibes\u003c\\/code> Table\u003c\\/h3>\n\u003cp>The \u003ccode>vibes\u003c\\/code> table is the heart of the system&#39;s storage. Every Vibe, regardless of its type (Record, Role, Process, or Capability), is stored as a row in this table. It is the immutable ledger of every interaction that has ever occurred.\u003c\\/p>\n\u003cp>Here are the key columns:\u003c\\/p>\n\u003cul>\n\u003cli>\u003ccode>ref\u003c\\/code> (Primary Key): A unique, human-readable text reference for the Vibe, acting as its content-addressable identifier. This is the primary way Vibes are referenced throughout the system.\u003c\\/li>\n\u003cli>\u003ccode>id\u003c\\/code>, \u003ccode>branches\u003c\\/code>, \u003ccode>revision\u003c\\/code>: These columns work together to manage versioning and identity. A Vibe&#39;s conceptual identity is its \u003ccode>id\u003c\\/code>, but it can exist on multiple \u003ccode>branches\u003c\\/code> (e.g., \u003ccode>main\u003c\\/code>, \u003ccode>dev\\/feature-x\u003c\\/code>) and have multiple \u003ccode>revision\u003c\\/code> numbers within those branches. This allows for powerful versioning and experimentation workflows.\u003c\\/li>\n\u003cli>\u003ccode>authorRef\u003c\\/code>: A foreign key to the \u003ccode>ref\u003c\\/code> of the Vibe that created this one, establishing a direct lineage.\u003c\\/li>\n\u003cli>\u003ccode>prototypeRef\u003c\\/code>: A reference to another Vibe that was used as a template, enabling creation by example.\u003c\\/li>\n\u003cli>\u003ccode>refinementId\u003c\\/code>: A reference to the \u003ccode>refinements\u003c\\/code> table, linking the Vibe to the specific \u003ccode>refine\u003c\\/code> operation that produced it.\u003c\\/li>\n\u003cli>\u003ccode>context\u003c\\/code>, \u003ccode>schema\u003c\\/code>, \u003ccode>solution\u003c\\/code>: These three \u003ccode>JSONB\u003c\\/code> columns store the core \u003ccode>{context, schema, solution}\u003c\\/code> triplet that defines a Vibe. The \u003ccode>schema\u003c\\/code> is stored directly, but as we&#39;ll see, it may contain references to other Vibes that need to be resolved.\u003c\\/li>\n\u003cli>\u003ccode>schema_refs\u003c\\/code>: A \u003ccode>TEXT[]\u003c\\/code> column, automatically populated by a trigger, that stores an array of all the \u003ccode>aug:\u003c\\/code> references found within the \u003ccode>schema\u003c\\/code>. This provides a quick way to identify Vibes that have schema dependencies.\u003c\\/li>\n\u003c\\/ul>\n\u003ch3>The \u003ccode>refinements\u003c\\/code> Table\u003c\\/h3>\n\u003cp>The \u003ccode>refinements\u003c\\/code> table acts as a transactional log for every \u003ccode>refine\u003c\\/code> operation. It captures the inputs and context of each state change, providing a complete and auditable history.\u003c\\/p>\n\u003cp>Key columns include:\u003c\\/p>\n\u003cul>\n\u003cli>\u003ccode>id\u003c\\/code>: The primary key for the refinement record.\u003c\\/li>\n\u003cli>\u003ccode>targetRefs\u003c\\/code>, \u003ccode>instructionRefs\u003c\\/code>, \u003ccode>budgetRefs\u003c\\/code>: These text arrays store the \u003ccode>ref\u003c\\/code>s of the Vibes that were used as inputs to the \u003ccode>refine\u003c\\/code> call. This explicitly records the dependencies of the operation.\u003c\\/li>\n\u003cli>\u003ccode>authorRef\u003c\\/code>: The \u003ccode>ref\u003c\\/code> of the Vibe that initiated the refinement.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>Together, these tables create a robust and interconnected graph of all activity in the system, where every Vibe is traceable to its author, its inputs, and the operation that created it.\u003c\\/p>\n\u003ch3>The \u003ccode>vibe_refs\u003c\\/code> Table: The Dependency Graph\u003c\\/h3>\n\u003cp>To provide a complete and efficient way to query the relationships between Vibes, the system maintains a \u003ccode>vibe_refs\u003c\\/code> table. This table stores a denormalized, direct graph of all schema dependencies.\u003c\\/p>\n\u003cp>When a Vibe is created or updated, a trigger function scans its \u003ccode>schema\u003c\\/code> for any \u003ccode>aug:\u003c\\/code> references and populates this table.\u003c\\/p>\n\u003cp>Key columns include:\u003c\\/p>\n\u003cul>\n\u003cli>\u003ccode>from_ref\u003c\\/code>: The \u003ccode>ref\u003c\\/code> of the Vibe containing the schema with the dependency.\u003c\\/li>\n\u003cli>\u003ccode>to_ref\u003c\\/code>: The \u003ccode>ref\u003c\\/code> of the Vibe being referenced within the schema.\u003c\\/li>\n\u003cli>\u003ccode>type\u003c\\/code>: The type of reference (e.g., &#39;schema&#39;).\u003c\\/li>\n\u003cli>\u003ccode>branch\u003c\\/code>, \u003ccode>from_id\u003c\\/code>, \u003ccode>from_revision\u003c\\/code>, \u003ccode>to_id\u003c\\/code>, \u003ccode>to_revision\u003c\\/code>: These columns capture the specific versioning details of both ends of the dependency link.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>This table is a performance optimization that allows the system to quickly answer questions like, &quot;Which Vibes will be affected if we update this specific schema component?&quot; without needing to scan the JSONB content of the entire \u003ccode>vibes\u003c\\/code> table. It makes the dependency graph an explicit and queryable part of the database.\u003c\\/p>\n\u003ch2>Dynamic Schema Resolution and Dependency Graphs\u003c\\/h2>\n\u003cp>A key innovation in the database design is how Vibe schemas are handled. A Vibe&#39;s \u003ccode>schema\u003c\\/code> is not necessarily a static, self-contained document. It can be a composite structure built from other Vibes, enabling powerful reuse and composition. This is achieved through special \u003ccode>aug:\u003c\\/code> references and a database function that resolves them just-in-time.\u003c\\/p>\n\u003ch3>Composable Schemas with \u003ccode>aug:\u003c\\/code> References\u003c\\/h3>\n\u003cp>Within a Vibe&#39;s \u003ccode>schema\u003c\\/code> field, we can embed references to other Vibes using a special URI format, like \u003ccode>aug:\\/common\\/schemas\\/address?1\u003c\\/code> or \u003ccode>aug:~dev\\/user-profile\u003c\\/code>. These references instruct the system to fetch the \u003ccode>schema\u003c\\/code> from the referenced Vibe and embed it into the current one during a resolution step.\u003c\\/p>\n\u003cp>This allows us to create a library of reusable schema components. For example, many different Record Vibes could all reference a canonical \u003ccode>address\u003c\\/code> schema instead of redefining it each time.\u003c\\/p>\n\u003ch3>The \u003ccode>resolveVibeSchema\u003c\\/code> Function and Reference Resolution\u003c\\/h3>\n\u003cp>The magic happens in the \u003ccode>resolveVibeSchema\u003c\\/code> PostgreSQL function and the surrounding application logic. When a client submits a Vibe, its \u003ccode>schema\u003c\\/code> can contain unresolved references that need to be processed. The system is designed to handle several cases gracefully.\u003c\\/p>\n\u003cp>Inside a schema, a reference to another Vibe can be represented by an object containing specific keys:\u003c\\/p>\n\u003cul>\n\u003cli>\u003ccode>$ref\u003c\\/code>: An \u003ccode>aug:\u003c\\/code> URI string pointing to a conceptual Vibe (e.g., \u003ccode>aug:\\/schemas\\/user\u003c\\/code>). This indicates that the system should find the \u003cstrong>latest appropriate version\u003c\\/strong> of that Vibe based on the current context (e.g., the current branch and timestamp).\u003c\\/li>\n\u003cli>\u003ccode>$refOriginal\u003c\\/code>: An \u003ccode>aug:\u003c\\/code> URI string pointing to a \u003cstrong>specific, versioned Vibe\u003c\\/strong> (e.g., \u003ccode>aug:\\/schemas\\/user?1\u003c\\/code>). This is used when the client has already resolved the reference to a specific version and wants to use that exact one.\u003c\\/li>\n\u003cli>\u003ccode>$refResolved\u003c\\/code>: This property is added by the system during the resolution process. It contains the canonical, fully-resolved \u003ccode>ref\u003c\\/code> of the Vibe version that was used to populate the schema, ensuring a permanent record of the exact dependency.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>The resolution logic, typically in a database trigger or application service, works as follows:\u003c\\/p>\n\u003col>\n\u003cli>It traverses the incoming \u003ccode>schema\u003c\\/code> looking for objects that contain a \u003ccode>$ref\u003c\\/code> or \u003ccode>$refOriginal\u003c\\/code> key, but do \u003cstrong>not\u003c\\/strong> already have a \u003ccode>$refResolved\u003c\\/code> key.\u003c\\/li>\n\u003cli>If an object has \u003ccode>$ref\u003c\\/code>, the system queries the database to find the correct version of the Vibe based on the URI and the current context (branch, date, etc.).\u003c\\/li>\n\u003cli>If an object has \u003ccode>$refOriginal\u003c\\/code>, the system uses that exact Vibe version.\u003c\\/li>\n\u003cli>Once the correct dependency Vibe is identified, its schema is recursively resolved and embedded.\u003c\\/li>\n\u003cli>The system then adds the \u003ccode>$refResolved\u003c\\/code> property to the object, storing the canonical \u003ccode>ref\u003c\\/code> of the dependency that was used (e.g., \u003ccode>main@schemas\\/user?1\u003c\\/code>).\u003c\\/li>\n\u003c\\/ol>\n\u003cp>This ensures that all schemas are fully resolved and their dependencies are explicitly recorded at the time of creation or update. The process is idempotent; if a schema is processed again, the system sees the \u003ccode>$refResolved\u003c\\/code> property and knows not to re-resolve that dependency.\u003c\\/p>\n\u003cp>This explicit dependency information, captured in the final resolved schema, is invaluable. It provides a complete, verifiable dependency graph of how any given Vibe is constructed, underpinning the system&#39;s traceability and allowing us to understand the precise impact of any change.\u003c\\/p>\n","currentChapter":"Core Tables"}}</script>
        <script id="vike_globalContext" type="application/json">{}</script>
        <script src="/docs/assets/entries/entry-client-routing.CGxaIKAB.js" type="module" async></script>
        <link rel="modulepreload" href="/docs/assets/entries/src_-document_-chapter.C_7418N7.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-FZmpFa9c.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-tfHUaCBC.js" as="script" type="text/javascript">
      </body>
    </html>