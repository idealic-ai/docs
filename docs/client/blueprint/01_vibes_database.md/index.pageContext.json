{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"blueprint","chapterSlug":"01_vibes_database"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>Chapter 1 (Appendix): Vibe Database Structure</h1>\n<p>This document details the underlying PostgreSQL database structure that stores and manages Vibes, providing the foundation for the system&#39;s principles of immutability, content-addressability, and verifiable lineage. The design is centered around two core tables, <code>vibes</code> and <code>refinements</code>, and a powerful set of functions for dynamically resolving Vibe schemas.</p>\n<h2>Core Tables</h2>\n<h3>The <code>vibes</code> Table</h3>\n<p>The <code>vibes</code> table is the heart of the system&#39;s storage. Every Vibe, regardless of its type (Record, Role, Process, or Capability), is stored as a row in this table. It is the immutable ledger of every interaction that has ever occurred.</p>\n<p>Here are the key columns:</p>\n<ul>\n<li><code>ref</code> (Primary Key): A unique, human-readable text reference for the Vibe, acting as its content-addressable identifier. This is the primary way Vibes are referenced throughout the system.</li>\n<li><code>id</code>, <code>branches</code>, <code>revision</code>: These columns work together to manage versioning and identity. A Vibe&#39;s conceptual identity is its <code>id</code>, but it can exist on multiple <code>branches</code> (e.g., <code>main</code>, <code>dev/feature-x</code>) and have multiple <code>revision</code> numbers within those branches. This allows for powerful versioning and experimentation workflows.</li>\n<li><code>authorRef</code>: A foreign key to the <code>ref</code> of the Vibe that created this one, establishing a direct lineage.</li>\n<li><code>prototypeRef</code>: A reference to another Vibe that was used as a template, enabling creation by example.</li>\n<li><code>refinementId</code>: A reference to the <code>refinements</code> table, linking the Vibe to the specific <code>refine</code> operation that produced it.</li>\n<li><code>context</code>, <code>schema</code>, <code>solution</code>: These three <code>JSONB</code> columns store the core <code>{context, schema, solution}</code> triplet that defines a Vibe. The <code>schema</code> is stored directly, but as we&#39;ll see, it may contain references to other Vibes that need to be resolved.</li>\n<li><code>schema_refs</code>: A <code>TEXT[]</code> column, automatically populated by a trigger, that stores an array of all the <code>aug:</code> references found within the <code>schema</code>. This provides a quick way to identify Vibes that have schema dependencies.</li>\n</ul>\n<h3>The <code>refinements</code> Table</h3>\n<p>The <code>refinements</code> table acts as a transactional log for every <code>refine</code> operation. It captures the inputs and context of each state change, providing a complete and auditable history.</p>\n<p>Key columns include:</p>\n<ul>\n<li><code>id</code>: The primary key for the refinement record.</li>\n<li><code>targetRefs</code>, <code>instructionRefs</code>, <code>budgetRefs</code>: These text arrays store the <code>ref</code>s of the Vibes that were used as inputs to the <code>refine</code> call. This explicitly records the dependencies of the operation.</li>\n<li><code>authorRef</code>: The <code>ref</code> of the Vibe that initiated the refinement.</li>\n</ul>\n<p>Together, these tables create a robust and interconnected graph of all activity in the system, where every Vibe is traceable to its author, its inputs, and the operation that created it.</p>\n<h3>The <code>vibe_refs</code> Table: The Dependency Graph</h3>\n<p>To provide a complete and efficient way to query the relationships between Vibes, the system maintains a <code>vibe_refs</code> table. This table stores a denormalized, direct graph of all schema dependencies.</p>\n<p>When a Vibe is created or updated, a trigger function scans its <code>schema</code> for any <code>aug:</code> references and populates this table.</p>\n<p>Key columns include:</p>\n<ul>\n<li><code>from_ref</code>: The <code>ref</code> of the Vibe containing the schema with the dependency.</li>\n<li><code>to_ref</code>: The <code>ref</code> of the Vibe being referenced within the schema.</li>\n<li><code>type</code>: The type of reference (e.g., &#39;schema&#39;).</li>\n<li><code>branch</code>, <code>from_id</code>, <code>from_revision</code>, <code>to_id</code>, <code>to_revision</code>: These columns capture the specific versioning details of both ends of the dependency link.</li>\n</ul>\n<p>This table is a performance optimization that allows the system to quickly answer questions like, &quot;Which Vibes will be affected if we update this specific schema component?&quot; without needing to scan the JSONB content of the entire <code>vibes</code> table. It makes the dependency graph an explicit and queryable part of the database.</p>\n<h2>Dynamic Schema Resolution and Dependency Graphs</h2>\n<p>A key innovation in the database design is how Vibe schemas are handled. A Vibe&#39;s <code>schema</code> is not necessarily a static, self-contained document. It can be a composite structure built from other Vibes, enabling powerful reuse and composition. This is achieved through special <code>aug:</code> references and a database function that resolves them just-in-time.</p>\n<h3>Composable Schemas with <code>aug:</code> References</h3>\n<p>Within a Vibe&#39;s <code>schema</code> field, we can embed references to other Vibes using a special URI format, like <code>aug:/common/schemas/address?1</code> or <code>aug:~dev/user-profile</code>. These references instruct the system to fetch the <code>schema</code> from the referenced Vibe and embed it into the current one during a resolution step.</p>\n<p>This allows us to create a library of reusable schema components. For example, many different Record Vibes could all reference a canonical <code>address</code> schema instead of redefining it each time.</p>\n<h3>The <code>resolveVibeSchema</code> Function and Reference Resolution</h3>\n<p>The magic happens in the <code>resolveVibeSchema</code> PostgreSQL function and the surrounding application logic. When a client submits a Vibe, its <code>schema</code> can contain unresolved references that need to be processed. The system is designed to handle several cases gracefully.</p>\n<p>Inside a schema, a reference to another Vibe can be represented by an object containing specific keys:</p>\n<ul>\n<li><code>$ref</code>: An <code>aug:</code> URI string pointing to a conceptual Vibe (e.g., <code>aug:/schemas/user</code>). This indicates that the system should find the <strong>latest appropriate version</strong> of that Vibe based on the current context (e.g., the current branch and timestamp).</li>\n<li><code>$refOriginal</code>: An <code>aug:</code> URI string pointing to a <strong>specific, versioned Vibe</strong> (e.g., <code>aug:/schemas/user?1</code>). This is used when the client has already resolved the reference to a specific version and wants to use that exact one.</li>\n<li><code>$refResolved</code>: This property is added by the system during the resolution process. It contains the canonical, fully-resolved <code>ref</code> of the Vibe version that was used to populate the schema, ensuring a permanent record of the exact dependency.</li>\n</ul>\n<p>The resolution logic, typically in a database trigger or application service, works as follows:</p>\n<ol>\n<li>It traverses the incoming <code>schema</code> looking for objects that contain a <code>$ref</code> or <code>$refOriginal</code> key, but do <strong>not</strong> already have a <code>$refResolved</code> key.</li>\n<li>If an object has <code>$ref</code>, the system queries the database to find the correct version of the Vibe based on the URI and the current context (branch, date, etc.).</li>\n<li>If an object has <code>$refOriginal</code>, the system uses that exact Vibe version.</li>\n<li>Once the correct dependency Vibe is identified, its schema is recursively resolved and embedded.</li>\n<li>The system then adds the <code>$refResolved</code> property to the object, storing the canonical <code>ref</code> of the dependency that was used (e.g., <code>main@schemas/user?1</code>).</li>\n</ol>\n<p>This ensures that all schemas are fully resolved and their dependencies are explicitly recorded at the time of creation or update. The process is idempotent; if a schema is processed again, the system sees the <code>$refResolved</code> property and knows not to re-resolve that dependency.</p>\n<p>This explicit dependency information, captured in the final resolved schema, is invaluable. It provides a complete, verifiable dependency graph of how any given Vibe is constructed, underpinning the system&#39;s traceability and allowing us to understand the precise impact of any change.</p>\n","currentChapter":"Core Tables"}}