<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/docs/assets/static/src_assets_tufte-2d3b6576.BrVfN5Rs.css">
        <meta charset="UTF-8" />
        
    <title>My Vike App</title><meta property="og:title" content="My Vike App" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="/docs/assets/static/logo.DLJJsk-H.svg"/>
    
    <meta name="description" content="Demo showcasing Vike" /><meta property="og:description" content="Demo showcasing Vike" />
    
  
      </head>
      <body>
        
        <div id="root"></div>
        
        <script id="vike_pageContext" type="application/json">{"_urlRewrite":null,"pageId":"\\/src\\/@document\\/@chapter","routeParams":{"document":"blueprint","chapterSlug":"02_instructions_examples"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"\\/manifesto\\/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"\\/manifesto\\/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"\\/manifesto\\/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"\\/rfc\\/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"\\/rfc\\/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"\\/rfc\\/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"\\/rfc\\/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"\\/rfc\\/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"\\/rfc\\/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"\\/rfc\\/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"\\/blueprint\\/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"\\/blueprint\\/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"\\/blueprint\\/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"\\/blueprint\\/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"\\/blueprint\\/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"\\/blueprint\\/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"\\/blueprint\\/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"\\/blueprint\\/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"\\/blueprint\\/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"\\/blueprint\\/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"\\/blueprint\\/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"\\/blueprint\\/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"\\/blueprint\\/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"\\/blueprint\\/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"\\/blueprint\\/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"\\/blueprint\\/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"\\/blueprint\\/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"\\/blueprint\\/12_determinism.md"}]},"content":"\u003ch1>Chapter 2.1: Instruction Examples\u003c\\/h1>\n\u003ch2>Example 1: Process Scheduling\u003c\\/h2>\n\u003cp>This example demonstrates how to structure a complex, multi-step process that involves different execution contexts (LLM, server, user). The process is designed to schedule a meeting, requiring participant identification, availability checks, time slot selection, and invitation management. Each context switch is explicitly modeled, and data dependencies between steps are clearly defined through references. The process shows how to handle both immediate LLM operations and long-running server tasks within a single, coherent workflow.\u003c\\/p>\n\u003cp>\u003cstrong>Nested Expression:\u003c\\/strong>\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">\\/\\/ Send the approved invitation\nSendInvitation_Activity(\n  \\/\\/ Get user approval for the drafted invitation\n  ConfirmInvitation_User(\n    \\/\\/ Create invitation with participants and selected time slot\n    DraftInvitation(\n      \\/\\/ Extract participant info from user&#39;s request\n      participants: IdentifyParticipants(prompt),\n      \\/\\/ Find a time that works for both participants\n      slot: FindCommonSlot(\n        \\/\\/ Get calendar data for identified participants\n        FetchAvailability_Activity(IdentifyParticipants(prompt)))\n      )\n    )\n  )\n)\n\u003c\\/code>\u003c\\/pre>\n\u003cp>Or alternatively:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-typescript\">\\/\\/ Extract participant info from user&#39;s request\nconst participants = IdentifyParticipants(prompt);\n\n\\/\\/ Get calendar data for identified participants\nconst availabilityParams = FetchAvailability(participants);\nconst availabilityData = FetchAvailability_Activity(availabilityParams);\n\n\\/\\/ Find a time that works for both participants\nconst commonSlot = FindCommonSlot(availabilityData);\n\n\\/\\/ Create invitation with participants and selected time slot\nconst invitation = DraftInvitation(participants, commonSlot);\n\n\\/\\/ Get user approval for the drafted invitation\nconst approval = ConfirmInvitation_User(invitation);\n\n\\/\\/ Send the approved invitation\nconst result = SendInvitation_Activity(approval);\n\u003c\\/code>\u003c\\/pre>\n\u003cp>Flattened Expression in pseudo code:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">Process(\n  \\/\\/ LLM determines participants and prepares calendar query parameters\n  LLM_Context({\n    participants: IdentifyParticipants(prompt),\n    availabilityParams: FetchAvailability({ participants }),\n  }),\n\n  \\/\\/ Server fetches actual calendar data\n  Server_Context({\n    availabilityData: FetchAvailability_Activity({ availabilityParams }),\n  }),\n\n  \\/\\/ LLM analyzes availability and creates invitation\n  LLM_Context({\n    commonSlot: FindCommonSlot({ availabilityData }),\n    invitation: DraftInvitation({ participants, commonSlot }),\n  }),\n\n  \\/\\/ User reviews and approves the invitation\n  User_Context({\n    approval: ConfirmInvitation_User({ invitation }),\n  }),\n\n  \\/\\/ Server sends out the approved invitation\n  Server_Context({\n    result: SendInvitation_Activity({ invitation, approval }),\n  })\n);\n\u003c\\/code>\u003c\\/pre>\n\u003cp>This example demonstrates how a complex, multi-step process is initiated through a simple, focused instruction. The process has multiple steps (identifying participants, fetching availability, finding slots, drafting &amp; confirming invitations), but the initial instruction focuses only on what&#39;s needed to start.\u003c\\/p>\n\u003cp>It&#39;s important to note that only the first LLM context (\u003ccode>LLM_Context\u003c\\/code> with \u003ccode>IdentifyParticipants\u003c\\/code> and \u003ccode>FetchAvailability\u003c\\/code>) serves as the entry point to the entire process - this initial LLM interaction becomes the inciting logic that starts the workflow, after which it becomes part of a process vibe that carries the state through its lifecycle, maintaining context and data dependencies between steps while ensuring that each subsequent action (whether performed by the server, LLM, or user) has access to the information it needs from previous steps. The vessel merely facilitates this interaction but does not itself become the process.\u003c\\/p>\n\u003ch3>The Process Schema\u003c\\/h3>\n\u003cp>This schema is part of a vibe \u003ccode>aug:processes\\/schedule-meeting:1\u003c\\/code> that exists as a prototype of the complete meeting scheduling workflow with all its steps and data dependencies. Later in this explanation, we will show how a vessel can instantiate this process by completing its first step in the process of working with LLM context.\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">{\n  &quot;$schema&quot;: &quot;https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema&quot;,\n  &quot;title&quot;: &quot;Process: Schedule Meeting&quot;,\n  &quot;description&quot;: &quot;A durable process to schedule a meeting, involving both LLM and server steps.&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;llmContext1&quot;: {\n      &quot;title&quot;: &quot;Initial Setup and Parameter Preparation&quot;,\n      &quot;description&quot;: &quot;LLM identifies participants and prepares parameters for server operations&quot;,\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;identifyParticipants1&quot;: {\n          &quot;title&quot;: &quot;Identify Meeting Participants&quot;,\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;organizer&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;The person initiating the meeting.&quot;\n            },\n            &quot;attendee&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;The person being invited.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;organizer&quot;, &quot;attendee&quot;]\n        },\n        &quot;fetchAvailability&quot;: {\n          &quot;title&quot;: &quot;Prepare Availability Fetch Parameters&quot;,\n          &quot;references&quot;: [&quot;identifyParticipants&quot;],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;organizerId&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;The system identifier for the organizer, derived from identifyParticipants.organizer.&quot;\n            },\n            &quot;attendeeId&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;The system identifier for the attendee, derived from identifyParticipants.attendee.&quot;\n            },\n            &quot;timeRange&quot;: {\n              &quot;type&quot;: &quot;object&quot;,\n              &quot;properties&quot;: {\n                &quot;start&quot;: {\n                  &quot;type&quot;: &quot;string&quot;,\n                  &quot;format&quot;: &quot;date-time&quot;,\n                  &quot;description&quot;: &quot;The start of the time range to check for availability.&quot;\n                },\n                &quot;end&quot;: {\n                  &quot;type&quot;: &quot;string&quot;,\n                  &quot;format&quot;: &quot;date-time&quot;,\n                  &quot;description&quot;: &quot;The end of the time range to check for availability.&quot;\n                }\n              },\n              &quot;required&quot;: [&quot;start&quot;, &quot;end&quot;]\n            }\n          },\n          &quot;required&quot;: [&quot;organizerId&quot;, &quot;attendeeId&quot;, &quot;timeRange&quot;]\n        }\n      },\n      &quot;required&quot;: [&quot;identifyParticipants&quot;, &quot;fetchAvailability&quot;]\n    },\n    &quot;serverContext1&quot;: {\n      &quot;title&quot;: &quot;Data Retrieval and Processing&quot;,\n      &quot;description&quot;: &quot;Server fetches and processes calendar availability data&quot;,\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;FetchAvailability_Activity&quot;: {\n          &quot;title&quot;: &quot;Calendar Availability Results&quot;,\n          &quot;references&quot;: [&quot;llmContext1.fetchAvailability&quot;],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;organizerSlots&quot;: {\n              &quot;type&quot;: &quot;array&quot;,\n              &quot;items&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;date-time&quot; },\n              &quot;description&quot;: &quot;Available time slots for the organizer.&quot;\n            },\n            &quot;attendeeSlots&quot;: {\n              &quot;type&quot;: &quot;array&quot;,\n              &quot;items&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;date-time&quot; },\n              &quot;description&quot;: &quot;Available time slots for the attendee.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;organizerSlots&quot;, &quot;attendeeSlots&quot;]\n        }\n      },\n      &quot;required&quot;: [&quot;FetchAvailability_Activity&quot;]\n    },\n    &quot;llmContext2&quot;: {\n      &quot;title&quot;: &quot;Meeting Time Selection and Communication Draft&quot;,\n      &quot;description&quot;: &quot;LLM analyzes availability and prepares meeting invitation&quot;,\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;findCommonSlot&quot;: {\n          &quot;title&quot;: &quot;Find Common Available Slot&quot;,\n          &quot;references&quot;: [\n            &quot;llmContext1.identifyParticipants&quot;,\n            &quot;serverContext1.FetchAvailability_Activity&quot;\n          ],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;selectedSlot&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;format&quot;: &quot;date-time&quot;,\n              &quot;description&quot;: &quot;The chosen meeting time that works for both participants.&quot;\n            },\n            &quot;reasoning&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;Explanation for why this slot was chosen.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;selectedSlot&quot;, &quot;reasoning&quot;]\n        },\n        &quot;draftInvitation&quot;: {\n          &quot;title&quot;: &quot;Draft Invitation&quot;,\n          &quot;references&quot;: [&quot;llmContext1.identifyParticipants&quot;, &quot;findCommonSlot&quot;],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;subject&quot;: { &quot;type&quot;: &quot;string&quot; },\n            &quot;body&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;description&quot;: &quot;The full text of the invitation email.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;subject&quot;, &quot;body&quot;]\n        }\n      },\n      &quot;required&quot;: [&quot;findCommonSlot&quot;, &quot;draftInvitation&quot;]\n    },\n    &quot;userContext&quot;: {\n      &quot;title&quot;: &quot;User Decision Point&quot;,\n      &quot;description&quot;: &quot;Awaits user approval of the proposed meeting details&quot;,\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;confirmInvitation&quot;: {\n          &quot;title&quot;: &quot;Get User Confirmation&quot;,\n          &quot;references&quot;: [&quot;llmContext2.draftInvitation&quot;],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;decision&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;enum&quot;: [&quot;Approve&quot;, &quot;Reject&quot;],\n              &quot;description&quot;: &quot;The user&#39;s decision on the proposed meeting.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;decision&quot;]\n        }\n      },\n      &quot;required&quot;: [&quot;confirmInvitation&quot;]\n    },\n    &quot;serverContext2&quot;: {\n      &quot;title&quot;: &quot;Final Communication Dispatch&quot;,\n      &quot;description&quot;: &quot;Server sends out the approved meeting invitation&quot;,\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;sendInvitation&quot;: {\n          &quot;title&quot;: &quot;Send Invitation&quot;,\n          &quot;references&quot;: [\n            &quot;llmContext1.identifyParticipants&quot;,\n            &quot;llmContext2.draftInvitation&quot;,\n            &quot;userContext.confirmInvitation&quot;\n          ],\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;properties&quot;: {\n            &quot;messageId&quot;: { &quot;type&quot;: &quot;string&quot; },\n            &quot;status&quot;: { &quot;type&quot;: &quot;string&quot; }\n          },\n          &quot;required&quot;: [&quot;messageId&quot;, &quot;status&quot;]\n        }\n      },\n      &quot;required&quot;: [&quot;sendInvitation&quot;]\n    }\n  },\n  &quot;required&quot;: [&quot;llmContext1&quot;, &quot;serverContext1&quot;, &quot;llmContext2&quot;, &quot;userContext&quot;, &quot;serverContext2&quot;]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003ch3>Focused Data Flow with \u003ccode>references\u003c\\/code>\u003c\\/h3>\n\u003cp>The \u003ccode>references\u003c\\/code> meta-property seen in the schema above is the key to managing data flow and context size. The workflow engine uses this property to inject only the necessary data from previous steps into the LLM prompt for the current step.\u003c\\/p>\n\u003cp>Let&#39;s look at a focused example. Imagine a step \u003ccode>step5_draft_email\u003c\\/code> that needs the user&#39;s name from a previous step, \u003ccode>step4_find_user\u003c\\/code>. The schema would look like this:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">&quot;step5_draft_email&quot;: {\n    &quot;description&quot;: &quot;Draft a personalized email to the user found in the previous step.&quot;,\n    &quot;references&quot;: [ &quot;step4_find_user.output&quot; ],\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n        &quot;recipientName&quot;: {\n            &quot;description&quot;: &quot;Use the &#39;userName&#39; field from the &#39;step4_find_user.output&#39; object provided in the prompt context.&quot;,\n            &quot;type&quot;: &quot;string&quot;\n        },\n        &quot;emailBody&quot;: { &quot;type&quot;: &quot;string&quot; }\n    }\n}\n\u003c\\/code>\u003c\\/pre>\n\u003cp>The workflow engine processes this:\u003c\\/p>\n\u003col>\n\u003cli>It sees \u003ccode>references: [ &quot;step4_find_user.output&quot; ]\u003c\\/code>.\u003c\\/li>\n\u003cli>It retrieves the entire output object \u003ccode>{ &quot;userId&quot;: &quot;...&quot;, &quot;userName&quot;: &quot;...&quot; }\u003c\\/code> from its state.\u003c\\/li>\n\u003cli>It constructs a minimal context and injects it into the prompt for the LLM.\u003c\\/li>\n\u003c\\/ol>\n\u003cpre>\n--- Context from previous steps ---\n{\n    \"step4_find_user\": {\n        \"output\": {\n            \"userId\": \"u-12345\",\n            \"userName\": \"Jane Doe\"\n        }\n    }\n}\n--- End Context ---\n\nPlease generate the JSON for the `step5_draft_email` step using the information provided above.\n\u003c\\/pre>\n\n\u003col start=\"4\">\n\u003cli>It sends the schema for \u003ccode>step5_draft_email\u003c\\/code> to the LLM, but \u003cstrong>without the \u003ccode>references\u003c\\/code> property\u003c\\/strong>. The LLM then uses the provided context to follow the instructions in the \u003ccode>description\u003c\\/code> fields. This provides a clean and powerful mechanism for piping data from server-side actions back into the LLM&#39;s reasoning process.\u003c\\/li>\n\u003c\\/ol>\n\u003cp>This ensures the LLM receives only the information it needs, preventing context overload and keeping the interaction efficient. The large \u003ccode>Process: Schedule Meeting\u003c\\/code> schema uses this pattern extensively to pass information between LLM, server, and user contexts.\u003c\\/p>\n\u003ch2>The Modular Schema\u003c\\/h2>\n\u003cp>Instead of exposing the entire complex process schema to the LLM, we create a tool specifically for \u003cem>initiating\u003c\\/em> the process. This tool is derived by taking the first LLM context from Example 1 and enhancing it with additional cognitive steps through Instruction composition.\u003c\\/p>\n\u003cp>Let&#39;s trace how this composition works, starting from the original process structure.\u003c\\/p>\n\u003ch3>Using Instructions for Cognitive Enhancement\u003c\\/h3>\n\u003cp>Instructions can compose with each other because their schemas merge like JavaScript objects, and JSON Schema preserves property order. This enables macro-like Instructions that wrap other Instructions while injecting additional steps:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">{\n  &quot;$schema&quot;: &quot;https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema&quot;,\n  &quot;title&quot;: &quot;Introspection_Mixin&quot;,\n  &quot;description&quot;: &quot;An instruction that enhances any schema with pre-action analysis and post-action reflection through natural composition&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;_considerations&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;description&quot;: &quot;Before performing the action, analyze the request and outline key considerations.&quot;\n    },\n    &quot;default&quot;: {\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;description&quot;: &quot;This is a placeholder that will be replaced by the target&#39;s schema at runtime.&quot;\n    },\n    &quot;_feedback&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;description&quot;: &quot;After completing the action, provide feedback about the decisions made.&quot;\n    }\n  },\n  &quot;required&quot;: [&quot;_considerations&quot;, &quot;default&quot;, &quot;_feedback&quot;]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003cp>When this Instruction composes with another, the \u003ccode>default\u003c\\/code> property acts as a slot that gets replaced by the other schema&#39;s properties. Because property order is preserved, we get \u003ccode>_considerations\u003c\\/code> first, then all the properties from the composed schema, then \u003ccode>_feedback\u003c\\/code> - creating a macro-like wrapper that injects thinking steps around the main task.\u003c\\/p>\n\u003ch3>Composing the Tool\u003c\\/h3>\n\u003cp>Here&#39;s how we transform the first LLM context from Example 1 into our tool:\u003c\\/p>\n\u003cp>Original Process first LLM context chunk looks like this:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">const llmContext1 = FetchAvailability(IdentifyParticipants(prompt));\n\u003c\\/code>\u003c\\/pre>\n\u003cp>Vessel wraps it with process initiation and introspection:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">StartProcess({\n  name: &#39;ScheduleMeeting&#39;,\n  llmContext1: Introspect_Mixin(FetchAvailability(IdentifyParticipants(prompt))),\n});\n\u003c\\/code>\u003c\\/pre>\n\u003cp>Introspect_Mixin is a mixin instruction that accepts named properties:\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">StartProcess({\n  name: &#39;ScheduleMeeting&#39;,\n  llmContext1: Introspect_Mixin({\n    default: {\n      identifyParticipants: IdentifyParticipants(prompt),\n      fetchAvailability: FetchAvailability({ participants }),\n    },\n  }),\n});\n\u003c\\/code>\u003c\\/pre>\n\u003cp>This yields jsonschema composition where the instructions are composed together. Note how we use the \u003ccode>description\u003c\\/code> field to instruct how arguments should be passed between steps - for example, the \u003ccode>fetchAvailability\u003c\\/code> description indicates that it should reuse participant emails from the identification step. This approach allows for clear data flow between instruction components without requiring explicit parameter declarations.\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-ts\">{\n  &quot;$schema&quot;: &quot;https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema&quot;,\n  &quot;title&quot;: &quot;Start Scheduling Process&quot;,\n  &quot;description&quot;: &quot;Initiates the meeting scheduling workflow with participant identification and availability checking&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;allOf&quot;: [\n    { &quot;$ref&quot;: &quot;aug:\\/vibes\\/macros\\/StartProcess:1&quot; },\n    {\n      &quot;properties&quot;: {\n        &quot;name&quot;: { &quot;const&quot;: &quot;ScheduleMeeting&quot; },\n        &quot;llmContext1&quot;: {\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;allOf&quot;: [\n            { &quot;$ref&quot;: &quot;aug:\\/vibes\\/macros\\/Introspect_Mixin&quot; },\n            { &quot;$ref&quot;: &quot;aug:\\/vibes\\/macros\\/Loop_Mixin&quot;, description: &quot;Loop at most 3 trimes&quot; },\n            {\n              &quot;properties&quot;: {\n                &quot;default&quot;: {\n                  &quot;type&quot;: &quot;object&quot;,\n                  &quot;properties&quot;: {\n                    &quot;identifyParticipants&quot;: {\n                      &quot;allOf&quot;: [\n                        { &quot;$ref&quot;: &quot;aug:instructions\\/identifyParticipants&quot; },\n                        { &quot;description&quot;: &quot;Extracts and identifies participant information from the user&#39;s prompt, determining who should be included in the meeting&quot; }\n                      ]\n                    },\n                    &quot;fetchAvailability&quot;: {\n                      &quot;allOf&quot;: [\n                        { &quot;$ref&quot;: &quot;aug:processes\\/schedule-meeting:1#fetchAvailability&quot; },\n                        { &quot;description&quot;: &quot;Retrieves calendar availability data for identified participants, reusing participant emails from the identification step to check their schedules: llm_context_1.identifyParticipant&quot; }\n                      ]\n                    }\n                  }\n                }\n              }\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003cp>This is what it looks like when mixin is expanded and llm does its job\u003c\\/p>\n\u003cblockquote>\n\u003cp>Prompt: Assistant, schedule a meeting between alice and bob!\u003c\\/p>\n\u003c\\/blockquote>\n\u003cpre>\u003ccode class=\"language-ts\">StartProcess({\n  name: &#39;ScheduleMeeting&#39;,\n  llmContext1: {\n    _considerations: &quot;Need to check both participants&#39; availability within business hours&quot;,\n    identifyParticipants: {\n      organizer: &#39;alice@example.com&#39;,\n      attendee: &#39;bob@example.com&#39;,\n    },\n    fetchAvailability: {\n      organizerEmail: &#39;alice@example.com&#39;, \\/\\/ Reused from identifyParticipants\n      attendeeEmail: &#39;bob@example.com&#39;, \\/\\/ Reused from identifyParticipants\n      timeRange: {\n        start: &#39;2024-03-20T09:00:00Z&#39;,\n        end: &#39;2024-03-20T17:00:00Z&#39;,\n      },\n    },\n    _feedback:\n      &#39;Prepared to check availability for Alice and Bob during their workday. Once complete, the process will continue with finding common slots.&#39;,\n  },\n});\n\u003c\\/code>\u003c\\/pre>\n\u003cp>This shows how the schema&#39;s structure guides the LLM to:\u003c\\/p>\n\u003col>\n\u003cli>Think through considerations before acting (\u003ccode>_considerations\u003c\\/code>)\u003c\\/li>\n\u003cli>Provide complete, well-structured data for the initial operations\u003c\\/li>\n\u003cli>Reuse participant emails directly from the identification step\u003c\\/li>\n\u003cli>Reflect on both the immediate step and the process continuation (\u003ccode>_feedback\u003c\\/code>)\u003c\\/li>\n\u003cli>Start the \u003ccode>ScheduleMeeting\u003c\\/code> process explicitly on the server and continue there\u003c\\/li>\n\u003c\\/ol>\n\u003ch3>The Composed Tool Schema\u003c\\/h3>\n\u003cp>This is the final schema presented to the LLM, with all references resolved. It merges vessel&#39;s own adjustments with tool definitions (e.g. instructions on how to pass output from one step to another)\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">{\n  &quot;$schema&quot;: &quot;https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema&quot;,\n  &quot;title&quot;: &quot;Vessel Toolkit: Meeting Scheduler&quot;,\n  &quot;description&quot;: &quot;A set of tools available to the Vessel for scheduling meetings.&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;name&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;const&quot;: &quot;ScheduleMeeting&quot;,\n      &quot;description&quot;: &quot;Identifies the process being started&quot;\n    },\n    &quot;llmContext1&quot;: {\n      &quot;type&quot;: &quot;object&quot;,\n      &quot;properties&quot;: {\n        &quot;_considerations&quot;: {\n          &quot;type&quot;: &quot;string&quot;,\n          &quot;description&quot;: &quot;Before performing the action, analyze the request and outline key considerations.&quot;\n        },\n        &quot;identifyParticipants&quot;: {\n          &quot;title&quot;: &quot;Identify Meeting Participants&quot;,\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;description&quot;: &quot;Identifies meeting participants from user input\\nExtracts and identifies participant information from the user&#39;s prompt, determining who should be included in the meeting&quot;,\n          &quot;properties&quot;: {\n            &quot;organizer&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;format&quot;: &quot;email&quot;,\n              &quot;description&quot;: &quot;Email of the person initiating the meeting.&quot;\n            },\n            &quot;attendee&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;format&quot;: &quot;email&quot;,\n              &quot;description&quot;: &quot;Email of the person being invited.&quot;\n            }\n          },\n          &quot;required&quot;: [&quot;organizer&quot;, &quot;attendee&quot;]\n        },\n        &quot;fetchAvailability&quot;: {\n          &quot;title&quot;: &quot;Fetch Participant Availability&quot;,\n          &quot;type&quot;: &quot;object&quot;,\n          &quot;description&quot;: &quot;Fetches calendar availability for specified participants\\nRetrieves calendar availability data for identified participants, reusing participant emails from the identification step to check their schedules&quot;,\n          &quot;properties&quot;: {\n            &quot;organizerEmail&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;format&quot;: &quot;email&quot;,\n              &quot;description&quot;: &quot;Email of organizer&quot;\n            },\n            &quot;attendeeEmail&quot;: {\n              &quot;type&quot;: &quot;string&quot;,\n              &quot;format&quot;: &quot;email&quot;,\n              &quot;description&quot;: &quot;Email of attendee.&quot;\n            },\n            &quot;timeRange&quot;: {\n              &quot;type&quot;: &quot;object&quot;,\n              &quot;properties&quot;: {\n                &quot;start&quot;: {\n                  &quot;type&quot;: &quot;string&quot;,\n                  &quot;format&quot;: &quot;date-time&quot;,\n                  &quot;description&quot;: &quot;The start of the time range to check for availability.&quot;\n                },\n                &quot;end&quot;: {\n                  &quot;type&quot;: &quot;string&quot;,\n                  &quot;format&quot;: &quot;date-time&quot;,\n                  &quot;description&quot;: &quot;The end of the time range to check for availability.&quot;\n                }\n              },\n              &quot;required&quot;: [&quot;start&quot;, &quot;end&quot;]\n            }\n          },\n          &quot;required&quot;: [&quot;organizerEmail&quot;, &quot;attendeeEmail&quot;, &quot;timeRange&quot;]\n        },\n        &quot;_feedback&quot;: {\n          &quot;type&quot;: &quot;string&quot;,\n          &quot;description&quot;: &quot;After completing the action, provide feedback about the decisions made.&quot;\n        }\n      },\n      &quot;required&quot;: [&quot;_considerations&quot;, &quot;identifyParticipants&quot;, &quot;fetchAvailability&quot;, &quot;_feedback&quot;]\n    }\n  },\n  &quot;required&quot;: [&quot;name&quot;, &quot;llmContext1&quot;]\n}\n\u003c\\/code>\u003c\\/pre>\n","currentChapter":"Example 1: Process Scheduling"}}</script>
        <script id="vike_globalContext" type="application/json">{}</script>
        <script src="/docs/assets/entries/entry-client-routing.CGxaIKAB.js" type="module" async></script>
        <link rel="modulepreload" href="/docs/assets/entries/src_-document_-chapter.C_7418N7.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-FZmpFa9c.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-tfHUaCBC.js" as="script" type="text/javascript">
      </body>
    </html>