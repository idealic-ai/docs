{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"rfc","chapterSlug":"04_agent_instancing"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>The Instancing Protocol</h1>\n<p><em>For definitions of key terms used in this document, please refer to the <a href=\"./00_glossary.md\">Glossary</a>.</em></p>\n<p>This document outlines a protocol for processing multiple, independent instances within a single agent request, using a state-driven architecture.</p>\n<h2>1. Foundational Requirement: The State System</h2>\n<p>The core prerequisite for this instancing protocol is the <strong>State System</strong>, which explicitly decouples the planning of actions from their execution.</p>\n<p>The <strong>State Object</strong> is the bridge between these phases. It is a mutable, JSON-like object that serves two critical functions:</p>\n<ol>\n<li><strong>Target for Execution</strong>: It is the canvas upon which tools operate. Every <code>Tool Call</code> includes an <code>_outputPath</code> property, which specifies a path within the <code>State</code> object where the tool&#39;s output should be written during execution.</li>\n<li><strong>Source for Dependencies</strong>: A <code>Tool Call</code> can reference a value from the <code>State</code> as one of its inputs. This allows for the creation of dependency graphs.</li>\n</ol>\n<h2>2. The Instancing Mechanism</h2>\n<p>The true power of this architecture is revealed in its native support for multi-instance operations, which is enabled by the State System.</p>\n<h3>2.1. State Identifiers</h3>\n<p>To process multiple instances in a single request, the system accepts an array of context messages. Each message representing a distinct instance is assigned a <strong>unique identifier</strong> via a special <code>_instance</code> property. These identifiers are short, unique tokens (e.g., circled numbers like <code>①</code>, <code>②</code>) that are easily visible to the LLM but carry no semantic meaning beyond their function as a reference.</p>\n<h3>2.2. Targeted Operations</h3>\n<p>This <code>_instance</code> is then used to target all operations to a specific instance&#39;s context. Furthermore, all meta-parameters for a <code>Tool Call</code> are prefixed with an underscore (<code>_</code>), and its <code>params</code> are inlined directly into the call object.</p>\n<ul>\n<li><strong><code>Tool Call</code> Association</strong>: Each <code>Tool Call</code> in the generated plan contains the <code>_instance</code> of the context it should operate on.</li>\n<li><strong>Implicit Scoping</strong>: The <code>_instance</code> on a <code>Tool Call</code> implicitly scopes all path-based operations (<code>_outputPath</code> and input references) within that call. This means that when a tool reads from or writes to a state object, the path is relative to the <code>_instance</code> of the context it belongs to.</li>\n</ul>\n<p>This mechanism allows the definitions of the tools themselves to remain simple and agnostic of the instancing context. The <code>_outputPath</code> and input references within a tool&#39;s schema do not need to be updated; the identifier cleanly separates the operational contexts.</p>\n<h3>2.3. Example</h3>\n<p>A single request might contain two state objects for sentiment analysis. The schema for the state can be provided to constrain the available properties and guide the LLM.</p>\n<pre><code class=\"language-json\">{\n  &quot;context&quot;: [\n    {\n      &quot;_instance&quot;: &quot;①&quot;,\n      &quot;type&quot;: &quot;state&quot;,\n      &quot;state&quot;: { &quot;text&quot;: &quot;This is wonderful!&quot; },\n      &quot;schema&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;properties&quot;: {\n          &quot;text&quot;: { &quot;type&quot;: &quot;string&quot; },\n          &quot;sentiment&quot;: { &quot;type&quot;: &quot;string&quot; }\n        },\n        &quot;required&quot;: [&quot;text&quot;]\n      }\n    },\n    { &quot;_instance&quot;: &quot;②&quot;, &quot;type&quot;: &quot;state&quot;, &quot;state&quot;: { &quot;text&quot;: &quot;This is terrible.&quot; } }\n  ]\n}\n</code></pre>\n<p>The LLM processes both in a single context and generates a unified plan:</p>\n<pre><code class=\"language-json\">{\n  &quot;calls&quot;: [\n    {\n      &quot;_tool&quot;: &quot;analyzeSentiment&quot;,\n      &quot;_instance&quot;: &quot;①&quot;,\n      &quot;text&quot;: &quot;†state.text&quot;,\n      &quot;_outputPath&quot;: &quot;sentiment&quot;\n    },\n    {\n      &quot;_tool&quot;: &quot;analyzeSentiment&quot;,\n      &quot;_instance&quot;: &quot;②&quot;,\n      &quot;text&quot;: &quot;†state.text&quot;,\n      &quot;_outputPath&quot;: &quot;sentiment&quot;\n    }\n  ]\n}\n</code></pre>\n<p>The host environment then executes this plan, writing the results to the respective state objects.</p>\n<h2>3. Complementary System: The Planning Graph</h2>\n<p>While not a strict requirement for instancing, the <strong>Planning System</strong> works symbiotically with this architecture to enable highly predictable, reusable workflows.</p>\n<p>A <strong>Plan</strong> is a template for a process, defined as a directed acyclic graph (DAG) of <code>Tool Calls</code>. This graph is generated by analyzing the dependencies between tools reading from and writing to a <code>State Object</code>.</p>\n<p>Crucially, this plan can be generated and perfected <em>before</em> execution. Once finalized, the plan can be passed as a <code>Context Message</code> to the agent. When processing multiple instances, the agent can then follow this pre-defined plan for each <code>State Object</code>, achieving highly consistent and predictable results across multiple invocations. The <code>State Object</code> for each instance serves as a snapshot of its current position within that execution graph.</p>\n<h2>4. Advantages of this Approach</h2>\n<p>This state-driven instancing model provides significant benefits:</p>\n<ul>\n<li><strong>Efficiency</strong>: It multiplies the throughput of the system by processing many instances in a single LLM request, dramatically improving speed and reducing costs.</li>\n<li><strong>Consistency &amp; Quality</strong>: By allowing the LLM to see multiple related instances in a single context, it can generate more consistent and higher-quality plans, leveraging patterns across all instances.</li>\n<li><strong>Predictability</strong>: When combined with a pre-defined <strong>Plan</strong>, the system can achieve deterministic outcomes. The deterministic execution loop ensures that once a plan is followed, its outcome is reliable and repeatable across every instance.</li>\n</ul>\n","currentChapter":"1. Foundational Requirement: The State System"}}