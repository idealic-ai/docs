{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"rfc","chapterSlug":"01_protocol_ideas"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>The Idea Protocol</h1>\n<p><em>For definitions of key terms used in this document, please refer to the [Glossary](./00. glossary.md).</em></p>\n<p>This document outlines the architecture for a decentralized web of living documents. It covers the protocol&#39;s core data structure (the <strong>Idea</strong>), the agents that operate on them (<strong>Ideators</strong>), and the decentralized discovery mechanism for publishing and resolving them via <strong>DNS</strong>.</p>\n<h2>The Mechanics of a Living Web</h2>\n<p>The architecture is built on a radical principle: <strong>the content is the protocol.</strong> The system&#39;s entire grammar consists of a single unit: a self-contained &quot;triplet&quot; called the <strong>Idea</strong>. This structure enables true ownership and portability; because there is no hidden state, you are never locked in.</p>\n<ul>\n<li><strong>Context:</strong> All the instructions, source material, and references used to generate the solution.</li>\n<li><strong>Schema:</strong> The <code>jsonschema</code> blueprint that gives the Idea&#39;s data a universal, semantic meaning, allowing any AI to understand and modify it.</li>\n<li><strong>Solution:</strong> The output, result, or content of the Idea.</li>\n</ul>\n<p>Ideas are <strong>immutable by design</strong>. The protocol has only one action: sharing an Idea. To evolve a thought, a new Idea is created that references the old, preserving a pristine, unbreakable chain of creation.</p>\n<h2>Ideators: Ideas with Inputs</h2>\n<p>An <strong>Ideator</strong> is not a distinct entity, but a functional role any <code>Idea</code> can fulfill. It can be seen as a function that performs work by transforming input into output within a <strong>latent space</strong>. This means its logic is not necessarily defined by explicit code, but is instead guided by the rich <code>context</code> of the <code>Idea</code>—its schemas, examples, and natural language instructions—which are interpreted by an LLM.</p>\n<p>This latent execution is what makes an Idea more than just a document. It is a living entity, ready to be adjusted, remixed, improved, and reused. Because the logic is interpreted by a capable LLM, anyone in the network can process any Idea without being restricted by proprietary code. This openness fosters a radical democracy of creation.</p>\n<p>The definitive signal that an <code>Idea</code> is an Ideator is the presence of a <code>context</code> message with <code>type: &quot;input&quot;</code>. This message defines the schema for the data the Ideator expects. For more deterministic control over the latent logic, the <code>context</code> can include structured instructions or even pseudocode.</p>\n<p>An <em>executable</em> Ideator is one that chooses to bypass the latent space for fully deterministic operations by including a <code>context</code> message with <code>type: &quot;code&quot;</code>, pointing to an explicit implementation.</p>\n<h3>The Idea Transformer: A Special Case</h3>\n<p>A common and powerful pattern is an Ideator whose input is itself another <code>Idea</code>. We call this specific type of Ideator an <strong>Idea Transformer</strong>. This is what enables the compositional pipelines described in the Edict of Autonomy, where Ideas are chained together and evolved.</p>\n<p>However, an Ideator&#39;s input can be any data that conforms to its input schema, not just a formal <code>Idea</code> triplet.</p>\n<p>In short:</p>\n<ul>\n<li>An <strong>Idea</strong> is a self-contained unit of data (<code>solution</code>, <code>schema</code>, <code>context</code>).</li>\n<li>An <strong>Ideator</strong> is any <code>Idea</code> that accepts an input (signified by <code>type: &quot;input&quot;</code>).</li>\n<li>An <strong>Idea Transformer</strong> is a specialized Ideator that takes another <code>Idea</code> as its input.</li>\n</ul>\n<h3>The Idea Document Specification</h3>\n<p>The following example shows the JSON document for a simple &quot;Commenter&quot; Ideator. This single document contains everything needed to understand and execute it.</p>\n<p><em>Example <code>commenter.json</code> content:</em></p>\n<pre><code class=\"language-json\">{\n  &quot;schema&quot;: {\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n      &quot;author&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;The author of the comment.&quot;\n      },\n      &quot;body&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;The content of the comment.&quot;\n      }\n    },\n    &quot;required&quot;: [&quot;author&quot;, &quot;body&quot;]\n  },\n  &quot;solution&quot;: {\n    &quot;author&quot;: &quot;John Doe&quot;,\n    &quot;body&quot;: &quot;Great post on decentralization! This is a really important topic.&quot;\n  },\n  &quot;context&quot;: [\n    {\n      &quot;type&quot;: &quot;system&quot;,\n      &quot;content&quot;: &quot;You are an Ideator that takes an &#39;Article&#39; Idea and produces a &#39;Comment&#39; Idea. The schema for the input &#39;Article&#39; is provided below.&quot;\n    },\n    {\n      &quot;type&quot;: &quot;input&quot;,\n      &quot;schema&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;properties&quot;: {\n          &quot;title&quot;: { &quot;type&quot;: &quot;string&quot; },\n          &quot;content&quot;: { &quot;type&quot;: &quot;string&quot; }\n        },\n        &quot;required&quot;: [&quot;title&quot;, &quot;content&quot;]\n      },\n      &quot;input&quot;: {\n        &quot;title&quot;: &quot;On Decentralization&quot;,\n        &quot;content&quot;: &quot;A short essay on the importance of decentralized systems...&quot;\n      }\n    },\n    { &quot;type&quot;: &quot;code&quot;, &quot;url&quot;: &quot;https://.../code/commenter-1.2.3.js&quot; }\n  ]\n}\n</code></pre>\n<h2>Beyond the Prompt: A New Computational Primitive</h2>\n<p>At first glance, an <code>Idea</code> might seem like a glorified prompt for a large language model (LLM). This is a common misconception. The key difference lies in the shift from single, ephemeral interactions to a system of persistent, composable assets.</p>\n<p>Unlike a simple, ephemeral request to a chatbot, an <code>Idea</code> is a self-contained, stateful artifact. It packages the <code>input</code>, the <code>output</code> (<code>solution</code>), the rules (<code>schema</code>), and the entire <code>context</code> of its creation into a single, portable unit. It&#39;s not just a question; it&#39;s the question, the answer, and the complete formula that connects them, enabling a persistent, composable system, not just a one-off transaction.</p>\n<p>This makes an <code>Idea</code> a true computational primitive—a building block for creating complex, evolving systems. You don&#39;t just &quot;run&quot; an Idea; you can fork it, remix it, feed it into other Ideas, and build entire pipelines of logic, all without writing traditional code. It&#39;s a platform, not a prompt.</p>\n<h2>From Single Ideas to Stateful Systems: A Gaming Analogy</h2>\n<p>To understand how <code>Ideas</code> compose into systems, consider a platform designed to host bots that can play <em>any</em> game.</p>\n<p>The platform itself doesn&#39;t need to know the rules of poker, chess, or backgammon. It only handles the generic mechanics: matchmaking players, managing turns, and tracking game state. The <em>semantics</em> of the specific game being played are encapsulated entirely within an <code>Idea</code> that travels through the system.</p>\n<ul>\n<li>An <code>Idea</code> document defines the current state of a poker table: the players, the cards, the pot size. Its <code>schema</code> defines the rules for a valid next move.</li>\n<li>The platform passes this <code>Idea</code> to a bot (an <code>Ideator</code>).</li>\n<li>The bot, using latent execution, processes the <code>Idea</code> and produces a new one representing the next game state (e.g., after it makes a bet).</li>\n</ul>\n<p>The platform can manage a complex, multi-user, stateful poker game without having a single line of poker-specific code. If the users want to play chess, they simply introduce a new <code>Idea</code> with the rules and state of chess. The system adapts instantly. This illustrates the power of separating the operational mechanics of a platform from the semantic logic contained within the <code>Idea</code>.</p>\n<hr>\n<h2>Publication &amp; Discovery via DNS</h2>\n<p>DNS provides a globally unique, resolvable name for any Idea, allowing for a fully self-describing system where any service can be understood by fetching a single definition file. This section outlines the layered architecture for this decentralized discovery and resolution system.</p>\n<h3>The Layered Architecture</h3>\n<p>The ecosystem is structured in six distinct layers (0-5), each building upon the last. This model allows creators to participate at the level that suits their needs, from a simple, decentralized identity to a fully-featured, managed web service. The core principle is that only Layer 0 is essential; everything else is an optional enhancement.</p>\n<p>It&#39;s helpful to view this model as a spectrum of autonomy with two endpoints. At one end, <strong>Layer 0</strong> provides the most fundamental autonomy: by controlling just a DNS record, a creator has complete freedom to host their tool&#39;s source anywhere, decoupling its identity from its storage. At the other end of the spectrum lies <strong>full sovereignty</strong>: using a custom domain and self-hosting all services, effectively becoming one&#39;s own provider. The managed layers (1-5) serve as an optional, progressive bridge between these two states of autonomy.</p>\n<h3>Layer 0: DNS Discovery (The Core Protocol)</h3>\n<p>This is the bedrock of the entire system. It is the only mandatory layer and establishes a decentralized identity.</p>\n<ul>\n<li><strong>How It Works:</strong> An Idea (which can also be an executable Ideator) is given a unique domain name. A <code>TXT</code> record is created for that domain containing an <code>idea</code> key pointing to a canonical JSON document. This document defines the Idea&#39;s complete interface: its output <code>schema</code>, an optional example <code>solution</code>, and an optional <code>context</code> array defining its lineage and instructions, such as its <code>input</code> schema and a <code>code</code> URL.</li>\n<li><strong>Purpose:</strong> This provides a globally unique, resolvable name for any component, allowing for a fully self-describing system where any service can be understood by fetching a single definition file.</li>\n<li><strong>Provider Cost:</strong> Negligible. Limited to the cost of hosting DNS records.</li>\n</ul>\n<hr>\n<h3>Layer 1: Managed Hosting</h3>\n<p>This layer provides an immediate, zero-friction hosting solution for the Ideator source file itself.</p>\n<ul>\n<li><strong>How It Works:</strong> As an easy entry point, we offer to host a user&#39;s Ideator source file on our S3 bucket. The <code>TXT</code> record we create for their managed subdomain will point to this S3 URL. At any time, the user can choose to host the file elsewhere and update their <code>TXT</code> record to point to the new location (e.g., their own server, IPFS, etc.).</li>\n<li><strong>Purpose:</strong> To eliminate the need for creators to arrange their own file hosting just to get started.</li>\n<li><strong>Provider Cost:</strong> Minimal. Limited to S3 storage and data transfer costs.</li>\n</ul>\n<hr>\n<h3>Layer 2: Static UI Generation</h3>\n<p>This layer makes Ideators accessible and useful to humans with zero server-side compute.</p>\n<ul>\n<li><strong>How It Works:</strong> A generic, static web page (e.g., an <code>index.html</code> hosted on S3 or GitHub Pages) is served for all Ideator domains that opt into this service. When a user visits <code>my-tool.ideators.network</code> in a browser, client-side JavaScript on that page performs a DNS-over-HTTPS (DoH) query to fetch the <code>TXT</code> record for the domain, retrieves the source URL (from Layer 1 hosting), fetches the Ideator&#39;s definition file, and dynamically renders a user interface.</li>\n<li><strong>Purpose:</strong> Provides a free, instantly usable web app for any Ideator, lowering the barrier to entry for both creators and users.</li>\n<li><strong>Provider Cost:</strong> Minimal. Limited to the cost of static file hosting and bandwidth.</li>\n</ul>\n<hr>\n<h3>Layer 3: CDN-Powered <code>GET</code> Endpoint</h3>\n<p>This layer enhances machine-to-machine interoperability for reading an Idea&#39;s definition, without requiring serverless functions.</p>\n<ul>\n<li><strong>How It Works:</strong> By placing a CDN in front of the hosting layer, we can use request rewriting rules. A <code>GET</code> request to an Idea&#39;s domain (<code>my-tool.ideators.network</code>) is intelligently routed by the CDN. Instead of serving raw JSON, the endpoint can dynamically generate and serve a JavaScript module. This allows developers to use <strong>named exports</strong> to import specific parts of the <code>Idea</code> directly, for example: <code>import { schema } from &#39;...&#39;</code>. To provide strong typing for developers, the response can also include an <code>X-TypeScript-Types</code> header pointing to a TypeScript declaration file (<code>.d.ts</code>).</li>\n<li><strong>Purpose:</strong> To provide a best-in-class developer experience. This approach enables powerful and idiomatic programmatic access, allowing developers to import an entire <code>Idea</code> or just the specific parts they need (like the <code>schema</code> or <code>solution</code>) using standard ES6 import syntax with full type-safety. The raw <code>Idea</code> document remains accessible to other HTTP clients via an <code>Accept: application/json</code> header.</li>\n<li><strong>Provider Cost:</strong> Low. Limited to CDN traffic costs, with no compute charges.</li>\n</ul>\n<hr>\n<h3>Layer 4: Publishing (<code>PUT</code>)</h3>\n<p>This layer provides the ability to publish and update an Idea programmatically.</p>\n<ul>\n<li><strong>How It Works:</strong> This layer handles authenticated <code>PUT</code> requests to an Idea&#39;s domain. A single request can upload a new version of the Idea&#39;s source file. A managed service would handle the file upload and atomically update any necessary records to make the new version live.</li>\n<li><strong>Purpose:</strong> To provide a secure and simple API for creators to manage the lifecycle of their Ideas without direct access to the underlying hosting or DNS.</li>\n<li><strong>Provider Cost (Managed):</strong> Minimal, related to storage write operations.</li>\n</ul>\n<hr>\n<h3>Layer 5: Full API Execution (<code>POST</code>)</h3>\n<p>This is the highest layer of functionality, transforming an Ideator into a true, invocable web service. This layer requires compute.</p>\n<ul>\n<li><strong>How It Works:</strong> This layer handles <code>POST</code> requests to an Ideator&#39;s domain, executing its logic. There are two implementation paths:<ol>\n<li><strong>Self-Hosted:</strong> A user delegates their subdomain&#39;s DNS (<code>NS</code> records) to their own server and implements the full API protocol, including the <code>POST</code> method. They bear all hosting and compute costs.</li>\n<li><strong>Managed Service (Optional):</strong> We can offer a managed endpoint using serverless compute (e.g., CloudFront Functions). This service would resolve the Ideator, execute its logic, and return the result.</li>\n</ol>\n</li>\n<li><strong>Important Consideration:</strong> The managed version of this layer is the only part of the ecosystem with significant, scaling operational costs for us (e.g., ~$0.10 per 1 million invocations). Therefore, this managed service is an <strong>optional, premium feature</strong>. It may be rate-limited, offered only to specific partners, or provided as a paid service.</li>\n<li><strong>Purpose:</strong> To provide the full power of a serverless architecture, allowing anyone to publish a fully functional microservice with just a static definition file.</li>\n<li><strong>Provider Cost (Managed):</strong> Direct, usage-based compute and traffic costs.</li>\n</ul>\n<h3>API Specification &amp; Usage Example</h3>\n<p>This section defines the technical specifications for discovering and interacting with an Idea&#39;s endpoint.</p>\n<h4>DNS <code>TXT</code> Record Specification</h4>\n<p>The <code>TXT</code> record is a simple pointer to the Idea&#39;s full definition.</p>\n<ul>\n<li><code>idea=&lt;url&gt;</code>: <strong>(Required)</strong> The URL pointing to the canonical Idea JSON document.</li>\n<li><code>page=&lt;url&gt;</code>: <strong>(Optional)</strong> A URL to a human-readable landing page.</li>\n</ul>\n<p><em>Example TXT record content:</em> <code>&quot;idea=https://.../commenter.json page=.../docs&quot;</code></p>\n<h4>HTTP Endpoint Specification</h4>\n<p>All HTTP interactions happen at the root of the Idea&#39;s domain (<code>/</code>).</p>\n<ul>\n<li><strong><code>GET /</code></strong><ul>\n<li>With <code>Accept: text/html</code> header (Layer 2): Returns the static UI loader or redirects to the <code>page</code> URL.</li>\n<li>With <code>Accept: application/json</code> header (Layer 3): Returns the Idea&#39;s source JSON file.</li>\n</ul>\n</li>\n<li><strong><code>PUT /</code></strong> (Layer 4)<ul>\n<li>Requires authentication. A single <code>PUT</code> request both uploads the new Idea source file and atomically updates the <code>code</code> URL in the <code>TXT</code> record to make the new version live.</li>\n</ul>\n</li>\n<li><strong><code>POST /</code></strong> (Layer 5)<ul>\n<li>Requires authentication/authorization. Executes the Ideator.</li>\n<li>The request body is a JSON object containing the payload, e.g., <code>{&quot;context&quot;: &quot;The user&#39;s input to be processed&quot;}</code>.</li>\n</ul>\n</li>\n</ul>\n<h4>Usage Example (<code>curl</code>)</h4>\n<pre><code class=\"language-bash\"># Target Ideator domain\nIDEATOR=&quot;commenter.ideators.network&quot;\n\n# Layer 0 (Step 1): Discover the Idea Document URL\nIDEA_URL=$(dig +short TXT $IDEATOR | grep -o &#39;idea=[^ &quot;]*&#39; | cut -d&#39;=&#39; -f2)\necho &quot;Idea Document is at: $IDEA_URL&quot;\n\n# Layer 0 (Step 2): Fetch the full definition\n# This single JSON file contains everything needed to understand the Ideator\ncurl &quot;$IDEA_URL&quot;\n\n# Layer 5: Execute the Ideator with a payload\ncurl &quot;https://$IDEATOR&quot; -X POST \\\n     -H &quot;Content-Type: application/json&quot; \\\n     -d &#39;{&quot;context&quot;: [{\\lf\n          &quot;type&quot;: &quot;input&quot;,\\\n          &quot;input&quot;: {\\\n            &quot;title&quot;: &quot;On Decentralization&quot;,\\\n            &quot;content&quot;: &quot;A short essay on the importance of decentralized systems...&quot;\\\n          }]}&#39;\n</code></pre>\n<h2>Summary of Autonomy</h2>\n<p>This layered model provides a clear path for users:</p>\n<ul>\n<li>Anyone can start at <strong>Layers 0-2</strong> with a managed subdomain, getting free source file hosting and a functional UI with minimal effort.</li>\n<li>They can opt-in to the convenience of <strong>Layer 3</strong> for better programmatic access.</li>\n<li>They can use the managed <strong>Layer 4</strong> service for full API power, subject to its conditions.</li>\n<li>At any time, they can delegate their DNS to self-host their own solution, taking full control over their implementation of Layers 3 and 4.</li>\n<li>Finally, they can use their own custom domain to achieve complete sovereignty (becoming their own provider of all layers).</li>\n</ul>\n","currentChapter":"The Mechanics of a Living Web"}}