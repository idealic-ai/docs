<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/docs/assets/static/src_assets_tufte-2d3b6576.BrVfN5Rs.css">
        <meta charset="UTF-8" />
        
    <title>My Vike App</title><meta property="og:title" content="My Vike App" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="/docs/assets/static/logo.DLJJsk-H.svg"/>
    
    <meta name="description" content="Demo showcasing Vike" /><meta property="og:description" content="Demo showcasing Vike" />
    
  
      </head>
      <body>
        
        <div id="root"></div>
        
        <script id="vike_pageContext" type="application/json">{"_urlRewrite":null,"pageId":"\\/src\\/@document\\/@chapter","routeParams":{"document":"rfc","chapterSlug":"01_protocol_ideas"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"\\/manifesto\\/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"\\/manifesto\\/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"\\/manifesto\\/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"\\/rfc\\/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"\\/rfc\\/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"\\/rfc\\/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"\\/rfc\\/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"\\/rfc\\/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"\\/rfc\\/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"\\/rfc\\/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"\\/blueprint\\/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"\\/blueprint\\/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"\\/blueprint\\/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"\\/blueprint\\/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"\\/blueprint\\/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"\\/blueprint\\/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"\\/blueprint\\/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"\\/blueprint\\/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"\\/blueprint\\/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"\\/blueprint\\/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"\\/blueprint\\/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"\\/blueprint\\/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"\\/blueprint\\/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"\\/blueprint\\/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"\\/blueprint\\/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"\\/blueprint\\/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"\\/blueprint\\/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"\\/blueprint\\/12_determinism.md"}]},"content":"\u003ch1>The Idea Protocol\u003c\\/h1>\n\u003cp>\u003cem>For definitions of key terms used in this document, please refer to the [Glossary](.\\/00. glossary.md).\u003c\\/em>\u003c\\/p>\n\u003cp>This document outlines the architecture for a decentralized web of living documents. It covers the protocol&#39;s core data structure (the \u003cstrong>Idea\u003c\\/strong>), the agents that operate on them (\u003cstrong>Ideators\u003c\\/strong>), and the decentralized discovery mechanism for publishing and resolving them via \u003cstrong>DNS\u003c\\/strong>.\u003c\\/p>\n\u003ch2>The Mechanics of a Living Web\u003c\\/h2>\n\u003cp>The architecture is built on a radical principle: \u003cstrong>the content is the protocol.\u003c\\/strong> The system&#39;s entire grammar consists of a single unit: a self-contained &quot;triplet&quot; called the \u003cstrong>Idea\u003c\\/strong>. This structure enables true ownership and portability; because there is no hidden state, you are never locked in.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Context:\u003c\\/strong> All the instructions, source material, and references used to generate the solution.\u003c\\/li>\n\u003cli>\u003cstrong>Schema:\u003c\\/strong> The \u003ccode>jsonschema\u003c\\/code> blueprint that gives the Idea&#39;s data a universal, semantic meaning, allowing any AI to understand and modify it.\u003c\\/li>\n\u003cli>\u003cstrong>Solution:\u003c\\/strong> The output, result, or content of the Idea.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>Ideas are \u003cstrong>immutable by design\u003c\\/strong>. The protocol has only one action: sharing an Idea. To evolve a thought, a new Idea is created that references the old, preserving a pristine, unbreakable chain of creation.\u003c\\/p>\n\u003ch2>Ideators: Ideas with Inputs\u003c\\/h2>\n\u003cp>An \u003cstrong>Ideator\u003c\\/strong> is not a distinct entity, but a functional role any \u003ccode>Idea\u003c\\/code> can fulfill. It can be seen as a function that performs work by transforming input into output within a \u003cstrong>latent space\u003c\\/strong>. This means its logic is not necessarily defined by explicit code, but is instead guided by the rich \u003ccode>context\u003c\\/code> of the \u003ccode>Idea\u003c\\/code>—its schemas, examples, and natural language instructions—which are interpreted by an LLM.\u003c\\/p>\n\u003cp>This latent execution is what makes an Idea more than just a document. It is a living entity, ready to be adjusted, remixed, improved, and reused. Because the logic is interpreted by a capable LLM, anyone in the network can process any Idea without being restricted by proprietary code. This openness fosters a radical democracy of creation.\u003c\\/p>\n\u003cp>The definitive signal that an \u003ccode>Idea\u003c\\/code> is an Ideator is the presence of a \u003ccode>context\u003c\\/code> message with \u003ccode>type: &quot;input&quot;\u003c\\/code>. This message defines the schema for the data the Ideator expects. For more deterministic control over the latent logic, the \u003ccode>context\u003c\\/code> can include structured instructions or even pseudocode.\u003c\\/p>\n\u003cp>An \u003cem>executable\u003c\\/em> Ideator is one that chooses to bypass the latent space for fully deterministic operations by including a \u003ccode>context\u003c\\/code> message with \u003ccode>type: &quot;code&quot;\u003c\\/code>, pointing to an explicit implementation.\u003c\\/p>\n\u003ch3>The Idea Transformer: A Special Case\u003c\\/h3>\n\u003cp>A common and powerful pattern is an Ideator whose input is itself another \u003ccode>Idea\u003c\\/code>. We call this specific type of Ideator an \u003cstrong>Idea Transformer\u003c\\/strong>. This is what enables the compositional pipelines described in the Edict of Autonomy, where Ideas are chained together and evolved.\u003c\\/p>\n\u003cp>However, an Ideator&#39;s input can be any data that conforms to its input schema, not just a formal \u003ccode>Idea\u003c\\/code> triplet.\u003c\\/p>\n\u003cp>In short:\u003c\\/p>\n\u003cul>\n\u003cli>An \u003cstrong>Idea\u003c\\/strong> is a self-contained unit of data (\u003ccode>solution\u003c\\/code>, \u003ccode>schema\u003c\\/code>, \u003ccode>context\u003c\\/code>).\u003c\\/li>\n\u003cli>An \u003cstrong>Ideator\u003c\\/strong> is any \u003ccode>Idea\u003c\\/code> that accepts an input (signified by \u003ccode>type: &quot;input&quot;\u003c\\/code>).\u003c\\/li>\n\u003cli>An \u003cstrong>Idea Transformer\u003c\\/strong> is a specialized Ideator that takes another \u003ccode>Idea\u003c\\/code> as its input.\u003c\\/li>\n\u003c\\/ul>\n\u003ch3>The Idea Document Specification\u003c\\/h3>\n\u003cp>The following example shows the JSON document for a simple &quot;Commenter&quot; Ideator. This single document contains everything needed to understand and execute it.\u003c\\/p>\n\u003cp>\u003cem>Example \u003ccode>commenter.json\u003c\\/code> content:\u003c\\/em>\u003c\\/p>\n\u003cpre>\u003ccode class=\"language-json\">{\n  &quot;schema&quot;: {\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n      &quot;author&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;The author of the comment.&quot;\n      },\n      &quot;body&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;description&quot;: &quot;The content of the comment.&quot;\n      }\n    },\n    &quot;required&quot;: [&quot;author&quot;, &quot;body&quot;]\n  },\n  &quot;solution&quot;: {\n    &quot;author&quot;: &quot;John Doe&quot;,\n    &quot;body&quot;: &quot;Great post on decentralization! This is a really important topic.&quot;\n  },\n  &quot;context&quot;: [\n    {\n      &quot;type&quot;: &quot;system&quot;,\n      &quot;content&quot;: &quot;You are an Ideator that takes an &#39;Article&#39; Idea and produces a &#39;Comment&#39; Idea. The schema for the input &#39;Article&#39; is provided below.&quot;\n    },\n    {\n      &quot;type&quot;: &quot;input&quot;,\n      &quot;schema&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;properties&quot;: {\n          &quot;title&quot;: { &quot;type&quot;: &quot;string&quot; },\n          &quot;content&quot;: { &quot;type&quot;: &quot;string&quot; }\n        },\n        &quot;required&quot;: [&quot;title&quot;, &quot;content&quot;]\n      },\n      &quot;input&quot;: {\n        &quot;title&quot;: &quot;On Decentralization&quot;,\n        &quot;content&quot;: &quot;A short essay on the importance of decentralized systems...&quot;\n      }\n    },\n    { &quot;type&quot;: &quot;code&quot;, &quot;url&quot;: &quot;https:\\/\\/...\\/code\\/commenter-1.2.3.js&quot; }\n  ]\n}\n\u003c\\/code>\u003c\\/pre>\n\u003ch2>Beyond the Prompt: A New Computational Primitive\u003c\\/h2>\n\u003cp>At first glance, an \u003ccode>Idea\u003c\\/code> might seem like a glorified prompt for a large language model (LLM). This is a common misconception. The key difference lies in the shift from single, ephemeral interactions to a system of persistent, composable assets.\u003c\\/p>\n\u003cp>Unlike a simple, ephemeral request to a chatbot, an \u003ccode>Idea\u003c\\/code> is a self-contained, stateful artifact. It packages the \u003ccode>input\u003c\\/code>, the \u003ccode>output\u003c\\/code> (\u003ccode>solution\u003c\\/code>), the rules (\u003ccode>schema\u003c\\/code>), and the entire \u003ccode>context\u003c\\/code> of its creation into a single, portable unit. It&#39;s not just a question; it&#39;s the question, the answer, and the complete formula that connects them, enabling a persistent, composable system, not just a one-off transaction.\u003c\\/p>\n\u003cp>This makes an \u003ccode>Idea\u003c\\/code> a true computational primitive—a building block for creating complex, evolving systems. You don&#39;t just &quot;run&quot; an Idea; you can fork it, remix it, feed it into other Ideas, and build entire pipelines of logic, all without writing traditional code. It&#39;s a platform, not a prompt.\u003c\\/p>\n\u003ch2>From Single Ideas to Stateful Systems: A Gaming Analogy\u003c\\/h2>\n\u003cp>To understand how \u003ccode>Ideas\u003c\\/code> compose into systems, consider a platform designed to host bots that can play \u003cem>any\u003c\\/em> game.\u003c\\/p>\n\u003cp>The platform itself doesn&#39;t need to know the rules of poker, chess, or backgammon. It only handles the generic mechanics: matchmaking players, managing turns, and tracking game state. The \u003cem>semantics\u003c\\/em> of the specific game being played are encapsulated entirely within an \u003ccode>Idea\u003c\\/code> that travels through the system.\u003c\\/p>\n\u003cul>\n\u003cli>An \u003ccode>Idea\u003c\\/code> document defines the current state of a poker table: the players, the cards, the pot size. Its \u003ccode>schema\u003c\\/code> defines the rules for a valid next move.\u003c\\/li>\n\u003cli>The platform passes this \u003ccode>Idea\u003c\\/code> to a bot (an \u003ccode>Ideator\u003c\\/code>).\u003c\\/li>\n\u003cli>The bot, using latent execution, processes the \u003ccode>Idea\u003c\\/code> and produces a new one representing the next game state (e.g., after it makes a bet).\u003c\\/li>\n\u003c\\/ul>\n\u003cp>The platform can manage a complex, multi-user, stateful poker game without having a single line of poker-specific code. If the users want to play chess, they simply introduce a new \u003ccode>Idea\u003c\\/code> with the rules and state of chess. The system adapts instantly. This illustrates the power of separating the operational mechanics of a platform from the semantic logic contained within the \u003ccode>Idea\u003c\\/code>.\u003c\\/p>\n\u003chr>\n\u003ch2>Publication &amp; Discovery via DNS\u003c\\/h2>\n\u003cp>DNS provides a globally unique, resolvable name for any Idea, allowing for a fully self-describing system where any service can be understood by fetching a single definition file. This section outlines the layered architecture for this decentralized discovery and resolution system.\u003c\\/p>\n\u003ch3>The Layered Architecture\u003c\\/h3>\n\u003cp>The ecosystem is structured in six distinct layers (0-5), each building upon the last. This model allows creators to participate at the level that suits their needs, from a simple, decentralized identity to a fully-featured, managed web service. The core principle is that only Layer 0 is essential; everything else is an optional enhancement.\u003c\\/p>\n\u003cp>It&#39;s helpful to view this model as a spectrum of autonomy with two endpoints. At one end, \u003cstrong>Layer 0\u003c\\/strong> provides the most fundamental autonomy: by controlling just a DNS record, a creator has complete freedom to host their tool&#39;s source anywhere, decoupling its identity from its storage. At the other end of the spectrum lies \u003cstrong>full sovereignty\u003c\\/strong>: using a custom domain and self-hosting all services, effectively becoming one&#39;s own provider. The managed layers (1-5) serve as an optional, progressive bridge between these two states of autonomy.\u003c\\/p>\n\u003ch3>Layer 0: DNS Discovery (The Core Protocol)\u003c\\/h3>\n\u003cp>This is the bedrock of the entire system. It is the only mandatory layer and establishes a decentralized identity.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> An Idea (which can also be an executable Ideator) is given a unique domain name. A \u003ccode>TXT\u003c\\/code> record is created for that domain containing an \u003ccode>idea\u003c\\/code> key pointing to a canonical JSON document. This document defines the Idea&#39;s complete interface: its output \u003ccode>schema\u003c\\/code>, an optional example \u003ccode>solution\u003c\\/code>, and an optional \u003ccode>context\u003c\\/code> array defining its lineage and instructions, such as its \u003ccode>input\u003c\\/code> schema and a \u003ccode>code\u003c\\/code> URL.\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> This provides a globally unique, resolvable name for any component, allowing for a fully self-describing system where any service can be understood by fetching a single definition file.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost:\u003c\\/strong> Negligible. Limited to the cost of hosting DNS records.\u003c\\/li>\n\u003c\\/ul>\n\u003chr>\n\u003ch3>Layer 1: Managed Hosting\u003c\\/h3>\n\u003cp>This layer provides an immediate, zero-friction hosting solution for the Ideator source file itself.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> As an easy entry point, we offer to host a user&#39;s Ideator source file on our S3 bucket. The \u003ccode>TXT\u003c\\/code> record we create for their managed subdomain will point to this S3 URL. At any time, the user can choose to host the file elsewhere and update their \u003ccode>TXT\u003c\\/code> record to point to the new location (e.g., their own server, IPFS, etc.).\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> To eliminate the need for creators to arrange their own file hosting just to get started.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost:\u003c\\/strong> Minimal. Limited to S3 storage and data transfer costs.\u003c\\/li>\n\u003c\\/ul>\n\u003chr>\n\u003ch3>Layer 2: Static UI Generation\u003c\\/h3>\n\u003cp>This layer makes Ideators accessible and useful to humans with zero server-side compute.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> A generic, static web page (e.g., an \u003ccode>index.html\u003c\\/code> hosted on S3 or GitHub Pages) is served for all Ideator domains that opt into this service. When a user visits \u003ccode>my-tool.ideators.network\u003c\\/code> in a browser, client-side JavaScript on that page performs a DNS-over-HTTPS (DoH) query to fetch the \u003ccode>TXT\u003c\\/code> record for the domain, retrieves the source URL (from Layer 1 hosting), fetches the Ideator&#39;s definition file, and dynamically renders a user interface.\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> Provides a free, instantly usable web app for any Ideator, lowering the barrier to entry for both creators and users.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost:\u003c\\/strong> Minimal. Limited to the cost of static file hosting and bandwidth.\u003c\\/li>\n\u003c\\/ul>\n\u003chr>\n\u003ch3>Layer 3: CDN-Powered \u003ccode>GET\u003c\\/code> Endpoint\u003c\\/h3>\n\u003cp>This layer enhances machine-to-machine interoperability for reading an Idea&#39;s definition, without requiring serverless functions.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> By placing a CDN in front of the hosting layer, we can use request rewriting rules. A \u003ccode>GET\u003c\\/code> request to an Idea&#39;s domain (\u003ccode>my-tool.ideators.network\u003c\\/code>) is intelligently routed by the CDN. Instead of serving raw JSON, the endpoint can dynamically generate and serve a JavaScript module. This allows developers to use \u003cstrong>named exports\u003c\\/strong> to import specific parts of the \u003ccode>Idea\u003c\\/code> directly, for example: \u003ccode>import { schema } from &#39;...&#39;\u003c\\/code>. To provide strong typing for developers, the response can also include an \u003ccode>X-TypeScript-Types\u003c\\/code> header pointing to a TypeScript declaration file (\u003ccode>.d.ts\u003c\\/code>).\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> To provide a best-in-class developer experience. This approach enables powerful and idiomatic programmatic access, allowing developers to import an entire \u003ccode>Idea\u003c\\/code> or just the specific parts they need (like the \u003ccode>schema\u003c\\/code> or \u003ccode>solution\u003c\\/code>) using standard ES6 import syntax with full type-safety. The raw \u003ccode>Idea\u003c\\/code> document remains accessible to other HTTP clients via an \u003ccode>Accept: application\\/json\u003c\\/code> header.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost:\u003c\\/strong> Low. Limited to CDN traffic costs, with no compute charges.\u003c\\/li>\n\u003c\\/ul>\n\u003chr>\n\u003ch3>Layer 4: Publishing (\u003ccode>PUT\u003c\\/code>)\u003c\\/h3>\n\u003cp>This layer provides the ability to publish and update an Idea programmatically.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> This layer handles authenticated \u003ccode>PUT\u003c\\/code> requests to an Idea&#39;s domain. A single request can upload a new version of the Idea&#39;s source file. A managed service would handle the file upload and atomically update any necessary records to make the new version live.\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> To provide a secure and simple API for creators to manage the lifecycle of their Ideas without direct access to the underlying hosting or DNS.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost (Managed):\u003c\\/strong> Minimal, related to storage write operations.\u003c\\/li>\n\u003c\\/ul>\n\u003chr>\n\u003ch3>Layer 5: Full API Execution (\u003ccode>POST\u003c\\/code>)\u003c\\/h3>\n\u003cp>This is the highest layer of functionality, transforming an Ideator into a true, invocable web service. This layer requires compute.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>How It Works:\u003c\\/strong> This layer handles \u003ccode>POST\u003c\\/code> requests to an Ideator&#39;s domain, executing its logic. There are two implementation paths:\u003col>\n\u003cli>\u003cstrong>Self-Hosted:\u003c\\/strong> A user delegates their subdomain&#39;s DNS (\u003ccode>NS\u003c\\/code> records) to their own server and implements the full API protocol, including the \u003ccode>POST\u003c\\/code> method. They bear all hosting and compute costs.\u003c\\/li>\n\u003cli>\u003cstrong>Managed Service (Optional):\u003c\\/strong> We can offer a managed endpoint using serverless compute (e.g., CloudFront Functions). This service would resolve the Ideator, execute its logic, and return the result.\u003c\\/li>\n\u003c\\/ol>\n\u003c\\/li>\n\u003cli>\u003cstrong>Important Consideration:\u003c\\/strong> The managed version of this layer is the only part of the ecosystem with significant, scaling operational costs for us (e.g., ~$0.10 per 1 million invocations). Therefore, this managed service is an \u003cstrong>optional, premium feature\u003c\\/strong>. It may be rate-limited, offered only to specific partners, or provided as a paid service.\u003c\\/li>\n\u003cli>\u003cstrong>Purpose:\u003c\\/strong> To provide the full power of a serverless architecture, allowing anyone to publish a fully functional microservice with just a static definition file.\u003c\\/li>\n\u003cli>\u003cstrong>Provider Cost (Managed):\u003c\\/strong> Direct, usage-based compute and traffic costs.\u003c\\/li>\n\u003c\\/ul>\n\u003ch3>API Specification &amp; Usage Example\u003c\\/h3>\n\u003cp>This section defines the technical specifications for discovering and interacting with an Idea&#39;s endpoint.\u003c\\/p>\n\u003ch4>DNS \u003ccode>TXT\u003c\\/code> Record Specification\u003c\\/h4>\n\u003cp>The \u003ccode>TXT\u003c\\/code> record is a simple pointer to the Idea&#39;s full definition.\u003c\\/p>\n\u003cul>\n\u003cli>\u003ccode>idea=&lt;url&gt;\u003c\\/code>: \u003cstrong>(Required)\u003c\\/strong> The URL pointing to the canonical Idea JSON document.\u003c\\/li>\n\u003cli>\u003ccode>page=&lt;url&gt;\u003c\\/code>: \u003cstrong>(Optional)\u003c\\/strong> A URL to a human-readable landing page.\u003c\\/li>\n\u003c\\/ul>\n\u003cp>\u003cem>Example TXT record content:\u003c\\/em> \u003ccode>&quot;idea=https:\\/\\/...\\/commenter.json page=...\\/docs&quot;\u003c\\/code>\u003c\\/p>\n\u003ch4>HTTP Endpoint Specification\u003c\\/h4>\n\u003cp>All HTTP interactions happen at the root of the Idea&#39;s domain (\u003ccode>\\/\u003c\\/code>).\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>\u003ccode>GET \\/\u003c\\/code>\u003c\\/strong>\u003cul>\n\u003cli>With \u003ccode>Accept: text\\/html\u003c\\/code> header (Layer 2): Returns the static UI loader or redirects to the \u003ccode>page\u003c\\/code> URL.\u003c\\/li>\n\u003cli>With \u003ccode>Accept: application\\/json\u003c\\/code> header (Layer 3): Returns the Idea&#39;s source JSON file.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>PUT \\/\u003c\\/code>\u003c\\/strong> (Layer 4)\u003cul>\n\u003cli>Requires authentication. A single \u003ccode>PUT\u003c\\/code> request both uploads the new Idea source file and atomically updates the \u003ccode>code\u003c\\/code> URL in the \u003ccode>TXT\u003c\\/code> record to make the new version live.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cstrong>\u003ccode>POST \\/\u003c\\/code>\u003c\\/strong> (Layer 5)\u003cul>\n\u003cli>Requires authentication\\/authorization. Executes the Ideator.\u003c\\/li>\n\u003cli>The request body is a JSON object containing the payload, e.g., \u003ccode>{&quot;context&quot;: &quot;The user&#39;s input to be processed&quot;}\u003c\\/code>.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003c\\/ul>\n\u003ch4>Usage Example (\u003ccode>curl\u003c\\/code>)\u003c\\/h4>\n\u003cpre>\u003ccode class=\"language-bash\"># Target Ideator domain\nIDEATOR=&quot;commenter.ideators.network&quot;\n\n# Layer 0 (Step 1): Discover the Idea Document URL\nIDEA_URL=$(dig +short TXT $IDEATOR | grep -o &#39;idea=[^ &quot;]*&#39; | cut -d&#39;=&#39; -f2)\necho &quot;Idea Document is at: $IDEA_URL&quot;\n\n# Layer 0 (Step 2): Fetch the full definition\n# This single JSON file contains everything needed to understand the Ideator\ncurl &quot;$IDEA_URL&quot;\n\n# Layer 5: Execute the Ideator with a payload\ncurl &quot;https:\\/\\/$IDEATOR&quot; -X POST \\\n     -H &quot;Content-Type: application\\/json&quot; \\\n     -d &#39;{&quot;context&quot;: [{\\lf\n          &quot;type&quot;: &quot;input&quot;,\\\n          &quot;input&quot;: {\\\n            &quot;title&quot;: &quot;On Decentralization&quot;,\\\n            &quot;content&quot;: &quot;A short essay on the importance of decentralized systems...&quot;\\\n          }]}&#39;\n\u003c\\/code>\u003c\\/pre>\n\u003ch2>Summary of Autonomy\u003c\\/h2>\n\u003cp>This layered model provides a clear path for users:\u003c\\/p>\n\u003cul>\n\u003cli>Anyone can start at \u003cstrong>Layers 0-2\u003c\\/strong> with a managed subdomain, getting free source file hosting and a functional UI with minimal effort.\u003c\\/li>\n\u003cli>They can opt-in to the convenience of \u003cstrong>Layer 3\u003c\\/strong> for better programmatic access.\u003c\\/li>\n\u003cli>They can use the managed \u003cstrong>Layer 4\u003c\\/strong> service for full API power, subject to its conditions.\u003c\\/li>\n\u003cli>At any time, they can delegate their DNS to self-host their own solution, taking full control over their implementation of Layers 3 and 4.\u003c\\/li>\n\u003cli>Finally, they can use their own custom domain to achieve complete sovereignty (becoming their own provider of all layers).\u003c\\/li>\n\u003c\\/ul>\n","currentChapter":"The Mechanics of a Living Web"}}</script>
        <script id="vike_globalContext" type="application/json">{}</script>
        <script src="/docs/assets/entries/entry-client-routing.CGxaIKAB.js" type="module" async></script>
        <link rel="modulepreload" href="/docs/assets/entries/src_-document_-chapter.C_7418N7.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-FZmpFa9c.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-tfHUaCBC.js" as="script" type="text/javascript">
      </body>
    </html>