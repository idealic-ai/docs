{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"rfc","chapterSlug":"03_agent_imports"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>The Imports Protocol</h1>\n<p>The [Call Protocol](./02. agent_calls.md) defines the high-level controls for <code>Call</code> execution: <strong>Scope</strong> (Inline vs. Module) and <strong>Method</strong> (Explicit vs. Latent). The <strong>Imports Protocol</strong> explains how to combine these controls and manage the context for each resulting execution pattern.</p>\n<h2>Combining Scope and Method</h2>\n<ol>\n<li><p><strong>Inline Explicit (<code>_activity</code>)</strong>: This is the classic tool-use pattern. The LLM generates <code>params</code>, and a local function is immediately executed by the host. <code>_imports</code> are not typically used here as the Method is not Latent.</p>\n</li>\n<li><p><strong>Inline Latent (no <code>_activity</code>)</strong>: The LLM generates both <code>params</code> and <code>output</code> in a single turn. The <code>_imports</code> property can be used here to focus the LLM&#39;s attention on specific parts of the context, preventing it from being influenced by irrelevant information.</p>\n</li>\n<li><p><strong>Modular Explicit (<code>_module</code> + <code>_activity</code>)</strong>: The LLM generates <code>params</code>. The system then invokes the specified Activity (<code>_activity</code>) from the resolved <code>_module</code> in a new, isolated context. If <code>_imports</code> are specified, that filtered context is passed as an additional argument to the Activity code.</p>\n</li>\n<li><p><strong>Modular Latent (<code>_module</code>, no <code>_activity</code>)</strong>: The LLM generates <code>params</code>. The system then initiates a new, isolated LLM call, using the <code>Idea</code> specified in <code>_module</code> as the guide. The context for this new call is constructed <em>only</em> from the data specified in <code>_imports</code>, ensuring a clean, sandboxed environment.</p>\n</li>\n</ol>\n<h2><code>_imports</code>: Focusing the Field of View</h2>\n<p>The <code>_imports</code> property is the primary mechanism for controlling the context available to a <code>Call</code>. It acts as an allow-list, filtering the parent environment to provide a focused, limited field of view for the execution.</p>\n<ul>\n<li><strong>In an Inline Scope</strong>: <code>_imports</code> focus the LLM&#39;s attention.</li>\n<li><strong>In a Module Scope</strong>: <code>_imports</code> define the <em>entire context</em> for the isolated execution.</li>\n</ul>\n<h2>Provisioning vs. Requesting Context: Static vs. Dynamic Imports</h2>\n<p>The <code>_imports</code> property within a <code>Tool</code>&#39;s schema determines whether the context is pre-approved and <strong>provisioned</strong> to the tool, or dynamically <strong>requested</strong> by the LLM at runtime.</p>\n<ul>\n<li><p><strong>Static Imports (Context Provisioning)</strong>: If the <code>_imports</code> property is a <code>const</code> value (e.g., <code>_imports: { &quot;const&quot;: [&quot;user_request&quot;] }</code>), the context is <strong>provisioned</strong>. The <code>Tool</code> designer has hard-coded the exact context the tool is allowed to see.</p>\n</li>\n<li><p><strong>Dynamic Imports (Context Requesting)</strong>: If the <code>_imports</code> property is a flexible schema (e.g., an array of enums <code>_imports: { &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: { &quot;enum&quot;: [&quot;session_memory&quot;] } }</code>), the context is <strong>requested</strong>. The LLM decides which of the available imports it needs to generate the <code>Call</code>.</p>\n</li>\n</ul>\n<p>This dynamic pattern is especially powerful when combined with a human-in-the-loop approval system, providing a critical layer of transparency and control.</p>\n<h2>The Power of a Limited Context</h2>\n<ul>\n<li><strong>Enhanced Security &amp; Focus</strong>: By restricting the field of view, Imports prevent accidental data leakage and focus the LLM, leading to more predictable, accurate, and cost-effective executions.</li>\n<li><strong>Improved Modularity</strong>: Imports allow modules (<code>Ideas</code> and <code>Activities</code>) to be truly self-contained and reusable.</li>\n</ul>\n","currentChapter":"Combining Scope and Method"}}