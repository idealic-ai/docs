<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/docs/assets/static/src_assets_tufte-2d3b6576.BrVfN5Rs.css">
        <meta charset="UTF-8" />
        
    <title>My Vike App</title><meta property="og:title" content="My Vike App" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="/docs/assets/static/logo.DLJJsk-H.svg"/>
    
    <meta name="description" content="Demo showcasing Vike" /><meta property="og:description" content="Demo showcasing Vike" />
    
  
      </head>
      <body>
        
        <div id="root"><div><nav><div><strong><a href="/docs/manifesto/">Manifesto</a></strong>: <span><a href="/docs/manifesto/01_call.md">Call</a> | </span><span><a href="/docs/manifesto/02_inner_journey.md">Inner Journey</a> | </span><span><a href="/docs/manifesto/03_outer_work.md">Outer Work</a></span></div><div><strong><a href="/docs/rfc/">RFCs</a></strong></div><div><strong><a href="/docs/blueprint/">Blueprint</a></strong></div></nav><main><article><section><h1>From Ideas to Action: The Call Protocol</h1>
<p><em>For definitions of key terms used in this document, please refer to the <a href="./00_glossary.md">Glossary</a>.</em></p>
<p>The <a href="./01_protocol_ideas.md">Idea Protocol</a> defines a powerful, self-contained data structure for representing knowledge and latent logic. This document describes the <strong>Call Protocol</strong>, which bridges the declarative world of <code>Ideas</code> with the imperative world of execution.</p>
<p>This protocol is a formalization of the agent tool system we have already designed. It renames the concept of a &quot;tool activation&quot; to a <strong>Call</strong> to better distinguish between the definition of a tool and its specific use.</p>
<h2>The Idea-to-Call Pipeline</h2>
<ol>
<li><strong>Idea</strong>: A self-contained, output-focused document representing knowledge or a process.</li>
<li><strong>Tool</strong>: An <code>Idea</code> can be inverted and registered within the agent&#39;s tool system, making it an executable <strong>Tool</strong>. It becomes a function signature, ready to be used.</li>
<li><strong>Call</strong>: When the LLM decides to use a <code>Tool</code>, it fills in the specific <code>params</code>, creating a <strong>Call</strong>. A <code>Call</code> is a single, concrete instance of a <code>Tool</code> being activated.</li>
</ol>
<p>The core principle remains: <strong>any Idea can be turned into a Tool, which can then be activated as a Call.</strong></p>
<p>For a detailed explanation of how an <code>Idea</code>&#39;s input schema is inverted to become a <code>Tool</code>&#39;s parameter schema, see the <strong><a href="./06_agent_input.md">Input Protocol</a></strong>.</p>
<h2>The Controls of Execution: Scope and Method</h2>
<p>A <code>Call</code>&#39;s execution is defined by two independent properties: the <strong>Scope</strong> (where it runs) and the <strong>Method</strong> (how it runs). These controls are signaled by special properties (<code>_module</code>, <code>_activity</code>, <code>_output</code>) in the tool&#39;s schema.</p>
<h3>The Two Axes of Execution</h3>
<ol>
<li><p><strong>Scope (Inline vs. Module)</strong>
The scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.</p>
<ul>
<li><strong>Inline Scope</strong>: The default mode where the <code>Call</code> is processed directly.</li>
<li><strong>Module Scope</strong>: Signaled by <code>_module</code>, this delegates the <code>Call</code> to an external <code>Activity</code> or <code>Idea</code>.</li>
</ul>
</li>
<li><p><strong>Method (Explicit vs. Latent)</strong>
The method determines whether the output is generated by deterministic code or by an LLM.</p>
<ul>
<li><strong>Explicit Method</strong>: Signaled by the presence of an <code>_activity</code> property, the <code>Call</code>&#39;s output is generated by deterministic code.</li>
<li><strong>Latent Method</strong>: The default behavior when <code>_activity</code> is absent. The <code>Call</code>&#39;s output is generated by an LLM. Requires the optional <code>_output</code> property to be present.</li>
</ul>
</li>
</ol>
<p>These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the <strong><a href="./03_agent_imports.md">Imports Protocol</a></strong>.</p>
<h2>Idea, Tool, and Call: A Spectrum of Focus</h2>
<p>To understand the bridge, we must understand the fundamental difference in focus between these three concepts.</p>
<ul>
<li><p>An <strong>Idea</strong> is <strong>output-focused</strong>. Its primary purpose is to represent a complete thought or result. The <code>schema</code> defines the shape of the <code>solution</code> (the output), which was generated from the <code>context</code>. It is a record of what <em>was</em> or <em>could be</em>.</p>
</li>
<li><p>A <strong>Tool</strong> is <strong>interface-focused</strong>. Its definition centers on the <code>params</code> it requires to run. It&#39;s an abstract template for an action—a function signature waiting to be invoked.</p>
</li>
<li><p>A <strong>Call</strong> is <strong>invocation-focused</strong>. It is a concrete, executable instance of a <code>Tool</code>. It takes the <code>Tool</code>&#39;s parameter-focused interface and fills it with specific values, making it a ready-to-run request for what <em>should be done</em>.</p>
</li>
</ul>
<h2>The Vessel Idea: A single moment of decision</h2>
<p>When an agent needs to make a decision, the complete request sent to the LLM is structured as a specific type of <code>Idea</code> that we call a <strong>Vessel Idea</strong>. It represents a single, self-contained moment of decision-making.</p>
<p>A Vessel Idea bundles the two key ingredients required for the LLM to make a choice:</p>
<ol>
<li><strong>The Context</strong>: This includes all relevant information the agent needs, such as the user&#39;s request, memory, and other environmental data.</li>
<li><strong>The Schema</strong>: For a Vessel Idea, the schema&#39;s primary role is to define the &quot;Vessel&quot; — the set of possible <code>Tools</code> the agent is allowed to use in this specific situation.</li>
</ol>
<p>The LLM processes this entire <code>Idea</code>—the context and the schema of available tools—and its <code>solution</code> is the result of that decision: an array of zero or more <code>Calls</code> to be executed.</p>
<p>This structure allows a single, coherent <code>Idea</code> to represent a complex, multi-step action.</p>
</section></article></main></div></div>
        
        <script id="vike_pageContext" type="application/json">{"_urlRewrite":null,"pageId":"\\/src\\/@document\\/@chapter","routeParams":{"document":"rfc","chapterSlug":"02_agent_calls"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"\\/manifesto\\/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"\\/manifesto\\/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"\\/manifesto\\/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"\\/rfc\\/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"\\/rfc\\/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"\\/rfc\\/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"\\/rfc\\/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"\\/rfc\\/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"\\/rfc\\/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"\\/rfc\\/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"\\/blueprint\\/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"\\/blueprint\\/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"\\/blueprint\\/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"\\/blueprint\\/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"\\/blueprint\\/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"\\/blueprint\\/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"\\/blueprint\\/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"\\/blueprint\\/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"\\/blueprint\\/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"\\/blueprint\\/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"\\/blueprint\\/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"\\/blueprint\\/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"\\/blueprint\\/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"\\/blueprint\\/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"\\/blueprint\\/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"\\/blueprint\\/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"\\/blueprint\\/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"\\/blueprint\\/12_determinism.md"}]},"content":"\u003ch1>From Ideas to Action: The Call Protocol\u003c\\/h1>\n\u003cp>\u003cem>For definitions of key terms used in this document, please refer to the \u003ca href=\".\\/00_glossary.md\">Glossary\u003c\\/a>.\u003c\\/em>\u003c\\/p>\n\u003cp>The \u003ca href=\".\\/01_protocol_ideas.md\">Idea Protocol\u003c\\/a> defines a powerful, self-contained data structure for representing knowledge and latent logic. This document describes the \u003cstrong>Call Protocol\u003c\\/strong>, which bridges the declarative world of \u003ccode>Ideas\u003c\\/code> with the imperative world of execution.\u003c\\/p>\n\u003cp>This protocol is a formalization of the agent tool system we have already designed. It renames the concept of a &quot;tool activation&quot; to a \u003cstrong>Call\u003c\\/strong> to better distinguish between the definition of a tool and its specific use.\u003c\\/p>\n\u003ch2>The Idea-to-Call Pipeline\u003c\\/h2>\n\u003col>\n\u003cli>\u003cstrong>Idea\u003c\\/strong>: A self-contained, output-focused document representing knowledge or a process.\u003c\\/li>\n\u003cli>\u003cstrong>Tool\u003c\\/strong>: An \u003ccode>Idea\u003c\\/code> can be inverted and registered within the agent&#39;s tool system, making it an executable \u003cstrong>Tool\u003c\\/strong>. It becomes a function signature, ready to be used.\u003c\\/li>\n\u003cli>\u003cstrong>Call\u003c\\/strong>: When the LLM decides to use a \u003ccode>Tool\u003c\\/code>, it fills in the specific \u003ccode>params\u003c\\/code>, creating a \u003cstrong>Call\u003c\\/strong>. A \u003ccode>Call\u003c\\/code> is a single, concrete instance of a \u003ccode>Tool\u003c\\/code> being activated.\u003c\\/li>\n\u003c\\/ol>\n\u003cp>The core principle remains: \u003cstrong>any Idea can be turned into a Tool, which can then be activated as a Call.\u003c\\/strong>\u003c\\/p>\n\u003cp>For a detailed explanation of how an \u003ccode>Idea\u003c\\/code>&#39;s input schema is inverted to become a \u003ccode>Tool\u003c\\/code>&#39;s parameter schema, see the \u003cstrong>\u003ca href=\".\\/06_agent_input.md\">Input Protocol\u003c\\/a>\u003c\\/strong>.\u003c\\/p>\n\u003ch2>The Controls of Execution: Scope and Method\u003c\\/h2>\n\u003cp>A \u003ccode>Call\u003c\\/code>&#39;s execution is defined by two independent properties: the \u003cstrong>Scope\u003c\\/strong> (where it runs) and the \u003cstrong>Method\u003c\\/strong> (how it runs). These controls are signaled by special properties (\u003ccode>_module\u003c\\/code>, \u003ccode>_activity\u003c\\/code>, \u003ccode>_output\u003c\\/code>) in the tool&#39;s schema.\u003c\\/p>\n\u003ch3>The Two Axes of Execution\u003c\\/h3>\n\u003col>\n\u003cli>\u003cp>\u003cstrong>Scope (Inline vs. Module)\u003c\\/strong>\nThe scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Inline Scope\u003c\\/strong>: The default mode where the \u003ccode>Call\u003c\\/code> is processed directly.\u003c\\/li>\n\u003cli>\u003cstrong>Module Scope\u003c\\/strong>: Signaled by \u003ccode>_module\u003c\\/code>, this delegates the \u003ccode>Call\u003c\\/code> to an external \u003ccode>Activity\u003c\\/code> or \u003ccode>Idea\u003c\\/code>.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003cli>\u003cp>\u003cstrong>Method (Explicit vs. Latent)\u003c\\/strong>\nThe method determines whether the output is generated by deterministic code or by an LLM.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cstrong>Explicit Method\u003c\\/strong>: Signaled by the presence of an \u003ccode>_activity\u003c\\/code> property, the \u003ccode>Call\u003c\\/code>&#39;s output is generated by deterministic code.\u003c\\/li>\n\u003cli>\u003cstrong>Latent Method\u003c\\/strong>: The default behavior when \u003ccode>_activity\u003c\\/code> is absent. The \u003ccode>Call\u003c\\/code>&#39;s output is generated by an LLM. Requires the optional \u003ccode>_output\u003c\\/code> property to be present.\u003c\\/li>\n\u003c\\/ul>\n\u003c\\/li>\n\u003c\\/ol>\n\u003cp>These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the \u003cstrong>\u003ca href=\".\\/03_agent_imports.md\">Imports Protocol\u003c\\/a>\u003c\\/strong>.\u003c\\/p>\n\u003ch2>Idea, Tool, and Call: A Spectrum of Focus\u003c\\/h2>\n\u003cp>To understand the bridge, we must understand the fundamental difference in focus between these three concepts.\u003c\\/p>\n\u003cul>\n\u003cli>\u003cp>An \u003cstrong>Idea\u003c\\/strong> is \u003cstrong>output-focused\u003c\\/strong>. Its primary purpose is to represent a complete thought or result. The \u003ccode>schema\u003c\\/code> defines the shape of the \u003ccode>solution\u003c\\/code> (the output), which was generated from the \u003ccode>context\u003c\\/code>. It is a record of what \u003cem>was\u003c\\/em> or \u003cem>could be\u003c\\/em>.\u003c\\/p>\n\u003c\\/li>\n\u003cli>\u003cp>A \u003cstrong>Tool\u003c\\/strong> is \u003cstrong>interface-focused\u003c\\/strong>. Its definition centers on the \u003ccode>params\u003c\\/code> it requires to run. It&#39;s an abstract template for an action—a function signature waiting to be invoked.\u003c\\/p>\n\u003c\\/li>\n\u003cli>\u003cp>A \u003cstrong>Call\u003c\\/strong> is \u003cstrong>invocation-focused\u003c\\/strong>. It is a concrete, executable instance of a \u003ccode>Tool\u003c\\/code>. It takes the \u003ccode>Tool\u003c\\/code>&#39;s parameter-focused interface and fills it with specific values, making it a ready-to-run request for what \u003cem>should be done\u003c\\/em>.\u003c\\/p>\n\u003c\\/li>\n\u003c\\/ul>\n\u003ch2>The Vessel Idea: A single moment of decision\u003c\\/h2>\n\u003cp>When an agent needs to make a decision, the complete request sent to the LLM is structured as a specific type of \u003ccode>Idea\u003c\\/code> that we call a \u003cstrong>Vessel Idea\u003c\\/strong>. It represents a single, self-contained moment of decision-making.\u003c\\/p>\n\u003cp>A Vessel Idea bundles the two key ingredients required for the LLM to make a choice:\u003c\\/p>\n\u003col>\n\u003cli>\u003cstrong>The Context\u003c\\/strong>: This includes all relevant information the agent needs, such as the user&#39;s request, memory, and other environmental data.\u003c\\/li>\n\u003cli>\u003cstrong>The Schema\u003c\\/strong>: For a Vessel Idea, the schema&#39;s primary role is to define the &quot;Vessel&quot; — the set of possible \u003ccode>Tools\u003c\\/code> the agent is allowed to use in this specific situation.\u003c\\/li>\n\u003c\\/ol>\n\u003cp>The LLM processes this entire \u003ccode>Idea\u003c\\/code>—the context and the schema of available tools—and its \u003ccode>solution\u003c\\/code> is the result of that decision: an array of zero or more \u003ccode>Calls\u003c\\/code> to be executed.\u003c\\/p>\n\u003cp>This structure allows a single, coherent \u003ccode>Idea\u003c\\/code> to represent a complex, multi-step action.\u003c\\/p>\n","currentChapter":"The Idea-to-Call Pipeline"}}</script>
        <script id="vike_globalContext" type="application/json">{}</script>
        <script src="/docs/assets/entries/entry-client-routing.CGxaIKAB.js" type="module" async></script>
        <link rel="modulepreload" href="/docs/assets/entries/src_-document_-chapter.C_7418N7.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-FZmpFa9c.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/docs/assets/chunks/chunk-tfHUaCBC.js" as="script" type="text/javascript">
      </body>
    </html>