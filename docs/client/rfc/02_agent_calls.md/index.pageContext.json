{"_urlRewrite":null,"pageId":"/src/@document/@chapter","routeParams":{"document":"rfc","chapterSlug":"02_agent_calls"},"data":{"sitemap":{"manifesto":[{"id":"Call","number":1,"numberStr":"01","name":"Call","slug":"01_call","path":"01_call.md","url":"/manifesto/01_call.md"},{"id":"Inner Journey","number":2,"numberStr":"02","name":"Inner Journey","slug":"02_inner_journey","path":"02_inner_journey.md","url":"/manifesto/02_inner_journey.md"},{"id":"Outer Work","number":3,"numberStr":"03","name":"Outer Work","slug":"03_outer_work","path":"03_outer_work.md","url":"/manifesto/03_outer_work.md"}],"rfc":[{"id":"00_glossary","number":0,"numberStr":"00","name":"00_glossary","slug":"00_glossary","path":"00_glossary.md","url":"/rfc/00_glossary.md"},{"id":"The Mechanics of a Living Web","number":1,"numberStr":"01","name":"The Mechanics of a Living Web","slug":"01_protocol_ideas","path":"01_protocol_ideas.md","url":"/rfc/01_protocol_ideas.md"},{"id":"The Idea-to-Call Pipeline","number":2,"numberStr":"02","name":"The Idea-to-Call Pipeline","slug":"02_agent_calls","path":"02_agent_calls.md","url":"/rfc/02_agent_calls.md"},{"id":"Combining Scope and Method","number":3,"numberStr":"03","name":"Combining Scope and Method","slug":"03_agent_imports","path":"03_agent_imports.md","url":"/rfc/03_agent_imports.md"},{"id":"1. Foundational Requirement: The State System","number":4,"numberStr":"04","name":"1. Foundational Requirement: The State System","slug":"04_agent_instancing","path":"04_agent_instancing.md","url":"/rfc/04_agent_instancing.md"},{"id":"From Poker-Specific to Protocol-Driven","number":5,"numberStr":"05","name":"From Poker-Specific to Protocol-Driven","slug":"05_system_reactor","path":"05_system_reactor.md","url":"/rfc/05_system_reactor.md"},{"id":"The `Input` Message Type","number":6,"numberStr":"06","name":"The `Input` Message Type","slug":"06_agent_input","path":"06_agent_input.md","url":"/rfc/06_agent_input.md"}],"blueprint":[{"id":"Core Components","number":0,"numberStr":"00","name":"Core Components","slug":"00_architecture","path":"00_architecture.md","url":"/blueprint/00_architecture.md"},{"id":"B","number":0,"numberStr":"00","name":"B","slug":"00_glossary","path":"00_glossary.md","url":"/blueprint/00_glossary.md"},{"id":"New Ideas in This Chapter","number":0,"numberStr":"00","name":"New Ideas in This Chapter","slug":"00_references","path":"00_references.md","url":"/blueprint/00_references.md"},{"id":"New Ideas in This Chapter","number":1,"numberStr":"01","name":"New Ideas in This Chapter","slug":"01_vibes","path":"01_vibes.md","url":"/blueprint/01_vibes.md"},{"id":"Core Tables","number":1,"numberStr":"01","name":"Core Tables","slug":"01_vibes_database","path":"01_vibes_database.md","url":"/blueprint/01_vibes_database.md"},{"id":"Examples of Vibe Structures","number":1,"numberStr":"01","name":"Examples of Vibe Structures","slug":"01_vibes_examples","path":"01_vibes_examples.md","url":"/blueprint/01_vibes_examples.md"},{"id":"New Ideas in This Chapter","number":2,"numberStr":"02","name":"New Ideas in This Chapter","slug":"02_instructions","path":"02_instructions.md","url":"/blueprint/02_instructions.md"},{"id":"Example 1: Process Scheduling","number":2,"numberStr":"02","name":"Example 1: Process Scheduling","slug":"02_instructions_examples","path":"02_instructions_examples.md","url":"/blueprint/02_instructions_examples.md"},{"id":"Context Switching with Execution Environments","number":2,"numberStr":"02","name":"Context Switching with Execution Environments","slug":"02_instructions_guidance","path":"02_instructions_guidance.md","url":"/blueprint/02_instructions_guidance.md"},{"id":"New Ideas in This Chapter","number":4,"numberStr":"04","name":"New Ideas in This Chapter","slug":"04_refinements","path":"04_refinements.md","url":"/blueprint/04_refinements.md"},{"id":"Detailed Example: Evolving Record Vibe Schemas","number":4,"numberStr":"04","name":"Detailed Example: Evolving Record Vibe Schemas","slug":"04_refinements_examples","path":"04_refinements_examples.md","url":"/blueprint/04_refinements_examples.md"},{"id":"New Ideas in This Chapter","number":5,"numberStr":"05","name":"New Ideas in This Chapter","slug":"05_exchange","path":"05_exchange.md","url":"/blueprint/05_exchange.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets","path":"06_budgets.md","url":"/blueprint/06_budgets.md"},{"id":"Self-Sustaining Startup Ecosystem","number":6,"numberStr":"06","name":"Self-Sustaining Startup Ecosystem","slug":"06_budgets_examples","path":"06_budgets_examples.md","url":"/blueprint/06_budgets_examples.md"},{"id":"New Ideas in This Chapter","number":6,"numberStr":"06","name":"New Ideas in This Chapter","slug":"06_budgets_stats","path":"06_budgets_stats.md","url":"/blueprint/06_budgets_stats.md"},{"id":"New Ideas in This Chapter","number":7,"numberStr":"07","name":"New Ideas in This Chapter","slug":"07_processes","path":"07_processes.md","url":"/blueprint/07_processes.md"},{"id":"New Ideas in This Chapter","number":8,"numberStr":"08","name":"New Ideas in This Chapter","slug":"08_branches","path":"08_branches.md","url":"/blueprint/08_branches.md"},{"id":"Navigating the Determinism Landscape","number":12,"numberStr":"12","name":"Navigating the Determinism Landscape","slug":"12_determinism","path":"12_determinism.md","url":"/blueprint/12_determinism.md"}]},"content":"<h1>From Ideas to Action: The Call Protocol</h1>\n<p><em>For definitions of key terms used in this document, please refer to the <a href=\"./00_glossary.md\">Glossary</a>.</em></p>\n<p>The <a href=\"./01_protocol_ideas.md\">Idea Protocol</a> defines a powerful, self-contained data structure for representing knowledge and latent logic. This document describes the <strong>Call Protocol</strong>, which bridges the declarative world of <code>Ideas</code> with the imperative world of execution.</p>\n<p>This protocol is a formalization of the agent tool system we have already designed. It renames the concept of a &quot;tool activation&quot; to a <strong>Call</strong> to better distinguish between the definition of a tool and its specific use.</p>\n<h2>The Idea-to-Call Pipeline</h2>\n<ol>\n<li><strong>Idea</strong>: A self-contained, output-focused document representing knowledge or a process.</li>\n<li><strong>Tool</strong>: An <code>Idea</code> can be inverted and registered within the agent&#39;s tool system, making it an executable <strong>Tool</strong>. It becomes a function signature, ready to be used.</li>\n<li><strong>Call</strong>: When the LLM decides to use a <code>Tool</code>, it fills in the specific <code>params</code>, creating a <strong>Call</strong>. A <code>Call</code> is a single, concrete instance of a <code>Tool</code> being activated.</li>\n</ol>\n<p>The core principle remains: <strong>any Idea can be turned into a Tool, which can then be activated as a Call.</strong></p>\n<p>For a detailed explanation of how an <code>Idea</code>&#39;s input schema is inverted to become a <code>Tool</code>&#39;s parameter schema, see the <strong><a href=\"./06_agent_input.md\">Input Protocol</a></strong>.</p>\n<h2>The Controls of Execution: Scope and Method</h2>\n<p>A <code>Call</code>&#39;s execution is defined by two independent properties: the <strong>Scope</strong> (where it runs) and the <strong>Method</strong> (how it runs). These controls are signaled by special properties (<code>_module</code>, <code>_activity</code>, <code>_output</code>) in the tool&#39;s schema.</p>\n<h3>The Two Axes of Execution</h3>\n<ol>\n<li><p><strong>Scope (Inline vs. Module)</strong>\nThe scope determines whether the execution happens within the current agent context or is delegated to an external, isolated module.</p>\n<ul>\n<li><strong>Inline Scope</strong>: The default mode where the <code>Call</code> is processed directly.</li>\n<li><strong>Module Scope</strong>: Signaled by <code>_module</code>, this delegates the <code>Call</code> to an external <code>Activity</code> or <code>Idea</code>.</li>\n</ul>\n</li>\n<li><p><strong>Method (Explicit vs. Latent)</strong>\nThe method determines whether the output is generated by deterministic code or by an LLM.</p>\n<ul>\n<li><strong>Explicit Method</strong>: Signaled by the presence of an <code>_activity</code> property, the <code>Call</code>&#39;s output is generated by deterministic code.</li>\n<li><strong>Latent Method</strong>: The default behavior when <code>_activity</code> is absent. The <code>Call</code>&#39;s output is generated by an LLM. Requires the optional <code>_output</code> property to be present.</li>\n</ul>\n</li>\n</ol>\n<p>These controls can be combined into different execution patterns and can have their context controlled via imports. For a detailed explanation of how these controls are combined and how context is managed, see the <strong><a href=\"./03_agent_imports.md\">Imports Protocol</a></strong>.</p>\n<h2>Idea, Tool, and Call: A Spectrum of Focus</h2>\n<p>To understand the bridge, we must understand the fundamental difference in focus between these three concepts.</p>\n<ul>\n<li><p>An <strong>Idea</strong> is <strong>output-focused</strong>. Its primary purpose is to represent a complete thought or result. The <code>schema</code> defines the shape of the <code>solution</code> (the output), which was generated from the <code>context</code>. It is a record of what <em>was</em> or <em>could be</em>.</p>\n</li>\n<li><p>A <strong>Tool</strong> is <strong>interface-focused</strong>. Its definition centers on the <code>params</code> it requires to run. It&#39;s an abstract template for an actionâ€”a function signature waiting to be invoked.</p>\n</li>\n<li><p>A <strong>Call</strong> is <strong>invocation-focused</strong>. It is a concrete, executable instance of a <code>Tool</code>. It takes the <code>Tool</code>&#39;s parameter-focused interface and fills it with specific values, making it a ready-to-run request for what <em>should be done</em>.</p>\n</li>\n</ul>\n<h2>The Vessel Idea: A single moment of decision</h2>\n<p>When an agent needs to make a decision, the complete request sent to the LLM is structured as a specific type of <code>Idea</code> that we call a <strong>Vessel Idea</strong>. It represents a single, self-contained moment of decision-making.</p>\n<p>A Vessel Idea bundles the two key ingredients required for the LLM to make a choice:</p>\n<ol>\n<li><strong>The Context</strong>: This includes all relevant information the agent needs, such as the user&#39;s request, memory, and other environmental data.</li>\n<li><strong>The Schema</strong>: For a Vessel Idea, the schema&#39;s primary role is to define the &quot;Vessel&quot; â€” the set of possible <code>Tools</code> the agent is allowed to use in this specific situation.</li>\n</ol>\n<p>The LLM processes this entire <code>Idea</code>â€”the context and the schema of available toolsâ€”and its <code>solution</code> is the result of that decision: an array of zero or more <code>Calls</code> to be executed.</p>\n<p>This structure allows a single, coherent <code>Idea</code> to represent a complex, multi-step action.</p>\n","currentChapter":"The Idea-to-Call Pipeline"}}