## How Information Blueprints Change and Grow

Imagine you have a special digital container for information, let's call it a "Record Vibe." This isn't just any file; it's a smart container that knows its own structure. Think of it like a very organized digital box.

This idea of making blueprints more specific, which we call the "schema refinement principle," isn't just for when you first set up your system. It's how the system keeps learning and changing over time. Just like you might get permission to change the _information inside_ one of these digital boxes, you can also get permission to change the _blueprint_ of the box itself. The blueprint is stored in a special part of the Record Vibe called its `schema` field. The actual information is stored in another part called the `solution` field.

To change the blueprint (the `schema`), we use a process called `Refine`. We give the system an "instruction Vibe" – another smart container whose `solution` field tells the system exactly how to update the blueprint of our target Record Vibe. When this is done, we get a new version of our Record Vibe. This new version has the updated blueprint in its `schema` field and new information in its `solution` field that matches the new blueprint. This is great because it means our information structures can change as our needs change, like when a business grows. It’s like letting the way we use information shape how that information is organized.

Let's look at an example: Imagine a company wants to turn its simple promotional website into a full online store.

**Starting Point: A Basic Product Page**
Initially, the company has Record Vibes for its products. For example, `aug:products/superwidget:1` (the `:1` just means it's the first version). These product Vibes follow a blueprint defined in another Vibe, say `aug:products/example:1`. This `example:1` Vibe is like a master template for what a basic product page should look like.

- The `schema` field of this template (`aug:products/example:1`) contains the rules (written in a language called JSON Schema) for what information a basic product page needs. So, `superwidget:1` also follows these rules.
- The `solution` field of the template (`aug:products/example:1`) might have some example data for a basic product.

Here's what the blueprint (`aug:products/example:1#schema`) for this basic product page might look like in simple terms:

```json
// This is the blueprint inside the 'schema' field
{
  "type": "object", // Means we're describing a collection of items
  "properties": {
    // These are the items (fields) it can have
    "productName": { "type": "string" }, // A place for text (the product's name)
    "description": { "type": "string" }, // A place for text (a description)
    "promoImage": { "type": "string", "format": "uri" } // A place for a web link to an image
  },
  "required": ["productName", "description"] // Means 'productName' and 'description' must be filled in
}
```

This blueprint says every basic product must have a name and a description, and can optionally have a promotional image.

**The Goal: Adding Shop Features**
As the business decides to open an online shop, they realize they need to track new things for each product: how many are in stock (`stockLevel`) and how much they cost (`price`). This means the blueprint for their product Record Vibes needs to change to include these new fields.

**Changing the Blueprint and Data with `Refine`**
To make this change, we use the `Refine` operation on our existing SuperWidget product (`aug:products/superwidget:1`). Here’s what we need:

- **`target`**: This is the Vibe we want to change, which is `aug:products/superwidget:1`.
- **`instruction`**: This is a special "instruction Vibe," let's call it `aug:migrations/evolve-to-shop-item:1`. The important part of this instruction Vibe is its `solution` field. This `solution` tells the system exactly how to change the blueprint (the `schema` of `superwidget:1`) and how to update its data (the `solution` of `superwidget:1`).

  For example, the `solution` of our instruction Vibe might say something like:

  ```json
  // What aug:migrations/evolve-to-shop-item:1's solution field might contain
  {
    "schemaModifications": {
      // Instructions for changing the blueprint
      "addProperties": {
        // Add these new fields to the blueprint
        "stockLevel": { "type": "integer", "minimum": 0, "description": "Current available stock" },
        "price": { "type": "number", "format": "currency", "description": "Retail price" }
      },
      "addToRequired": ["stockLevel", "price"] // Make these new fields mandatory
    },
    "solutionUpdate": {
      // Instructions for updating the data
      "stockLevel": 0, // Set the starting stock level to 0
      "price": "0.00" // Set the starting price to 0.00
    }
  }
  ```

- **`capability`**: This is like a permission slip. Someone, like a "System Architect," needs to have the authority (the capability) to change basic products into shop-ready products.

The actual command to make this change might look like this (don't worry too much about the exact format):

`aug:products/superwidget:2 = Refine(aug:products/superwidget:1, aug:migrations/evolve-to-shop-item:1, aug:capability-architect-master:1)`

This operation creates a new version of the SuperWidget product. Because the changes (adding new fields) are compatible with the old blueprint (you can still understand the old parts), it's considered a new version of the _same_ product. Think of it like adding new, optional pages to a manual. Someone with the old manual can still use it; they just won't see the new pages. The system keeps track of this as the next version, which we'll call `aug:products/superwidget:2` for clarity.

If the change was so different that it broke compatibility with the old blueprint (like renaming `productName` to `itemName`), the system would usually create a Vibe with a completely new identity, not just a new version.

**The Result: A Shop-Ready Product**
Now, we have a new version of our product, `aug:products/superwidget:2`. This version is ready for the online shop:

- Its `schema` field (its blueprint) now includes the new fields for stock and price:
  ```json
  // The new blueprint in aug:products/superwidget:2's schema field
  {
    "type": "object",
    "properties": {
      "productName": { "type": "string" },
      "description": { "type": "string" },
      "promoImage": { "type": "string", "format": "uri" },
      "stockLevel": { "type": "integer", "minimum": 0, "description": "Current available stock" },
      "price": { "type": "number", "format": "currency", "description": "Retail price" }
    },
    "required": ["productName", "description", "stockLevel", "price"]
  }
  ```
- Its `solution` field (its data) now includes the original information plus the new `stockLevel` and `price` fields, which were initialized (given starting values) by our instruction Vibe:
  `json
    // The data in aug:products/superwidget:2's solution field
    {
      "productName": "Super Widget",
      "description": "The best widget for your needs.",
      "promoImage": "http://example.com/superwidget.png",
      "stockLevel": 0,
      "price": "0.00"
    }
    `
  Importantly, the original `aug:products/superwidget:1` is still there in the system's records, unchanged. If we had other basic products (like `aug:products/anotheritem:1`), they would need to go through a similar `Refine` process to become shop-ready (e.g., becoming `aug:products/anotheritem:2`).**Updating Data with the New Blueprint**
  Now that our `aug:products/superwidget:2` has the new "Shop Product Blueprint" in its `schema` field, someone like an "Inventory Manager" can be given permission to update its data (its `solution`).

For example, to update the stock level:

- **`target`**: `aug:products/superwidget:2` (our shop-ready product).
- **`instruction`**: An instruction Vibe, say `aug:updates/update-stock:1`, whose `solution` simply specifies the new stock level: `{ "stockLevel": 150 }`.
- **`capability`**: A permission slip held by the "Inventory Manager" allowing them to update stock.

The `Refine` command would be:
`aug:products/superwidget:3 = Refine(aug:products/superwidget:2, aug:updates/update-stock:1, aug:capability-inventory-mgr:1)`

This creates `aug:products/superwidget:3`, another new version of the product, this time with the stock count updated in its `solution`. Its blueprint (the `schema` field) remains the "Shop Product Blueprint" from version `:2`.

### More Complex Blueprint Changes: Moving to a Whole New Blueprint Version

The previous example showed adding new things to a blueprint. This is like adding extra rooms to a house plan – the original parts of the house are still recognizable. But what if you need to make a more fundamental, "breaking" change? This is like deciding to change the name of a room in the plan, or removing a room entirely. For these kinds of changes, it's often better to move the product information to a completely new blueprint version.

Imagine you have an old house plan (V1) and you create a brand new, improved house plan (V2). Instead of trying to patch the old plan, you take the key features from the old house and design them into the new V2 plan. This is the core idea here.

**Scenario: Changing `price` to `priceInCents`**
Let's say our existing product Vibes (like `aug:products/superwidget:3`) were based on an old blueprint (V1), perhaps defined in a template Vibe called `aug:products/example:1`. This V1 blueprint included a `price` field stored as text (e.g., "19.99").

Now, we want to move these V1 products to a new V2 blueprint. This V2 blueprint, perhaps defined in a new template Vibe `aug:products/example-v2:1`, will use a field called `priceInCents` that stores the price as a whole number (e.g., 1999 for $19.99). This is better for calculations and avoids issues with decimal points. The old `price` field will be removed in V2.

Here's how we might do this:

1.  **Create the V2 Product Template (`aug:products/example-v2:1`)**:
    This Vibe is the master template for all V2 products. It contains:

    - **`input`**: Some example starting information, like an ID for this template.
    - **`schema`**: This holds the new "ProductBlueprintV2" definition. It looks like this:
      ```json
      // "ProductBlueprintV2" - this is the blueprint for V2 products
      {
        "type": "object",
        "properties": {
          "productId": { "type": "string", "description": "Unique business ID for the product" },
          "productName": { "type": "string" },
          "description": { "type": "string" },
          "promoImage": { "type": "string", "format": "uri" },
          "stockLevel": { "type": "integer", "minimum": 0 },
          "priceInCents": {
            "type": "integer",
            "minimum": 0,
            "description": "Retail price in cents"
          }
        },
        "required": ["productId", "productName", "description", "stockLevel", "priceInCents"]
      }
      ```
      Notice `priceInCents` is here, and the old `price` field is gone. It also has a `productId` which is a business-friendly ID.
    - **`solution`**: Example data that fits the V2 blueprint, like default values for a generic V2 product:
      `json
    {
      "productId": "PROD-V2-EXEMPLAR",
      "productName": "Generic Product V2",
      "description": "This is a standard Version 2 product.",
      "promoImage": "http://example.com/generic-v2.png",
      "stockLevel": 0,
      "priceInCents": 0
    }
    `
      When we want to move a specific product, like our SuperWidget, to this V2 structure, the new V2 SuperWidget Vibe will use this blueprint from `aug:products/example-v2:1` and its data will be filled according to this V2 structure.

2.  **The `Refine` Operation for Moving SuperWidget to V2**:
    To create a V2 SuperWidget, using the V2 blueprint from `aug:products/example-v2:1` and filling it with data from the old V1 SuperWidget (`aug:products/superwidget:3`):

    - **`target`**: This time, the `target` is the V2 template itself: `aug:products/example-v2:1`. This template provides the new blueprint (from its `schema` field) and any default V2 values (from its `solution` field) for the new V2 SuperWidget we're about to create.

    - **`instruction`**: The `instruction` Vibe's `solution` provides the data or directions for the `Refine` operation. The system is flexible about what these instructions look like. It could be plain English, code, or structured data.

      In this migration case, a simple way is to use the _old V1 product Vibe itself_ as the instruction. So, for SuperWidget:

      - The `instruction` is `aug:products/superwidget:3` (our latest V1 SuperWidget).
      - Its `solution` (which contains all the V1 data like `productName`, `description`, old `price`, `stockLevel`) is used as the source material for the move.

      The process that has permission to do this (see `capability` below) will know how to:

      - Take the V2 blueprint from the `target` (`aug:products/example-v2:1#schema`).
      - Look at the data in the `instruction` (`aug:products/superwidget:3#solution`).
      - Make necessary changes (like converting the text `price` "19.99" into the number `priceInCents` 1999).
      - Fill in the new V2 structure. If there are new V2 fields that weren't in V1, the process might generate them or use default values from the `target` template's `solution` (`aug:products/example-v2:1#solution`).

    - **`capability`**: A permission slip, say `aug:migrations/product#v1-to-v2`. This permit allows the use of the V2 template (`aug:products/example-v2:1`) as a base, and an old V1 product (like `aug:products/superwidget:3`) as instructions, to create a new V2 product. The actual logic for converting the data is part of the process that uses this permission.

    The `Refine` call would create a brand new Vibe with a distinct identity:
    `aug:products/superwidget-v2:1 = Refine(target: aug:products/example-v2:1, instruction: aug:products/superwidget:3, capability: aug:migrations/product#v1-to-v2)`

3.  **Result (SuperWidget V2)**:
    A **completely new** Record Vibe, `aug:products/superwidget-v2:1`, is created (notice the new name, indicating it's a distinct item, not just a revision of the old one):

    - Its `schema` field (blueprint) is identical to the V2 template's blueprint (`aug:products/example-v2:1#schema`).
    - Its `solution` field (data) is now filled according to the V2 blueprint. The data comes from the migration process (which had the permission slip) using the old V1 SuperWidget data as the main input:
      ```json
      // Data in aug:products/superwidget-v2:1#solution
      {
        "productId": "SW-001", // Carried over from V1 to keep the same business product ID
        "productName": "SuperWidget Pro", // Could be updated during migration
        "description": "The next generation SuperWidget.", // Could be updated
        "promoImage": "http://example.com/superwidget-v2.png", // Could be updated
        "stockLevel": 150, // Carried over from V1 data (aug:products/superwidget:3#solution)
        "priceInCents": 1999 // Changed from V1 price (e.g., from "19.99")
      }
      ```
    - The original Vibes (`aug:products/superwidget:3` and the template `aug:products/example-v2:1`) are not changed at all.

    _(Just a note: The `productId` like "SW-001" is the product's own identifier that businesses use. It's part of its data (`solution`). This is different from the Vibe's unique system ID, which is like a serial number the system uses internally.)_

4.  **Migrating Another Product (e.g., SuperGizmo)**:
    To move another V1 product, say `aug:products/supergizmo:1` (assuming it's a V1 product), to its V2 version:
    - The `target` is still the V2 template: `aug:products/example-v2:1`.
    - The `instruction` would be the V1 SuperGizmo: `aug:products/supergizmo:1`.
    - The same permission slip (`aug:migrations/product#v1-to-v2`) can be used.
    - The `Refine` call:
      `aug:products/supergizmo-v2:1 = Refine(target: aug:products/example-v2:1, instruction: aug:products/supergizmo:1, capability: aug:migrations/product#v1-to-v2)`
      This creates `aug:products/supergizmo-v2:1`, which follows the V2 blueprint from `aug:products/example-v2:1#schema`.**Why is this way of moving to a new blueprint good?**

- **Clean New Blueprints**: The new V2 Vibes (like `aug:products/superwidget-v2:1`) are fresh and clean. They only contain fields defined in the V2 blueprint, without any leftover bits from the old V1 blueprint.
- **Clear Transformation Rules**: The `instruction` Vibe (or the process that uses it with a permission slip) clearly defines how to change data from V1 to V2. These rules themselves can be recorded and versioned, so you always know how the transformation happened.
- **Full History (Immutability and Lineage)**: The old V1 Vibe (`aug:products/superwidget:3`) is still there, untouched. This gives a complete history. You can trace the new V2 Vibe back to its V1 origins.
- **Gradual Changeover Possible**: Systems that use product data can be updated one by one to understand the new "ProductBlueprintV2". During the transition, some systems might still read the old V1 Vibes (if they're still around and needed), while others read the new V2 Vibes.

This method allows for strong and clean changes to how data is structured. It fully uses the system's principles of keeping old versions unchanged (immutability) and making transformations clear and explicit. It's a structured way to handle big blueprint changes, not just simple additions.

**The Chain of Permission and Change:**
This whole example shows a sequence of events:

1.  A high-level business decision (like launching an online shop) starts the process.
2.  People with the right permissions (like a System Architect) make changes to blueprints. They do this by `Refine`ing existing Record Vibes using specific `instruction` Vibes. The `solution` (data part) of these `instruction` Vibes explains how to change both the blueprint (`schema` field) and the data (`solution` field) of the target Record Vibe. This all happens under an authorizing Permission (Capability).
3.  This results in new Record Vibes. Each new Vibe has the updated blueprint in its `schema` field and matching data in its `solution` field.
4.  This new, updated blueprint then allows other people (like an Inventory Manager) to be given Permissions to do new kinds of tasks with the data (`solutions`) of these evolved Record Vibes.

This permission-driven system treats blueprint changes as a normal part of how data changes over time. Modifications to a Vibe's structure (its `schema` field) are handled using the same `Refine` action and permission-based approvals that control all other changes. This ensures that data structures can grow and adapt in a controlled, traceable, and secure way that directly matches what the business needs.

---

## Managing Permissions for These `Refine` Changes in Practice

Permissions are very specific and are given out for particular tasks using special "permits." These permits can allow actions on individual Vibes, or more powerfully, on any Vibe that matches a certain blueprint (as defined in a template Vibe).

Here are some everyday e-commerce examples, broken down into steps. We'll use `aug:/...` for system-wide paths and `aug:...` for local ones (like within your company).

- **Product Managers Launching New Products:**
  A Product Manager is introducing new electronic gadgets.

  - **Permit Given:** "Permit to Create New Product Listings from Approved Product Templates using Standard Launch Instructions." This permit itself is a type of Vibe, an instance of `aug:/permits/spawn-policy:1`.
  - **What they can do:** The Product Manager can `Refine` (which in this case means create or spawn) any target template Vibe whose blueprint (`schema` field) describes an electronics product (e.g., `aug:products/electronics-product:1`, a base template for electronics). They can use any `instruction` Vibe that follows the `aug:schema-instruction-launch:1` blueprint (which defines how launch instructions should be structured).
  - **Result:** They can create various new product Vibes. For instance, to create a new smartwatch, the `target` might be `aug:products/smartwatch:1` (a template for smartwatches, which itself might be based on the `electronics-product:1` template). The `instruction` would be something like `aug:announcements/smartwatch-gen5-details:1` (containing the details for the new smartwatch). This would create `aug:products/smartwatch-gen5:1`. They could do something similar for `aug:products/earbuds-pro:1` using an `aug:products/earbuds:1` template.

- **Inventory Managers Updating Stock:**
  An Inventory Manager needs to update stock levels for all products based on new shipments.

  - **Permit Given:** "Permit to Update Stock Counts for Any Inventory-Tracked Product via System Feeds," an instance of `aug:/permits/input-change:1`.
  - **What they can do:** The Inventory Manager can `Refine` any target product Vibe whose blueprint matches an `aug:products/inventory-tracked-product:1` template (meaning it's a product for which inventory is tracked). They'd use a specific instruction like `aug:feeds/stock-feed:1` (which contains the new stock numbers).
  - **Result:** The `stockLevel` field inside any valid product Vibe (like `aug:products/smartwatch-gen5:1` or `aug:products/charger-c30:1`) can be updated.

- **Marketing Specialists Setting Up Promotions:**
  A Marketing Specialist needs to create different kinds of discount rules for sales.

  - **Permit Given:** "Permit to Define New Discount Rules in Promotion Engine via Approved Rule Structures," an instance of `aug:/permits/schema-govern:1`.
  - **What they can do:** The Marketing Specialist can `Refine` a target Vibe like `aug:schema-promo-rules:1` (which might hold the master list of all promotion rule blueprints). They can use any `instruction` Vibe that fits the `aug:schema-instruction-discount:1` blueprint (e.g., instructions for percentage-off, buy-one-get-one (BOGO), or tiered discounts).
  - **Result:** Various new discount rule blueprints (like `percentage-off-category-x` or `bogo-on-accessories`) can be added to the system's overall set of promotion rules.

- **Content Writers Updating Product Descriptions:**
  A Content Writer needs to update marketing text for product pages.

  - **Permit Given:** "Permit to Update Product Page Content for Any Product via SEO Guidelines," an instance of `aug:/permits/editorial:1`.
  - **What they can do:** The Content Writer can `Refine` any target product page Vibe that matches the `aug:schema-prod-page:1` blueprint, using a specific instruction like `aug:guide-seo-desc:1` (which might contain SEO best practices or standard phrasing).
  - **Result:** The `description` and `marketingCopy` fields in the data (`solution`) of any valid product page Vibe (e.g., `aug:products/smartwatch-gen5:1`) can be updated.

- **Customer Support Leads Adjusting Orders:**
  A Customer Support Lead needs to make standard changes to customer orders.
  - **Permit Given:** "Permit to Adjust Customer Orders via Standard Service Protocols," an instance of `aug:/permits/merge-policy:1` (or a more specific permit for adjustments).
  - **What they can do:** The Support Lead can `Refine` any target customer order Vibe that matches the `aug:schema-order:1` blueprint. They'd use an `instruction` that follows an approved `aug:schema-instruction-order-adj:1` blueprint (e.g., for giving partial refunds, changing shipping, or swapping items according to set rules).
  - **Result:** New versions of customer order Vibes (e.g., `aug:order-12345:1`, `aug:order-67890:1`) can be created, showing the approved changes.

Whenever any Vibe tries to `Refine` another, the system checks if it has a Permission (Capability) that includes a valid permit. This permit must clearly state that the `target` Vibe (either a specific one or one matching a blueprint) is allowed to be changed by the specific `instruction` Vibe (again, either a specific one or one matching a blueprint). The permit itself, through how it's defined and the blueprints it refers to, clearly lays out what's allowed and what the limits are for the action.
