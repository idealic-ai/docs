The `refine` primitive is the cornerstone of change. Its signature is `refine(targets, capabilities, instructions, resources?)`.
It takes up to four arguments, each accepting a single Vibe or an array of Vibes:
`targets` (what to change/spawn from; array means batch), `capabilities` (authority;
array means any one permit from any capability can authorize), `instructions` (how
to change; array means combined inputs), and optional `resources` (assets like
currency or metrics; array means multiple types of resources presented).
It always produces new, immutable Vibe(s), leaving originals intact.


---

Core principles of Capabilities (in the context of authorizing `refine`):
- Distinct Vibe type; chain of trust for permissions is established via `issuerRef` metadata within each permit.
- Permits authorize you to `refine`, which is the fundamental mechanism for state transformation and how new vibes emerge.
- Delegation of authority is achieved by `refine`ing a parent Capability (as `target`) to create a new, more restricted (i.e., `narrowed`) Capability; this act of `refine`ing itself requires authorization.
- Refinement (and `narrowing`) is how the system learns and refines itself: by making processes, tools, and patterns more specific, it achieves greater predictability, determinism, and sophistication, reducing edge cases.
- Both vessels and processes use permits to enact these authorized, refining transformations.
- Scope of authority is defined by the `target` schema, `instruction` schema, and an optional `resources` schema within each permit, the latter defining any required assets (like currency or metric achievements).
- Immutability means revocation occurs by publishing a new Vibe that marks the previous one as invalid; this affects the validity of derived permits.


---

Bootstrapping the system with `refine(targets, capabilities, instructions, resources?)`
relies on platform-provided elements:
Bootstrapping the system by using `refine(targets, capabilities, instructions, resources?)`
relies on platform-provided elements:
1. Initial `targets`: Minimal base templates like
   `aug:/types/Vessel:1`, `aug:/types/Process:1`, and
   `aug:/types/Data:1`, serving as starting points.
2. Initial `capabilities`: A foundational license from platform owners,
   enabling initial actions and tied to user entitlements. Its permits often
   don't require resources for bootstrapping core schemas.
3. Initial `instructions`: User-defined instructions specifying how to
   customize these base templates.
4. Initial `resources`: Usually none for defining foundational schemas; resource
   requirements apply later, governed by specific capabilities.
Schema refinement typically follows a refinement principle, specializing templates
within constraints set by the capability and template design. These base
templates link to the Vibe Source concepts from Chapter 1.
Schema refinement typically follows a principle of `narrowing`, specializing templates
within constraints set by the capability and template design. These base
templates link to the Vibe Source concepts from Chapter 1.


---

Capability authorization for a `refine` call involves a multi-step check:
1. Validate each presented `capability` Vibe itself (e.g., not revoked).
2. Iterate through each permit within each presented `capability.solution`.
3. For each permit, validate its metadata (expiry, recipient) and then verify that the `targets` Vibe(s) and `instructions` Vibe(s) of the `refine` call conform to the respective `target` and `instruction` schemas defined within that permit.
4. If any single permit from any provided capability meets all these criteria, then `refine` is approved by that permit for the specified targets.
5. If no permit (across all provided capabilities) authorizes the use of `refine`, it's rejected.
Capability authorization when you `refine` involves a multi-step check:
1. Validate each presented `capability` Vibe itself (e.g., not revoked).
2. Iterate through each permit within each presented `capability.solution`.
3. For each permit, validate its metadata (expiry, recipient) and then verify that the `targets` Vibe(s) and `instructions` Vibe(s) provided when you `refine` conform to the respective `target` and `instruction` schemas defined within that permit.
4. If any single permit from any provided capability meets all these criteria, then `refine` is approved by that permit for the specified targets.
5. If no permit (across all provided capabilities) authorizes the attempt to `refine`, it's rejected.
This ensures granular, auditable control over all Vibe transformations, including resource requirements and batch operations.


---

Schema refinement makes a Vibe's `schema` definition more specific, like adding
fields, tightening constraints, or refining types. It's an extension of the old
schema, preserving the Vibe's core concept while adding detail. A refined Vibe
remains compatible with systems expecting the original, general schema; those
systems will simply ignore the newer, specific parts. This ensures
Vibes evolve coherently (e.g., a generic "Product" can become a more specific
"Electronic Product" but not an unrelated "User Profile").


---

Schema refinement applies to all Vibe types, making their guiding `schema` definitions
more specific. For Record Vibes, the JSON Schema refines. For Capabilities, permits
become more restrictive (delegation, `narrowing` authority), including defining constraints on allowed
targets, instructions, and resources. For Roles, tool configurations specialize.
For Processes, workflows get more detailed. Each time you `refine`, it yields a new
Vibe with the refined schema, ensuring controlled, auditable evolution system-wide.


---

Record Vibe schema evolution (i.e., `narrowing` of the schema) is managed by `refine` calls authorized by
Capabilities. It typically involves either additive refinement (new fields,
tighter constraints) or major version migration (defining a new schema version
and transforming old Vibe data to fit). This ensures controlled, auditable
evolution of data structures, treating schema changes as part of data evolution.


---

Permissions for `refine` are managed through specific permits within
a Capability. These permits define granular, task-oriented authorizations,
allowing actions on specific Vibe instances or any Vibe(s) matching `target`,
`instruction`, and `resource` schemas. This system ensures all changes,
including those involving resources, are controlled, auditable, and verified
against explicit permit definitions, accommodating single or multiple Vibes for
each argument in the `refine` call.
