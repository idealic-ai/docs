## Making Your Business Information More Detailed Over Time

Imagine your business keeps records for everything – products, customers, orders. Each type of record has a specific structure, like a form or a blueprint, that dictates what information it must contain. We call this blueprint a **`schema`**. The actual information you fill in (like a product's name or description) is its **`solution`** or content.

Now, businesses don't stand still. Your needs change, and so does the information you need to track. The "schema refinement principle" is a fancy way of saying that these blueprints (`schemas`) can and should become more specific and detailed as your business evolves. This isn't just something you do once when you first set things up; it's an ongoing process.

Think of it like this: when you first started, your customer record blueprint might have just asked for a name and email. Later, as you wanted to offer loyalty programs, you'd need to add fields for 'purchase history' or 'loyalty points'. You're refining the blueprint.

### How Do These Blueprints Change in the System?

There's a special process called **`Refine`**. This process can change not only the actual data (`solution`) in a record but also the record's very blueprint (`schema`).

To do this, the `Refine` process uses an **`instruction`**. This `instruction` is itself another information record, and its content (`solution`) provides the directions on how to update the target record's blueprint and data. After the `Refine` process, you get a new version of your original record. This new version will have the updated blueprint (`schema`) and its data (`solution`) will match this new, evolved structure.

This allows your data structures to grow and adapt smoothly as your business needs change. It’s like starting with a basic sales report and then, when needed, evolving it to include regional sales, sales by product category, and so on, all in a controlled way.

### Example: Turning a Simple Product Listing into an Online Store Item

Let's say your company starts by listing products on a simple promotional website. As your business grows, you decide to turn this into a full e-commerce platform where people can buy things directly.

**Initial Situation: Basic Product Info**

Initially, your product records (let's call them "Product Vibes") are simple. For example, you have a record for your 'SuperWidget', identified as `aug:products/superwidget:1` (the `:1` just means it's the first version).

These product records follow a basic blueprint, say `aug:products/example:1`. This blueprint defines what information a basic product record should have.

- The blueprint (`schema`) section of `aug:products/example:1` (and therefore of your 'SuperWidget' record) would contain the rules for this basic structure. It's written in a format called JSON Schema, but think of it as a checklist.
- The content (`solution`) section of `aug:products/example:1` would have example data for a basic product.

This initial blueprint (`aug:products/example:1#schema`) might say that a product must have:

```json
// Blueprint for a basic product
{
  "type": "object", // The record is a collection of details
  "properties": { // Here are the possible details:
    "productName": { "type": "string" }, // Product's name (text)
    "description": { "type": "string" }, // Product's description (text)
    "promoImage": { "type": "string", "format": "uri" } // Link to a promotional image (web address)
  },
  "required": ["productName", "description"] // Name and description are mandatory
}
```

**The Business Goal: We Need to Sell Online!**

To sell online, just having a name, description, and image isn't enough. You critically need to track how many items you have in stock (`stockLevel`) and how much they cost (`price`). This means your product records need to be updated to include these new pieces of information. In other words, their blueprint (`schema`) must change.

**Using the `Refine` Process to Evolve the Product Blueprint**

To add `stockLevel` and `price` to our 'SuperWidget' record (`aug:products/superwidget:1`), we use the `Refine` process:

- **`target`**: This is the record we want to change, which is `aug:products/superwidget:1`.
- **`instruction`**: This is a special "directions" record, let's call it `aug:migrations/evolve-to-shop-item:1`. The content (`solution`) of this directions record is key. It tells the system exactly how to:
    1.  Modify the blueprint (`schema`) of the 'SuperWidget' to include `stockLevel` and `price`.
    2.  Update the 'SuperWidget's actual data (`solution`) to include these new fields, perhaps with initial values.

    Here's a simplified idea of what those directions (`aug:migrations/evolve-to-shop-item:1#solution`) might look like:
    ```json
    // Directions to change the product blueprint and data
    {
      "schemaModifications": { // How to change the blueprint
        "addProperties": { // Add these new details:
          "stockLevel": { "type": "integer", "minimum": 0, "description": "Current available stock" },
          "price": { "type": "number", "format": "currency", "description": "Retail price" }
        },
        "addToRequired": ["stockLevel", "price"] // Make stock and price mandatory
      },
      "solutionUpdate": { // How to update the actual data
        "stockLevel": 0, // Set initial stock to 0
        "price": "0.00"  // Set initial price to 0.00
      }
    }
    ```
- **`capability`**: This is like a permission slip. Someone, perhaps a "System Architect," needs to have the authority to make this kind of change. This permission slip (`aug:capability-architect-master:1`) confirms they are allowed to upgrade basic products into sellable shop items.

The `Refine` command would conceptually look like this:

`New SuperWidget version = Refine(Old SuperWidget, Directions for Evolving, Architect's Permission Slip)`

Or, using the system names:

`aug:products/superwidget:2 = Refine(aug:products/superwidget:1, aug:migrations/evolve-to-shop-item:1, aug:capability-architect-master:1)`

This `Refine` operation creates a **new version** of the 'SuperWidget' record, which we'll call `aug:products/superwidget:2`. This new version is now ready for the online shop. Importantly, the original `aug:products/superwidget:1` is still preserved in the system's records, unchanged – like keeping an archive of old documents.

Because this change (adding new fields) is compatible with the old structure (older systems can just ignore the new fields), it's considered a new revision of the same conceptual 'SuperWidget'. If the change was fundamentally incompatible (like completely renaming 'productName' to 'itemLabel'), it would likely result in a record with a completely new identity, not just a new version number.The new version of our product record, `aug:products/superwidget:2`, is now structured for e-commerce:

- Its blueprint section (`schema`) now includes the definitions for `stockLevel` and `price`. It looks like this:
  ```json
  // Blueprint for an e-commerce product (in aug:products/superwidget:2#schema)
  {
    "type": "object",
    "properties": {
      "productName": { "type": "string" },
      "description": { "type": "string" },
      "promoImage": { "type": "string", "format": "uri" },
      "stockLevel": { "type": "integer", "minimum": 0, "description": "Current available stock" },
      "price": { "type": "number", "format": "currency", "description": "Retail price" }
    },
    "required": ["productName", "description", "stockLevel", "price"]
  }
  ```
- Its data/content section (`solution`) now contains the original product information plus the newly added `stockLevel` and `price`, initialized as per our instructions:
  ```json
  // Actual data for SuperWidget, version 2 (in aug:products/superwidget:2#solution)
  {
    "productName": "Super Widget",
    "description": "The best widget for your needs.",
    "promoImage": "http://example.com/superwidget.png",
    "stockLevel": 0,
    "price": "0.00"
  }
  ```

Other existing basic product records (like one for an 'AnotherItem') would go through a similar `Refine` process to evolve them into their shop-ready versions (e.g., `aug:products/anotheritem:2`).

**Updating Data with the New Blueprint**

Now that our 'SuperWidget' (`aug:products/superwidget:2`) has this new, richer blueprint, someone like an "Inventory Manager" can be given permission to update its data, specifically the stock levels.

Let's say 150 units of 'SuperWidget' arrive in the warehouse. To update the record:

- **`target`**: `aug:products/superwidget:2` (the shop-ready version).
- **`instruction`**: A different "directions" record, say `aug:updates/update-stock:1`. Its content (`solution`) would simply specify the new stock level: `{ "stockLevel": 150 }`.
- **`capability`**: A permission slip held by the "Inventory Manager" allowing them to update stock counts.

The `Refine` call would be:

`aug:products/superwidget:3 = Refine(aug:products/superwidget:2, aug:updates/update-stock:1, aug:capability-inventory-mgr:1)`

This creates `aug:products/superwidget:3`, another new version of the product record, this time with `"stockLevel": 150` in its data (`solution`). The blueprint (`schema`) remains the same advanced "Shop Product Structure" we defined earlier.

### Handling Major Blueprint Changes: Migrating to a Whole New Version

The previous example showed adding new information, which is often straightforward. But what if you need to make a more fundamental change that isn't just an addition? For example, what if you want to rename an existing field, change its data type (e.g., from text to a number), or remove a field entirely? These are sometimes called "breaking changes" because old systems or reports might not understand the new structure without being updated.

For these situations, a more robust approach is to migrate your existing product records to conform to a completely new blueprint version. Think of it like moving from an old, outdated customer database to a brand new CRM system. You don't just tweak the old one; you set up the new one and carefully move the data across.

**Scenario: Improving Price Tracking – From Text `price` to Numeric `priceInCents`**

Let's imagine our current product records (like `aug:products/superwidget:3`) were based on a Version 1 (V1) blueprint. This V1 blueprint included `price` as a text field (e.g., "19.99").

For better accuracy in financial calculations and to avoid issues with different currency symbols or formats, we decide to move to a Version 2 (V2) blueprint. This V2 blueprint will:

1.  Use a field called `priceInCents` which will store the price as a whole number (e.g., 1999 for $19.99).
2.  Remove the old `price` text field.

**Step 1: Design the New V2 Product Blueprint (`aug:products/example-v2:1`)**

First, we create a new master template, or exemplar, for all V2 products. Let's call it `aug:products/example-v2:1`. This template defines the standard for V2 products:

-   **Its Blueprint (`schema`)**: This section contains the new "ProductSchemaV2" definition. This is the core of our V2 structure. It would look something like this (notice `priceInCents` and no `price`):
    ```json
    // "ProductSchemaV2" - The blueprint for V2 products
    {
      "type": "object",
      "properties": {
        "productId": { "type": "string", "description": "Unique business ID for the product" },
        "productName": { "type": "string" },
        "description": { "type": "string" },
        "promoImage": { "type": "string", "format": "uri" },
        "stockLevel": { "type": "integer", "minimum": 0 },
        "priceInCents": { "type": "integer", "minimum": 0, "description": "Retail price in cents" }
      },
      "required": ["productId", "productName", "description", "stockLevel", "priceInCents"]
    }
    ```
-   **Its Example Data (`solution`)**: This section would contain example data for a generic V2 product, matching the new V2 blueprint:
    ```json
    {
      "productId": "PROD-V2-EXEMPLAR",
      "productName": "Generic Product V2",
      "description": "This is a standard Version 2 product.",
      "promoImage": "http://example.com/generic-v2.png",
      "stockLevel": 0,
      "priceInCents": 0
    }
    ```
This `aug:products/example-v2:1` exemplar acts as the gold standard for our new V2 product records. When we migrate an existing product like 'SuperWidget', the new V2 'SuperWidget' record will copy this blueprint and use its example data as a starting point if needed.**Step 2: The `Refine` Process for Migrating 'SuperWidget' to V2**

Now, to create the new V2 version of our 'SuperWidget', we'll use the `Refine` process again, but in a slightly different way for migration:

-   **`target`**: This time, the `target` is our new V2 exemplar itself, `aug:products/example-v2:1`. This might seem a bit abstract, but think of it as telling the system: "I want to create a new product that follows the blueprint and default data defined in this V2 exemplar."

-   **`instruction`**: The `instruction` provides the specific data for the new V2 product. In this migration scenario, the most straightforward `instruction` is the *old V1 product record itself*. So, for 'SuperWidget', the `instruction` would be `aug:products/superwidget:3` (our latest V1 version).
    The data (`solution`) within this old V1 record (containing its original `productName`, `description`, old `price` string, `stockLevel`, etc.) provides all the raw material for the migration.

-   **`capability`**: We need a specific permission slip for this migration, say `aug:migrations/product#v1-to-v2`. This permission authorizes the system to use the V1 product data (from the `instruction`) to create a new V2 product based on the V2 exemplar (the `target`).
    Crucially, the process acting under this permission slip contains the *logic for transforming the data*. For example, it knows how to:
    *   Take the `price` string from the V1 data (e.g., "19.99").
    *   Convert it into an integer for `priceInCents` (e.g., 1999).
    *   Map other V1 fields (like `productName`, `stockLevel`) to their corresponding V2 fields.
    *   If the V2 blueprint has new fields not present in V1, this process might fill them with default values from the V2 exemplar (`aug:products/example-v2:1#solution`) or generate them according to specific rules.

The `Refine` call for migration would look like this:

`New V2 SuperWidget = Refine(target: V2 Product Exemplar, instruction: Old V1 SuperWidget, capability: V1-to-V2 Migration Permit)`

Or, using system names:

`aug:products/superwidget-v2:1 = Refine(target: aug:products/example-v2:1, instruction: aug:products/superwidget:3, capability: aug:migrations/product#v1-to-v2)`

**Step 3: The Result – A Brand New V2 'SuperWidget'**

A **completely new** product record, `aug:products/superwidget-v2:1`, is created. Notice it has a new name/identity (`superwidget-v2:1` instead of just a version bump on `superwidget`). This signifies it's a distinct item conforming to the new V2 standard.

-   Its blueprint (`schema`) is identical to the V2 blueprint defined in `aug:products/example-v2:1#schema`.
-   Its data (`solution`) is now populated according to this V2 blueprint. The migration process (authorized by the `capability`) used the data from the old V1 `aug:products/superwidget:3` and transformed it:
    ```json
    // Data for the new V2 SuperWidget (in aug:products/superwidget-v2:1#solution)
    {
      "productId": "SW-001", // Business ID, hopefully carried over from V1
      "productName": "SuperWidget Pro", // Name, possibly updated during migration
      "description": "The next generation SuperWidget.", // Description, possibly updated
      "promoImage": "http://example.com/superwidget-v2.png", // Image link, possibly updated
      "stockLevel": 150, // Carried over from V1 data
      "priceInCents": 1999 // Transformed from V1 price (e.g., "19.99")
    }
    ```
-   The original V1 record (`aug:products/superwidget:3`) and the V2 exemplar (`aug:products/example-v2:1`) remain untouched and available in the system.

*(Note: The `productId` like "SW-001" is the product's unique business code, part of its data. This is different from the system's internal unique ID for the record itself.)*

**Step 4: Migrating Other Products**

To migrate another V1 product, say `aug:products/supergizmo:1`, to its V2 version, you'd follow the same pattern:
-   `target`: Still `aug:products/example-v2:1` (the V2 blueprint template).
-   `instruction`: The old V1 `aug:products/supergizmo:1` record.
-   `capability`: The same `aug:migrations/product#v1-to-v2` permission.
-   This would create a new `aug:products/supergizmo-v2:1` record, correctly structured for V2.

**Why is This Migration Approach Beneficial?**

-   **Clean and Clear Blueprints**: New V2 product records are pure instances of the V2 blueprint. They don't carry around old, unused fields from V1 in their structure.
-   **Explicit Transformation Rules**: The logic for converting data from V1 to V2 (e.g., how `price` becomes `priceInCents`) is clearly defined, often within the process authorized by the migration `capability`. This logic itself can be reviewed, audited, and even versioned.
-   **Full History (Immutability and Lineage)**: The old V1 product records still exist, providing a complete audit trail. You can always see what the data looked like before the migration. The connection from the new V2 record back to its V1 origin is clear.
-   **Phased Rollout Possible**: You can migrate products gradually. Systems that use product data (e.g., your website, inventory system, accounting software) can be updated over time to understand the new V2 blueprint. During this transition, some systems might still read V1 records while newer ones read V2 records.

This strategy allows your business data structures to evolve robustly and cleanly, even when significant changes are needed. It ensures changes are controlled, auditable, and don't break existing operations unexpectedly.

### The Big Picture: Business Needs Driving Controlled Evolution

This whole process shows a clear chain of events:

1.  A **business need arises** (e.g., "We need to launch an online shop!" or "We need more accurate price tracking!").
2.  This triggers **authorized personnel** (like a System Architect or a Data Modeler) to plan and execute changes to the data blueprints (`schemas`). They do this using the `Refine` process, guided by specific `instruction` records and their `capability` (permission).
3.  This results in **new versions of records, or entirely new records**, with evolved blueprints (`schema` fields) and updated data (`solution` fields).
4.  These evolved records and their new structures then **enable other business roles** (like an Inventory Manager or a Financial Analyst) to perform new types of operations or get new insights from the data, again, using their own specific permissions.

This approach treats changes to data blueprints as a core part of how data itself evolves. It's all managed through the same `Refine` tool and permission-based system, ensuring that your information structures can adapt to changing business requirements in a secure, controlled, and traceable way.

--- 

## Managing Who Can Change What: Practical Permission Management

Think of permissions in this system like job roles and responsibilities in a company. Not everyone can do everything. Permissions are very specific and tied to particular tasks, granted through digital "permits."

These permits can authorize actions on:
*   Specific, individual records (e.g., "Alice can only update *this specific* marketing document").
*   More powerfully, any record that matches a certain blueprint (e.g., "Bob, as Inventory Manager, can update stock levels for *any product* that is marked as an inventory-tracked item").

Here are some examples from an e-commerce business, showing how tasks are controlled:

-   **Product Managers Launching New Gadgets:**
    A Product Manager needs to add new electronic gadgets to the product catalog.
    -   **Permit Issued:** "Permission to Create New Product Listings from Approved Product Templates using Standard Launch Information."
    -   **What they can do:** They are allowed to use the `Refine` process to take an approved product template (e.g., a template for `aug:products/electronics-product:1`) and use a set of "launch instructions" (e.g., details for a new smartwatch in `aug:announcements/smartwatch-gen5-details:1`) to create a new, specific product listing (e.g., `aug:products/smartwatch-gen5:1`).
    -   **Business Outcome:** The Product Manager can efficiently introduce new products like smartwatches or earbuds by filling in pre-defined templates with specific details, ensuring consistency.

-   **Inventory Managers Adjusting Stock Levels:**
    An Inventory Manager needs to update stock numbers for all products based on new shipments or sales.
    -   **Permit Issued:** "Permission to Update Stock Counts for Any Inventory-Tracked Product using System Feed Data."
    -   **What they can do:** They can use `Refine` to update any product record that has the "inventory-tracked" blueprint, using an instruction that provides the new stock data (e.g., from an automated `aug:feeds/stock-feed:1`).
    -   **Business Outcome:** Stock levels for any product (smartwatches, chargers, etc.) are kept accurate, reflecting real-time inventory changes.

-   **Marketing Specialists Setting Up Promotions:**
    A Marketing Specialist needs to create different discount rules for upcoming sales events.
    -   **Permit Issued:** "Permission to Define New Discount Rules in the Promotion System using Approved Rule Structures."
    -   **What they can do:** They can use `Refine` to add new types of discount rules (e.g., percentage-off, buy-one-get-one-free) to the main promotion rules blueprint (`aug:schema-promo-rules:1`), using instructions that define how each new discount type works.
    -   **Business Outcome:** The marketing team can flexibly create and manage various promotional campaigns according to approved structures.

-   **Content Writers Updating Product Descriptions:**
    A Content Writer needs to improve the marketing text on product pages for better SEO.
    -   **Permit Issued:** "Permission to Update Product Page Content for Any Product, following SEO Guidelines."
    -   **What they can do:** They can use `Refine` to update the `description` or `marketingCopy` fields in any product page record that follows the standard product page blueprint (`aug:schema-prod-page:1`), using an instruction that might reference SEO guidelines (`aug:guide-seo-desc:1`).
    -   **Business Outcome:** Product descriptions can be optimized for search engines and marketing effectiveness by authorized writers, without them needing access to change prices or stock levels.

Whenever someone or some automated process tries to use `Refine` to change a record, the system checks if they possess a valid `Capability` that includes an appropriate permit. This permit must clearly state that the `target` record (either a specific one or one matching a blueprint) is allowed to be transformed by the given `instruction` (again, specific or matching a blueprint). This ensures every change is authorized and within defined boundaries, providing strong governance over your business data.