# Chapter 4: Refining

## The `Refine` Primitive: Making Changes

The `refine` primitive is how we change and create Vibes. It's the core mechanism that:

- Takes a general Vibe and makes it more specific
- Creates new Vibes from templates
- Modifies existing Vibes in controlled ways

Every significant change in the system happens when you `refine` something. This action:

- Create a clear record of how Vibes evolve
- Track the creation of new data and processes
- Manage how experiments and changes happen

## The `Refine` Primitive: Unified Change

At the heart of how Vibes evolve, become more specific, and ultimately manifest as concrete solutions lies a single, powerful primitive: **`refine`**. This is the universal mechanism for all forms of Vibe modification and generation, guiding a Vibe from a more general or abstract state towards a more defined and concrete instance. Think of it as a process of **refinement** and specification, effectively `narrowing` its scope, where each time you `refine` a Vibe, it brings it closer to a tangible outcome, a more focused purpose, or eventually, a collapsed solution. This journey of progressive **refinement**, driven by instructions, and guided by capabilities, is fundamental to how the system works and makes decisions. Crucially, the act of `refining` represents the definitive, state-altering events within the system. They constitute the primary lineage—a 'source tree'—of significant changes, including the creation of new data items, the evolution of processes, and the instigation of experiments. This distinguishes them from other, more transient Vibe interactions or general messaging, which, while potentially part of the history, do not directly form this core evolutionary record.

> **Primitive call**
>
> `outputVibe(s) = refine(targets, instructions, capabilities, [resources])`
>
> This single verb, `refine`, takes three primary arguments and one optional argument. Each argument can accept either a single Vibe or an array of Vibes:
>
> - **`targets`**: One or more Vibe records that will be refined or template Vibes from which new Vibes will be spawned. If an array of `targets` is provided, the `refine` primitive is applied to each target Vibe, effectively performing a batch action that may result in an array of output Vibes.
> - **`instructions`**: One or more Vibes (which could be data or process) that describe _how_ the `targets` are to be refined or how new Vibes are to be generated. If an array of `instructions` is provided, the authorizing Capability's permit must define how these multiple instructions are to be interpreted (e.g., as a sequence to be applied, as a set of inputs to be merged, or if the permit's instruction schema is designed to directly accommodate an array of instructional components).
> - **`capabilities`**: One or more Capability Vibes that serve as the proof-of-authority for the operation. If an array of `capabilities` is provided, the `refine` primitive is authorized if _any single permit_ from _any_ of the provided Capability Vibes validates the operation for the given `targets` and `instructions`. Each permit specifies what kind of `targets` can be refined and by what `instructions`. The permits may form a chain of delegated authority.
> - **`resources` (optional)**: One or more Vibes (typically `Budget` Vibes) that are consumed or required by the operation. If a permit within an authorizing `capability` specifies a `resources` schema, then matching `resource` Vibes must be provided for the `refine` call to be approved.
>
> The result when you `refine` is **always** a fresh, immutable Vibe or an array of fresh, immutable Vibes if multiple `targets` were specified; the original Vibes remain untouched.

The `refine` primitive is versatile, supporting various contexts. For instance, a Vibe can `refine` itself (self-**refinement**), one Vibe can influence another (cross-**refinement**), or divergent versions can be reconciled (merge-**refinement**). A particularly crucial application is generative-**refinement** (spawn), where a new Vibe is created from a template `target` based on the `instructions`. When `refine` is used generatively to spawn new entities, these acts are fundamental to the system's evolutionary record, contributing significantly to the primary lineage of change.

Another common application of `refine` is budget allocation and delegation. Rather than splitting abstract capabilities, the `Budget` Vibe itself—a living economic engine—is the subject of `refine`. A broad, high-level `Budget` can be `refined` to create and fund new, more specific "child" `Budget` Vibes with constrained allocations. This creates a hierarchy of budgets, allowing authority to be delegated to teams or projects in a clear, auditable manner.

For instance, to allocate a portion of a department's budget to a specific project:

Let's assume we have:

- `DepartmentBudget`: A `Budget` Vibe with a balance of $50,000 for general marketing.
- `DelegateBudgetInstructions`: An `instructions` Vibe like `{ "createSubBudget": { "name": "Project Alpha Marketing", "amount": 10000, "purpose": "..." } }`.
- A `Capability` held by a manager that authorizes them to refine the `DepartmentBudget` to create sub-budgets.

The `refine` call would be conceptualized as:
`NewBudget = refine(targets: DepartmentBudget, instructions: DelegateBudgetInstructions, capabilities: ManagerCapability)`

This single operation performs two crucial functions:

1.  **Creates a New Budget Vibe**: A new, immutable `ProjectAlphaBudget` Vibe is created. Its own `schema` defines its specific purpose and spending rules, effectively forming a "charter for a micro-economy."

2.  **Funds the New Budget**: An atomic transaction is written to the ledger, debiting $10,000 from the `DepartmentBudget` and crediting $10,000 to the new `ProjectAlphaBudget`. The `solution` (live balance) of both budgets is updated to reflect this.

This approach, detailed further in the chapter on Budgets, replaces abstract capability-splitting with the direct manipulation of `Budget` Vibes, creating a clear, auditable trail of how funds are allocated and delegated.

```llm
The `refine` primitive is the cornerstone of change. Its signature is `refine(targets, instructions, capabilities, [resources])`.
It takes three required arguments and one optional argument, each accepting a single Vibe or an array of Vibes:
`targets` (what to change/spawn from; array means batch), `instructions` (how
to change; array means combined inputs), `capabilities` (authority;
array means any one permit from any capability can authorize), and optional `resources` (e.g., `Budget` Vibes to be consumed).
It always produces new, immutable Vibe(s), leaving originals intact.
```

> **Alice:** "So, instead of a whole bunch of different commands like 'create', 'edit', 'spawn', or 'refine', we just have this one `refine` primitive for everything that makes a Vibe more specific or brings a new one into existence?"
> **Bob:** "Exactly! One core primitive to guide how Vibes evolve. You bring your `targets` – the Vibe or Vibes you're looking to use as a base or template. Then you present your `instructions`, detailing how the new Vibe should be shaped from the targets. And finally, your `capabilities` – these are your 'authorization slips'. If you provide a few, the system just needs one of them to have a permit that says 'yes' to this use of `refine`. If all the conditions of a permit are met, poof! A brand new, immutable Vibe (or set of Vibes) appears!"

```question
What are the three mandatory arguments for the `refine` primitive?
* [x] `targets`: The Vibes to be refined or the templates to spawn from.
* [x] `instructions`: The Vibes describing how the refinement should occur.
* [x] `capabilities`: The Vibes providing proof-of-authority for the refinement.
* [ ] `resources (optional)`: The vibes representing access to budget or proof of previous successes.
```

```question
What is a guaranteed characteristic of the `refine` primitive's output?
* [x] It always produces a new, immutable Vibe.
* [ ] It modifies the `targets` in-place.
* [ ] It can sometimes return multiple new Vibes.
* [ ] The `capabilities` are consumed and invalidated after use.
* [ ] It always requires LLM intervention to complete.
```

## Capabilities: Authorizing Change

Capabilities are the gatekeepers for all attempts to `refine`. They ensure that changes to Vibes are made in a controlled and auditable manner. This section details their core principles relevant to authorizing change, how they enable the system's bootstrapping, and the mechanics of how their permits are evaluated when someone tries to `refine` something.

### Core Principles of Capabilities

- **Chain of Trust & Lineage:** The chain of trust for each specific permission is established through the `issuerRef` within the `metadata` of each permit. This `issuerRef` points to the Vibe (often another Capability or a foundational system authority) that issued that specific permit, allowing permissions to be traced back to their origin.
- **Scope Defined by Permit Schemas:** A Capability's scope—what it permits you to `refine`—is explicitly defined by the permits in its `solution`. This scope is inherently `narrowed` by the specificity of these permits. Each permit (e.g., `aug:permit-create-vessel?1`) has:

  - A `metadata` property: An object holding contextual information for this specific permit instance (e.g., `title`, `description`, `reason`, `recipient`, `expiryTimestamp`, `issuerRef`).
  - A `target` property: A JSON Schema (often using `$ref` to system, organizational, or user-specific Vibe schemas) defining permissible `target` arguments for a `refine` call.
  - An `instruction` property: A JSON Schema (often using `$ref` to instruction schemas) defining permissible `instruction` arguments.
  - The scope of permitted **refinements** is implicitly determined by what the `instruction` schema allows the `instruction` Vibe to specify, and explicitly by the `target` and `resources` schemas.

- **Delegation as Solution Refinement:** A Capability's own "schema of authority" (its permits) can be `narrowed` (refined) by using `refine` where the Capability itself is the `target`. This is the mechanism for delegation.

  - Create a new, more specific Capability by using `refine`: `aug:capability-new-delegated?1 = refine(aug:capability-parent?1, aug:capability-parent?1, aug:instruction-delegation?1, aug:optional-delegation-resource?1)`
  - The parent capability (`aug:capability-parent?1`) serves as the `target` for this `refine` call.
  - The `aug:instruction-delegation?1` Vibe specifies how to refine the parent capability to create the new delegated one.
  - The `aug:capability-parent?1` (or another appropriate capability) also serves as the `capability` authorizing this delegation.
  - An `aug:optional-delegation-resource?1` might be required if the authorizing permit for delegation itself demands a resource.

- **Permits Define Fundamental State Transformations Through Refinement:** The Capability's permits are more fundamental than just tools; they authorize you to `refine`, which is the very mechanism of state transformation. This is how new, more specific vibes come into existence. More importantly, this act of `refining` (and thus, `narrowing`) is how the system learns, improves, and **refines** its operations over time. By progressively making processes, tools, and patterns more precise through successive **refinement**, the system achieves more predictable and deterministic results, reduces edge cases, and evolves towards greater sophistication. Both vessels and processes use these permits to enact these authorized transformations, making the permit-driven **refinement** process the foundational mechanism for how all new, improved, and more reliable state emerges in the system.
- **Immutability & Revocation:** Capabilities are immutable. Revocation of a Capability is achieved by creating a new Vibe (often another Capability or a system status Vibe) that marks the original Capability as void or superseded. The validity of permits in other Capabilities that reference a revoked Capability (via `issuerRef`) is then compromised.

```llm
Core principles of Capabilities (in the context of authorizing `refine`):
- Distinct Vibe type; chain of trust for permissions is established via `issuerRef` metadata within each permit.
- Permits authorize you to `refine`, which is the fundamental mechanism for state transformation and how new vibes emerge.
- Delegation of authority is achieved by `refining` a parent Capability (as `target`) to create a new, more restricted (i.e., `narrowed`) Capability; this act of `refining` itself requires authorization.
- **Refinement** (and `narrowing`) is how the system learns and **refines** itself: by making processes, tools, and patterns more specific, it achieves greater predictability, determinism, and sophistication, reducing edge cases.
- Both vessels and processes use permits to enact these authorized transformations.
- Scope of authority is defined by the `target` schema, `instruction` schema, and an optional `resources` schema within each permit, the latter defining any required assets (like currency or metric achievements).
- Immutability means revocation occurs by publishing a new Vibe that marks the previous one as invalid; this affects the validity of derived permits.
```

> **Alice:** "So, if I get a Capability, I can't accidentally make it _more_ powerful when I delegate, only less? And all the 'who gave this permission and why' stuff is right there in each permit's `metadata`?"
> **Bob:** "Exactly, principle of least privilege in action. And yeah, if it gets revoked, the original just sits there; a new Vibe essentially puts up a 'VOID' sign on the old one."

```question
If a Capability `C1` is used to authorize the creation of a permit `PermitB` within a new Capability `C2` (so `PermitB`'s `metadata.issuerRef` points to `C1`), what happens if `C1` is subsequently revoked?
* [x] `C1` is marked as void (e.g., by a successor Vibe). Consequently, `PermitB` in `C2` becomes void because its authority (`issuerRef` = `C1`) is no longer valid. `C2` itself is not directly revoked but may become ineffective if it has no other valid permits.
* [ ] `C1` is deleted from the system, which automatically deletes `C2`.
* [ ] `C2` and `PermitB` remain fully valid because `C2` was already created and its permits define its own capabilities.
* [ ] The `issuerRef` in `PermitB`'s metadata is automatically updated to point to `C1`'s parent or a system default.
```

### Bootstrapping the System: Initial `refine` Operations

The `refine(targets, instructions, capabilities, [resources])` primitive requires up to four existing Vibe arguments (or arrays thereof) to function. This naturally leads to a question: how are the very first Vibes in the system created? This "bootstrap" or "genesis" phase relies on foundational elements provided by the platform itself.

1.  **Initial `capabilities` (The Platform License):**
    The initial `capabilities` (the fourth argument of the `refine` call, potentially an array containing a single platform capability) are provided by the platform administrators or "owners." This acts as a foundational license, enabling the first set of `refine` calls. It represents the user's authorized capabilities, potentially tied to their subscription level or organizational entitlements. This is the "permission slip" to start building. Crucially, the permits within this initial platform capability might not stipulate any `resources` for foundational operations, allowing the system to bootstrap without pre-existing resource Vibes.

2.  **Initial `targets` (Base Templates):**
    The platform provides a set of minimal, "initial" template Vibes that serve as the initial `targets` (the first argument) for creating fundamental entities. These typically include:

    - `aug:/types/Vessel?1`: A very generic template for creating new Vessel types.
    - `aug:/types/Process?1`: A minimal template for defining new Process types.
    - `aug:/types/Data?1`: A basic template for new structured Record types (e.g., might only contain a root `id` field or basic metadata structure).
    - `aug:/types/Capability?1`: A foundational template for creating new root Capability types, which can subsequently serve as the basis for delegation.
      These templates are the starting clay. Their schemas are often very open or minimal, designed to be shaped.

3.  **Initial `instructions` (User Intent):**
    The `instructions` (the second argument, likely a single Vibe) for these first refinements are typically crafted by the user or a setup/onboarding process. It specifies _how_ the user wants to modify or specialize one of the initial templates. For example, instructions (which are themselves Vibes, perhaps identified by `aug:instructions-invoice?1`) might detail how to _refine_ the `aug:/types/Data?1` to create a new schema Vibe by adding fields for `invoiceNumber`, `customerDetails`, and `lineItems`.

4.  **Initial `resources` (Typically None for Bootstrapping Foundational Schemas):**
    For the very first `refine` calls that establish foundational schemas (like defining what a "User Profile Vibe" or an "Invoice Vibe" looks like from a generic `aug:/types/Data?1` template), the `resources` argument would typically be omitted. The initial platform `capabilities` would have permits that authorize these foundational schema refinements without requiring any `resource` Vibes.
    Later, once the system is bootstrapped and actions require economic commitment (e.g., posting a task, creating a billable instance of an invoice), they will require `resource` Vibes. These `resource` Vibes are typically `Budget` Vibes, which hold and manage quantifiable assets like currency, tokens, or credits. The authorizing permit within a `Capability` will specify the required `Budget` schema, ensuring that the `refine` call is backed by verified funding.

**The Schema Refinement Principle in Bootstrapping:**

When you modify a base template's schema by using `refine`, you should make it more specific (`narrowing` its definition) - not completely different. Think of it like this:

- You can add new fields and details to the schema
- You should stay within the template's original purpose
- You can't change its fundamental nature

For example:

- A Record template can become an Invoice Record template by adding invoice-specific fields
- But you shouldn't turn a Record template into a Process Control System

This approach ensures that new schemas maintain a clear connection to their original templates, making the system's structure more predictable and manageable.

```llm
Bootstrapping the system by using `refine(targets, instructions, capabilities, [resources])`
relies on platform-provided elements:
1. Initial `targets`: Minimal base templates like
   `aug:/types/Vessel?1`, `aug:/types/Process?1`, and
   `aug:/types/Data?1`, serving as starting points.
2. Initial `instructions`: User-defined instructions specifying how to
   customize these base templates.
3. Initial `capabilities`: A foundational license from platform owners,
   enabling initial actions and tied to user entitlements. Its permits often
   don't require resources for bootstrapping core schemas.
4. Initial `resources`: Usually none for defining foundational schemas; resource
   requirements (typically via `Budget` Vibes) apply later, governed by specific capabilities.
Schema **refinement** typically follows a principle of `narrowing`, specializing templates
within constraints set by the capability and template design. These base
templates link to the Vibe Source concepts from Chapter 1.
```

> **Alice:** "Alright, `refine` needs up to three Vibes in the order: `targets`, `instructions`, and `capabilities`. But the _very_ first one? Where do _those_ come from? Does a stork bring them?"
> **Bob:** "Ha! Not quite a stork, but the platform plays delivery person. It basically provides some basic template `targets` (like plain dough), initial `capabilities` (your license to bake), and then you provide the `instructions` (your first recipe). For these initial creations of basic structures, you usually don't need any special `resources`."

```question
How are the initial `capabilities` for the first refinements provided?
* [x] They are provided by platform administrators/owners as a foundational license.
* [ ] They are generated automatically from the `targets`.
* [ ] The user creates them using a special command.
* [ ] They are cloned from the `instructions`.
```

```question
What serves as the initial `targets` in the bootstrapping phase?
* [x] Minimal, initial template Vibes provided by the platform (e.g., for Vessels, Processes, Data).
* [ ] The user must create these from scratch using external tools.
* [ ] Any existing Vibe in a public repository can be used.
* [ ] The `capabilities` themselves also act as the first `targets`.
```

```question
What is the "schema **refinement** principle" in the context of **refining** base templates?
* [x] Resulting schemas should generally be specializations (`narrowed` versions), adding detail within the template's conceptual boundaries.
* [ ] Schemas can be arbitrarily widened without restriction.
```

### How Capabilities Authorize `refine` Operations

Here's how the system checks if a `refine` call is allowed:

1.  **Check each `capability` provided**: For each Vibe in the `capabilities` argument when you `refine`, verify that it is a valid, non-revoked Capability Vibe.

1.  **Iterate through `capabilities` and their Permits**: The system will examine each provided `capability` one by one. For each `capability`, it will iterate through every permit in that `capability.solution`.

1.  **For each Permit, perform checks**: For `refine` to be authorized by a specific permit, all the following conditions related to that permit must be met:

    - Verify the permit's own `metadata` (like expiration date, recipient, and `issuerRef` validity).
    - Check if the `targets` Vibes provided when you `refine` conform to the `targets` schema specified in the permit. If multiple `targets` are provided, the permit must allow for this (e.g., its schema might specify it applies to an array of targets or to each target individually).
    - Check if the `instructions` Vibes provided when you `refine` conform to the `instructions` schema specified in the permit. If multiple `instructions` are provided, the permit's `instructions` schema must be designed to handle an array or a sequence of instructions.
    - Check if the provided `resources` Vibes (if any) when you `refine` conform to the `resources` schema specified in the permit.
      - If the permit defines a `resources` schema, then when you `refine`, you must provide matching `resources` Vibes.
      - If the permit _does not_ define a `resources` schema, then when you `refine`, you must _not_ provide `resources` for this permit to be a match (or it should provide an empty list/null, depending on system interpretation for explicit non-requirement).
      - If multiple `resources` are provided, the permit's `resources` schema must be designed to handle them.

1.  **Final Decision**:
    - If _any single permit_ from _any provided `capability`_ successfully validates all the above conditions (metadata, targets, instructions, and resources), then `refine` is approved by that specific permit.
    - Then, `refine` proceeds for the `targets` specified. If multiple `targets` were part of the attempt to `refine`, this authorization applies to all of them, assuming the permit's `targets` schema allows for batch processing or matches each individual target.
    - If no permit across any of the provided `capabilities` approves the attempt to `refine` with the given arguments, it is rejected.

The system keeps track of which specific permit (and from which Capability) authorized each act of `refining`. This creates a clear audit trail showing who approved what changes, with what instructions, for which targets, and with what resources.

This approach makes permissions very precise:

- You can create permits that only work with specific tasks, targets, instructions, and resource requirements.
- The system can automatically check if a request is allowed based on all these dimensions.
- Once a `refine` call is approved and recorded, future operations can trust that approval.
- Once an act of `refining` is approved and recorded, future actions can trust that approval.

```llm
Capability authorization when you `refine` involves a multi-step check:
1. Validate each presented `capability` Vibe itself (e.g., not revoked).
2. Iterate through each permit within each presented `capability.solution`.
3. For each permit, validate its metadata (expiry, recipient) and then verify that the `targets` Vibes and `instructions` Vibes provided when you `refine` conform to the respective `targets` and `instructions` schemas defined within that permit.
4. If any single permit from any provided capability meets all these criteria, then `refine` is approved by that permit for the specified targets.
5. If no permit (across all provided capabilities) authorizes the attempt to `refine`, it's rejected.
This ensures granular, auditable control over all Vibe transformations, including resource requirements and batch operations.
```

> **Alice:** "So it's like going through security at the airport with potentially a few different ID cards or boarding passes (`capabilities`)? The main Capability (or one of them) is my boarding pass, and each permit is like a gate agent checking if my specific flight (`targets` Vibes), my carry-on (`instructions` Vibes), and now maybe my airport lounge access card or my frequent flyer status (`resource` Vibes) match what's allowed for that gate?"
> **Bob:** "Great analogy! And if even one gate agent, looking at one of your valid boarding passes, says 'You're good to go for this specific operation with these items and qualifications,' then the `refine` call is approved. If all of them, across all your passes, say 'Nope, not on my list for this combination,' then it's a no-go."

```question
What is the final condition for `refine` to be approved by a Capability (or set of Capabilities)?
* [x] At least one permit within at least one of the `capability.solutions` must validate the `targets` Vibes and `instructions` Vibes against its defined schemas and have valid metadata.
* [ ] All permits within all presented `capability.solutions` must unanimously approve the call to `refine`.
* [ ] All permits within all presented `capability.solutions` must unanimously approve the attempt to `refine`.
* [ ] The `targets` Vibes must contain a special marker indicating they allow refining by the presented `capabilities`.
* [ ] The `instructions` Vibes must be digitally signed by the issuer of the `capabilities`.
* [ ] The `capabilities` must have a global `allowAllRefine` flag set to true.
```

```question
During the authorization process for a `refine` call, what aspects of a permit are checked?
* [x] The permit's own metadata (e.g., expiration, recipient).
* [x] Conformance of the `refine` call's `targets` Vibes to the permit's `targets` schema.
* [x] Conformance of the `refine` call's `instructions` Vibes to the permit's `instructions` schema.
* [x] Conformance of the `refine` call's `resources` Vibes (if any and if specified by the permit) to the permit's `resources` schema.
* [ ] The historical number of times the permit has been successfully used.
* [ ] The computational cost of the proposed `refine` operation.
```

---

## Evolving Vibe Structures: Schema Refinement

The `refine` primitive, once authorized by a Capability, can be used to evolve not just the `solution` (data content) of a Vibe, but also the very structural definition held within its `schema` field. This is a form of `narrowing` the schema. This applies to all Vibe types, allowing for a consistent mechanism of controlled evolution across the entire system.

### The Principle of Schema Refinement

Schema **refinement** is the process of making a Vibe's `schema` definition more specific. This often involves adding new fields, making existing fields mandatory, tightening constraints (e.g., `minLength` for a string, `maximum` for a number), or **refining** data types. The key idea is that the new schema is an extension or **refinement** of the old one, preserving its core conceptual nature while adding specificity. This ensures that Vibes evolve coherently. For instance, a generic "Product" Record Vibe might be refined to an "Electronic Product" Record Vibe by adding fields specific to electronics, but it wouldn't be transformed into something unrelated like a "User Profile."

Crucially, a Vibe with a **refined** schema remains compatible with the original, more general schema. Systems or processes designed to work with Vibes conforming to the original schema can still interact with the **refined** Vibe; they will simply be unaware of or ignore the additional, more specific fields or stricter constraints. For example, if a system expects a "Vehicle" Vibe with a `color` field, it can still process a "Car" Vibe (a **refined** "Vehicle") that has `color` and also an additional `numberOfDoors` field; the system will just use the `color` field as expected.

```llm
Schema **refinement** makes a Vibe's `schema` definition more specific, like adding
fields, tightening constraints, or **refining** types. It's an extension of the old
schema, preserving the Vibe's core concept while adding detail. A **refined** Vibe
remains compatible with systems expecting the original, general schema; those
systems will simply ignore the newer, specific parts. This ensures
Vibes evolve coherently (e.g., a generic "Product" can become a more specific
"Electronic Product" but not an unrelated "User Profile").
```

> **Alice:** "So, schema **refinement** is like taking a general idea, say 'a vehicle,' and getting more specific, like 'a two-door electric sports car with vegan leather seats'? We're not changing it into a 'bicycle' or a 'boat'?"
> **Bob:** "Exactly! You're adding details and constraints but keeping the fundamental nature. The goal is **refinement** and increased precision, not a total identity swap. The new, **refined** schema will still satisfy the requirements of the original, more general schema. If a system only knows how to deal with 'vehicles' and their basic properties, it can still handle your 'two-door electric sports car' by just looking at the parts it understands."

```question
What is the primary goal of "schema **refinement**"?
* [x] To make a Vibe's `schema` definition more specific while preserving its core conceptual nature and ensuring compatibility with systems expecting the original schema.
* [ ] To completely change a Vibe's `schema` definition into something unrelated.
* [ ] To reduce the number of fields in a Vibe's `schema` definition to make it simpler.
* [ ] To make a Vibe's `schema` definition more generic and less constrained.
* [ ] To convert a Record Vibe's schema into a Process Vibe's schema.
```

### Schema Refinement Across Vibe Types

The principle of "schema **refinement**"—making a Vibe's guiding `schema` definition more specific (i.e., `narrowing` it)—applies to all Vibe types, not just Record Vibes. Each time you `refine` modifies a Vibe's `schema` definition, it results in a new Vibe with this **refined** structure. The nature of this **refinement** varies depending on the Vibe type:

| Vibe Type        | Schema Changes                   | Input Changes                 | Refinement Effect             | Result Created             |
| :--------------- | :------------------------------- | :---------------------------- | :---------------------------- | :------------------------- |
| **Record Vibe**  | Fields added, constraints        | Updated context, examples,    | More specific JSON Schema     | New Record Vibe with       |
|                  | tightened, types **refined**     | validation rules              | definition                    | evolved `schema` and       |
|                  |                                  |                               |                               | conforming `solution`      |
|                  |                                  |                               |                               |                            |
| **Role Vibe**    | Tool/meme collection becomes     | Enhanced prompts, additional  | Specialized expertise and     | New Role Vibe (Vessel)     |
|                  | more specialized, focused        | context, behavior guidelines  | focused behavior patterns     | with **refined** tools     |
|                  | configuration                    |                               |                               | and operational parameters |
|                  |                                  |                               |                               |                            |
| **Process Vibe** | Sequential workflow DAG gets     | Step instructions, error      | Increased predictability and  | New Process Vibe with      |
|                  | more detailed, constrained       | handling, validation criteria | more specific execution steps | specialized pipeline and   |
|                  |                                  |                               |                               | enhanced error handling    |
|                  |                                  |                               |                               |                            |
| **Capability**   | Permits become more restrictive, | Authority context, delegation | `Narrowed` authority scope,   | New Capability with more   |
|                  | constraints on `targets`,        | rules, resource requirements  | delegation of limited         | specific permits and       |
|                  | `instructions`, and `resources`  |                               | permissions                   | constrained authority      |

This consistent application of schema **refinement** via the `refine` primitive allows the entire system, across all Vibe types, to evolve in a controlled, auditable, and progressively more **refined** (and `narrowed`) manner.

### Instance Migration During Refinement

When a Vibe undergoes refinement, the user is given choices on how to propagate the refined changes to existing instances of that Vibe:

1. **User-Controlled Propagation**: The system presents options for how to apply the refinement changes to existing instances, allowing the user to choose the appropriate migration strategy.

2. **Refinement Migration**: Rather than regenerating instances from scratch, the system applies the specific refinement changes to each individual existing Vibe, preserving the original instance while incorporating the refined schema and input modifications.

3. **Targeted Application**: Only the specific changes introduced in the refinement (new fields, updated constraints, enhanced prompts, etc.) are applied to existing instances, maintaining their existing data and context where compatible.

4. **Migration Strategies**: Users can choose from different propagation approaches:
   - **Immediate migration**: Apply refinements to all instances at once
   - **Selective migration**: Choose specific instances to migrate
   - **Gradual rollout**: Migrate instances incrementally with validation
   - **Branch-based testing**: Test refinements on copies before applying to originals

This migration mechanism ensures that refinements can propagate throughout the system in a controlled manner, with user oversight determining how and when the evolution occurs across the Vibe architecture.

```llm
Schema **refinement** applies to all Vibe types, making their guiding `schema` definitions
more specific. For Record Vibes, the JSON Schema **refines**. For Capabilities, permits
become more restrictive (delegation, `narrowing` authority), including defining constraints on allowed
targets, instructions, and resources. For Roles, tool configurations specialize.
For Processes, workflows get more detailed. Each time you `refine`, it yields a new
Vibe with the **refined** schema, ensuring controlled, auditable evolution system-wide.
Users control how refinement changes migrate to existing instances.
```

> **Alice:** "So this schema **refinement** isn't just for data records? If I have a Capability to rule the world, I can `refine` it to just rule, say, my local bakery, effectively `narrowing` its power? And that includes saying the bakery manager capability can only use 'local ingredients' as a resource? And that's also schema **refinement**?"
> **Bob:** "Precisely! The 'schema of authority' in the Capability gets more specific—fewer permits or more constrained ones, meaning it's `narrowed`. Same for a Role Vibe; its schema of tool configurations can be **refined** to make it a specialist. Or a Process Vibe can have its workflow schema **refined** to handle a very specific sub-task with extra validation. It's a universal principle."

```question
How does schema **refinement** manifest in a Capability Vibe (i.e., how is its authority `narrowed`)?
* [x] Its permits (its "schema of authority") become more restrictive, often representing delegation, including constraints on targets, instructions, and resources.
* [ ] New, unrelated tools are added to its `solution`.
* [ ] The `target` schema it can operate on becomes broader.
* [ ] Its `issuerRef` metadata is removed.
* [ ] It gains the ability to bypass `refine` operations.
```

```question
What is the outcome of schema **refinement** on a Role Vibe?
* [x] Its `schema` definition (tool/meme collection and orchestration) becomes more specialized.
* [ ] It transforms into a Process Vibe.
* [ ] It loses all its embedded tools.
* [ ] Its ability to activate tools concurrently is removed.
* [ ] It can only produce Record Vibe `solutions`.
```

### Evolving Record Vibe Schemas: Conceptual Overview

The "schema **refinement** principle"—making schemas more specific—is fundamental to system adaptation. Capabilities can authorize changes not only to a Record Vibe's `solution` (data) but also to the structural definition in its `schema` field. This is done by using `refine` on a Record Vibe with an `instruction` Vibe that defines the evolution.

Two main scenarios for schema evolution are:

1.  **Additive Refinement**: New fields are added, or constraints are tightened. The new schema is a direct extension of the old one. For example, adding `stockLevel` and `price` to a basic product schema when evolving a promotional listing into a full e-commerce product.
2.  **Major Version Migration**: For more fundamental ("breaking") changes (e.g., renaming or removing fields, significantly altering types), a new schema version is defined (e.g., "ProductSchemaV2" from "ProductSchemaV1"). Existing Vibes are migrated by using `refine` where the old Vibe's data (as part of the `instruction`) is used to populate a new Vibe instance conforming to the new schema version. This ensures clean separation and explicit transformation.

This capability-driven approach treats schema evolution as integral to data evolution, managed by the same `refine` primitive and permit-based authorization. This ensures data structures evolve controllably, auditably, and securely, reflecting business requirement changes.

```llm
Record Vibe schema evolution (i.e., `narrowing` of the schema) is managed by `refine` calls authorized by
Capabilities. It typically involves either additive **refinement** (new fields,
tighter constraints) or major version migration (defining a new schema version
and transforming old Vibe data to fit). This ensures controlled, auditable
evolution of data structures, treating schema changes as part of data evolution.
```

> **Alice:** "So if my product Vibe needs to add, say, a 'carbon_footprint' field, that's 'additive **refinement**'? And if I want to completely change how I store prices, from a string like '$19.99' to an integer for cents, that's more like a 'major version migration'?"
> **Bob:** "You nailed it. Additive is like adding a new room to your house. Migration is like moving to a new house designed with different plumbing – you need a process to pack up your stuff from the old house and arrange it properly in the new one. Both use `refine`, but the `instruction` Vibe looks different."

```question
What are the two main scenarios for evolving Record Vibe schemas as described?
* [x] Additive Refinement: Adding new fields or tightening constraints on the existing schema.
* [x] Major Version Migration: Defining a new schema version and transforming data from old Vibes to conform to it.
* [ ] Schema Deletion: Removing the schema field entirely from a Record Vibe.
* [ ] Automatic Schema Generalization: The system automatically makes schemas less specific over time.
```

_For detailed walkthroughs of these schema evolution scenarios, including `refine` call examples and JSON structures, please see the accompanying document: `04. refining.examples.md`._

---

## Practical Permission Management for `refine` Operations: Conceptual Overview

Permissions for using `refine` are granular and task-oriented, granted via specific permits within a Capability. These permits can authorize actions on specific Vibe instances or, more powerfully, on any Vibe(s) conforming to specified schemas for their `targets`, `instructions`, and `resources` arguments.

This ensures that all changes, from data updates to schema evolutions (schema `narrowing`), and including actions that consume or require specific resources (like budget tokens or metric achievements), are controlled and auditable. The system verifies that the presented `Capability` (or one of the capabilities if multiple are provided) contains a valid permit that explicitly authorizes the `targets` Vibe(s) to be transformed by the specific `instructions` Vibe(s), using the specified `resources` Vibe(s) (if any).

```llm
Permissions for `refine` are managed through specific permits within
a Capability. These permits define granular, task-oriented authorizations,
allowing actions on specific Vibe instances or any Vibe(s) matching `target`,
`instruction`, and `resource` schemas. This system ensures all changes,
including those involving resources, are controlled, auditable, and verified
against explicit permit definitions, accommodating single or multiple Vibes for
each argument in the `refine` call.
```

> **Alice:** "So, these permits are super specific? Like, one permit might let me change the _price_ of a product, but another, separate permit is needed to change its _description_? And yet another if changing the price also costs some 'listing fee' resource?"
> **Bob:** "Exactly. Or a permit might allow a Product Manager to `refine` a 'Product Template Vibe' using an 'Approved Product Launch Instruction Vibe,' but only if they also provide a 'Marketing Budget Allocation Vibe' as a resource, and not use any other kind of instruction, or target any other kind of Vibe. Granular control across targets, instructions, and resources is key."

```question
How does the system ensure that when you `refine`, it is controlled and auditable?
* [x] By verifying that the presented `Capabilitys` contains a valid permit explicitly authorizing the `targets` Vibe(s) to be transformed by the specific `instructions` Vibe(s), potentially requiring specific `resources` Vibe(s).
* [ ] By requiring all `refine` calls to be approved by a human administrator in real-time.
* [ ] By encrypting all `instructions` Vibes so only authorized `targets` Vibes can decrypt them.
* [ ] By limiting `refine` to only affect the `solution` field, never the `schema` field.
* [ ] By allowing any Vibe to be a `capability` as long as its name starts with "permit-".
```

_For e-commerce examples illustrating practical permission management for various roles and tasks (e.g., Product Managers launching products, Inventory Managers adjusting stock), please see the accompanying document: `04. refining.examples.md`._

This consistent way to `refine` schema allows the entire system, across all Vibe types, to evolve in a controlled, auditable, and progressively more **refined** (and `narrowed`) manner.
